1 /home/SySeVR/data/CVE_2011_1175_VULN_handle_tcptls_connection.c fclose 74
static void *CVE_2011_1175_VULN_handle_tcptls_connection(void *data) 1
struct ast_tcptls_session_instance * tcptls_session = data ; 3
int ( * ssl_setup ) ( SSL * ) = ( tcptls_session -> client ) ? SSL_connect : SSL_accept 5
int ret ; 6
if ( ! tcptls_session -> parent -> tls_cfg )  13
if ( tcptls_session -> ssl = SSL_new ( tcptls_session -> parent -> tls_cfg -> ssl_ctx ) )  18
if ( ( ret = ssl_setup ( tcptls_session -> ssl ) ) <= 0 )  20
tcptls_session -> f = funopen ( tcptls_session -> ssl , ssl_read , ssl_write , NULL , ssl_close ); 24
if ( ( tcptls_session -> client && ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_DONT_VERIFY_SERVER ) ) || ( ! tcptls_session -> client && ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_VERIFY_CLIENT ) ) )  35
X509 * peer ; 37
peer = SSL_get_peer_certificate ( tcptls_session -> ssl ); 39
if ( ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_IGNORE_COMMON_NAME ) )  45
unsigned char * str2 ; 47
X509_NAME * name = X509_get_subject_name ( peer ) ; 48
int pos = - 1 ; 49
int found = 0 ; 50
pos = X509_NAME_get_index_by_NID ( name , NID_commonName , pos ); 55
if ( pos < 0 )  56
if ( str2 )  60
if ( ! strcasecmp ( tcptls_session -> parent -> hostname , ( char * ) str2 ) )  61
found = 1; 62
if ( found )  66
if ( ! found )  69
fclose ( tcptls_session -> f ); 74
0
------------------------------
2 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c fclose 185
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
0
------------------------------
3 /home/SySeVR/data/CVE_2014_8643_VULN_XRE_InitChildProcess.c sleep 130
nsresult
CVE_2014_8643_VULN_XRE_InitChildProcess(int aArgc,
char* aArgv[]) 3
if ( aArgc < 1 )  42
const int kTimeoutMs = 1000 ; 46
MachSendMessage child_message ( 0 ) ; 48
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( mach_task_self ( ) ) ) )  49
ReceivePort child_recv_port ; 54
mach_port_t raw_child_recv_port = child_recv_port . GetPort ( ) ; 55
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( raw_child_recv_port ) ) )  56
MachPortSender child_sender ( mach_port_name ) ; 61
kern_return_t err = child_sender . SendMessage ( child_message , kTimeoutMs ) ; 62
if ( err != KERN_SUCCESS )  63
MachReceiveMessage parent_message ; 68
err = child_recv_port . WaitForMessage ( & parent_message , kTimeoutMs ); 69
if ( err != KERN_SUCCESS )  70
if ( parent_message . GetTranslatedPort ( 0 ) == MACH_PORT_NULL )  75
err = task_set_bootstrap_port ( mach_task_self ( ) , parent_message . GetTranslatedPort ( 0 ) ); 79
if ( err != KERN_SUCCESS )  81
if ( aArgc < 1 )  90
if ( PR_GetEnv ( "MOZ_DEBUG_CHILD_PROCESS" ) )  127
sleep ( 30 ); 130
0
------------------------------
4 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c snprintf 30
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char * header_content ; 4
char todir [ PATH_MAX ] ; 10
vms -> starting = 0; 15
if ( vms -> msgArray [ vms -> curmsg ] == 0 )  18
header_content = mail_fetchheader ( vms -> mailstream , vms -> msgArray [ vms -> curmsg ] ); 24
if ( ast_strlen_zero ( header_content ) )  26
snprintf ( todir , sizeof ( todir ) , "%s%s/%s/tmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ); 30
make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ); 31
0
------------------------------
5 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c snprintf 62
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
0
------------------------------
6 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
7 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
8 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
9 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
10 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
11 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
12 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
13 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c snprintf 37
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
0
------------------------------
14 /home/SySeVR/data/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 22
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
avc -> streams [ i ] = & avs [ i ]; 33
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 34
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 37
av_free ( avc -> streams ); 40
av_dict_free ( & avc -> metadata ); 41
av_free ( avc ); 42
av_free ( avs ); 43
0
------------------------------
15 /home/SySeVR/data/CVE_2012_6617_PATCHED_prepare_sdp_description.c snprintf 18
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 18
0
------------------------------
16 /home/SySeVR/data/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 20
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
avc -> streams [ i ] = & avs [ i ]; 31
avc -> streams [ i ] -> codec = stream -> streams [ i ] -> codec; 32
av_sdp_create ( & avc , 1 , * pbuffer , 2048 ); 35
av_free ( avc -> streams ); 38
av_dict_free ( & avc -> metadata ); 39
av_free ( avc ); 40
av_free ( avs ); 41
0
------------------------------
17 /home/SySeVR/data/CVE_2012_6617_VULN_prepare_sdp_description.c snprintf 16
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://%s:%d?multicast=1?ttl=%d" , inet_ntoa ( stream -> multicast_ip ) , stream -> multicast_port , stream -> multicast_ttl ); 16
0
------------------------------
18 /home/SySeVR/data/CVE_2013_0874_PATCHED_doubles2str.c snprintf 16
static char *CVE_2013_0874_PATCHED_doubles2str(double *dp, int count, const char *sep) 1
int i ; 3
char * ap , * ap0 ; 4
uint64_t component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15L L + strlen ( sep ) 7
if ( count >= ( INT_MAX - 1 ) / component_len )  8
ap = av_malloc ( component_len * count + 1 ); 10
if ( ! ap )  11
ap [ 0 ] = '\0'; 14
for (i = 0; i < count; i++) 15
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 16
if ( l >= component_len )  17
ap += l; 21
0
------------------------------
19 /home/SySeVR/data/CVE_2013_0874_VULN_doubles2str.c snprintf 14
static char *CVE_2013_0874_VULN_doubles2str(double *dp, int count, const char *sep) 1
int i ; 3
char * ap , * ap0 ; 4
int component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15 + strlen ( sep ); 7
ap = av_malloc ( component_len * count ); 8
if ( ! ap )  9
ap [ 0 ] = '\0'; 12
for (i = 0; i < count; i++) 13
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 14
if ( l >= component_len )  15
ap += l; 19
0
------------------------------
20 /home/SySeVR/data/CVE_2013_2547_VULN_crypto_report_one.c snprintf 18
static int CVE_2013_2547_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) )  13
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL )  15
struct crypto_report_larval rl ; 16
snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , "%s" , "larval" ); 18
if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) )  20
0
------------------------------
21 /home/SySeVR/data/CVE_2013_2548_VULN_crypto_report_one.c snprintf 18
static int CVE_2013_2548_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) )  13
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL )  15
struct crypto_report_larval rl ; 16
snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , "%s" , "larval" ); 18
if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) )  20
0
------------------------------
22 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c snprintf 168
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
cmd = REQ_OFFSET_TO_STR ( req , rlpart1 ); 49
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
snprintf ( p -> lastmsg , sizeof ( p -> lastmsg ) , "Rx: %s" , cmd ); 168
if ( ! p -> initreq . headers && req -> has_to_tag )  175
ast_string_field_set ( p , tag , totag ); 186
p -> pendinginvite = p -> icseq; 187
transmit_response_reliable ( p , "481 Call/Transaction Does Not Exist" , req ); 188
0
------------------------------
23 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c snprintf 130
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( req -> method == SIP_INVITE )  127
unsigned int ran = ( ast_random ( ) % 10 ) + 1 ; 128
char seconds [ 4 ] ; 129
snprintf ( seconds , sizeof ( seconds ) , "%u" , ran ); 130
transmit_response_with_retry_after ( p , "500 Server error" , req , seconds ); 131
0
------------------------------
24 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c snprintf 100
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
if ( ! ast_strlen_zero ( __get_header ( req , "via" , & via_pos ) ) )  79
if ( p -> ocseq && ( p -> ocseq < seqno ) )  83
if ( p -> owner )  91
struct ast_control_pvt_cause_code * cause_code ; 92
int data_size = sizeof ( * cause_code ) ; 93
data_size += 4 + strlen ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 95
cause_code = ast_alloca ( data_size ); 96
snprintf ( cause_code -> code , data_size - sizeof ( * cause_code ) + 1 , "SIP %s" , REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 100
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
0
------------------------------
25 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c snprintf 225
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
cupsd_job_t * job ; 10
char filename [ 1024 ] ; 11
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
struct stat fileinfo ; 18
int kbytes ; 19
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
if ( ! filetype )  170
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  199
if ( stat ( con -> filename , & fileinfo ) )  206
kbytes = 0; 207
kbytes = ( fileinfo . st_size + 1023 ) / 1024; 209
job -> koctets += kbytes; 213
if ( add_file ( con , job , filetype , compression ) )  222
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
0
------------------------------
26 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c snprintf 161
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
ippSetString ( con -> request , & format , 0 , mimetype ); 165
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 167
0
------------------------------
27 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c snprintf 153
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 149
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 153
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported format \"%s\"." ) , mimetype ); 156
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 159
0
------------------------------
28 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memset 373
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
unsigned pix_fmt_id ; 4
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
height *= 2; 122
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
s -> rgb = 0; 141
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
s -> upscale_v = 6; 299
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
for (i = 0; i < 4; i++) 343
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
0
------------------------------
29 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memset 66
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
memset ( v_count , 0 , sizeof ( v_count ) ); 66
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
0
------------------------------
30 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memset 65
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
memset ( h_count , 0 , sizeof ( h_count ) ); 65
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
0
------------------------------
31 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c memset 67
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
unsigned int y ; 6
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
memcpy ( diffFrame -> data [ 0 ] , s -> last_frame -> data [ 0 ] , s -> last_frame -> linesize [ 0 ] * s -> last_frame -> height ); 61
if ( last_fctl_chunk . dispose_op == APNG_DISPOSE_OP_BACKGROUND )  64
for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) 65
size_t row_start = s -> last_frame -> linesize [ 0 ] * y + bpp * last_fctl_chunk . x_offset ; 66
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
0
------------------------------
32 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memset 168
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; 5
struct brcmf_if * ifp = netdev_priv ( ndev ) ; 6
const struct brcmf_tlv * ssid_ie ; 7
const struct brcmf_tlv * country_ie ; 8
const struct brcmf_tlv * rsn_ie ; 11
const struct brcmf_vs_tlv * wpa_ie ; 12
struct brcmf_join_params join_params ; 13
enum nl80211_iftype dev_role ; 14
u16 chanspec ; 16
bool mbss ; 17
int is_11d ; 18
dev_role = ifp -> vif -> wdev . iftype; 27
mbss = ifp -> vif -> mbss; 28
country_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_COUNTRY ); 32
is_11d = country_ie ? 1 : 0; 35
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); 61
wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); 65
if ( wpa_ie != NULL || rsn_ie != NULL )  68
if ( wpa_ie != NULL )  70
err = brcmf_configure_wpaie ( ifp , wpa_ie , false ); 72
if ( err < 0 )  73
struct brcmf_vs_tlv * tmp_ie ; 76
tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; 78
err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); 81
if ( err < 0 )  82
if ( ! mbss )  92
chanspec = chandef_to_chanspec ( & cfg -> d11inf , & settings -> chandef ); 93
err = brcmf_fil_iovar_int_set ( ifp , "chanspec" , chanspec ); 95
if ( err < 0 )  96
if ( is_11d != ifp -> vif -> is_11d )  102
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_REGULATORY , is_11d ); 103
if ( err < 0 )  105
if ( settings -> beacon_interval )  110
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_BCNPRD , settings -> beacon_interval ); 111
if ( err < 0 )  113
if ( settings -> dtim_period )  119
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_DTIMPRD , settings -> dtim_period ); 120
if ( err < 0 )  122
if ( ( dev_role == NL80211_IFTYPE_AP ) && ( ( ifp -> ifidx == 0 ) || ! brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_RSDB ) ) )  128
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_DOWN , 1 ); 131
if ( err < 0 )  132
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_INFRA , 1 ); 139
if ( err < 0 )  140
if ( WARN_ON ( is_11d != ifp -> vif -> is_11d ) )  144
if ( dev_role == NL80211_IFTYPE_AP )  149
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_AP , 1 ); 153
if ( err < 0 )  154
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_UP , 1 ); 158
if ( err < 0 )  159
memset ( & join_params , 0 , sizeof ( join_params ) ); 168
memcpy ( & join_params . ssid_le , & ssid_le , sizeof ( ssid_le ) ); 170
err = brcmf_fil_cmd_data_set ( ifp , BRCMF_C_SET_SSID , & join_params , sizeof ( join_params ) ); 172
if ( err < 0 )  174
brcmf_err ( "SET SSID error (%d)\n" , err ); 175
if ( ( err ) && ( ! mbss ) )  201
return err ; 205
0
------------------------------
33 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memset 37
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
struct brcmf_ssid_le ssid_le ; 9
memset ( & ssid_le , 0 , sizeof ( ssid_le ) ); 37
memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ); 47
ssid_le . SSID_len = cpu_to_le32 ( ssid_ie -> len ); 48
brcmf_dbg ( TRACE , "SSID is (%s) in Head\n" , ssid_le . SSID ); 49
0
------------------------------
34 /home/SySeVR/data/CVE_2006_2448_PATCHED_restore_sigcontext.c memset 58
static long CVE_2006_2448_PATCHED_restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,
struct sigcontext __user *sc) 2
elf_vrreg_t __user * v_regs ; 5
unsigned long err = 0 ; 7
elf_greg_t * gregs = ( elf_greg_t * ) regs ; 9
unsigned long msr ; 11
int i ; 13
err |= __copy_from_user ( regs , & sc -> gp_regs , PT_MSR * sizeof ( unsigned long ) ); 20
for (i = PT_MSR+1; i <= PT_RESULT; i++) 24
if ( i == PT_SOFTE )  25
err |= __get_user ( gregs [ i ] , & sc -> gp_regs [ i ] ); 27
if ( set != NULL )  32
err |= __get_user ( set -> sig [ 0 ] , & sc -> oldmask ); 33
err |= __copy_from_user ( & current -> thread . fpr , & sc -> fp_regs , FP_REGS_SIZE ); 44
err |= __get_user ( v_regs , & sc -> v_regs ); 47
err |= __get_user ( msr , & sc -> gp_regs [ PT_MSR ] ); 48
if ( err )  49
if ( v_regs && ! access_ok ( VERIFY_READ , v_regs , 34 * sizeof ( vector128 ) ) )  51
if ( v_regs != 0 && ( msr & MSR_VEC ) != 0 )  54
if ( current -> thread . used_vr )  57
memset ( current -> thread . vr , 0 , 33 * sizeof ( vector128 ) ); 58
err |= __get_user ( current -> thread . vrsave , ( u32 __user * ) & v_regs [ 33 ] ); 61
current -> thread . vrsave = 0; 63
return err ; 69
0
------------------------------
35 /home/SySeVR/data/CVE_2006_2448_VULN_restore_sigcontext.c memset 56
static long CVE_2006_2448_VULN_restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,
struct sigcontext __user *sc) 2
elf_vrreg_t __user * v_regs ; 5
unsigned long err = 0 ; 7
elf_greg_t * gregs = ( elf_greg_t * ) regs ; 9
unsigned long msr ; 11
int i ; 13
err |= __copy_from_user ( regs , & sc -> gp_regs , PT_MSR * sizeof ( unsigned long ) ); 20
for (i = PT_MSR+1; i <= PT_RESULT; i++) 24
if ( i == PT_SOFTE )  25
err |= __get_user ( gregs [ i ] , & sc -> gp_regs [ i ] ); 27
if ( set != NULL )  32
err |= __get_user ( set -> sig [ 0 ] , & sc -> oldmask ); 33
err |= __copy_from_user ( & current -> thread . fpr , & sc -> fp_regs , FP_REGS_SIZE ); 44
err |= __get_user ( v_regs , & sc -> v_regs ); 47
err |= __get_user ( msr , & sc -> gp_regs [ PT_MSR ] ); 48
if ( err )  49
if ( v_regs != 0 && ( msr & MSR_VEC ) != 0 )  52
if ( current -> thread . used_vr )  55
memset ( current -> thread . vr , 0 , 33 * sizeof ( vector128 ) ); 56
err |= __get_user ( current -> thread . vrsave , ( u32 __user * ) & v_regs [ 33 ] ); 59
current -> thread . vrsave = 0; 61
return err ; 67
0
------------------------------
36 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c memset 108
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
int err = 0 ; 6
unsigned blocksize , bbits ; 7
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  42
if ( block_end > to || block_start < from )  46
void * kaddr ; 47
kaddr = kmap_atomic ( page , KM_USER0 ); 49
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
if ( block_start < from )  53
memset ( kaddr + block_start , 0 , from - block_start ); 54
if ( PageUptodate ( page ) )  62
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )  67
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
if ( ! buffer_uptodate ( * wait_bh ) )  78
err = - EIO; 79
if ( ! err )  81
bh = head; 95
block_start = 0; 96
block_end = block_start + blocksize; 98
if ( block_end <= from )  99
if ( block_start >= to )  101
if ( buffer_new ( bh ) )  103
void * kaddr ; 104
kaddr = kmap_atomic ( page , KM_USER0 ); 107
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
block_start = block_end; 114
bh = bh -> b_this_page; 115
while ( bh != head )  116
0
------------------------------
37 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c memset 54
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  42
if ( block_end > to || block_start < from )  46
void * kaddr ; 47
kaddr = kmap_atomic ( page , KM_USER0 ); 49
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
if ( block_start < from )  53
memset ( kaddr + block_start , 0 , from - block_start ); 54
kunmap_atomic ( kaddr , KM_USER0 ); 57
if ( PageUptodate ( page ) )  62
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
0
------------------------------
38 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c memset 51
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  42
if ( block_end > to || block_start < from )  46
void * kaddr ; 47
kaddr = kmap_atomic ( page , KM_USER0 ); 49
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
memset ( kaddr + block_start , 0 , from - block_start ); 54
kunmap_atomic ( kaddr , KM_USER0 ); 57
if ( PageUptodate ( page ) )  62
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
0
------------------------------
39 /home/SySeVR/data/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c memset 88
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
if ( ! info && ctrl )  64
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , skb -> data [ CAPI_MSG_BASELEN + 14 ] ); 65
if ( ! info && ctrl )  75
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 76
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 77
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 78
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 79
if ( ! info && ctrl )  87
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 88
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , skb -> data [ CAPI_MSG_BASELEN + 16 ] ); 89
0
------------------------------
40 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memset 329
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
while ( aCount > 0 )  258
PRUint8 byte ; 259
switch ( mState )  261
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
mState = eRLEStateNeedSecondEscapeByte; 266
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
if ( mBIH . compression == BI_RLE8 )  283
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mState = eRLEStateInitial; 294
switch ( byte )  298
mAlphaPtr = mAlpha; 304
mState = eRLEStateInitial; 307
mState = eRLEStateNeedXDelta; 316
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
mState = eRLEStateAbsoluteMode; 342
mState = eRLEStateAbsoluteModePadded; 344
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
mState = eRLEStateNeedYDelta; 358
byte = * aBuffer ++; 363
aCount --; 364
mState = eRLEStateInitial; 365
if ( byte == 0 )  366
if ( mBIH . compression == BI_RLE8 )  379
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( mState == eRLEStateAbsoluteMode )  398
mState = eRLEStateInitial; 399
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
mState = eRLEStateInitial; 405
if ( mCurLine == 0 )  417
0
------------------------------
41 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memset 281
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
while ( aCount > 0 )  258
PRUint8 byte ; 259
switch ( mState )  261
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
mState = eRLEStateNeedSecondEscapeByte; 266
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
if ( mBIH . compression == BI_RLE8 )  283
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mState = eRLEStateInitial; 294
switch ( byte )  298
mAlphaPtr = mAlpha; 304
mState = eRLEStateInitial; 307
mState = eRLEStateNeedXDelta; 316
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
mState = eRLEStateAbsoluteMode; 342
mState = eRLEStateAbsoluteModePadded; 344
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
mState = eRLEStateNeedYDelta; 358
byte = * aBuffer ++; 363
aCount --; 364
mState = eRLEStateInitial; 365
if ( byte == 0 )  366
if ( mBIH . compression == BI_RLE8 )  379
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( mState == eRLEStateAbsoluteMode )  398
mState = eRLEStateInitial; 399
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
mState = eRLEStateInitial; 405
if ( mCurLine == 0 )  417
0
------------------------------
42 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memset 55
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
mColors [ colorNum ] . blue = * aBuffer; 105
mColors [ colorNum ] . green = * aBuffer; 108
mColors [ colorNum ] . red = * aBuffer; 111
colorNum ++; 112
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
SetPixel ( mDecoding , byte , mColors ); 285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
SetPixel ( mDecoding , byte , mColors ); 383
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
0
------------------------------
43 /home/SySeVR/data/CVE_2008_3915_PATCHED_init_state.c memset 6
static int
CVE_2008_3915_PATCHED_init_state(struct posix_acl_state *state, int cnt) 2
memset ( state , 0 , sizeof ( struct posix_acl_state ) ); 6
state -> empty = 1; 7
state -> users = kzalloc ( alloc , GFP_KERNEL ); 15
if ( ! state -> users )  16
state -> groups = kzalloc ( alloc , GFP_KERNEL ); 18
if ( ! state -> groups )  19
kfree ( state -> users ); 20
0
------------------------------
44 /home/SySeVR/data/CVE_2008_3915_VULN_init_state.c memset 6
static int
CVE_2008_3915_VULN_init_state(struct posix_acl_state *state, int cnt) 2
memset ( state , 0 , sizeof ( struct posix_acl_state ) ); 6
state -> empty = 1; 7
state -> users = kzalloc ( alloc , GFP_KERNEL ); 15
if ( ! state -> users )  16
state -> groups = kzalloc ( alloc , GFP_KERNEL ); 18
if ( ! state -> groups )  19
kfree ( state -> users ); 20
0
------------------------------
45 /home/SySeVR/data/CVE_2009_2484_VULN_Win32AddConnection.c memset 27
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
NETRESOURCE net_resource ; 7
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
memset ( & net_resource , 0 , sizeof ( net_resource ) ); 27
net_resource . dwType = RESOURCETYPE_DISK; 28
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
0
------------------------------
46 /home/SySeVR/data/CVE_2009_4307_PATCHED_ext4_fill_flex_info.c memset 28
static int CVE_2009_4307_PATCHED_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
size_t size ; 8
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_inodes , ext4_free_inodes_count ( sb , gdp ) ); 40
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_blocks , ext4_free_blks_count ( sb , gdp ) ); 42
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . used_dirs , ext4_used_dirs_count ( sb , gdp ) ); 44
0
------------------------------
47 /home/SySeVR/data/CVE_2010_0437_VULN_ip6_dst_lookup_tail.c memset 50
static int CVE_2010_0437_VULN_ip6_dst_lookup_tail(struct sock *sk,
struct dst_entry **dst, struct flowi *fl) 2
int err ; 4
struct net * net = sock_net ( sk ) ; 5
if ( * dst == NULL )  7
* dst = ip6_route_output ( net , sk , fl ); 8
if ( err = ( * dst ) -> error )  10
if ( ipv6_addr_any ( & fl -> fl6_src ) )  13
err = ipv6_dev_get_saddr ( ip6_dst_idev ( * dst ) -> dev , & fl -> fl6_dst , sk ? inet6_sk ( sk ) -> srcprefs : 0 , & fl -> fl6_src ); 14
if ( err )  18
if ( ! ( ( * dst ) -> neighbour -> nud_state & NUD_VALID ) )  31
struct inet6_ifaddr * ifp ; 32
struct flowi fl_gw ; 33
int redirect ; 34
ifp = ipv6_get_ifaddr ( net , & fl -> fl6_src , ( * dst ) -> dev , 1 ); 36
redirect = ( ifp && ifp -> flags & IFA_F_OPTIMISTIC ); 39
if ( redirect )  43
memcpy ( & fl_gw , fl , sizeof ( struct flowi ) ); 49
memset ( & fl_gw . fl6_dst , 0 , sizeof ( struct in6_addr ) ); 50
* dst = ip6_route_output ( net , sk , & fl_gw ); 51
if ( err = ( * dst ) -> error )  52
if ( err == - ENETUNREACH )  61
dst_release ( * dst ); 63
return err ; 65
0
------------------------------
48 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP.c memset 119
static int CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
int pixel_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
unsigned char * pixels ; 28
int pixel ; 29
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixels = s -> frame . data [ 0 ]; 39
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 81
for (i = 0; i < line_packets; i++) 82
pixel_skip = buf [ stream_ptr ++ ]; 84
pixel_ptr += ( pixel_skip * 2 ); 85
pixel_countdown -= pixel_skip; 86
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 87
if ( byte_run < 0 )  88
byte_run = - byte_run; 89
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 90
stream_ptr += 2; 91
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 93
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 94
pixel_ptr += 2; 95
for (j = 0; j < byte_run; j++, pixel_countdown--) 99
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 100
stream_ptr += 2; 101
pixel_ptr += 2; 102
y_ptr += s -> frame . linesize [ 0 ]; 107
stream_ptr = stream_ptr + chunk_size - 6; 114
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 119
y_ptr = 0; 124
for (lines = 0; lines < s->avctx->height; lines++) 125
stream_ptr ++; 129
pixel_countdown = ( s -> avctx -> width * 2 ); 130
while ( pixel_countdown > 0 )  132
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 133
if ( byte_run > 0 )  134
palette_idx1 = buf [ stream_ptr ++ ]; 135
for (j = 0; j < byte_run; j++) 137
pixels [ pixel_ptr ++ ] = palette_idx1; 138
pixel_countdown --; 139
byte_run = - byte_run; 145
for (j = 0; j < byte_run; j++) 147
palette_idx1 = buf [ stream_ptr ++ ]; 148
pixels [ pixel_ptr ++ ] = palette_idx1; 149
pixel_countdown --; 150
pixel_countdown = s -> avctx -> width; 165
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 167
pixel_ptr += 2; 168
y_ptr += s -> frame . linesize [ 0 ]; 171
y_ptr = 0; 176
for (lines = 0; lines < s->avctx->height; lines++) 177
stream_ptr ++; 181
pixel_countdown = s -> avctx -> width; 182
while ( pixel_countdown > 0 )  184
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 185
if ( byte_run > 0 )  186
stream_ptr += 2; 188
for (j = 0; j < byte_run; j++) 190
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 191
pixel_ptr += 2; 192
pixel_countdown --; 193
byte_run = - byte_run; 199
for (j = 0; j < byte_run; j++) 201
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 202
stream_ptr += 2; 203
pixel_ptr += 2; 204
pixel_countdown --; 205
y_ptr += s -> frame . linesize [ 0 ]; 213
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  220
stream_ptr += chunk_size - 6; 223
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 227
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 232
pixel_ptr += 2; 233
stream_ptr += s -> avctx -> width * 2; 236
stream_ptr += chunk_size - 6; 243
frame_size -= chunk_size; 251
num_chunks --; 252
0
------------------------------
49 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c memset 212
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
compressed_lines --; 134
pixel_ptr = y_ptr; 135
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_ptr += pixel_skip; 141
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
pixels [ pixel_ptr ++ ] = palette_idx1; 150
pixels [ pixel_ptr ++ ] = palette_idx2; 151
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
pixels [ pixel_ptr ++ ] = palette_idx1; 157
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_ptr = y_ptr; 177
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_ptr += pixel_skip; 185
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
pixels [ pixel_ptr ++ ] = palette_idx1; 192
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
pixels [ pixel_ptr ++ ] = palette_idx1; 199
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 212
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixels [ pixel_ptr ++ ] = palette_idx1; 232
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixels [ pixel_ptr ++ ] = palette_idx1; 243
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 265
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
0
------------------------------
50 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_15_16BPP.c memset 118
static int CVE_2010_3429_VULN_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
int pixel_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
unsigned char * pixels ; 28
int pixel ; 29
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixels = s -> frame . data [ 0 ]; 39
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 80
for (i = 0; i < line_packets; i++) 81
pixel_skip = buf [ stream_ptr ++ ]; 83
pixel_ptr += ( pixel_skip * 2 ); 84
pixel_countdown -= pixel_skip; 85
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 86
if ( byte_run < 0 )  87
byte_run = - byte_run; 88
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 89
stream_ptr += 2; 90
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 92
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 93
pixel_ptr += 2; 94
for (j = 0; j < byte_run; j++, pixel_countdown--) 98
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 99
stream_ptr += 2; 100
pixel_ptr += 2; 101
y_ptr += s -> frame . linesize [ 0 ]; 106
stream_ptr = stream_ptr + chunk_size - 6; 113
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 118
y_ptr = 0; 123
for (lines = 0; lines < s->avctx->height; lines++) 124
stream_ptr ++; 128
pixel_countdown = ( s -> avctx -> width * 2 ); 129
while ( pixel_countdown > 0 )  131
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 132
if ( byte_run > 0 )  133
palette_idx1 = buf [ stream_ptr ++ ]; 134
for (j = 0; j < byte_run; j++) 136
pixels [ pixel_ptr ++ ] = palette_idx1; 137
pixel_countdown --; 138
byte_run = - byte_run; 144
for (j = 0; j < byte_run; j++) 146
palette_idx1 = buf [ stream_ptr ++ ]; 147
pixels [ pixel_ptr ++ ] = palette_idx1; 148
pixel_countdown --; 149
pixel_countdown = s -> avctx -> width; 164
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 166
pixel_ptr += 2; 167
y_ptr += s -> frame . linesize [ 0 ]; 170
y_ptr = 0; 175
for (lines = 0; lines < s->avctx->height; lines++) 176
stream_ptr ++; 180
pixel_countdown = s -> avctx -> width; 181
while ( pixel_countdown > 0 )  183
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 184
if ( byte_run > 0 )  185
stream_ptr += 2; 187
for (j = 0; j < byte_run; j++) 189
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 190
pixel_ptr += 2; 191
pixel_countdown --; 192
byte_run = - byte_run; 198
for (j = 0; j < byte_run; j++) 200
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 201
stream_ptr += 2; 202
pixel_ptr += 2; 203
pixel_countdown --; 204
y_ptr += s -> frame . linesize [ 0 ]; 212
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  219
stream_ptr += chunk_size - 6; 222
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 226
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 231
pixel_ptr += 2; 232
stream_ptr += s -> avctx -> width * 2; 235
stream_ptr += chunk_size - 6; 242
frame_size -= chunk_size; 250
num_chunks --; 251
0
------------------------------
51 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c memset 208
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_ptr = y_ptr; 133
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_ptr += pixel_skip; 138
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
pixels [ pixel_ptr ++ ] = palette_idx1; 147
pixels [ pixel_ptr ++ ] = palette_idx2; 148
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
pixels [ pixel_ptr ++ ] = palette_idx1; 154
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_ptr = y_ptr; 174
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_ptr += pixel_skip; 181
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
pixels [ pixel_ptr ++ ] = palette_idx1; 188
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
pixels [ pixel_ptr ++ ] = palette_idx1; 195
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 208
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
for (j = 0; j < byte_run; j++) 227
pixels [ pixel_ptr ++ ] = palette_idx1; 228
pixel_countdown --; 229
byte_run = - byte_run; 235
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixels [ pixel_ptr ++ ] = palette_idx1; 239
pixel_countdown --; 240
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 261
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
frame_size -= chunk_size; 278
num_chunks --; 279
0
------------------------------
52 /home/SySeVR/data/CVE_2010_3848_PATCHED_econet_sendmsg.c memset 162
static int CVE_2010_3848_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sockaddr_in udpdest ; 18
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( dev -> type == ARPHRD_ECONET )  68
if ( udpsock == NULL )  150
if ( len > 32768 )  155
memset ( & udpdest , 0 , sizeof ( udpdest ) ); 162
udpdest . sin_family = AF_INET; 163
udpdest . sin_port = htons ( AUN_PORT ); 164
udpdest . sin_addr . s_addr = htonl ( network | addr . station ); 181
0
------------------------------
53 /home/SySeVR/data/CVE_2010_3848_VULN_econet_sendmsg.c memset 157
static int CVE_2010_3848_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sockaddr_in udpdest ; 18
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( len + 15 > dev -> mtu )  68
if ( dev -> type == ARPHRD_ECONET )  73
if ( udpsock == NULL )  150
memset ( & udpdest , 0 , sizeof ( udpdest ) ); 157
udpdest . sin_family = AF_INET; 158
udpdest . sin_port = htons ( AUN_PORT ); 159
udpdest . sin_addr . s_addr = htonl ( network | addr . station ); 176
udpmsg . msg_name = ( void * ) & udpdest; 228
udpmsg . msg_namelen = sizeof ( udpdest ); 229
udpmsg . msg_iov = & iov [ 0 ]; 230
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 231
udpmsg . msg_control = NULL; 232
udpmsg . msg_controllen = 0; 233
udpmsg . msg_flags = 0; 234
err = sock_sendmsg ( udpsock , & udpmsg , size ); 237
return err ; 244
0
------------------------------
54 /home/SySeVR/data/CVE_2010_3849_PATCHED_econet_sendmsg.c memset 147
static int CVE_2010_3849_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sockaddr_in udpdest ; 18
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL || msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  37
addr . station = saddr -> addr . station; 41
addr . net = saddr -> addr . net; 42
dev = net2dev_map [ addr . net ]; 47
if ( dev == NULL )  50
dev = net2dev_map [ 0 ]; 51
if ( dev == NULL )  53
if ( len + 15 > dev -> mtu )  59
if ( dev -> type == ARPHRD_ECONET )  64
if ( udpsock == NULL )  140
memset ( & udpdest , 0 , sizeof ( udpdest ) ); 147
udpdest . sin_family = AF_INET; 148
udpdest . sin_port = htons ( AUN_PORT ); 149
udpdest . sin_addr . s_addr = htonl ( network | addr . station ); 166
udpmsg . msg_name = ( void * ) & udpdest; 218
udpmsg . msg_namelen = sizeof ( udpdest ); 219
udpmsg . msg_iov = & iov [ 0 ]; 220
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 221
udpmsg . msg_control = NULL; 222
udpmsg . msg_controllen = 0; 223
udpmsg . msg_flags = 0; 224
err = sock_sendmsg ( udpsock , & udpmsg , size ); 227
return err ; 234
0
------------------------------
55 /home/SySeVR/data/CVE_2010_3849_VULN_econet_sendmsg.c memset 157
static int CVE_2010_3849_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sockaddr_in udpdest ; 18
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( len + 15 > dev -> mtu )  68
if ( dev -> type == ARPHRD_ECONET )  73
if ( udpsock == NULL )  150
memset ( & udpdest , 0 , sizeof ( udpdest ) ); 157
udpdest . sin_family = AF_INET; 158
udpdest . sin_port = htons ( AUN_PORT ); 159
udpdest . sin_addr . s_addr = htonl ( network | addr . station ); 176
udpmsg . msg_name = ( void * ) & udpdest; 228
udpmsg . msg_namelen = sizeof ( udpdest ); 229
udpmsg . msg_iov = & iov [ 0 ]; 230
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 231
udpmsg . msg_control = NULL; 232
udpmsg . msg_controllen = 0; 233
udpmsg . msg_flags = 0; 234
err = sock_sendmsg ( udpsock , & udpmsg , size ); 237
return err ; 244
0
------------------------------
56 /home/SySeVR/data/CVE_2010_3875_PATCHED_ax25_getname.c memset 10
static int CVE_2010_3875_PATCHED_ax25_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddr_len, int peer) 2
struct full_sockaddr_ax25 * fsa = ( struct full_sockaddr_ax25 * ) uaddr ; 4
memset ( fsa , 0 , sizeof ( fsa ) ); 10
fsa -> fsa_ax25 . sax25_family = AF_AX25; 20
fsa -> fsa_ax25 . sax25_call = ax25 -> dest_addr; 21
fsa -> fsa_ax25 . sax25_ndigis = ndigi; 25
fsa -> fsa_digipeater [ i ] = ax25 -> digipeat -> calls [ i ]; 27
0
------------------------------
57 /home/SySeVR/data/CVE_2010_3876_VULN_packet_getname_spkt.c memset 16
static int CVE_2010_3876_VULN_packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,
int *uaddr_len, int peer) 2
struct net_device * dev ; 4
struct sock * sk = sock -> sk ; 5
if ( peer )  7
uaddr -> sa_family = AF_PACKET; 10
dev = dev_get_by_index_rcu ( sock_net ( sk ) , pkt_sk ( sk ) -> ifindex ); 12
if ( dev )  13
memset ( uaddr -> sa_data , 0 , 14 ); 16
* uaddr_len = sizeof ( * uaddr ); 18
0
------------------------------
58 /home/SySeVR/data/CVE_2010_4649_PATCHED_ib_uverbs_poll_cq.c memset 24
ssize_t CVE_2010_4649_PATCHED_ib_uverbs_poll_cq(struct ib_uverbs_file *file,
const char __user *buf, int in_len,
int out_len) 3
struct CVE_2010_4649_PATCHED_ib_uverbs_poll_cq cmd ; 5
struct ib_uverbs_poll_cq_resp resp ; 6
struct ib_cq * cq ; 9
if ( copy_from_user ( & cmd , buf , sizeof cmd ) )  13
cq = idr_read_cq ( cmd . cq_handle , file -> ucontext , 0 ); 16
if ( ! cq )  17
memset ( & resp , 0 , sizeof resp ); 24
while ( resp . count < cmd . ne )  25
++ resp . count; 37
if ( copy_to_user ( header_ptr , & resp , sizeof resp ) )  40
0
------------------------------
59 /home/SySeVR/data/CVE_2011_1138_PATCHED_dissect_6lowpan_iphc.c memset 227
static tvbuff_t *
CVE_2011_1138_PATCHED_dissect_6lowpan_iphc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size) 2
gint offset = 0 ; 4
guint16 iphc_flags ; 12
guint8 iphc_traffic ; 13
guint8 iphc_hop_limit ; 14
guint8 iphc_src_mode ; 15
guint8 ipv6_class = 0 ; 19
struct ip6_hdr ipv6 ; 20
iphc_flags = tvb_get_ntohs ( tvb , offset ); 38
iphc_traffic = ( iphc_flags & LOWPAN_IPHC_FLAG_FLOW ) >> LOWPAN_IPHC_FLAG_OFFSET_FLOW; 39
iphc_hop_limit = ( iphc_flags & LOWPAN_IPHC_FLAG_HLIM ) >> LOWPAN_IPHC_FLAG_OFFSET_HLIM; 40
iphc_src_mode = ( iphc_flags & LOWPAN_IPHC_FLAG_SRC_MODE ) >> LOWPAN_IPHC_FLAG_OFFSET_SRC_MODE; 41
offset += sizeof ( guint16 ); 58
if ( iphc_flags & LOWPAN_IPHC_FLAG_CONTEXT_ID )  61
offset += sizeof ( guint8 ); 67
offset <<= 3; 74
if ( iphc_traffic != LOWPAN_IPHC_FLOW_COMPRESSED )  76
ipv6_class |= tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_ECN_BITS ); 77
offset += LOWPAN_IPHC_ECN_BITS; 78
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS ) )  81
ipv6_class |= ( tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_DSCP_BITS ) << LOWPAN_IPHC_ECN_BITS ); 82
offset += LOWPAN_IPHC_DSCP_BITS; 83
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_ECN_LABEL ) )  98
offset += ( ( 4 - offset ) & 0x7 ); 100
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , offset , LOWPAN_IPHC_LABEL_BITS , FALSE ); 101
offset += LOWPAN_IPHC_LABEL_BITS; 105
ipv6 . ip6_flow = 0; 107
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow ) | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ); 110
ipv6 . ip6_vfc = ( 0x6 << 4 ) | ( ipv6_class >> 4 ); 111
offset >>= 3; 114
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_NHDR ) )  121
ipv6 . ip6_nxt = tvb_get_guint8 ( tvb , offset ); 122
offset += sizeof ( guint8 ); 127
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_1 )  131
ipv6 . ip6_hlim = 1; 132
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_64 )  134
ipv6 . ip6_hlim = 64; 135
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_255 )  137
ipv6 . ip6_hlim = 255; 138
ipv6 . ip6_hlim = tvb_get_guint8 ( tvb , offset ); 141
memset ( & ipv6 . ip6_src , 0 , sizeof ( ipv6 . ip6_src ) ); 154
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_SRC_COMP ) )  159
ipv6 . ip6_src . bytes [ 0 ] = 0xfe; 161
ipv6 . ip6_src . bytes [ 1 ] = 0x80; 162
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_SRC_UNSPEC )  193
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  197
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  198
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_COMPRESSED )  199
memset ( & ipv6 . ip6_dst , 0 , sizeof ( ipv6 . ip6_dst ) ); 227
ipv6 . ip6_dst . bytes [ 0 ] = 0xfe; 234
ipv6 . ip6_dst . bytes [ 1 ] = 0x80; 235
length = sizeof ( ipv6 . ip6_dst ); 238
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 239
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 244
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 248
lowpan_dldst_to_ifcid ( pinfo , & ipv6 . ip6_dst . bytes [ 8 ] ); 252
ti = proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset , length , ( guint8 * ) & ipv6 . ip6_dst ); 333
expert_add_info_format ( pinfo , ti , PI_UNDECODED , PI_WARN , "Failed to recover destination IPv6 address" ); 336
offset += length; 338
ipv6 . ip6_nxt = lowpan_parse_nhc_proto ( tvb , offset ); 352
nhdr_list = dissect_6lowpan_iphc_nhc ( tvb , pinfo , tree , offset , dgram_size - sizeof ( struct ip6_hdr ) ); 355
length = ( gint ) tvb_ensure_length_remaining ( tvb , offset ); 359
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + length ); 360
nhdr_list -> next = NULL; 361
nhdr_list -> proto = ipv6 . ip6_nxt; 362
nhdr_list -> length = length; 363
nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); 365
nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); 368
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 370
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 378
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 379
return ipv6_tvb ; 380
0
------------------------------
60 /home/SySeVR/data/CVE_2011_1138_PATCHED_dissect_6lowpan_iphc.c memset 154
static tvbuff_t *
CVE_2011_1138_PATCHED_dissect_6lowpan_iphc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size) 2
gint offset = 0 ; 4
guint16 iphc_flags ; 12
guint8 iphc_traffic ; 13
guint8 iphc_hop_limit ; 14
guint8 ipv6_class = 0 ; 19
struct ip6_hdr ipv6 ; 20
iphc_flags = tvb_get_ntohs ( tvb , offset ); 38
iphc_traffic = ( iphc_flags & LOWPAN_IPHC_FLAG_FLOW ) >> LOWPAN_IPHC_FLAG_OFFSET_FLOW; 39
iphc_hop_limit = ( iphc_flags & LOWPAN_IPHC_FLAG_HLIM ) >> LOWPAN_IPHC_FLAG_OFFSET_HLIM; 40
offset += sizeof ( guint16 ); 58
if ( iphc_flags & LOWPAN_IPHC_FLAG_CONTEXT_ID )  61
offset += sizeof ( guint8 ); 67
offset <<= 3; 74
if ( iphc_traffic != LOWPAN_IPHC_FLOW_COMPRESSED )  76
ipv6_class |= tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_ECN_BITS ); 77
offset += LOWPAN_IPHC_ECN_BITS; 78
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS ) )  81
ipv6_class |= ( tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_DSCP_BITS ) << LOWPAN_IPHC_ECN_BITS ); 82
offset += LOWPAN_IPHC_DSCP_BITS; 83
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_ECN_LABEL ) )  98
offset += ( ( 4 - offset ) & 0x7 ); 100
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , offset , LOWPAN_IPHC_LABEL_BITS , FALSE ); 101
offset += LOWPAN_IPHC_LABEL_BITS; 105
ipv6 . ip6_flow = 0; 107
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow ) | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ); 110
ipv6 . ip6_vfc = ( 0x6 << 4 ) | ( ipv6_class >> 4 ); 111
offset >>= 3; 114
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_NHDR ) )  121
ipv6 . ip6_nxt = tvb_get_guint8 ( tvb , offset ); 122
offset += sizeof ( guint8 ); 127
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_1 )  131
ipv6 . ip6_hlim = 1; 132
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_64 )  134
ipv6 . ip6_hlim = 64; 135
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_255 )  137
ipv6 . ip6_hlim = 255; 138
ipv6 . ip6_hlim = tvb_get_guint8 ( tvb , offset ); 141
memset ( & ipv6 . ip6_src , 0 , sizeof ( ipv6 . ip6_src ) ); 154
ipv6 . ip6_src . bytes [ 0 ] = 0xfe; 161
ipv6 . ip6_src . bytes [ 1 ] = 0x80; 162
length = sizeof ( ipv6 . ip6_src ); 165
tvb_memcpy ( tvb , & ipv6 . ip6_src . bytes [ sizeof ( ipv6 . ip6_src ) - length ] , offset , length ); 166
tvb_memcpy ( tvb , & ipv6 . ip6_src . bytes [ sizeof ( ipv6 . ip6_src ) - length ] , offset , length ); 171
tvb_memcpy ( tvb , & ipv6 . ip6_src . bytes [ sizeof ( ipv6 . ip6_src ) - length ] , offset , length ); 175
lowpan_dlsrc_to_ifcid ( pinfo , & ipv6 . ip6_src . bytes [ 8 ] ); 179
ti = proto_tree_add_ipv6 ( tree , hf_6lowpan_source , tvb , offset , length , ( guint8 * ) & ipv6 . ip6_src ); 209
expert_add_info_format ( pinfo , ti , PI_UNDECODED , PI_WARN , "Failed to recover source IPv6 address" ); 212
offset += length; 214
memset ( & ipv6 . ip6_dst , 0 , sizeof ( ipv6 . ip6_dst ) ); 227
ipv6 . ip6_dst . bytes [ 0 ] = 0xfe; 234
ipv6 . ip6_dst . bytes [ 1 ] = 0x80; 235
length = sizeof ( ipv6 . ip6_dst ); 238
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 239
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 244
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 248
lowpan_dldst_to_ifcid ( pinfo , & ipv6 . ip6_dst . bytes [ 8 ] ); 252
tvb_memcpy ( tvb , & ipv6 . ip6_dst . bytes [ sizeof ( ipv6 . ip6_dst ) - length ] , offset , length ); 262
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 266
ipv6 . ip6_dst . bytes [ 11 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 267
ipv6 . ip6_dst . bytes [ 12 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 268
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 269
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 270
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 271
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 275
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 276
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 277
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 278
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 283
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 314
ipv6 . ip6_dst . bytes [ 2 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 315
ipv6 . ip6_dst . bytes [ 12 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 318
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 319
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 320
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 321
ti = proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset , length , ( guint8 * ) & ipv6 . ip6_dst ); 333
expert_add_info_format ( pinfo , ti , PI_UNDECODED , PI_WARN , "Failed to recover destination IPv6 address" ); 336
offset += length; 338
ipv6 . ip6_nxt = lowpan_parse_nhc_proto ( tvb , offset ); 352
nhdr_list = dissect_6lowpan_iphc_nhc ( tvb , pinfo , tree , offset , dgram_size - sizeof ( struct ip6_hdr ) ); 355
length = ( gint ) tvb_ensure_length_remaining ( tvb , offset ); 359
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + length ); 360
nhdr_list -> next = NULL; 361
nhdr_list -> proto = ipv6 . ip6_nxt; 362
nhdr_list -> length = length; 363
nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); 365
nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); 368
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 370
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 378
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 379
return ipv6_tvb ; 380
0
------------------------------
61 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c memset 99
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int ptr ; 13
int ifp_len ; 19
int repaired [ 16 ] ; 20
ptr = 0; 27
if ( ptr + 2 > len )  32
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
memset ( repaired , 0 , sizeof ( repaired ) ); 99
repaired [ x ] = TRUE; 104
s -> rx [ x ] . fec_span = span; 114
s -> rx [ x ] . fec_entries = entries; 121
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
memcpy ( s -> rx [ x ] . fec [ i ] , data , s -> rx [ x ] . fec_len [ i ] ); 131
for (j = 0; j < s->rx[x].fec_len[i]; j++) 134
for (l = x; l != ((x - (16 - span*entries)) & UDPTL_BUF_MASK); l = (l - 1) & UDPTL_BUF_MASK) 142
if ( s -> rx [ l ] . fec_len [ 0 ] <= 0 )  143
for (m = 0; m < s->rx[l].fec_entries; m++) 145
limit = ( l + m ) & UDPTL_BUF_MASK; 146
for (which = -1, k = (limit - s->rx[l].fec_span * s->rx[l].fec_entries) & UDPTL_BUF_MASK; k != limit; k = (k + s->rx[l].fec_entries) & UDPTL_BUF_MASK) 147
if ( s -> rx [ k ] . buf_len <= 0 )  148
which = ( which == - 1 ) ? k : - 2; 149
if ( which >= 0 )  151
for (j = 0; j < s->rx[l].fec_len[m]; j++) 153
s -> rx [ which ] . buf [ j ] = s -> rx [ l ] . fec [ m ] [ j ]; 154
for (k = (limit - s->rx[l].fec_span * s->rx[l].fec_entries) & UDPTL_BUF_MASK; k != limit; k = (k + s->rx[l].fec_entries) & UDPTL_BUF_MASK) 155
s -> rx [ which ] . buf [ j ] ^= ( s -> rx [ k ] . buf_len > j ) ? s -> rx [ k ] . buf [ j ] : 0; 156
s -> rx [ which ] . buf_len = s -> rx [ l ] . fec_len [ m ]; 158
repaired [ which ] = TRUE; 159
for (l = (x + 1) & UDPTL_BUF_MASK, j = seq_no - UDPTL_BUF_MASK; l != x; l = (l + 1) & UDPTL_BUF_MASK, j++) 164
if ( repaired [ l ] )  165
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 167
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 168
s -> f [ ifp_no ] . mallocd = 0; 170
s -> f [ ifp_no ] . seqno = j; 171
s -> f [ ifp_no ] . datalen = s -> rx [ l ] . buf_len; 172
s -> f [ ifp_no ] . data = s -> rx [ l ] . buf; 173
s -> f [ ifp_no ] . offset = 0; 174
s -> f [ ifp_no ] . src = "UDPTL"; 175
if ( ifp_no > 0 )  176
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 177
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 178
ifp_no ++; 179
if ( seq_no >= s -> rx_seq_no )  186
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
0
------------------------------
62 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c memset 29
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
memset ( & s -> f [ 0 ] , 0 , sizeof ( s -> f [ 0 ] ) ); 29
if ( seq_no > s -> rx_seq_no )  45
if ( seq_no - i >= s -> rx_seq_no )  61
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 65
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 66
s -> f [ ifp_no ] . mallocd = 0; 68
s -> f [ ifp_no ] . seqno = seq_no - i; 69
s -> f [ ifp_no ] . datalen = lengths [ i - 1 ]; 70
s -> f [ ifp_no ] . data = ( uint8_t * ) bufs [ i - 1 ]; 71
s -> f [ ifp_no ] . offset = 0; 72
s -> f [ ifp_no ] . src = "UDPTL"; 73
if ( ifp_no > 0 )  74
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 75
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 76
ifp_no ++; 77
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
0
------------------------------
63 /home/SySeVR/data/CVE_2011_1495_PATCHED__ctl_do_mpt_command.c memset 206
static long
CVE_2011_1495_PATCHED__ctl_do_mpt_command(struct MPT2SAS_ADAPTER *ioc,
struct mpt2_ioctl_command karg, void __user *mf, enum block_state state) 3
u32 ioc_state ; 7
u16 smid ; 9
u16 wait_state_count ; 22
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )  26
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )  28
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )  31
wait_state_count = 0; 38
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 39
while ( ioc_state != MPI2_IOC_STATE_OPERATIONAL )  40
if ( wait_state_count ++ == 10 )  41
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 49
mpi_request = kzalloc ( ioc -> request_sz , GFP_KERNEL ); 58
if ( ! mpi_request )  59
if ( karg . data_sge_offset * 4 > ioc -> request_sz || karg . data_sge_offset > ( UINT_MAX / 4 ) )  67
if ( copy_from_user ( mpi_request , mf , karg . data_sge_offset * 4 ) )  74
if ( mpi_request -> Function == MPI2_FUNCTION_SCSI_TASK_MGMT )  81
smid = mpt2sas_base_get_smid_hpr ( ioc , ioc -> ctl_cb_idx ); 82
if ( ! smid )  83
smid = mpt2sas_base_get_smid_scsiio ( ioc , ioc -> ctl_cb_idx , NULL ); 91
if ( ! smid )  92
ioc -> ctl_cmds . status = MPT2_CMD_PENDING; 101
memset ( ioc -> ctl_cmds . reply , 0 , ioc -> reply_sz ); 102
ioc -> ctl_cmds . smid = smid; 105
data_out_sz = karg . data_out_size; 106
data_in_sz = karg . data_in_size; 107
if ( mpi_request -> Function == MPI2_FUNCTION_SCSI_IO_REQUEST || mpi_request -> Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH )  109
if ( ! le16_to_cpu ( mpi_request -> FunctionDependent1 ) || le16_to_cpu ( mpi_request -> FunctionDependent1 ) > ioc -> facts . MaxDevHandle )  111
if ( data_out_sz )  121
data_out = pci_alloc_consistent ( ioc -> pdev , data_out_sz , & data_out_dma ); 122
if ( ! data_out )  124
if ( copy_from_user ( data_out , karg . data_out_buf_ptr , data_out_sz ) )  131
if ( data_in_sz )  141
data_in = pci_alloc_consistent ( ioc -> pdev , data_in_sz , & data_in_dma ); 142
if ( ! data_in )  144
switch ( mpi_request -> Function )  197
memset ( ioc -> ctl_cmds . sense , 0 , SCSI_SENSE_BUFFERSIZE ); 206
init_completion ( & ioc -> ctl_cmds . done ); 282
timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , timeout * HZ ); 283
if ( ! ( ioc -> ctl_cmds . status & MPT2_CMD_COMPLETE ) )  296
if ( ! ( ioc -> ctl_cmds . status & MPT2_CMD_RESET ) )  300
mpi_reply = ioc -> ctl_cmds . reply; 305
ioc_status = le16_to_cpu ( mpi_reply -> IOCStatus ) & MPI2_IOCSTATUS_MASK; 306
if ( mpi_reply -> Function == MPI2_FUNCTION_SCSI_TASK_MGMT && ( ioc -> logging_level & MPT_DEBUG_TM ) )  309
Mpi2SCSITaskManagementReply_t * tm_reply = ( Mpi2SCSITaskManagementReply_t * ) mpi_reply ; 311
if ( copy_to_user ( karg . reply_frame_buf_ptr , ioc -> ctl_cmds . reply , sz ) )  336
if ( copy_to_user ( karg . sense_data_ptr , ioc -> ctl_cmds . sense , sz ) )  350
ioc -> ctl_cmds . status = MPT2_CMD_NOT_USED; 391
mutex_unlock ( & ioc -> ctl_cmds . mutex ); 392
0
------------------------------
64 /home/SySeVR/data/CVE_2011_1495_PATCHED__ctl_do_mpt_command.c memset 102
static long
CVE_2011_1495_PATCHED__ctl_do_mpt_command(struct MPT2SAS_ADAPTER *ioc,
struct mpt2_ioctl_command karg, void __user *mf, enum block_state state) 3
u32 ioc_state ; 7
u16 smid ; 9
u16 wait_state_count ; 22
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )  26
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )  28
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )  31
wait_state_count = 0; 38
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 39
while ( ioc_state != MPI2_IOC_STATE_OPERATIONAL )  40
if ( wait_state_count ++ == 10 )  41
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 49
mpi_request = kzalloc ( ioc -> request_sz , GFP_KERNEL ); 58
if ( ! mpi_request )  59
if ( karg . data_sge_offset * 4 > ioc -> request_sz || karg . data_sge_offset > ( UINT_MAX / 4 ) )  67
if ( copy_from_user ( mpi_request , mf , karg . data_sge_offset * 4 ) )  74
if ( mpi_request -> Function == MPI2_FUNCTION_SCSI_TASK_MGMT )  81
smid = mpt2sas_base_get_smid_hpr ( ioc , ioc -> ctl_cb_idx ); 82
if ( ! smid )  83
smid = mpt2sas_base_get_smid_scsiio ( ioc , ioc -> ctl_cb_idx , NULL ); 91
if ( ! smid )  92
ioc -> ctl_cmds . status = MPT2_CMD_PENDING; 101
memset ( ioc -> ctl_cmds . reply , 0 , ioc -> reply_sz ); 102
ioc -> ctl_cmds . smid = smid; 105
if ( ! le16_to_cpu ( mpi_request -> FunctionDependent1 ) || le16_to_cpu ( mpi_request -> FunctionDependent1 ) > ioc -> facts . MaxDevHandle )  111
mpt2sas_base_free_smid ( ioc , smid ); 115
data_out = pci_alloc_consistent ( ioc -> pdev , data_out_sz , & data_out_dma ); 122
if ( ! data_out )  124
if ( copy_from_user ( data_out , karg . data_out_buf_ptr , data_out_sz ) )  131
data_in = pci_alloc_consistent ( ioc -> pdev , data_in_sz , & data_in_dma ); 142
if ( ! data_in )  144
psge += ioc -> sge_size; 167
ioc -> base_add_sg_single ( psge , sgl_flags | data_in_sz , data_in_dma ); 174
memset ( ioc -> ctl_cmds . sense , 0 , SCSI_SENSE_BUFFERSIZE ); 206
data = data_out; 250
if ( data [ 1 ] == 0x91 && ( data [ 10 ] == 1 || data [ 10 ] == 2 ) )  252
init_completion ( & ioc -> ctl_cmds . done ); 282
timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , timeout * HZ ); 283
if ( ( mpi_request -> Function == MPI2_FUNCTION_SMP_PASSTHROUGH || mpi_request -> Function == MPI2_FUNCTION_SAS_IO_UNIT_CONTROL ) && ioc -> ioc_link_reset_in_progress )  290
if ( ! ( ioc -> ctl_cmds . status & MPT2_CMD_COMPLETE ) )  296
if ( ! ( ioc -> ctl_cmds . status & MPT2_CMD_RESET ) )  300
mpi_reply = ioc -> ctl_cmds . reply; 305
ioc_status = le16_to_cpu ( mpi_reply -> IOCStatus ) & MPI2_IOCSTATUS_MASK; 306
if ( mpi_reply -> Function == MPI2_FUNCTION_SCSI_TASK_MGMT && ( ioc -> logging_level & MPT_DEBUG_TM ) )  309
Mpi2SCSITaskManagementReply_t * tm_reply = ( Mpi2SCSITaskManagementReply_t * ) mpi_reply ; 311
if ( copy_to_user ( karg . data_in_buf_ptr , data_in , data_in_sz ) )  324
sz = min_t ( u32 , karg . max_reply_bytes , ioc -> reply_sz ); 335
if ( copy_to_user ( karg . reply_frame_buf_ptr , ioc -> ctl_cmds . reply , sz ) )  336
if ( copy_to_user ( karg . sense_data_ptr , ioc -> ctl_cmds . sense , sz ) )  350
ioc -> tm_cmds . status = MPT2_CMD_NOT_USED; 373
mpt2sas_base_hard_reset_handler ( ioc , CAN_SLEEP , FORCE_BIG_HAMMER ); 375
if ( data_in )  382
pci_free_consistent ( ioc -> pdev , data_in_sz , data_in , data_in_dma ); 383
if ( data_out )  386
pci_free_consistent ( ioc -> pdev , data_out_sz , data_out , data_out_dma ); 387
ioc -> ctl_cmds . status = MPT2_CMD_NOT_USED; 391
mutex_unlock ( & ioc -> ctl_cmds . mutex ); 392
0
------------------------------
65 /home/SySeVR/data/CVE_2011_1495_VULN__ctl_diag_read_buffer.c memset 104
static long
CVE_2011_1495_VULN__ctl_diag_read_buffer(void __user *arg, enum block_state state) 2
struct mpt2_diag_read_buffer karg ; 4
struct mpt2_diag_read_buffer __user * uarg = arg ; 5
struct MPT2SAS_ADAPTER * ioc ; 6
void * request_data , * diag_data ; 7
u8 buffer_type ; 11
u16 smid ; 13
if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) )  17
if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )  22
buffer_type = karg . unique_id & 0x000000ff; 28
if ( ! _ctl_diag_capability ( ioc , buffer_type ) )  29
if ( karg . unique_id != ioc -> unique_id [ buffer_type ] )  35
request_data = ioc -> diag_buffer [ buffer_type ]; 41
if ( ! request_data )  42
if ( ( karg . starting_offset % 4 ) || ( karg . bytes_to_read % 4 ) )  48
diag_data = ( void * ) ( request_data + karg . starting_offset ); 55
if ( copy_to_user ( ( void __user * ) uarg -> diagnostic_data , diag_data , karg . bytes_to_read ) )  60
if ( ( karg . flags & MPT2_FLAGS_REREGISTER ) == 0 )  68
if ( ( ioc -> diag_buffer_status [ buffer_type ] & MPT2_DIAG_BUFFER_IS_RELEASED ) == 0 )  73
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )  82
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )  84
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )  87
smid = mpt2sas_base_get_smid ( ioc , ioc -> ctl_cb_idx ); 94
if ( ! smid )  95
ioc -> ctl_cmds . status = MPT2_CMD_PENDING; 103
memset ( ioc -> ctl_cmds . reply , 0 , ioc -> reply_sz ); 104
ioc -> ctl_cmds . smid = smid; 106
mpi_request -> BufferLength = cpu_to_le32 ( ioc -> diag_buffer_sz [ buffer_type ] ); 110
mpi_request -> BufferAddress = cpu_to_le64 ( ioc -> diag_buffer_dma [ buffer_type ] ); 112
mpi_request -> ProductSpecific [ i ] = cpu_to_le32 ( ioc -> product_specific [ buffer_type ] [ i ] ); 115
mpi_request -> VF_ID = 0; 117
mpi_request -> VP_ID = 0; 118
mpt2sas_base_put_smid_default ( ioc , smid ); 120
init_completion ( & ioc -> ctl_cmds . done ); 121
timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , MPT2_IOCTL_DEFAULT_TIMEOUT * HZ ); 122
if ( ! ( ioc -> ctl_cmds . status & MPT2_CMD_COMPLETE ) )  125
printk ( MPT2SAS_ERR_FMT "%s: timeout\n" , ioc -> name ,
__func__ ) 127
_debug_dump_mf ( mpi_request , sizeof ( Mpi2DiagBufferPostRequest_t ) / 4 ); 128
if ( ! ( ioc -> ctl_cmds . status & MPT2_CMD_RESET ) )  130
if ( ( ioc -> ctl_cmds . status & MPT2_CMD_REPLY_VALID ) == 0 )  136
printk ( MPT2SAS_ERR_FMT "%s: no reply message\n" ,
ioc -> name , __func__ ) 138
mpi_reply = ioc -> ctl_cmds . reply; 143
ioc_status = le16_to_cpu ( mpi_reply -> IOCStatus ) & MPI2_IOCSTATUS_MASK; 144
if ( ioc_status == MPI2_IOCSTATUS_SUCCESS )  146
ioc -> diag_buffer_status [ buffer_type ] |= MPT2_DIAG_BUFFER_IS_REGISTERED; 147
dctlprintk ( ioc , printk ( MPT2SAS_INFO_FMT "%s: success\n" ,
ioc -> name , __func__ ) ) 150
printk ( MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "
"log_info(0x%08x)\n" , ioc -> name , __func__ ,
ioc_status , le32_to_cpu ( mpi_reply -> IOCLogInfo ) ) 154
mpt2sas_base_hard_reset_handler ( ioc , CAN_SLEEP , FORCE_BIG_HAMMER ); 160
ioc -> ctl_cmds . status = MPT2_CMD_NOT_USED; 165
mutex_unlock ( & ioc -> ctl_cmds . mutex ); 166
0
------------------------------
66 /home/SySeVR/data/CVE_2011_2174_PATCHED_tvb_uncompress.c memset 209
tvbuff_t *
CVE_2011_2174_PATCHED_tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen) 2
guint bytes_out = 0 ; 5
guint8 * uncompr = NULL ; 7
gint wbits = MAX_WBITS ; 12
if ( tvb == NULL )  20
compr = tvb_memdup ( tvb , offset , comprlen ); 24
if ( ! compr )  26
bufsiz = tvb_length_remaining ( tvb , offset ) * 2; 33
bufsiz = CLAMP ( bufsiz , TVB_Z_MIN_BUFSIZ , TVB_Z_MAX_BUFSIZ ); 34
next = compr; 40
strm = g_new0 ( z_stream , 1 ); 42
strm -> next_in = next; 43
strm -> avail_in = comprlen; 44
strmbuf = g_malloc0 ( bufsiz ); 46
strm -> next_out = strmbuf; 47
strm -> avail_out = bufsiz; 48
err = inflateInit2 ( strm , wbits ); 50
inits_done = 1; 51
if ( err != Z_OK )  52
while ( 1 )  60
memset ( strmbuf , '\0' , bufsiz ); 61
strm -> next_out = strmbuf; 62
strm -> avail_out = bufsiz; 63
err = inflate ( strm , Z_SYNC_FLUSH ); 65
if ( err == Z_OK || err == Z_STREAM_END )  67
guint bytes_pass = bufsiz - strm -> avail_out ; 68
if ( uncompr == NULL )  74
uncompr = g_memdup ( strmbuf , bytes_pass ); 75
guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ; 77
uncompr = new_data; 84
bytes_out += bytes_pass; 87
if ( err == Z_STREAM_END )  89
if ( err == Z_BUF_ERROR )  95
if ( err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && ( * compr == 0x1f ) && ( * ( compr + 1 ) == 0x8b ) )  112
Bytef * c = compr + 2 ; 129
if ( * c == Z_DEFLATED )  132
c ++; 133
flags = * c; 142
c += 7; 145
if ( flags & ( 1 << 2 ) )  147
gint xsize = ( gint ) ( * c | ( * ( c + 1 ) << 8 ) ) ; 149
c += xsize; 152
if ( flags & ( 1 << 3 ) )  155
while ( ( c - compr ) < comprlen && * c != '\0' )  158
c ++; 159
c ++; 162
if ( flags & ( 1 << 4 ) )  165
while ( ( c - compr ) < comprlen && * c != '\0' )  168
c ++; 169
c ++; 172
next = c; 177
if ( c - compr > comprlen )  179
comprlen -= ( int ) ( c - compr ); 186
inits_done ++; 190
if ( err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3 )  191
wbits = - MAX_WBITS; 201
strm -> next_in = next; 205
strm -> avail_in = comprlen; 206
memset ( strmbuf , '\0' , bufsiz ); 209
strm -> next_out = strmbuf; 210
strm -> avail_out = bufsiz; 211
err = inflateInit2 ( strm , wbits ); 213
inits_done ++; 215
if ( err != Z_OK )  217
g_free ( strm ); 218
g_free ( strmbuf ); 219
0
------------------------------
67 /home/SySeVR/data/CVE_2011_2174_PATCHED_tvb_uncompress.c memset 61
tvbuff_t *
CVE_2011_2174_PATCHED_tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen) 2
guint bytes_out = 0 ; 5
guint8 * uncompr = NULL ; 7
gint wbits = MAX_WBITS ; 12
if ( tvb == NULL )  20
compr = tvb_memdup ( tvb , offset , comprlen ); 24
if ( ! compr )  26
bufsiz = tvb_length_remaining ( tvb , offset ) * 2; 33
bufsiz = CLAMP ( bufsiz , TVB_Z_MIN_BUFSIZ , TVB_Z_MAX_BUFSIZ ); 34
next = compr; 40
strm = g_new0 ( z_stream , 1 ); 42
strm -> next_in = next; 43
strm -> avail_in = comprlen; 44
strmbuf = g_malloc0 ( bufsiz ); 46
strm -> next_out = strmbuf; 47
strm -> avail_out = bufsiz; 48
err = inflateInit2 ( strm , wbits ); 50
inits_done = 1; 51
if ( err != Z_OK )  52
while ( 1 )  60
memset ( strmbuf , '\0' , bufsiz ); 61
strm -> next_out = strmbuf; 62
strm -> avail_out = bufsiz; 63
err = inflate ( strm , Z_SYNC_FLUSH ); 65
if ( err == Z_OK || err == Z_STREAM_END )  67
guint bytes_pass = bufsiz - strm -> avail_out ; 68
if ( uncompr == NULL )  74
uncompr = g_memdup ( strmbuf , bytes_pass ); 75
guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ; 77
g_memmove ( new_data , uncompr , bytes_out ); 79
g_memmove ( ( new_data + bytes_out ) , strmbuf , bytes_pass ); 80
g_free ( uncompr ); 83
uncompr = new_data; 84
bytes_out += bytes_pass; 87
if ( err == Z_STREAM_END )  89
if ( err == Z_BUF_ERROR )  95
if ( uncompr != NULL )  105
if ( err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && ( * compr == 0x1f ) && ( * ( compr + 1 ) == 0x8b ) )  112
Bytef * c = compr + 2 ; 129
if ( * c == Z_DEFLATED )  132
c ++; 133
inflateEnd ( strm ); 135
g_free ( strm ); 136
g_free ( strmbuf ); 138
flags = * c; 142
c += 7; 145
if ( flags & ( 1 << 2 ) )  147
gint xsize = ( gint ) ( * c | ( * ( c + 1 ) << 8 ) ) ; 149
c += xsize; 152
if ( flags & ( 1 << 3 ) )  155
while ( ( c - compr ) < comprlen && * c != '\0' )  158
c ++; 159
c ++; 162
if ( flags & ( 1 << 4 ) )  165
while ( ( c - compr ) < comprlen && * c != '\0' )  168
c ++; 169
c ++; 172
inflateReset ( strm ); 176
next = c; 177
strm -> next_in = next; 178
if ( c - compr > comprlen )  179
inflateEnd ( strm ); 180
g_free ( strm ); 181
g_free ( strmbuf ); 183
comprlen -= ( int ) ( c - compr ); 186
inflateEnd ( strm ); 188
err = inflateInit2 ( strm , wbits ); 189
inits_done ++; 190
if ( err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3 )  191
wbits = - MAX_WBITS; 201
strm -> next_in = next; 205
strm -> avail_in = comprlen; 206
memset ( strmbuf , '\0' , bufsiz ); 209
strm -> next_out = strmbuf; 210
strm -> avail_out = bufsiz; 211
err = inflateInit2 ( strm , wbits ); 213
inits_done ++; 215
if ( err != Z_OK )  217
g_free ( strm ); 218
g_free ( strmbuf ); 219
g_free ( uncompr ); 221
if ( uncompr == NULL )  230
printf ( "bytes  in: %u\nbytes out: %u\n\n" , bytes_in , bytes_out ); 241
if ( uncompr != NULL )  244
uncompr_tvb = tvb_new_real_data ( ( guint8 * ) uncompr , bytes_out , bytes_out ); 245
tvb_set_free_cb ( uncompr_tvb , g_free ); 247
return uncompr_tvb ; 250
0
------------------------------
68 /home/SySeVR/data/CVE_2011_3002_PATCHED_GrowAtomTable.c memset 23
static int CVE_2011_3002_PATCHED_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newmap = moz_xrealloc ( atable -> amap , sizeof ( int ) * size ); 7
newrev = moz_xrealloc ( atable -> arev , sizeof ( int ) * size ); 8
newmap = moz_xmalloc ( sizeof ( int ) * size ); 10
newrev = moz_xmalloc ( sizeof ( int ) * size ); 11
atable -> size = 0; 12
if ( ! newmap || ! newrev )  14
memset ( & newrev [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 23
0
------------------------------
69 /home/SySeVR/data/CVE_2011_3002_PATCHED_GrowAtomTable.c memset 22
static int CVE_2011_3002_PATCHED_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newmap = moz_xrealloc ( atable -> amap , sizeof ( int ) * size ); 7
newrev = moz_xrealloc ( atable -> arev , sizeof ( int ) * size ); 8
newmap = moz_xmalloc ( sizeof ( int ) * size ); 10
newrev = moz_xmalloc ( sizeof ( int ) * size ); 11
atable -> size = 0; 12
if ( ! newmap || ! newrev )  14
memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 22
0
------------------------------
70 /home/SySeVR/data/CVE_2011_3002_VULN_GrowAtomTable.c memset 23
static int CVE_2011_3002_VULN_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newmap = realloc ( atable -> amap , sizeof ( int ) * size ); 7
newrev = realloc ( atable -> arev , sizeof ( int ) * size ); 8
newmap = malloc ( sizeof ( int ) * size ); 10
newrev = malloc ( sizeof ( int ) * size ); 11
atable -> size = 0; 12
if ( ! newmap || ! newrev )  14
memset ( & newrev [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 23
0
------------------------------
71 /home/SySeVR/data/CVE_2011_3002_VULN_GrowAtomTable.c memset 22
static int CVE_2011_3002_VULN_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newmap = realloc ( atable -> amap , sizeof ( int ) * size ); 7
newrev = realloc ( atable -> arev , sizeof ( int ) * size ); 8
newmap = malloc ( sizeof ( int ) * size ); 10
newrev = malloc ( sizeof ( int ) * size ); 11
atable -> size = 0; 12
if ( ! newmap || ! newrev )  14
memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 22
0
------------------------------
72 /home/SySeVR/data/CVE_2011_3003_VULN_ZeroDataIfElementArray.c memset 6
PRBool CVE_2011_3003_VULN_ZeroDataIfElementArray() 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER )  2
mData = realloc ( mData , mByteLength ); 3
if ( ! mData )  4
memset ( mData , 0 , mByteLength ); 6
0
------------------------------
73 /home/SySeVR/data/CVE_2012_0041_VULN_dissect_packet.c memset 7
void
CVE_2012_0041_VULN_dissect_packet(epan_dissect_t *edt, union wtap_pseudo_header *pseudo_header,
const guchar *pd, frame_data *fd, column_info *cinfo) 3
memset ( & edt -> pi , 0 , sizeof ( edt -> pi ) ); 7
edt -> pi . current_proto = "<Missing Protocol Name>"; 8
edt -> pi . cinfo = cinfo; 9
edt -> pi . fd = fd; 10
edt -> pi . pseudo_header = pseudo_header; 11
edt -> pi . dl_src . type = AT_NONE; 12
edt -> pi . dl_dst . type = AT_NONE; 13
edt -> pi . net_src . type = AT_NONE; 14
edt -> pi . net_dst . type = AT_NONE; 15
edt -> pi . src . type = AT_NONE; 16
edt -> pi . dst . type = AT_NONE; 17
edt -> pi . ctype = CT_NONE; 18
edt -> pi . noreassembly_reason = ""; 19
edt -> pi . ptype = PT_NONE; 20
edt -> pi . p2p_dir = P2P_DIR_UNKNOWN; 21
edt -> pi . dcetransporttype = - 1; 22
edt -> pi . annex_a_used = MTP2_ANNEX_A_USED_UNKNOWN; 23
edt -> pi . dcerpc_procedure_name = ""; 24
edt -> pi . link_dir = LINK_DIR_UNKNOWN; 25
edt -> tvb = NULL; 26
edt -> pi . ethertype = G_MAXINT; 29
edt -> tvb = tvb_new_real_data ( pd , fd -> cap_len , fd -> pkt_len ); 34
add_new_data_source ( & edt -> pi , edt -> tvb , "Frame" ); 36
call_dissector ( frame_handle , edt -> tvb , & edt -> pi , edt -> tree ); 43
proto_tree_add_protocol_format ( edt -> tree , proto_malformed , edt -> tvb , 0 , 0 , "[Malformed Frame: Packet Length]" ); 51
0
------------------------------
74 /home/SySeVR/data/CVE_2012_2100_VULN_ext4_fill_flex_info.c memset 28
static int CVE_2012_2100_VULN_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
size_t size ; 8
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ); 40
atomic_add ( ext4_free_blks_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_blocks ); 42
atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ); 44
0
------------------------------
75 /home/SySeVR/data/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c memset 103
int CVE_2012_2783_PATCHED_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != p && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
0
------------------------------
76 /home/SySeVR/data/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c memset 102
int CVE_2012_2783_PATCHED_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != p && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
0
------------------------------
77 /home/SySeVR/data/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c memset 72
int CVE_2012_2783_PATCHED_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != p && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
0
------------------------------
78 /home/SySeVR/data/CVE_2012_2783_VULN_ff_vp56_decode_frame.c memset 103
int CVE_2012_2783_VULN_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
0
------------------------------
79 /home/SySeVR/data/CVE_2012_2783_VULN_ff_vp56_decode_frame.c memset 102
int CVE_2012_2783_VULN_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
0
------------------------------
80 /home/SySeVR/data/CVE_2012_2783_VULN_ff_vp56_decode_frame.c memset 72
int CVE_2012_2783_VULN_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
0
------------------------------
81 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
82 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
83 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
84 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
85 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 224
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
86 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 217
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
87 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 206
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
88 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memset 187
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
int bytes_written = 0 ; 4
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
89 /home/SySeVR/data/CVE_2012_6542_PATCHED_llc_ui_getname.c memset 9
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
0
------------------------------
90 /home/SySeVR/data/CVE_2012_6542_VULN_llc_ui_getname.c memset 14
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sock * sk = sock -> sk ; 5
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
* uaddrlen = sizeof ( sllc ); 13
memset ( uaddr , 0 , * uaddrlen ); 14
0
------------------------------
91 /home/SySeVR/data/CVE_2012_6542_VULN_llc_ui_getname.c memset 9
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
0
------------------------------
92 /home/SySeVR/data/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memset 17
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
memset ( & ifr , 0 , sizeof ( ifr ) ); 17
ifr . ifr_name [ IFNAMSIZ - 1 ] = '\0'; 32
ret = tun_set_iff ( tfile -> net , file , & ifr ); 34
if ( ret )  36
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  39
return ret ; 206
0
------------------------------
93 /home/SySeVR/data/CVE_2012_6618_PATCHED_av_probe_input_buffer.c memset 50
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
0
------------------------------
94 /home/SySeVR/data/CVE_2012_6618_VULN_av_probe_input_buffer.c memset 50
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
return ret ; 71
0
------------------------------
95 /home/SySeVR/data/CVE_2013_0848_VULN_decode_init.c memset 6
static av_cold int CVE_2013_0848_VULN_decode_init(AVCodecContext *avctx) 1
HYuvContext * s = avctx -> priv_data ; 3
memset ( s -> vlc , 0 , 3 * sizeof ( VLC ) ); 6
avctx -> coded_frame = & s -> picture; 8
avcodec_get_frame_defaults ( & s -> picture ); 9
s -> interlaced = s -> height > 288; 10
s -> bgr32 = 1; 12
if ( avctx -> extradata_size )  14
if ( ( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12 )  15
s -> version = 1; 17
if ( s -> version == 2 )  23
if ( avctx -> extradata_size < 4 )  26
method = ( ( uint8_t * ) avctx -> extradata ) [ 0 ]; 29
s -> decorrelate = method & 64 ? 1 : 0; 30
s -> predictor = method & 63; 31
s -> bitstream_bpp = ( ( uint8_t * ) avctx -> extradata ) [ 1 ]; 32
if ( s -> bitstream_bpp == 0 )  33
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 34
interlace = ( ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x30 ) >> 4; 35
s -> interlaced = ( interlace == 1 ) ? 1 : ( interlace == 2 ) ? 0 : s -> interlaced; 36
s -> context = ( ( uint8_t * ) avctx -> extradata ) [ 2 ] & 0x40 ? 1 : 0; 37
if ( read_huffman_tables ( s , ( ( uint8_t * ) avctx -> extradata ) + 4 , avctx -> extradata_size - 4 ) < 0 )  39
switch ( avctx -> bits_per_coded_sample & 7 )  43
s -> decorrelate = avctx -> bits_per_coded_sample >= 24; 54
s -> predictor = MEDIAN; 57
s -> decorrelate = 0; 58
s -> predictor = LEFT; 61
s -> decorrelate = 0; 62
s -> bitstream_bpp = avctx -> bits_per_coded_sample & ~7; 65
s -> context = 0; 66
if ( read_old_huffman_tables ( s ) < 0 )  68
switch ( s -> bitstream_bpp )  72
avctx -> pix_fmt = PIX_FMT_YUV420P; 74
if ( s -> yuy2 )  77
avctx -> pix_fmt = PIX_FMT_YUYV422; 78
if ( s -> bgr32 )  85
if ( ( avctx -> pix_fmt == PIX_FMT_YUV422P || avctx -> pix_fmt == PIX_FMT_YUV420P ) && avctx -> width & 1 )  95
alloc_temp ( s ); 100
0
------------------------------
96 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c memset 288
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
0
------------------------------
97 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c memset 288
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
0
------------------------------
98 /home/SySeVR/data/CVE_2013_0851_PATCHED_decode_frame.c memset 55
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 26 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
0
------------------------------
99 /home/SySeVR/data/CVE_2013_0851_VULN_decode_frame.c memset 55
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
MadContext * s = avctx -> priv_data ; 8
int width , height ; 9
if ( buf_size < 17 )  13
buf += 8; 21
width = AV_RL16 ( & buf [ 8 ] ); 26
height = AV_RL16 ( & buf [ 10 ] ); 27
buf += 16; 29
if ( avctx -> width != width || avctx -> height != height )  31
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
if ( av_image_check_size ( width , height , 0 , avctx ) < 0 )  34
s -> frame . reference = 3; 43
if ( ! s -> frame . data [ 0 ] )  44
if ( avctx -> get_buffer ( avctx , & s -> frame ) < 0 )  45
if ( ! s -> bitstream_buf )  52
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
0
------------------------------
100 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c memset 429
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( useService )  300
BOOL isLocal = FALSE ; 301
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 302
if ( useService )  311
BOOL unpromptedElevation ; 312
if ( IsUnpromptedElevation ( unpromptedElevation ) )  313
useService = ! unpromptedElevation; 314
if ( useService )  320
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 321
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
HKEY baseKey ; 323
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  324
useService = testOnlyFallbackKeyExists; 330
useService = false; 336
if ( useService )  349
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 352
useService = ( ret == ERROR_SUCCESS ); 353
if ( useService )  355
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 377
if ( lastState != SERVICE_STOPPED )  378
useService = false; 382
if ( ! useService && sBackgroundUpdate )  393
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
SHELLEXECUTEINFO sinfo ; 428
memset ( & sinfo , 0 , sizeof ( SHELLEXECUTEINFO ) ); 429
sinfo . cbSize = sizeof ( SHELLEXECUTEINFO ); 430
sinfo . fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOCLOSEPROCESS; 431
sinfo . hwnd = NULL; 434
sinfo . lpFile = argv [ 0 ]; 435
sinfo . lpParameters = cmdLine; 436
sinfo . nShow = SW_SHOWNORMAL; 438
bool result = ShellExecuteEx ( & sinfo ) ; 440
if ( result )  443
WaitForSingleObject ( sinfo . hProcess , INFINITE ); 444
CloseHandle ( sinfo . hProcess ); 445
0
------------------------------
101 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c memset 429
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( useService )  300
BOOL isLocal = FALSE ; 301
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 302
if ( useService )  311
BOOL unpromptedElevation ; 312
if ( IsUnpromptedElevation ( unpromptedElevation ) )  313
useService = ! unpromptedElevation; 314
if ( useService )  320
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 321
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
HKEY baseKey ; 323
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  324
useService = testOnlyFallbackKeyExists; 330
useService = false; 336
if ( useService )  349
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 352
useService = ( ret == ERROR_SUCCESS ); 353
if ( useService )  355
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 377
if ( lastState != SERVICE_STOPPED )  378
useService = false; 382
if ( ! useService && sBackgroundUpdate )  393
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
SHELLEXECUTEINFO sinfo ; 428
memset ( & sinfo , 0 , sizeof ( SHELLEXECUTEINFO ) ); 429
sinfo . cbSize = sizeof ( SHELLEXECUTEINFO ); 430
sinfo . fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOCLOSEPROCESS; 431
sinfo . hwnd = NULL; 434
sinfo . lpFile = argv [ 0 ]; 435
sinfo . lpParameters = cmdLine; 436
sinfo . nShow = SW_SHOWNORMAL; 438
bool result = ShellExecuteEx ( & sinfo ) ; 440
if ( result )  443
WaitForSingleObject ( sinfo . hProcess , INFINITE ); 444
CloseHandle ( sinfo . hProcess ); 445
0
------------------------------
102 /home/SySeVR/data/CVE_2013_1920_PATCHED_get_free_port.c memset 20
static int CVE_2013_1920_PATCHED_get_free_port(struct domain *d) 1
struct evtchn * chn ; 3
int port ; 4
if ( d -> is_dying )  7
for ( port = 0; port_is_valid(d, port); port++ ) 10
if ( evtchn_from_port ( d , port ) -> state == ECS_FREE )  11
if ( port == MAX_EVTCHNS ( d ) )  14
chn = xmalloc_array ( struct evtchn , EVTCHNS_PER_BUCKET ) 17
if ( unlikely ( chn == NULL ) )  18
memset ( chn , 0 , EVTCHNS_PER_BUCKET * sizeof ( * chn ) ); 20
if ( xsm_alloc_security_evtchn ( & chn [ i ] ) )  24
xsm_free_security_evtchn ( & chn [ j ] ); 27
xfree ( chn ); 28
bucket_from_port ( d , port ) = chn; 33
0
------------------------------
103 /home/SySeVR/data/CVE_2013_1920_VULN_get_free_port.c memset 20
static int CVE_2013_1920_VULN_get_free_port(struct domain *d) 1
struct evtchn * chn ; 3
int port ; 4
if ( d -> is_dying )  7
for ( port = 0; port_is_valid(d, port); port++ ) 10
if ( evtchn_from_port ( d , port ) -> state == ECS_FREE )  11
if ( port == MAX_EVTCHNS ( d ) )  14
chn = xmalloc_array ( struct evtchn , EVTCHNS_PER_BUCKET ) 17
if ( unlikely ( chn == NULL ) )  18
memset ( chn , 0 , EVTCHNS_PER_BUCKET * sizeof ( * chn ) ); 20
bucket_from_port ( d , port ) = chn; 21
if ( xsm_alloc_security_evtchn ( & chn [ i ] ) )  25
xsm_free_security_evtchn ( & chn [ j ] ); 28
xfree ( chn ); 29
0
------------------------------
104 /home/SySeVR/data/CVE_2013_3674_VULN_cdg_decode_frame.c memset 41
static int CVE_2013_3674_VULN_cdg_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
int ret ; 6
uint8_t command , inst ; 7
uint8_t cdg_data [ CDG_DATA_SIZE ] ; 8
CDGraphicsContext * cc = avctx -> priv_data ; 10
if ( buf_size < CDG_MINIMUM_PKT_SIZE )  12
if ( buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE )  16
ret = avctx -> reget_buffer ( avctx , & cc -> frame ); 21
if ( ret )  22
if ( ! avctx -> frame_number )  26
memset ( cc -> frame . data [ 0 ] , 0 , cc -> frame . linesize [ 0 ] * avctx -> height ); 27
memset ( cc -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ); 28
command = bytestream_get_byte ( & buf ); 31
inst = bytestream_get_byte ( & buf ); 32
inst &= CDG_MASK; 33
if ( ( command & CDG_MASK ) == CDG_COMMAND )  37
switch ( inst )  38
if ( ! ( cdg_data [ 1 ] & 0x0F ) )  40
memset ( cc -> frame . data [ 0 ] , cdg_data [ 0 ] & 0x0F , cc -> frame . linesize [ 0 ] * CDG_FULL_HEIGHT ); 41
0
------------------------------
105 /home/SySeVR/data/CVE_2013_3674_VULN_cdg_decode_frame.c memset 28
static int CVE_2013_3674_VULN_cdg_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
int ret ; 6
CDGraphicsContext * cc = avctx -> priv_data ; 10
if ( buf_size < CDG_MINIMUM_PKT_SIZE )  12
if ( buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE )  16
ret = avctx -> reget_buffer ( avctx , & cc -> frame ); 21
if ( ret )  22
if ( ! avctx -> frame_number )  26
memset ( cc -> frame . data [ 0 ] , 0 , cc -> frame . linesize [ 0 ] * avctx -> height ); 27
memset ( cc -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ); 28
memset ( cc -> frame . data [ 0 ] , cdg_data [ 0 ] & 0x0F , cc -> frame . linesize [ 0 ] * CDG_FULL_HEIGHT ); 41
0
------------------------------
106 /home/SySeVR/data/CVE_2013_3674_VULN_cdg_decode_frame.c memset 27
static int CVE_2013_3674_VULN_cdg_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
int ret ; 6
CDGraphicsContext * cc = avctx -> priv_data ; 10
if ( buf_size < CDG_MINIMUM_PKT_SIZE )  12
if ( buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE )  16
ret = avctx -> reget_buffer ( avctx , & cc -> frame ); 21
if ( ret )  22
if ( ! avctx -> frame_number )  26
memset ( cc -> frame . data [ 0 ] , 0 , cc -> frame . linesize [ 0 ] * avctx -> height ); 27
memset ( cc -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ); 28
memset ( cc -> frame . data [ 0 ] , cdg_data [ 0 ] & 0x0F , cc -> frame . linesize [ 0 ] * CDG_FULL_HEIGHT ); 41
0
------------------------------
107 /home/SySeVR/data/CVE_2013_4079_VULN_dissect_schedule_message.c memset 53
static void
CVE_2013_4079_VULN_dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 2
guint8 len , sched_begin , sched_end , new_slots [ 48 ] ; 5
guint8 offset = 0 ; 6
gboolean valid_message = TRUE ; 7
guint16 other_slots [ 48 ] ; 8
len = tvb_length ( tvb ); 12
schedule_item = proto_tree_add_protocol_format ( top_tree , proto_cbch , tvb , 0 , len , "GSM CBCH Schedule Message" ); 16
sched_tree = proto_item_add_subtree ( schedule_item , ett_schedule_msg ); 19
octet1 = tvb_get_guint8 ( tvb , offset ); 22
if ( 0 == ( octet1 & 0xC0 ) )  23
sched_begin = octet1 & 0x3F; 25
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_begin_slot , tvb , offset ++ , 1 , ENC_BIG_ENDIAN ); 26
if ( 1 == sched_begin )  27
if ( ( 2 <= sched_begin ) && ( 48 >= sched_begin ) )  31
valid_message = FALSE; 38
sched_end = tvb_get_guint8 ( tvb , offset ); 41
if ( sched_end < sched_begin )  43
valid_message = FALSE; 46
if ( valid_message )  49
memset ( & other_slots , 0xFF , sizeof ( other_slots ) ); 53
octet1 = tvb_get_guint8 ( tvb , offset ); 75
if ( ( octet1 & 0x80 ) == 0x80 )  76
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 82
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 83
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 84
offset += 2; 87
other_slots [ new_slots [ i ] - 1 ] = msg_id; 88
if ( ( octet1 & 0xC0 ) == 0 )  90
if ( octet1 < new_slots [ i ] )  93
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 95
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 98
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 102
if ( octet1 == 0x40 )  107
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , new_slots [ k ] ); 110
if ( octet1 == 0x41 )  113
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , new_slots [ k ] ); 116
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
proto_item_set_end ( item , tvb , offset ); 126
item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ); 129
sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ); 130
for (k=0; offset<len; j++) 131
while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) )  133
octet1 = tvb_get_guint8 ( tvb , offset ); 140
if ( ( octet1 & 0x80 ) == 0x80 )  141
if ( ( offset + 1 ) < len )  143
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 149
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 150
other_slots [ k ] = msg_id; 151
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message: %d, First transmission of an SMSCB within the Schedule Period" , ++ k , msg_id ); 152
offset += 2; 155
if ( ( octet1 & 0xC0 ) == 0 )  158
if ( octet1 < k )  161
other_slots [ k ] = other_slots [ octet1 - 1 ]; 163
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , ++ k , other_slots [ octet1 - 1 ] , octet1 ); 164
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , ++ k , octet1 ); 170
if ( octet1 == 0x40 )  175
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , ++ k ); 178
if ( octet1 == 0x41 )  180
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , ++ k ); 183
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , ++ k , octet1 ); 188
proto_item_set_end ( item , tvb , offset ); 191
proto_tree_add_text ( sched_tree , tvb , offset , - 1 , "Padding" ); 192
0
------------------------------
108 /home/SySeVR/data/CVE_2013_4079_VULN_dissect_schedule_message.c memset 52
static void
CVE_2013_4079_VULN_dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 2
guint8 len , sched_begin , sched_end , new_slots [ 48 ] ; 5
guint8 offset = 0 ; 6
gboolean valid_message = TRUE ; 7
len = tvb_length ( tvb ); 12
schedule_item = proto_tree_add_protocol_format ( top_tree , proto_cbch , tvb , 0 , len , "GSM CBCH Schedule Message" ); 16
sched_tree = proto_item_add_subtree ( schedule_item , ett_schedule_msg ); 19
octet1 = tvb_get_guint8 ( tvb , offset ); 22
if ( 0 == ( octet1 & 0xC0 ) )  23
sched_begin = octet1 & 0x3F; 25
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_begin_slot , tvb , offset ++ , 1 , ENC_BIG_ENDIAN ); 26
if ( 1 == sched_begin )  27
if ( ( 2 <= sched_begin ) && ( 48 >= sched_begin ) )  31
valid_message = FALSE; 38
sched_end = tvb_get_guint8 ( tvb , offset ); 41
if ( sched_end < sched_begin )  43
valid_message = FALSE; 46
if ( valid_message )  49
memset ( & new_slots , 0xFF , sizeof ( new_slots ) ); 52
new_slots [ k ++ ] = ( i << 3 ) + j + 1; 65
item = proto_tree_add_text ( sched_tree , tvb , offset - 6 , 6 , "This schedule contains %d slots with new messages" , k ); 70
sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ); 71
for (i=0; i<k; i++) 72
DISSECTOR_ASSERT ( new_slots [ i ] < 48 ); 74
octet1 = tvb_get_guint8 ( tvb , offset ); 75
if ( ( octet1 & 0x80 ) == 0x80 )  76
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 82
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 83
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 84
offset += 2; 87
other_slots [ new_slots [ i ] - 1 ] = msg_id; 88
if ( ( octet1 & 0xC0 ) == 0 )  90
if ( octet1 < new_slots [ i ] )  93
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 95
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 98
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 102
if ( octet1 == 0x40 )  107
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , new_slots [ k ] ); 110
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 111
if ( octet1 == 0x41 )  113
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , new_slots [ k ] ); 116
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 117
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 123
proto_item_set_end ( item , tvb , offset ); 126
item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ); 129
sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ); 130
for (k=0; offset<len; j++) 131
while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) )  133
k ++; 135
if ( k >= sched_end )  137
octet1 = tvb_get_guint8 ( tvb , offset ); 140
if ( ( octet1 & 0x80 ) == 0x80 )  141
if ( ( offset + 1 ) < len )  143
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 149
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 150
other_slots [ k ] = msg_id; 151
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message: %d, First transmission of an SMSCB within the Schedule Period" , ++ k , msg_id ); 152
offset += 2; 155
if ( ( octet1 & 0xC0 ) == 0 )  158
if ( octet1 < k )  161
other_slots [ k ] = other_slots [ octet1 - 1 ]; 163
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , ++ k , other_slots [ octet1 - 1 ] , octet1 ); 164
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , ++ k , octet1 ); 170
if ( octet1 == 0x40 )  175
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , ++ k ); 178
if ( octet1 == 0x41 )  180
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , ++ k ); 183
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , ++ k , octet1 ); 188
proto_item_set_end ( item , tvb , offset ); 191
proto_tree_add_text ( sched_tree , tvb , offset , - 1 , "Padding" ); 192
0
------------------------------
109 /home/SySeVR/data/CVE_2013_4514_VULN_wvlan_set_station_nickname.c memset 17
int CVE_2013_4514_VULN_wvlan_set_station_nickname(struct net_device *dev,
struct iw_request_info *info,
union iwreq_data *wrqu,
char *extra) 4
struct wl_private * lp = wl_priv ( dev ) ; 6
memset ( lp -> StationName , 0 , sizeof ( lp -> StationName ) ); 17
memcpy ( lp -> StationName , extra , wrqu -> data . length ); 19
wl_apply ( lp ); 22
wl_unlock ( lp , & flags ); 23
0
------------------------------
110 /home/SySeVR/data/CVE_2013_4922_VULN_dissect_dcom_ActivationProperties.c memset 25
static int
CVE_2013_4922_VULN_dissect_dcom_ActivationProperties(tvbuff_t *tvb, gint offset, packet_info *pinfo,
proto_tree *tree, guint8 *drep, gint size _U_) 3
dcerpc_info * di ; 5
di = ( dcerpc_info * ) pinfo -> private_data; 20
di -> private_data = g_new ( property_guids_t , 1 ); 24
memset ( di -> private_data , 0 , sizeof ( property_guids_t ) ); 25
g_free ( di -> private_data ); 30
0
------------------------------
111 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c memset 336
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
112 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c memset 85
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
if ( ! process_sdp_o ( value , p ) )  103
res = ( p -> session_modify == FALSE ) ? 0 : - 1; 104
if ( process_sdp_a_audio ( value , p , & newaudiortp , & last_rtpmap_codec ) )  122
if ( process_sdp_a_video ( value , p , & newvideortp , & last_rtpmap_codec ) )  124
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_image ( value , p ) )  128
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
ast_copy_string ( p -> offered_media [ SDP_AUDIO ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_AUDIO ] . codecs ) ); 190
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
ast_copy_string ( p -> offered_media [ SDP_VIDEO ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_VIDEO ] . codecs ) ); 243
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
ast_copy_string ( p -> offered_media [ SDP_TEXT ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_TEXT ] . codecs ) ); 288
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
ast_verbose ( "Got T.38 offer in SDP in dialog %s\n" , p -> callid ); 329
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
if ( p -> t38 . state != T38_ENABLED )  335
memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); 336
ast_udptl_set_error_correction_scheme ( p -> udptl , UDPTL_ERROR_CORRECTION_NONE ); 340
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
if ( process_sdp_a_audio ( value , p , & newaudiortp , & last_rtpmap_codec ) )  388
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
if ( process_sdp_a_video ( value , p , & newvideortp , & last_rtpmap_codec ) )  397
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
if ( process_sdp_a_image ( value , p ) )  412
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
change_t38_state ( p , T38_DISABLED ); 481
ast_format_cap_joint_copy ( p -> caps , newpeercapability , newjointcapability ); 493
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
ast_verbose ( "Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> caps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , peercapability ) , ast_getformatname_multiple ( s3 , SIPBUFSIZE , vpeercapability ) , ast_getformatname_multiple ( s4 , SIPBUFSIZE , tpeercapability ) , ast_getformatname_multiple ( s5 , SIPBUFSIZE , newjointcapability ) ); 507
ast_verbose ( "Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n" , ast_rtp_lookup_mime_multiple2 ( s1 , NULL , p -> noncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s2 , NULL , peernoncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s3 , NULL , newnoncodeccapability , 0 , 0 ) ); 519
ast_format_cap_copy ( p -> jointcaps , newjointcapability ); 528
ast_format_cap_copy ( p -> peercaps , newpeercapability ); 529
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_PREFERRED_CODEC ) )  533
ast_codec_choose ( & p -> prefs , p -> jointcaps , 1 , & tmp_fmt ); 534
ast_format_cap_set ( p -> jointcaps , & tmp_fmt ); 535
if ( p -> rtp )  540
ast_rtp_instance_set_remote_address ( p -> rtp , sa ); 543
ast_rtp_codecs_payloads_copy ( & newaudiortp , ast_rtp_instance_get_codecs ( p -> rtp ) , p -> rtp ); 549
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_RTCP , 1 ); 552
if ( p -> owner )  554
ast_channel_set_fd ( p -> owner , 1 , ast_rtp_instance_fd ( p -> rtp , 1 ) ); 555
if ( ast_test_flag ( & p -> flags [ 0 ] , SIP_DTMF ) == SIP_DTMF_AUTO )  558
ast_clear_flag ( & p -> flags [ 0 ] , SIP_DTMF ); 559
if ( newnoncodeccapability & AST_RTP_DTMF )  560
ast_set_flag ( & p -> flags [ 0 ] , SIP_DTMF_RFC2833 ); 562
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_DTMF , 1 ); 564
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_DTMF_COMPENSATE , ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_RFC2833_COMPENSATE ) ); 565
ast_set_flag ( & p -> flags [ 0 ] , SIP_DTMF_INBAND ); 567
if ( p -> owner )  574
ast_channel_set_fd ( p -> owner , 1 , - 1 ); 575
ast_rtp_instance_set_prop ( p -> rtp , AST_RTP_PROPERTY_RTCP , 0 ); 578
ast_rtp_instance_stop ( p -> rtp ); 580
if ( p -> vrtp )  587
ast_rtp_instance_set_remote_address ( p -> vrtp , vsa ); 590
ast_rtp_codecs_payloads_copy ( & newvideortp , ast_rtp_instance_get_codecs ( p -> vrtp ) , p -> vrtp ); 595
ast_rtp_instance_stop ( p -> vrtp ); 597
if ( p -> trtp )  604
ast_rtp_instance_set_remote_address ( p -> trtp , tsa ); 607
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
ast_rtp_red_init ( p -> trtp , 300 , red_data_pt , 2 ); 614
ast_rtp_codecs_payloads_copy ( & newtextrtp , ast_rtp_instance_get_codecs ( p -> trtp ) , p -> trtp ); 618
ast_rtp_instance_stop ( p -> trtp ); 620
if ( p -> udptl )  627
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_SYMMETRICRTP ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_UDPTL_DESTINATION ) )  629
ast_rtp_instance_get_remote_address ( p -> rtp , isa ); 630
ast_udptl_set_peer ( p -> udptl , isa ); 636
if ( ! ast_udptl_get_far_max_datagram ( p -> udptl ) )  641
ast_udptl_set_far_max_datagram ( p -> udptl , 0 ); 643
if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  647
if ( ( t38action == SDP_T38_INITIATE ) && p -> owner && p -> lastinvite )  650
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_FAX_DETECT_T38 ) )  654
ast_channel_lock ( p -> owner ); 655
if ( strcmp ( p -> owner -> exten , "fax" ) )  656
const char * target_context = S_OR ( p -> owner -> macrocontext , p -> owner -> context ) ; 657
ast_channel_unlock ( p -> owner ); 658
if ( ast_exists_extension ( p -> owner , target_context , "fax" , 1 , S_COR ( p -> owner -> caller . id . number . valid , p -> owner -> caller . id . number . str , NULL ) ) )  659
pbx_builtin_setvar_helper ( p -> owner , "FAXEXTEN" , p -> owner -> exten ); 662
if ( ast_async_goto ( p -> owner , target_context , "fax" , 1 ) )  663
ast_log ( LOG_NOTICE , "Failed to async goto '%s' into fax of '%s'\n" , p -> owner -> name , target_context ); 664
ast_channel_unlock ( p -> owner ); 670
ast_udptl_stop ( p -> udptl ); 676
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
ast_debug ( 2 , "We're settling with these formats: %s\n" , ast_getformatname_multiple ( buf , SIPBUFSIZE , p -> jointcaps ) ); 689
if ( ! p -> owner )  691
if ( ast_format_cap_has_type ( p -> jointcaps , AST_FORMAT_TYPE_AUDIO ) )  697
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
ast_codec_choose ( & p -> prefs , p -> jointcaps , 1 , & tmp_fmt ); 705
ast_format_cap_set ( p -> owner -> nativeformats , & tmp_fmt ); 707
ast_format_cap_joint_append ( p -> caps , vpeercapability , p -> owner -> nativeformats ); 708
ast_format_cap_joint_append ( p -> caps , tpeercapability , p -> owner -> nativeformats ); 709
ast_set_read_format ( p -> owner , & p -> owner -> readformat ); 711
ast_set_write_format ( p -> owner , & p -> owner -> writeformat ); 712
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_CALL_ONHOLD ) && ( ! ast_sockaddr_isnull ( sa ) || ! ast_sockaddr_isnull ( vsa ) || ! ast_sockaddr_isnull ( tsa ) || ! ast_sockaddr_isnull ( isa ) ) && ( ! sendonly || sendonly == - 1 ) )  715
ast_queue_control ( p -> owner , AST_CONTROL_UNHOLD ); 716
ast_queue_frame ( p -> owner , & ast_null_frame ); 718
ast_queue_control_data ( p -> owner , AST_CONTROL_HOLD , S_OR ( p -> mohsuggest , NULL ) , ! ast_strlen_zero ( p -> mohsuggest ) ? strlen ( p -> mohsuggest ) + 1 : 0 ); 721
ast_rtp_instance_stop ( p -> rtp ); 725
ast_queue_frame ( p -> owner , & ast_null_frame ); 728
return res ; 738
0
------------------------------
113 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c memset 42
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
0
------------------------------
114 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c memset 42
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  134
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 143
if ( ! p )  144
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 150
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 151
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 152
sg_list [ i ] = p; 153
sg_indx = i; 154
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  157
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 163
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 165
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 166
byte_count += upsg -> sg [ i ] . count; 167
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 168
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
0
------------------------------
115 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c memset 7
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
memset ( state , 128 , sizeof ( state ) ); 7
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); 12
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 49
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 58
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 87
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); 93
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); 109
av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); 113
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); 118
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); 136
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); 171
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
context_count = f -> context_count [ idx ]; 178
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( f -> version <= 2 )  183
av_assert0 ( context_count >= 0 ); 184
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
0
------------------------------
116 /home/SySeVR/data/CVE_2013_7264_PATCHED_l2tp_ip_recvmsg.c memset 34
static int CVE_2013_7264_PATCHED_l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
size_t len, int noblock, int flags, int *addr_len) 2
struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; 7
struct sk_buff * skb ; 8
if ( flags & MSG_OOB )  10
skb = skb_recv_datagram ( sk , flags , noblock , & err ); 13
if ( ! skb )  14
copied = skb -> len; 17
if ( len < copied )  18
msg -> msg_flags |= MSG_TRUNC; 19
copied = len; 20
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 23
if ( err )  24
if ( sin )  30
sin -> sin_family = AF_INET; 31
sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr; 32
sin -> sin_port = 0; 33
memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ); 34
* addr_len = sizeof ( * sin ); 35
0
------------------------------
117 /home/SySeVR/data/CVE_2013_7264_VULN_l2tp_ip_recvmsg.c memset 37
static int CVE_2013_7264_VULN_l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
size_t len, int noblock, int flags, int *addr_len) 2
struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; 7
struct sk_buff * skb ; 8
if ( flags & MSG_OOB )  10
skb = skb_recv_datagram ( sk , flags , noblock , & err ); 16
if ( ! skb )  17
copied = skb -> len; 20
if ( len < copied )  21
msg -> msg_flags |= MSG_TRUNC; 22
copied = len; 23
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 26
if ( err )  27
if ( sin )  33
sin -> sin_family = AF_INET; 34
sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr; 35
sin -> sin_port = 0; 36
memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ); 37
0
------------------------------
118 /home/SySeVR/data/CVE_2013_7339_VULN_rds_ib_laddr_check.c memset 14
static int CVE_2013_7339_VULN_rds_ib_laddr_check(__be32 addr) 1
struct rdma_cm_id * cm_id ; 4
struct sockaddr_in sin ; 5
cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ); 10
if ( IS_ERR ( cm_id ) )  11
memset ( & sin , 0 , sizeof ( sin ) ); 14
sin . sin_family = AF_INET; 15
sin . sin_addr . s_addr = addr; 16
ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ); 19
if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  22
rdsdebug ( "addr %pI4 ret %d node type %d\n" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ); 25
return ret ; 31
0
------------------------------
119 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c memset 417
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
context -> accept_socket = INVALID_SOCKET; 271
if ( context -> accept_socket == INVALID_SOCKET )  283
err_count = 0; 289
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
context -> overlapped . Pointer = NULL; 328
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
0
------------------------------
120 /home/SySeVR/data/CVE_2014_3640_VULN_udp_input.c memset 58
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
memset ( & ( ( struct ipovly * ) ip ) -> ih_mbuf , 0 , sizeof ( struct mbuf_ptr ) ); 58
0
------------------------------
121 /home/SySeVR/data/CVE_2014_4654_VULN_snd_ctl_elem_add.c memset 20
static int CVE_2014_4654_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
0
------------------------------
122 /home/SySeVR/data/CVE_2014_4655_PATCHED_snd_ctl_elem_add.c memset 18
static int CVE_2014_4655_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_kcontrol kctl , * _kctl ; 5
if ( info -> count < 1 )  11
memset ( & kctl , 0 , sizeof ( kctl ) ); 18
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 29
kctl . count = info -> owner ? info -> owner : 1; 30
kctl . info = snd_ctl_elem_user_enum_info; 33
kctl . info = snd_ctl_elem_user_info; 35
kctl . get = snd_ctl_elem_user_get; 37
kctl . put = snd_ctl_elem_user_put; 39
kctl . tlv . c = snd_ctl_elem_user_tlv; 41
kctl . private_free = snd_ctl_elem_user_free; 89
_kctl = snd_ctl_new ( & kctl , access ); 90
if ( _kctl == NULL )  91
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
0
------------------------------
123 /home/SySeVR/data/CVE_2014_4655_VULN_snd_ctl_elem_add.c memset 20
static int CVE_2014_4655_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
0
------------------------------
124 /home/SySeVR/data/CVE_2014_5163_PATCHED_decode_apn.c memset 8
static void
CVE_2014_5163_PATCHED_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH + 1 ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
0
------------------------------
125 /home/SySeVR/data/CVE_2014_5163_VULN_decode_apn.c memset 8
static void
CVE_2014_5163_VULN_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
0
------------------------------
126 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 153
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for(y = 0; y < avctx->height ; y++ ) 151
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 152
memset ( row , 0 , avctx -> width << 2 ); 153
decodeplane32 ( ( uint32_t * ) row , s -> planebuf , s -> planesize , plane ); 156
0
------------------------------
127 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 143
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for (y = 0; y < avctx->height ; y++) 141
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 143
for (plane = 0; plane < s->bpp; plane++) 144
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 145
decodeplane8 ( s -> ham_buf , s -> planebuf , s -> planesize , plane ); 146
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 148
decode_rgb8 ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 185
decode_rgbn ( & gb , s -> frame . data [ 0 ] , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 187
decode_deep_tvdc32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] , s -> tvdc ); 195
* ( AVFrame * ) data = s -> frame; 206
0
------------------------------
128 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 133
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
for (y = 0; y < avctx->height ; y++ ) 131
memset ( s -> mask_buf , 0 , avctx -> width * sizeof ( uint32_t ) ); 133
for (plane = 0; plane < s->bpp; plane++) 134
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 135
decodeplane32 ( s -> mask_buf , s -> planebuf , s -> planesize , plane ); 136
lookup_pal_indicies ( ( uint32_t * ) row , s -> mask_buf , s -> mask_palbuf , avctx -> width ); 138
0
------------------------------
129 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 124
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
for(y = 0; y < avctx->height ; y++ ) 122
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 123
memset ( row , 0 , avctx -> width ); 124
decodeplane8 ( row , s -> planebuf , s -> planesize , plane ); 127
0
------------------------------
130 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 94
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for(y = 0; y < avctx->height; y++ ) 92
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 93
memset ( row , 0 , avctx -> width << 2 ); 94
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
0
------------------------------
131 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 84
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for (y = 0; y < avctx->height; y++) 82
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 84
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 85
decodeplane8 ( s -> ham_buf , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 86
buf += s -> planesize; 87
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 89
0
------------------------------
132 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 75
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
for(y = 0; y < avctx->height; y++ ) 73
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 74
memset ( row , 0 , avctx -> width ); 75
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
0
------------------------------
133 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 47
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
for(y = 0; y < avctx->height; y++) 45
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 47
for (plane = 0; plane < s->bpp; plane++) 48
const uint8_t * start = buf + ( plane * avctx -> height + y ) * s -> planesize ; 49
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
0
------------------------------
134 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 44
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 44
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 46
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
0
------------------------------
135 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memset 35
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 35
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 38
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
0
------------------------------
136 /home/SySeVR/data/CVE_2014_6429_VULN_SnifferDecompress.c memset 104
static int
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
137 /home/SySeVR/data/CVE_2014_6429_VULN_SnifferDecompress.c memset 77
static int
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
138 /home/SySeVR/data/CVE_2014_6431_VULN_SnifferDecompress.c memset 104
static int
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
139 /home/SySeVR/data/CVE_2014_6431_VULN_SnifferDecompress.c memset 77
static int
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
140 /home/SySeVR/data/CVE_2014_6432_PATCHED_SnifferDecompress.c memset 115
static int
CVE_2014_6432_PATCHED_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( pin < pin_end )  22
bit_mask = bit_mask >> 1; 25
if ( 0 == bit_mask )  28
if ( pin + 2 >= pin_end )  33
bit_mask = 0x8000; 38
bit_value = pletoh16 ( pin ); 39
pin += 2; 40
if ( ! ( bit_mask & bit_value ) )  44
if ( pout + 1 > pout_end )  49
* ( pout ++ ) = * ( pin ++ ); 54
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 61
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 62
pin ++; 63
if ( pin >= pin_end )  64
switch ( code_type )  71
length = code_low + 3; 79
if ( pout + length > pout_end )  81
memset ( pout , * pin ++ , length ); 88
pout += length; 89
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 99
if ( pin >= pin_end )  102
if ( pout + length > pout_end )  108
memset ( pout , * pin ++ , length ); 115
pout += length; 116
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 126
if ( pin >= pin_end )  129
if ( pout - offset < outbuf )  135
length = ( unsigned int ) ( * pin ++ ) + 16; 142
if ( pout + length > pout_end )  143
if ( pout - offset + length > pout )  149
memcpy ( pout , pout - offset , length ); 157
pout += length; 158
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 168
if ( pout - offset < outbuf )  170
length = code_type; 177
if ( pout + length > pout_end )  178
if ( pout - offset + length > pout )  184
memcpy ( pout , pout - offset , length ); 192
pout += length; 193
return ( int ) ( pout - outbuf ) ; 199
0
------------------------------
141 /home/SySeVR/data/CVE_2014_6432_PATCHED_SnifferDecompress.c memset 88
static int
CVE_2014_6432_PATCHED_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( pin < pin_end )  22
bit_mask = bit_mask >> 1; 25
if ( 0 == bit_mask )  28
if ( pin + 2 >= pin_end )  33
bit_mask = 0x8000; 38
bit_value = pletoh16 ( pin ); 39
pin += 2; 40
if ( ! ( bit_mask & bit_value ) )  44
if ( pout + 1 > pout_end )  49
* ( pout ++ ) = * ( pin ++ ); 54
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 61
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 62
pin ++; 63
if ( pin >= pin_end )  64
switch ( code_type )  71
length = code_low + 3; 79
if ( pout + length > pout_end )  81
memset ( pout , * pin ++ , length ); 88
pout += length; 89
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 99
if ( pin >= pin_end )  102
if ( pout + length > pout_end )  108
memset ( pout , * pin ++ , length ); 115
pout += length; 116
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 126
if ( pin >= pin_end )  129
if ( pout - offset < outbuf )  135
length = ( unsigned int ) ( * pin ++ ) + 16; 142
if ( pout + length > pout_end )  143
if ( pout - offset + length > pout )  149
memcpy ( pout , pout - offset , length ); 157
pout += length; 158
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 168
if ( pout - offset < outbuf )  170
length = code_type; 177
if ( pout + length > pout_end )  178
if ( pout - offset + length > pout )  184
memcpy ( pout , pout - offset , length ); 192
pout += length; 193
return ( int ) ( pout - outbuf ) ; 199
0
------------------------------
142 /home/SySeVR/data/CVE_2014_6432_VULN_SnifferDecompress.c memset 104
static int
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
143 /home/SySeVR/data/CVE_2014_6432_VULN_SnifferDecompress.c memset 77
static int
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
144 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memset 346
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
height *= 2; 114
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
s -> first_picture = 0; 121
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
s -> rgb = 1; 131
if ( ! s -> lossless )  132
s -> rgb = 0; 133
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
for (i = 0; i < 4; i++) 316
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
0
------------------------------
145 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memset 60
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
memset ( v_count , 0 , sizeof ( v_count ) ); 60
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 73
if ( ! h_count [ i ] || ! v_count [ i ] )  76
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 77
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 83
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 89
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
return ret ; 119
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 126
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
if ( ! s -> lossless )  132
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 139
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
av_assert0 ( s -> nb_components == 3 ); 176
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
av_assert0 ( s -> nb_components == 4 ); 189
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
av_assert0 ( s -> nb_components == 4 ); 208
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); 283
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 288
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 305
av_frame_unref ( s -> picture_ptr ); 309
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 319
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 324
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 328
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
av_freep ( & s -> blocks [ i ] ); 338
av_freep ( & s -> last_nnz [ i ] ); 339
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
0
------------------------------
146 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memset 59
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
memset ( h_count , 0 , sizeof ( h_count ) ); 59
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 73
if ( ! h_count [ i ] || ! v_count [ i ] )  76
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 77
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 83
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 89
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
return ret ; 119
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 126
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
if ( ! s -> lossless )  132
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 139
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
av_assert0 ( s -> nb_components == 3 ); 176
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
av_assert0 ( s -> nb_components == 4 ); 189
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
av_assert0 ( s -> nb_components == 4 ); 208
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); 283
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 288
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 305
av_frame_unref ( s -> picture_ptr ); 309
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 319
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 324
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 328
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
av_freep ( & s -> blocks [ i ] ); 338
av_freep ( & s -> last_nnz [ i ] ); 339
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
0
------------------------------
147 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c memset 476
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
useService = testOnlyFallbackKeyExists; 379
useService = false; 385
if ( useService )  398
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 401
useService = ( ret == ERROR_SUCCESS ); 402
if ( useService )  404
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 426
if ( lastState != SERVICE_STOPPED )  427
useService = false; 431
if ( ! useService && sStagedUpdate )  441
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
SHELLEXECUTEINFO sinfo ; 475
memset ( & sinfo , 0 , sizeof ( SHELLEXECUTEINFO ) ); 476
sinfo . cbSize = sizeof ( SHELLEXECUTEINFO ); 477
sinfo . fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOCLOSEPROCESS; 478
sinfo . hwnd = nullptr; 481
sinfo . lpFile = argv [ 0 ]; 482
sinfo . lpParameters = cmdLine; 483
sinfo . nShow = SW_SHOWNORMAL; 485
bool result = ShellExecuteEx ( & sinfo ) ; 487
if ( result )  490
WaitForSingleObject ( sinfo . hProcess , INFINITE ); 491
CloseHandle ( sinfo . hProcess ); 492
0
------------------------------
148 /home/SySeVR/data/CVE_2015_3339_PATCHED_prepare_binprm.c memset 13
int CVE_2015_3339_PATCHED_prepare_binprm(struct linux_binprm *bprm) 1
int retval ; 3
retval = security_bprm_set_creds ( bprm ); 8
if ( retval )  9
bprm -> cred_prepared = 1; 11
memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ); 13
return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; 14
0
------------------------------
149 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 225
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
len = netlink_send ( fd , incoming_cn_msg ); 223
if ( len < 0 )  224
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 225
0
------------------------------
150 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 97
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
syslog ( LOG_ERR , "malloc failed" ); 97
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
151 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 94
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 94
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
152 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 75
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
syslog ( LOG_ERR , "recv failed; error:%d" , len ); 75
0
------------------------------
153 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 60
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
if ( len < 0 )  59
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 60
0
------------------------------
154 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 40
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
addr . nl_family = AF_NETLINK; 32
addr . nl_pad = 0; 33
addr . nl_pid = 0; 34
addr . nl_groups = CN_KVP_IDX; 35
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 38
if ( error < 0 )  39
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 40
0
------------------------------
155 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 29
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
if ( fd < 0 )  28
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 29
0
------------------------------
156 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 23
int CVE_2012_2669_VULN_main(void) 1
if ( kvp_file_init ( ) )  22
syslog ( LOG_ERR , "Failed to initialize the pools" ); 23
0
------------------------------
157 /home/SySeVR/data/CVE_2012_2669_VULN_main.c syslog 16
int CVE_2012_2669_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 16
0
------------------------------
158 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 277
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
0
------------------------------
159 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 114
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
syslog ( LOG_ERR , "malloc failed" ); 114
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
160 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 111
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
161 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
0
------------------------------
162 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 64
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
0
------------------------------
163 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 44
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
0
------------------------------
164 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 33
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
0
------------------------------
165 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 27
int CVE_2012_5532_VULN_main(void) 1
if ( kvp_file_init ( ) )  26
syslog ( LOG_ERR , "Failed to initialize the pools" ); 27
0
------------------------------
166 /home/SySeVR/data/CVE_2012_5532_VULN_main.c syslog 20
int CVE_2012_5532_VULN_main(void) 1
syslog ( LOG_INFO , "KVP starting; pid is:%d" , getpid ( ) ); 20
0
------------------------------
167 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c MoveFileEx 741
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 575
NS_tchar * targetPath = argv [ callbackIndex ] ; 577
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 578
if ( sReplaceRequest )  580
NS_tchar installDir [ MAXPATHLEN ] ; 597
if ( ! GetInstallationDir ( installDir ) )  598
targetPath = buffer; 602
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  604
if ( ! sReplaceRequest )  620
const int max_retries = 10 ; 653
int retries = 1 ; 654
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , 0 , NULL ); 660
if ( callbackFile != INVALID_HANDLE_VALUE )  665
while ( ++ retries <= max_retries )  674
if ( callbackFile == INVALID_HANDLE_VALUE )  678
if ( ! sBackgroundUpdate && ! sReplaceRequest && _wrmdir ( DELETE_DIR ) )  729
if ( MoveFileEx ( DELETE_DIR , NULL , MOVEFILE_DELAY_UNTIL_REBOOT ) )  741
0
------------------------------
168 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c MoveFileEx 735
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 575
NS_tchar * targetPath = argv [ callbackIndex ] ; 577
NS_tchar buffer [ MAXPATHLEN * 2 ] ; 578
if ( sReplaceRequest )  579
NS_tchar installDir [ MAXPATHLEN ] ; 591
if ( ! GetInstallationDir ( installDir ) )  592
targetPath = buffer; 596
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  598
if ( ! sReplaceRequest )  614
const int max_retries = 10 ; 647
int retries = 1 ; 648
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , 0 , NULL ); 654
if ( callbackFile != INVALID_HANDLE_VALUE )  659
while ( ++ retries <= max_retries )  668
if ( callbackFile == INVALID_HANDLE_VALUE )  672
if ( ! sBackgroundUpdate && ! sReplaceRequest && _wrmdir ( DELETE_DIR ) )  723
if ( MoveFileEx ( DELETE_DIR , NULL , MOVEFILE_DELAY_UNTIL_REBOOT ) )  735
0
------------------------------
169 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c MoveFileEx 795
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( ! sStagedUpdate && ! sReplaceRequest && _wrmdir ( DELETE_DIR ) )  783
if ( MoveFileEx ( DELETE_DIR , nullptr , MOVEFILE_DELAY_UNTIL_REBOOT ) )  795
0
------------------------------
170 /home/SySeVR/data/CVE_2011_3002_VULN_GrowAtomTable.c realloc 8
static int CVE_2011_3002_VULN_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newrev = realloc ( atable -> arev , sizeof ( int ) * size ); 8
if ( ! newmap || ! newrev )  14
if ( newrev )  18
atable -> arev = newrev; 19
memset ( & newrev [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 23
atable -> arev = newrev; 25
atable -> size = size; 26
0
------------------------------
171 /home/SySeVR/data/CVE_2011_3002_VULN_GrowAtomTable.c realloc 7
static int CVE_2011_3002_VULN_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newmap = realloc ( atable -> amap , sizeof ( int ) * size ); 7
if ( ! newmap || ! newrev )  14
if ( newmap )  16
atable -> amap = newmap; 17
atable -> arev = newrev; 19
memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 22
atable -> amap = newmap; 24
atable -> arev = newrev; 25
atable -> size = size; 26
0
------------------------------
172 /home/SySeVR/data/CVE_2011_3003_PATCHED_CopyDataIfElementArray.c realloc 3
PRBool CVE_2011_3003_PATCHED_CopyDataIfElementArray(const void* data) 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER )  2
mData = realloc ( mData , mByteLength ); 3
if ( ! mData )  4
memcpy ( mData , data , mByteLength ); 8
0
------------------------------
173 /home/SySeVR/data/CVE_2011_3003_VULN_CopyDataIfElementArray.c realloc 3
PRBool CVE_2011_3003_VULN_CopyDataIfElementArray(const void* data) 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER )  2
mData = realloc ( mData , mByteLength ); 3
if ( ! mData )  4
memcpy ( mData , data , mByteLength ); 6
0
------------------------------
174 /home/SySeVR/data/CVE_2011_3003_VULN_ZeroDataIfElementArray.c realloc 3
PRBool CVE_2011_3003_VULN_ZeroDataIfElementArray() 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER )  2
mData = realloc ( mData , mByteLength ); 3
if ( ! mData )  4
memset ( mData , 0 , mByteLength ); 6
0
------------------------------
175 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c realloc 86
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
memcpy ( ( unsigned char * ) p_stream -> p_headers + p_stream -> i_headers - p_oggpacket -> bytes , p_oggpacket -> packet , p_stream -> i_headers ); 89
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
free ( p_stream -> fmt . p_extra ); 111
p_stream -> fmt . i_extra = p_stream -> i_headers; 113
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers ); 114
if ( p_stream -> fmt . p_extra )  115
memcpy ( p_stream -> fmt . p_extra , p_stream -> p_headers , p_stream -> i_headers ); 116
p_stream -> fmt . i_extra = 0; 119
if ( Ogg_LogicalStreamResetEsFormat ( p_demux , p_stream ) )  121
es_out_Control ( p_demux -> out , ES_OUT_SET_ES_FMT , p_stream -> p_es , & p_stream -> fmt ); 122
if ( p_stream -> i_headers > 0 )  125
Ogg_ExtractMeta ( p_demux , p_stream -> fmt . i_codec , p_stream -> p_headers , p_stream -> i_headers ); 126
if ( p_stream -> fmt . i_codec == VLC_CODEC_VORBIS || p_stream -> fmt . i_codec == VLC_CODEC_SPEEX || p_stream -> fmt . i_codec == VLC_CODEC_FLAC )  138
if ( p_stream -> i_pcr >= 0 )  142
if ( p_stream -> i_previous_pcr == 0 && p_stream -> i_pcr > 3 * DEFAULT_PTS_DELAY )  146
es_out_Control ( p_demux -> out , ES_OUT_SET_PCR , VLC_TS_0 + p_stream -> i_pcr ); 152
p_stream -> i_previous_pcr = p_stream -> i_pcr; 156
i_pts = p_stream -> i_pcr; 159
i_interpolated_pts = p_stream -> i_interpolated_pcr; 164
Ogg_UpdatePCR ( p_stream , p_oggpacket ); 165
if ( p_stream -> fmt . i_cat != SPU_ES )  168
if ( p_stream -> i_pcr >= 0 )  170
if ( p_stream -> i_previous_pcr == 0 && p_stream -> i_pcr > 3 * DEFAULT_PTS_DELAY )  174
es_out_Control ( p_demux -> out , ES_OUT_SET_PCR , VLC_TS_0 + p_stream -> i_pcr ); 180
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> i_pcr >= 0 )  185
p_stream -> i_previous_pcr = p_stream -> i_pcr; 190
i_pts = p_stream -> i_pcr; 193
if ( p_stream -> i_skip_frames > 0 )  210
p_stream -> i_skip_frames --; 213
if ( i_pts == 0 )  218
if ( i_pts == - 1 && i_interpolated_pts == 0 )  219
if ( i_pts == - 1 )  220
if ( p_stream -> fmt . i_cat == AUDIO_ES )  222
p_block -> i_dts = p_block -> i_pts = i_pts; 223
if ( p_stream -> fmt . i_cat == SPU_ES )  224
p_block -> i_dts = p_block -> i_pts = i_pts; 226
p_block -> i_length = 0; 227
if ( p_stream -> fmt . i_codec == VLC_CODEC_THEORA )  229
p_block -> i_dts = p_block -> i_pts = i_pts; 231
if ( ( p_oggpacket -> granulepos & ( ( 1 << p_stream -> i_granule_shift ) - 1 ) ) == 0 )  232
p_block -> i_flags |= BLOCK_FLAG_TYPE_I; 234
if ( p_stream -> fmt . i_codec == VLC_CODEC_DIRAC )  237
p_block -> i_dts = p_stream -> i_pcr; 244
p_block -> i_pts = VLC_TS_INVALID; 245
p_block -> i_pts = u_pnum * INT64_C ( 1000000 ) / p_stream -> f_rate / 2; 250
p_block -> i_dts = i_pts; 254
p_block -> i_pts = VLC_TS_INVALID; 255
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> fmt . i_codec != VLC_CODEC_TARKIN && p_stream -> fmt . i_codec != VLC_CODEC_THEORA && p_stream -> fmt . i_codec != VLC_CODEC_CMML && p_stream -> fmt . i_codec != VLC_CODEC_DIRAC && p_stream -> fmt . i_codec != VLC_CODEC_KATE )  258
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT )  271
p_block -> i_length = ( mtime_t ) lenbytes * 1000; 290
if ( p_block -> i_buffer >= ( unsigned int ) i_header_len )  295
p_block -> i_buffer -= i_header_len; 296
if ( p_stream -> fmt . i_codec == VLC_CODEC_TARKIN )  301
msg_Warn ( p_demux , "tarkin pts: %" PRId64 ", granule: %" PRId64 ,
p_block -> i_pts , p_block -> i_dts ) 305
memcpy ( p_block -> p_buffer , p_oggpacket -> packet + i_header_len , p_oggpacket -> bytes - i_header_len ); 309
es_out_Send ( p_demux -> out , p_stream -> p_es , p_block ); 312
0
------------------------------
176 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strdup 125
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
* title = strdup ( "Server Error" ); 125
0
------------------------------
177 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c strdup 74
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
infoBlock -> MARChannelID = location; 56
location += len + 1; 57
if ( len >= 64 )  58
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
if ( len >= 32 )  67
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
178 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c strdup 72
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
infoBlock -> MARChannelID = location; 56
location += len + 1; 57
if ( len >= 64 )  58
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
if ( len >= 32 )  67
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
179 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c strdup 74
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
infoBlock -> MARChannelID = location; 56
location += len + 1; 57
if ( len >= 64 )  58
infoBlock -> MARChannelID = NULL; 59
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
if ( len >= 32 )  67
infoBlock -> MARChannelID = NULL; 68
infoBlock -> productVersion = NULL; 69
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
180 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c strdup 72
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
infoBlock -> MARChannelID = location; 56
location += len + 1; 57
if ( len >= 64 )  58
infoBlock -> MARChannelID = NULL; 59
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
if ( len >= 32 )  67
infoBlock -> MARChannelID = NULL; 68
infoBlock -> productVersion = NULL; 69
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
181 /home/SySeVR/data/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcsncpy 24
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
0
------------------------------
182 /home/SySeVR/data/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
0
------------------------------
183 /home/SySeVR/data/CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
0
------------------------------
184 /home/SySeVR/data/CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand.c wcsncpy 62
BOOL
CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
if ( ! PathAppendSafe ( installDirUpdater , L "updater.exe" ) ) 63
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
LOG_WARN ( ( "Error checking if the updaters are the same.\n"
"Path 1: %ls\nPath 2: %ls" , argv [ 0 ] , installDirUpdater ) ) 72
0
------------------------------
185 /home/SySeVR/data/CVE_2012_1183_PATCHED_milliwatt_generate.c strerror 35
static int CVE_2012_1183_PATCHED_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) - ( AST_FRIENDLY_OFFSET / sizeof ( buf [ 0 ] ) ) ; 4
struct ast_frame wf =
. frametype = AST_FRAME_VOICE ,
. offset = AST_FRIENDLY_OFFSET ,
. src = __FUNCTION__ , 9
wf . data . ptr = buf + AST_FRIENDLY_OFFSET; 12
if ( samples > maxsamples )  19
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
if ( ast_write ( chan , & wf ) < 0 )  34
ast_log ( LOG_WARNING , "Failed to write frame to '%s': %s\n" , chan -> name , strerror ( errno ) ); 35
0
------------------------------
186 /home/SySeVR/data/CVE_2012_1183_VULN_milliwatt_generate.c strerror 35
static int CVE_2012_1183_VULN_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) ; 4
struct ast_frame wf =
. frametype = AST_FRAME_VOICE ,
. offset = AST_FRIENDLY_OFFSET ,
. src = __FUNCTION__ , 9
wf . data . ptr = buf + AST_FRIENDLY_OFFSET; 12
if ( samples > maxsamples )  19
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
if ( ast_write ( chan , & wf ) < 0 )  34
ast_log ( LOG_WARNING , "Failed to write frame to '%s': %s\n" , chan -> name , strerror ( errno ) ); 35
0
------------------------------
187 /home/SySeVR/data/CVE_2012_3553_PATCHED_setsubstate.c strerror 248
static void CVE_2012_3553_PATCHED_setsubstate(struct skinny_subchannel *sub, int state) 1
struct skinny_line * l = sub -> line ; 3
struct skinny_subline * subline = sub -> subline ; 4
struct skinny_device * d = l -> device ; 5
struct ast_channel * c = sub -> owner ; 6
pthread_t t ; 7
int actualstate = state ; 8
if ( ! l -> device )  10
if ( sub -> substate == SUBSTATE_ONHOOK )  15
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  19
sub -> aa_sched = 0; 21
sub -> aa_beep = 0; 22
sub -> aa_mute = 0; 23
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  26
actualstate = SUBSTATE_CALLWAIT; 27
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  30
const char * slastation ; 31
struct skinny_subline * tmpsubline ; 32
slastation = pbx_builtin_getvar_helper ( c , "SLASTATION" ); 33
if ( slastation )  35
subline = tmpsubline; 38
if ( subline )  42
subline -> sub = sub; 44
sub -> subline = subline; 45
subline -> callid = sub -> callid; 46
if ( subline )  64
switch ( actualstate )  65
if ( sub -> related )  68
sub -> related -> related = NULL; 69
sub -> cxmode = SKINNY_CX_RECVONLY; 85
sub -> substate = SUBSTATE_ONHOOK; 86
if ( sub -> rtp )  87
sub -> rtp = NULL; 89
sub -> substate = SUBSTATE_ONHOOK; 91
sub -> substate = SUBSTATE_CONNECTED; 113
if ( sub -> substate != SUBSTATE_CONNECTED )  117
sub -> substate = SUBSTATE_HOLD; 129
if ( actualstate == sub -> substate )  152
switch ( actualstate )  158
l -> activesub = sub; 161
sub -> substate = SUBSTATE_OFFHOOK; 169
if ( sub -> related )  179
sub -> related -> related = NULL; 180
if ( sub == l -> activesub )  183
l -> activesub = NULL; 184
sub -> cxmode = SKINNY_CX_RECVONLY; 199
sub -> substate = SUBSTATE_ONHOOK; 200
if ( sub -> rtp )  201
sub -> rtp = NULL; 203
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  210
if ( ast_pthread_create ( & t , NULL , skinny_newcall , c ) )  247
ast_log ( LOG_WARNING , "Unable to create new call thread: %s\n" , strerror ( errno ) ); 248
0
------------------------------
188 /home/SySeVR/data/CVE_2012_3553_PATCHED_setsubstate.c strerror 173
static void CVE_2012_3553_PATCHED_setsubstate(struct skinny_subchannel *sub, int state) 1
struct skinny_line * l = sub -> line ; 3
struct skinny_subline * subline = sub -> subline ; 4
struct skinny_device * d = l -> device ; 5
struct ast_channel * c = sub -> owner ; 6
pthread_t t ; 7
int actualstate = state ; 8
if ( ! l -> device )  10
if ( sub -> substate == SUBSTATE_ONHOOK )  15
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  19
sub -> aa_sched = 0; 21
sub -> aa_beep = 0; 22
sub -> aa_mute = 0; 23
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  26
actualstate = SUBSTATE_CALLWAIT; 27
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  30
const char * slastation ; 31
struct skinny_subline * tmpsubline ; 32
slastation = pbx_builtin_getvar_helper ( c , "SLASTATION" ); 33
if ( slastation )  35
subline = tmpsubline; 38
if ( subline )  42
subline -> sub = sub; 44
sub -> subline = subline; 45
subline -> callid = sub -> callid; 46
if ( subline )  64
switch ( actualstate )  65
if ( sub -> related )  68
sub -> related -> related = NULL; 69
sub -> cxmode = SKINNY_CX_RECVONLY; 85
sub -> substate = SUBSTATE_ONHOOK; 86
if ( sub -> rtp )  87
sub -> rtp = NULL; 89
sub -> substate = SUBSTATE_ONHOOK; 91
sub -> substate = SUBSTATE_CONNECTED; 113
if ( sub -> substate != SUBSTATE_CONNECTED )  117
sub -> substate = SUBSTATE_HOLD; 129
if ( actualstate == sub -> substate )  152
switch ( actualstate )  158
sub -> substate = SUBSTATE_OFFHOOK; 169
if ( ast_pthread_create ( & t , NULL , skinny_ss , sub -> owner ) )  172
ast_log ( LOG_WARNING , "Unable to create switch thread: %s\n" , strerror ( errno ) ); 173
0
------------------------------
189 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strerror 82
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
syslog ( LOG_ERR , "recvfrom failed; pid:%u error:%d %s" , addr . nl_pid , errno , strerror ( errno ) ); 82
0
------------------------------
190 /home/SySeVR/data/CVE_2014_3640_VULN_udp_input.c strerror 158
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
iphlen += sizeof ( struct udphdr ); 143
m -> m_len -= iphlen; 144
m -> m_data += iphlen; 145
if ( sosendto ( so , m ) == - 1 )  153
m -> m_len += iphlen; 154
m -> m_data -= iphlen; 155
icmp_error ( m , ICMP_UNREACH , ICMP_UNREACH_NET , 0 , strerror ( errno ) ); 158
0
------------------------------
191 /home/SySeVR/data/CVE_2014_3640_VULN_udp_input.c strerror 157
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
iphlen += sizeof ( struct udphdr ); 143
m -> m_len -= iphlen; 144
m -> m_data += iphlen; 145
if ( sosendto ( so , m ) == - 1 )  153
DEBUG_MISC ( ( dfd , "udp tx errno = %d-%s\n" , errno , strerror ( errno ) ) ); 157
0
------------------------------
192 /home/SySeVR/data/CVE_2014_3640_VULN_udp_input.c strerror 119
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
Slirp * slirp = m -> slirp ; 5
register struct ip * ip ;
register struct udphdr * uh ; 7
int len ; 8
struct socket * so ; 10
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
ip -> ip_len = len; 44
if ( uh -> uh_sum )  57
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( slirp -> restricted )  74
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
so = slirp -> udp_last_so; 89
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
struct socket * tmp ; 92
for (tmp = slirp->udb.so_next; tmp != &slirp->udb;
tmp = tmp->so_next) 95
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so = tmp; 98
if ( tmp == & slirp -> udb )  102
so = NULL; 103
slirp -> udp_last_so = so; 105
if ( so == NULL )  109
so = socreate ( slirp ); 114
if ( ! so )  115
if ( udp_attach ( so ) == - 1 )  118
DEBUG_MISC ( ( dfd , " udp_attach errno = %d-%s\n" , errno , strerror ( errno ) ) ); 119
0
------------------------------
193 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 184
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
194 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 183
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
195 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 180
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
196 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 155
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
197 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 154
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
198 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 151
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
199 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c fprintf 27
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
fprintf ( stderr , "Received extension type %d size %d\n" , type , size ); 27
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
200 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 184
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
201 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 183
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
202 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 180
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
203 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 155
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
fprintf ( stderr , "Received extension type %d size %d\n" , type , size ); 27
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
204 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 154
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
fprintf ( stderr , "Received extension type %d size %d\n" , type , size ); 27
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
205 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 151
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
fprintf ( stderr , "Received extension type %d size %d\n" , type , size ); 27
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
206 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c fprintf 27
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
fprintf ( stderr , "Received extension type %d size %d\n" , type , size ); 27
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
207 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 184
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
208 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 183
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
209 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 180
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
210 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 155
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
211 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 154
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
212 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 151
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
213 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c fprintf 27
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
fprintf ( stderr , "Received extension type %d size %d\n" , type , size ); 27
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
214 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c fprintf 136
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int i ; 5
int j ; 6
int x ; 10
int ptr ; 13
int seq_no ; 16
const uint8_t * data ; 18
int ifp_len ; 19
int repaired [ 16 ] ; 20
int span ; 23
int entries ; 24
ptr = 0; 27
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
for ( ; seq_no > s->rx_seq_no; s->rx_seq_no++) 89
x = s -> rx_seq_no & UDPTL_BUF_MASK; 90
s -> rx [ x ] . buf_len = - 1; 91
s -> rx [ x ] . fec_len [ 0 ] = 0; 92
s -> rx [ x ] . fec_span = 0; 93
s -> rx [ x ] . fec_entries = 0; 94
x = seq_no & UDPTL_BUF_MASK; 97
memset ( repaired , 0 , sizeof ( repaired ) ); 99
s -> rx [ x ] . buf_len = ifp_len; 103
repaired [ x ] = TRUE; 104
if ( ptr + 2 > len )  109
if ( buf [ ptr ++ ] != 1 )  111
span = buf [ ptr ++ ]; 113
s -> rx [ x ] . fec_span = span; 114
if ( ptr + 1 > len )  118
entries = buf [ ptr ++ ]; 120
s -> rx [ x ] . fec_entries = entries; 121
for (i = 0; i < entries; i++) 124
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
fprintf ( stderr , "FEC: " ); 133
for (j = 0; j < s->rx[x].fec_len[i]; j++) 134
fprintf ( stderr , "%02X " , data [ j ] ); 135
fprintf ( stderr , "\n" ); 136
0
------------------------------
215 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c fprintf 135
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int i ; 5
int j ; 6
int x ; 10
int ptr ; 13
int seq_no ; 16
const uint8_t * data ; 18
int ifp_len ; 19
int repaired [ 16 ] ; 20
int span ; 23
int entries ; 24
ptr = 0; 27
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
for ( ; seq_no > s->rx_seq_no; s->rx_seq_no++) 89
x = s -> rx_seq_no & UDPTL_BUF_MASK; 90
s -> rx [ x ] . buf_len = - 1; 91
s -> rx [ x ] . fec_len [ 0 ] = 0; 92
s -> rx [ x ] . fec_span = 0; 93
s -> rx [ x ] . fec_entries = 0; 94
x = seq_no & UDPTL_BUF_MASK; 97
memset ( repaired , 0 , sizeof ( repaired ) ); 99
s -> rx [ x ] . buf_len = ifp_len; 103
repaired [ x ] = TRUE; 104
if ( ptr + 2 > len )  109
if ( buf [ ptr ++ ] != 1 )  111
span = buf [ ptr ++ ]; 113
s -> rx [ x ] . fec_span = span; 114
if ( ptr + 1 > len )  118
entries = buf [ ptr ++ ]; 120
s -> rx [ x ] . fec_entries = entries; 121
for (i = 0; i < entries; i++) 124
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
fprintf ( stderr , "FEC: " ); 133
for (j = 0; j < s->rx[x].fec_len[i]; j++) 134
fprintf ( stderr , "%02X " , data [ j ] ); 135
fprintf ( stderr , "\n" ); 136
0
------------------------------
216 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c fprintf 133
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int i ; 5
int x ; 10
int ptr ; 13
int seq_no ; 16
int ifp_len ; 19
int repaired [ 16 ] ; 20
int span ; 23
int entries ; 24
ptr = 0; 27
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
for ( ; seq_no > s->rx_seq_no; s->rx_seq_no++) 89
x = s -> rx_seq_no & UDPTL_BUF_MASK; 90
s -> rx [ x ] . buf_len = - 1; 91
s -> rx [ x ] . fec_len [ 0 ] = 0; 92
s -> rx [ x ] . fec_span = 0; 93
s -> rx [ x ] . fec_entries = 0; 94
x = seq_no & UDPTL_BUF_MASK; 97
memset ( repaired , 0 , sizeof ( repaired ) ); 99
s -> rx [ x ] . buf_len = ifp_len; 103
repaired [ x ] = TRUE; 104
if ( ptr + 2 > len )  109
if ( buf [ ptr ++ ] != 1 )  111
span = buf [ ptr ++ ]; 113
s -> rx [ x ] . fec_span = span; 114
if ( ptr + 1 > len )  118
entries = buf [ ptr ++ ]; 120
s -> rx [ x ] . fec_entries = entries; 121
for (i = 0; i < entries; i++) 124
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
fprintf ( stderr , "FEC: " ); 133
fprintf ( stderr , "%02X " , data [ j ] ); 135
fprintf ( stderr , "\n" ); 136
0
------------------------------
217 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c fprintf 268
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
fprintf ( stderr , "Unable to create elevated lock file! Exiting\n" ); 268
fprintf ( stderr , "The post update process which runs as the user"
" for service update could not be launched." ) 415
0
------------------------------
218 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c fprintf 103
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
fprintf ( stderr , "Could not get the installation directory\n" ); 103
0
------------------------------
219 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c fprintf 18
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
fprintf ( stderr , "Usage: updater update-dir apply-to-dir [wait-pid [callback-working-dir callback-path args...]]\n" ); 18
0
------------------------------
220 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c fprintf 268
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
fprintf ( stderr , "Unable to create elevated lock file! Exiting\n" ); 268
0
------------------------------
221 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c fprintf 103
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
fprintf ( stderr , "Could not get the installation directory\n" ); 103
0
------------------------------
222 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c fprintf 18
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
fprintf ( stderr , "Usage: updater update-dir apply-to-dir [wait-pid [callback-working-dir callback-path args...]]\n" ); 18
0
------------------------------
223 /home/SySeVR/data/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c fprintf 80
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
fprintf ( stderr , "CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 76
fprintf ( stderr , "\n" ); 80
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
0
------------------------------
224 /home/SySeVR/data/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c fprintf 79
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
fprintf ( stderr , "CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 76
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
0
------------------------------
225 /home/SySeVR/data/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c fprintf 76
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
fprintf ( stderr , "CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist " ); 76
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
fprintf ( stderr , "\n" ); 80
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
0
------------------------------
226 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c fprintf 322
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
fprintf ( stderr , "Unable to create elevated lock file! Exiting\n" ); 322
fprintf ( stderr , "The post update process which runs as the user"
" for service update could not be launched." ) 462
0
------------------------------
227 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c fprintf 184
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
0
------------------------------
228 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c fprintf 37
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
fprintf ( stderr , "Usage: updater patch-dir install-dir apply-to-dir [wait-pid [callback-working-dir callback-path args...]]\n" ); 37
0
------------------------------
229 /home/SySeVR/data/CVE_2005_3356_PATCHED_sys_mq_open.c strlen 17
asmlinkage long CVE_2005_3356_PATCHED_sys_mq_open(const char __user *u_name, int oflag, mode_t mode,
struct mq_attr __user *u_attr) 2
struct dentry * dentry ; 4
char * name ; 6
int fd , error ; 7
if ( IS_ERR ( name = getname ( u_name ) ) )  9
fd = get_unused_fd ( ); 12
if ( fd < 0 )  13
dentry = lookup_one_len ( name , mqueue_mnt -> mnt_root , strlen ( name ) ); 17
if ( IS_ERR ( dentry ) )  18
error = PTR_ERR ( dentry ); 19
if ( dentry -> d_inode )  25
filp = do_open ( dentry , oflag ); 29
filp = do_create ( mqueue_mnt -> mnt_root , dentry , oflag , mode , u_attr ); 31
if ( ! dentry -> d_inode )  36
filp = do_open ( dentry , oflag ); 38
if ( IS_ERR ( filp ) )  41
error = PTR_ERR ( filp ); 42
fd_install ( fd , filp ); 47
dput ( dentry ); 51
fd = error; 56
return fd ; 61
0
------------------------------
230 /home/SySeVR/data/CVE_2005_3356_VULN_sys_mq_open.c strlen 17
asmlinkage long CVE_2005_3356_VULN_sys_mq_open(const char __user *u_name, int oflag, mode_t mode,
struct mq_attr __user *u_attr) 2
struct dentry * dentry ; 4
char * name ; 6
int fd , error ; 7
if ( IS_ERR ( name = getname ( u_name ) ) )  9
fd = get_unused_fd ( ); 12
if ( fd < 0 )  13
dentry = lookup_one_len ( name , mqueue_mnt -> mnt_root , strlen ( name ) ); 17
if ( IS_ERR ( dentry ) )  18
error = PTR_ERR ( dentry ); 19
if ( dentry -> d_inode )  25
filp = ( oflag & O_EXCL ) ? ERR_PTR ( - EEXIST ) : do_open ( dentry , oflag ); 26
filp = do_create ( mqueue_mnt -> mnt_root , dentry , oflag , mode , u_attr ); 29
filp = ( dentry -> d_inode ) ? do_open ( dentry , oflag ) : ERR_PTR ( - ENOENT ); 33
dput ( dentry ); 36
if ( IS_ERR ( filp ) )  38
error = PTR_ERR ( filp ); 39
fd_install ( fd , filp ); 44
fd = error; 51
return fd ; 56
0
------------------------------
231 /home/SySeVR/data/CVE_2005_4618_PATCHED_sysctl_string.c strlen 14
int CVE_2005_4618_PATCHED_sysctl_string(ctl_table *table, int __user *name, int nlen,
void __user *oldval, size_t __user *oldlenp,
void __user *newval, size_t newlen, void **context) 3
size_t l , len ; 5
if ( ! table -> data || ! table -> maxlen )  7
if ( oldval && oldlenp )  10
if ( get_user ( len , oldlenp ) )  11
if ( len )  13
l = strlen ( table -> data ) + 1; 14
if ( len > l )  15
len = l; 15
if ( len >= table -> maxlen )  16
if ( copy_to_user ( oldval , table -> data , len ) )  18
if ( put_user ( len , oldlenp ) )  20
0
------------------------------
232 /home/SySeVR/data/CVE_2007_1217_VULN_bufprint.c strlen 7
static void CVE_2007_1217_VULN_bufprint(char *fmt,...) 1
va_list f ; 3
vsprintf ( p , fmt , f ); 5
p += strlen ( p ); 7
0
------------------------------
233 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strlen 107
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
0
------------------------------
234 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strlen 106
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
235 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strlen 103
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
236 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strlen 103
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
237 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strlen 60
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
0
------------------------------
238 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strlen 60
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
0
------------------------------
239 /home/SySeVR/data/CVE_2009_1439_PATCHED_CIFSTCon.c strlen 91
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
240 /home/SySeVR/data/CVE_2009_1439_PATCHED_CIFSTCon.c strlen 88
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
241 /home/SySeVR/data/CVE_2009_1439_VULN_CIFSTCon.c strlen 91
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
242 /home/SySeVR/data/CVE_2009_1439_VULN_CIFSTCon.c strlen 88
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
243 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c strlen 110
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( s -> tlsext_debug_cb )  29
s -> tlsext_debug_cb ( s , 0 , type , data , size , s -> tlsext_debug_arg ); 30
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
OPENSSL_free ( s -> session -> tlsext_hostname ); 101
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( s -> session -> tlsext_ecpointformatlist != NULL )  142
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 142
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( s -> session -> tlsext_ellipticcurvelist != NULL )  171
OPENSSL_free ( s -> session -> tlsext_ellipticcurvelist ); 171
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
n2s ( sdata , s -> s3 -> client_opaque_prf_input_len ); 199
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input != NULL )  206
OPENSSL_free ( s -> s3 -> client_opaque_prf_input ); 207
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
if ( ! renegotiate_seen && s -> new_session && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  345
0
------------------------------
244 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c strlen 100
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
245 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c strlen 110
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( s -> tlsext_debug_cb )  29
s -> tlsext_debug_cb ( s , 0 , type , data , size , s -> tlsext_debug_arg ); 30
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
OPENSSL_free ( s -> session -> tlsext_hostname ); 101
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( s -> session -> tlsext_ecpointformatlist != NULL )  142
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 142
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( s -> session -> tlsext_ellipticcurvelist != NULL )  171
OPENSSL_free ( s -> session -> tlsext_ellipticcurvelist ); 171
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
n2s ( sdata , s -> s3 -> client_opaque_prf_input_len ); 199
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input != NULL )  206
OPENSSL_free ( s -> s3 -> client_opaque_prf_input ); 207
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
if ( ! renegotiate_seen && s -> new_session && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  351
0
------------------------------
246 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c strlen 100
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
247 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c strlen 110
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( s -> tlsext_debug_cb )  29
s -> tlsext_debug_cb ( s , 0 , type , data , size , s -> tlsext_debug_arg ); 30
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
OPENSSL_free ( s -> session -> tlsext_hostname ); 101
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( s -> session -> tlsext_ecpointformatlist != NULL )  142
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 142
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( s -> session -> tlsext_ellipticcurvelist != NULL )  171
OPENSSL_free ( s -> session -> tlsext_ellipticcurvelist ); 171
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
n2s ( sdata , s -> s3 -> client_opaque_prf_input_len ); 199
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input != NULL )  206
OPENSSL_free ( s -> s3 -> client_opaque_prf_input ); 207
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
if ( ! renegotiate_seen && s -> new_session && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  345
0
------------------------------
248 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c strlen 100
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
249 /home/SySeVR/data/CVE_2011_1010_VULN_mac_partition.c strlen 72
int CVE_2011_1010_VULN_mac_partition(struct parsed_partitions *state) 1
unsigned char * data ; 5
int blk , blocks_in_map ; 6
unsigned secsize ; 7
struct CVE_2011_1010_VULN_mac_partition * part ; 12
struct mac_driver_desc * md ; 13
md = read_part_sector ( state , 0 , & sect ); 16
if ( ! md )  17
if ( be16_to_cpu ( md -> signature ) != MAC_DRIVER_MAGIC )  19
secsize = be16_to_cpu ( md -> block_size ); 23
data = read_part_sector ( state , secsize / 512 , & sect ); 25
if ( ! data )  26
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + secsize % 512 ); 28
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  29
blocks_in_map = be32_to_cpu ( part -> map_count ); 34
for (blk = 1; blk <= blocks_in_map; ++blk) 35
int pos = blk * secsize ; 36
data = read_part_sector ( state , pos / 512 , & sect ); 38
if ( ! data )  39
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + pos % 512 ); 41
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  42
if ( machine_is ( powermac ) )  55
if ( strcasecmp ( part -> type , "Apple_UNIX_SVR2" ) == 0 || ( strnicmp ( part -> type , "Linux" , 5 ) == 0 && strcasecmp ( part -> type , "Linux_swap" ) != 0 ) )  66
int i , l ; 69
l = strlen ( part -> name ); 72
for (i = 0; i <= l - 4; ++i) 75
0
------------------------------
250 /home/SySeVR/data/CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4.c strlen 14
static int
CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * protocol = NULL ; 5
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
0
------------------------------
251 /home/SySeVR/data/CVE_2011_1592_VULN_dissect_nfs_clientaddr4.c strlen 14
static int
CVE_2011_1592_VULN_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * protocol = NULL ; 5
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
0
------------------------------
252 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c strlen 151
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
char * p ; 4
int sig_set = 0 ; 6
int cipher_name_set = 0 ; 7
int cipher_key_bytes ; 9
int fn_cipher_key_bytes ; 11
struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; 13
substring_t args [ MAX_OPT_ARGS ] ; 15
int token ; 16
char * sig_src ; 17
char * cipher_key_bytes_src ; 24
char * fn_cipher_key_bytes_src ; 25
if ( ! options )  29
while ( ( p = strsep ( & options , "," ) ) != NULL )  34
if ( ! * p )  35
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
sig_set = 1; 49
cipher_name_set = 1; 60
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
if ( ! sig_set )  143
if ( ! cipher_name_set )  150
int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; 151
BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ); 153
0
------------------------------
253 /home/SySeVR/data/CVE_2011_4101_VULN_dissect_infiniband_common.c strlen 227
static void
CVE_2011_4101_VULN_dissect_infiniband_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean starts_with_grh) 2
gint offset = 0 ; 26
dst_addr = ep_alloc ( ADDR_MAX_LEN ); 44
if ( tree && tree -> parent )  61
tree = tree -> parent; 64
if ( 0 && ! tree )  74
if ( starts_with_grh )  88
lnh_val = IBA_GLOBAL; 90
offset += 1; 108
lnh_val = tvb_get_guint8 ( tvb , offset ); 116
lnh_val = lnh_val & 0x03; 117
offset += 1; 118
* ( ( guint16 * ) dst_addr ) = tvb_get_ntohs ( tvb , offset ); 125
switch ( lnh_val )  150
memcpy ( dst_addr , & DSTgid , GID_SIZE ); 184
SET_ADDRESS ( & pinfo -> dst , AT_STRINGZ , ( int ) strlen ( dst_addr ) + 1 , dst_addr ); 227
0
------------------------------
254 /home/SySeVR/data/CVE_2011_4598_PATCHED_handle_request_info.c strlen 165
static void CVE_2011_4598_PATCHED_handle_request_info(struct sip_pvt *p, struct sip_request *req) 1
const char * c = get_header ( req , "Content-Type" ) ; 5
if ( ! strcasecmp ( c , "application/dtmf-relay" ) || ! strcasecmp ( c , "application/vnd.nortelnetworks.digits" ) )  8
if ( ! strcasecmp ( c , "application/dtmf" ) )  73
if ( ! strcasecmp ( c , "application/media_control+xml" ) )  117
if ( ! ast_strlen_zero ( c = get_header ( req , "X-ClientCode" ) ) )  123
if ( ! ast_strlen_zero ( c = get_header ( req , "Record" ) ) )  135
struct ast_call_feature * feat ; 143
int j ; 144
if ( ! p -> owner )  147
feat = ast_find_call_feature ( "automon" ); 155
if ( ! feat || ast_strlen_zero ( feat -> exten ) )  156
for (j=0; j < strlen(feat->exten); j++) 165
0
------------------------------
255 /home/SySeVR/data/CVE_2011_4598_VULN_handle_request_info.c strlen 158
static void CVE_2011_4598_VULN_handle_request_info(struct sip_pvt *p, struct sip_request *req) 1
const char * c = get_header ( req , "Content-Type" ) ; 5
if ( ! strcasecmp ( c , "application/dtmf-relay" ) || ! strcasecmp ( c , "application/vnd.nortelnetworks.digits" ) )  8
if ( ! p -> owner )  12
if ( ast_strlen_zero ( c = get_body ( req , "Signal" , '=' ) ) && ast_strlen_zero ( c = get_body ( req , "d" , '=' ) ) )  19
if ( ! ast_strlen_zero ( ( c = get_body ( req , "Duration" , '=' ) ) ) )  27
if ( ! strcasecmp ( c , "application/dtmf" ) )  73
if ( ! strcasecmp ( c , "application/media_control+xml" ) )  117
if ( ! ast_strlen_zero ( c = get_header ( req , "X-ClientCode" ) ) )  123
if ( ! ast_strlen_zero ( c = get_header ( req , "Record" ) ) )  135
struct ast_call_feature * feat ; 143
int j ; 144
feat = ast_find_call_feature ( "automon" ); 148
if ( ! feat || ast_strlen_zero ( feat -> exten ) )  149
for (j=0; j < strlen(feat->exten); j++) 158
0
------------------------------
256 /home/SySeVR/data/CVE_2012_1184_VULN_ast_parse_digest.c strlen 21
int CVE_2012_1184_VULN_ast_parse_digest(const char *digest, struct ast_http_digest *d, int request, int pedantic) 2
char * c , key [ 512 ] , val [ 512 ] ; 4
struct ast_str * str = ast_str_create ( 16 ) ; 5
if ( ast_strlen_zero ( digest ) || ! d || ! str )  7
c = ast_skip_blanks ( ast_str_buffer ( str ) ); 14
if ( strncasecmp ( c , "Digest " , strlen ( "Digest " ) ) )  16
c += strlen ( "Digest " ); 21
while ( * c && * ( c = ast_skip_blanks ( c ) ) )  24
while ( * c && * c != '=' && * c != ',' && ! isspace ( * c ) )  27
key [ i ++ ] = * c ++; 28
key [ i ] = '\0'; 30
c = ast_skip_blanks ( c ); 31
if ( * c == '=' )  32
c = ast_skip_blanks ( ++ c ); 33
if ( * c == '\"' )  35
c ++; 37
while ( * c && * c != '\"' )  38
if ( * c == '\\' && c [ 1 ] != '\0' )  39
c ++; 40
val [ i ++ ] = * c ++; 42
while ( * c && * c != ',' && ! isspace ( * c ) )  46
val [ i ++ ] = * c ++; 47
val [ i ] = '\0'; 50
while ( * c && * c != ',' )  53
c ++; 54
if ( * c )  56
c ++; 57
if ( ! strcasecmp ( key , "username" ) )  60
ast_string_field_set ( d , username , val ); 61
if ( ! strcasecmp ( key , "realm" ) )  62
ast_string_field_set ( d , realm , val ); 63
if ( ! strcasecmp ( key , "nonce" ) )  64
ast_string_field_set ( d , nonce , val ); 65
if ( ! strcasecmp ( key , "uri" ) )  66
ast_string_field_set ( d , uri , val ); 67
if ( ! strcasecmp ( key , "domain" ) )  68
ast_string_field_set ( d , domain , val ); 69
if ( ! strcasecmp ( key , "response" ) )  70
ast_string_field_set ( d , response , val ); 71
if ( ! strcasecmp ( key , "algorithm" ) )  72
if ( strcasecmp ( val , "MD5" ) )  73
ast_log ( LOG_WARNING , "Digest algorithm: \"%s\" not supported.\n" , val ); 74
if ( ! strcasecmp ( key , "cnonce" ) )  77
ast_string_field_set ( d , cnonce , val ); 78
if ( ! strcasecmp ( key , "opaque" ) )  79
ast_string_field_set ( d , opaque , val ); 80
if ( ! strcasecmp ( key , "qop" ) && ! strcasecmp ( val , "auth" ) )  81
if ( ! strcasecmp ( key , "nc" ) )  83
if ( sscanf ( val , "%30lx" , & u ) != 1 )  85
ast_log ( LOG_WARNING , "Incorrect Digest nc value: \"%s\".\n" , val ); 86
ast_string_field_set ( d , nc , val ); 89
0
------------------------------
257 /home/SySeVR/data/CVE_2012_1184_VULN_ast_parse_digest.c strlen 16
int CVE_2012_1184_VULN_ast_parse_digest(const char *digest, struct ast_http_digest *d, int request, int pedantic) 2
char * c , key [ 512 ] , val [ 512 ] ; 4
struct ast_str * str = ast_str_create ( 16 ) ; 5
if ( ast_strlen_zero ( digest ) || ! d || ! str )  7
c = ast_skip_blanks ( ast_str_buffer ( str ) ); 14
if ( strncasecmp ( c , "Digest " , strlen ( "Digest " ) ) )  16
0
------------------------------
258 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strlen 91
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 94
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_value , os_build ); 180
strcpy ( key_value , os_name ); 184
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
259 /home/SySeVR/data/CVE_2012_3553_PATCHED_setsubstate.c strlen 379
static void CVE_2012_3553_PATCHED_setsubstate(struct skinny_subchannel *sub, int state) 1
struct skinny_line * l = sub -> line ; 3
struct skinny_subline * subline = sub -> subline ; 4
struct skinny_device * d = l -> device ; 5
struct ast_channel * c = sub -> owner ; 6
int actualstate = state ; 8
if ( ! l -> device )  10
if ( sub -> substate == SUBSTATE_ONHOOK )  15
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  19
sub -> aa_sched = 0; 21
sub -> aa_beep = 0; 22
sub -> aa_mute = 0; 23
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  26
actualstate = SUBSTATE_CALLWAIT; 27
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  30
const char * slastation ; 31
struct skinny_subline * tmpsubline ; 32
slastation = pbx_builtin_getvar_helper ( c , "SLASTATION" ); 33
if ( slastation )  35
subline = tmpsubline; 38
if ( subline )  42
subline -> sub = sub; 44
sub -> subline = subline; 45
subline -> callid = sub -> callid; 46
if ( subline )  64
switch ( actualstate )  65
if ( sub -> related )  68
sub -> related -> related = NULL; 69
sub -> cxmode = SKINNY_CX_RECVONLY; 85
sub -> substate = SUBSTATE_ONHOOK; 86
if ( sub -> rtp )  87
sub -> rtp = NULL; 89
sub -> substate = SUBSTATE_ONHOOK; 91
sub -> substate = SUBSTATE_CONNECTED; 113
if ( sub -> substate != SUBSTATE_CONNECTED )  117
sub -> substate = SUBSTATE_HOLD; 129
if ( ( d -> hookstate == SKINNY_ONHOOK ) && ( ( actualstate == SUBSTATE_OFFHOOK ) || ( actualstate == SUBSTATE_DIALING ) || ( actualstate == SUBSTATE_RINGOUT ) || ( actualstate == SUBSTATE_CONNECTED ) || ( actualstate == SUBSTATE_BUSY ) || ( actualstate == SUBSTATE_CONGESTION ) || ( actualstate == SUBSTATE_PROGRESS ) ) )  141
d -> hookstate = SKINNY_OFFHOOK; 144
if ( actualstate == sub -> substate )  152
switch ( actualstate )  158
l -> activesub = sub; 161
sub -> substate = SUBSTATE_OFFHOOK; 169
if ( sub -> related )  179
sub -> related -> related = NULL; 180
if ( sub == l -> activesub )  183
l -> activesub = NULL; 184
sub -> cxmode = SKINNY_CX_RECVONLY; 199
sub -> substate = SUBSTATE_ONHOOK; 200
if ( sub -> rtp )  201
sub -> rtp = NULL; 203
if ( ast_strlen_zero ( sub -> exten ) || ! ast_exists_extension ( c , c -> context , sub -> exten , 1 , l -> cid_num ) )  210
if ( d -> hookstate == SKINNY_ONHOOK )  215
d -> hookstate = SKINNY_OFFHOOK; 216
sub -> substate = SUBSTATE_DIALING; 245
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS ) )  253
sub -> substate = SUBSTATE_RINGOUT; 265
if ( d -> hookstate == SKINNY_ONHOOK )  276
l -> activesub = sub; 277
sub -> substate = SUBSTATE_RINGIN; 284
sub -> substate = SUBSTATE_CALLWAIT; 297
sub -> substate = SUBSTATE_CONNECTED; 329
l -> activesub = sub; 330
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  333
sub -> substate = SUBSTATE_BUSY; 344
if ( ! ( sub -> substate == SUBSTATE_DIALING || sub -> substate == SUBSTATE_PROGRESS || sub -> substate == SUBSTATE_RINGOUT ) )  347
sub -> substate = SUBSTATE_CONGESTION; 358
if ( sub -> substate != SUBSTATE_DIALING )  361
sub -> substate = SUBSTATE_PROGRESS; 372
if ( sub -> substate != SUBSTATE_CONNECTED )  375
ast_queue_control_data ( sub -> owner , AST_CONTROL_HOLD , S_OR ( l -> mohsuggest , NULL ) , ! ast_strlen_zero ( l -> mohsuggest ) ? strlen ( l -> mohsuggest ) + 1 : 0 ); 379
0
------------------------------
260 /home/SySeVR/data/CVE_2012_3553_PATCHED_setsubstate.c strlen 131
static void CVE_2012_3553_PATCHED_setsubstate(struct skinny_subchannel *sub, int state) 1
struct skinny_line * l = sub -> line ; 3
struct skinny_subline * subline = sub -> subline ; 4
struct skinny_device * d = l -> device ; 5
struct ast_channel * c = sub -> owner ; 6
int actualstate = state ; 8
if ( ! l -> device )  10
if ( sub -> substate == SUBSTATE_ONHOOK )  15
if ( state != SUBSTATE_RINGIN && sub -> aa_sched )  19
sub -> aa_sched = 0; 21
sub -> aa_beep = 0; 22
sub -> aa_mute = 0; 23
if ( ( state == SUBSTATE_RINGIN ) && ( ( d -> hookstate == SKINNY_OFFHOOK ) || ( AST_LIST_NEXT ( AST_LIST_FIRST ( & l -> sub ) , list ) ) ) )  26
actualstate = SUBSTATE_CALLWAIT; 27
if ( ( state == SUBSTATE_CONNECTED ) && ( ! subline ) && ( AST_LIST_FIRST ( & l -> sublines ) ) )  30
const char * slastation ; 31
struct skinny_subline * tmpsubline ; 32
slastation = pbx_builtin_getvar_helper ( c , "SLASTATION" ); 33
if ( slastation )  35
subline = tmpsubline; 38
if ( subline )  42
subline -> sub = sub; 44
sub -> subline = subline; 45
subline -> callid = sub -> callid; 46
if ( subline )  64
switch ( actualstate )  65
if ( sub -> related )  68
sub -> related -> related = NULL; 69
sub -> cxmode = SKINNY_CX_RECVONLY; 85
sub -> substate = SUBSTATE_ONHOOK; 86
if ( sub -> rtp )  87
sub -> rtp = NULL; 89
sub -> substate = SUBSTATE_ONHOOK; 91
sub -> substate = SUBSTATE_CONNECTED; 113
if ( sub -> substate != SUBSTATE_CONNECTED )  117
sub -> substate = SUBSTATE_HOLD; 129
ast_queue_control_data ( sub -> owner , AST_CONTROL_HOLD , S_OR ( l -> mohsuggest , NULL ) , ! ast_strlen_zero ( l -> mohsuggest ) ? strlen ( l -> mohsuggest ) + 1 : 0 ); 131
0
------------------------------
261 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 236
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
proto_tree * hsrp_tree = NULL ; 114
guint8 type , len ; 115
if ( tree )  119
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 120
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 121
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
proto_tree * text_auth_tlv ; 224
gchar auth_buf [ 8 + 1 ] ; 225
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
0
------------------------------
262 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
0
------------------------------
263 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c strlen 231
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
proto_tree * hsrp_tree = NULL ; 112
guint8 type , len ; 113
if ( tree )  117
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 118
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 119
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
proto_tree * text_auth_tlv ; 219
gchar auth_buf [ 8 + 1 ] ; 220
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 222
offset += 2; 224
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 227
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
0
------------------------------
264 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c strlen 82
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
opcode = tvb_get_guint8 ( tvb , 1 ); 25
if ( tree )  44
proto_item * ti ; 45
proto_tree * hsrp_tree ; 46
gint offset ; 47
gchar auth_buf [ 8 + 1 ] ; 49
offset = 0; 51
ti = proto_tree_add_item ( tree , proto_hsrp , tvb , offset , - 1 , ENC_NA ); 52
hsrp_tree = proto_item_add_subtree ( ti , ett_hsrp ); 53
offset ++; 56
offset ++; 58
if ( opcode < 3 )  59
offset ++; 61
offset ++; 67
offset ++; 73
offset ++; 75
offset ++; 77
offset ++; 79
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
0
------------------------------
265 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strlen 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
266 /home/SySeVR/data/CVE_2012_6617_PATCHED_prepare_sdp_description.c strlen 45
static int CVE_2012_6617_PATCHED_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
AVOutputFormat * rtp_format = av_guess_format ( "rtp" , NULL , NULL ) ; 6
avc = avformat_alloc_context ( ); 9
if ( avc == NULL || ! rtp_format )  10
avc -> oformat = rtp_format; 13
avc -> nb_streams = stream -> nb_streams; 16
if ( stream -> is_multicast )  17
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 22
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  25
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  28
* pbuffer = av_mallocz ( 2048 ); 36
return strlen ( * pbuffer ) ; 45
0
------------------------------
267 /home/SySeVR/data/CVE_2012_6617_VULN_prepare_sdp_description.c strlen 43
static int CVE_2012_6617_VULN_prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
struct in_addr my_ip) 2
AVFormatContext * avc ; 4
AVStream * avs = NULL ; 5
avc = avformat_alloc_context ( ); 8
if ( avc == NULL )  9
avc -> nb_streams = stream -> nb_streams; 14
if ( stream -> is_multicast )  15
snprintf ( avc -> filename , 1024 , "rtp://0.0.0.0" ); 20
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avc -> streams ) || ! ( avc -> streams = av_malloc ( avc -> nb_streams * sizeof ( * avc -> streams ) ) ) )  23
if ( avc -> nb_streams >= INT_MAX / sizeof ( * avs ) || ! ( avs = av_malloc ( avc -> nb_streams * sizeof ( * avs ) ) ) )  26
* pbuffer = av_mallocz ( 2048 ); 34
return strlen ( * pbuffer ) ; 43
0
------------------------------
268 /home/SySeVR/data/CVE_2013_0874_PATCHED_doubles2str.c strlen 23
static char *CVE_2013_0874_PATCHED_doubles2str(double *dp, int count, const char *sep) 1
int i ; 3
char * ap , * ap0 ; 4
uint64_t component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15L L + strlen ( sep ) 7
if ( count >= ( INT_MAX - 1 ) / component_len )  8
ap = av_malloc ( component_len * count + 1 ); 10
if ( ! ap )  11
ap0 = ap; 13
ap [ 0 ] = '\0'; 14
for (i = 0; i < count; i++) 15
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 16
if ( l >= component_len )  17
ap += l; 21
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 23
return ap0 ; 24
0
------------------------------
269 /home/SySeVR/data/CVE_2013_0874_PATCHED_doubles2str.c strlen 23
static char *CVE_2013_0874_PATCHED_doubles2str(double *dp, int count, const char *sep) 1
int i ; 3
char * ap , * ap0 ; 4
uint64_t component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15L L + strlen ( sep ) 7
if ( count >= ( INT_MAX - 1 ) / component_len )  8
ap = av_malloc ( component_len * count + 1 ); 10
if ( ! ap )  11
ap0 = ap; 13
ap [ 0 ] = '\0'; 14
for (i = 0; i < count; i++) 15
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 16
if ( l >= component_len )  17
ap += l; 21
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 23
return ap0 ; 24
0
------------------------------
270 /home/SySeVR/data/CVE_2013_0874_VULN_doubles2str.c strlen 21
static char *CVE_2013_0874_VULN_doubles2str(double *dp, int count, const char *sep) 1
int i ; 3
char * ap , * ap0 ; 4
int component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15 + strlen ( sep ); 7
ap = av_malloc ( component_len * count ); 8
if ( ! ap )  9
ap0 = ap; 11
ap [ 0 ] = '\0'; 12
for (i = 0; i < count; i++) 13
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 14
if ( l >= component_len )  15
ap += l; 19
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 21
return ap0 ; 22
0
------------------------------
271 /home/SySeVR/data/CVE_2013_0874_VULN_doubles2str.c strlen 21
static char *CVE_2013_0874_VULN_doubles2str(double *dp, int count, const char *sep) 1
int i ; 3
char * ap , * ap0 ; 4
int component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15 + strlen ( sep ); 7
ap = av_malloc ( component_len * count ); 8
if ( ! ap )  9
ap0 = ap; 11
ap [ 0 ] = '\0'; 12
for (i = 0; i < count; i++) 13
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 14
if ( l >= component_len )  15
ap += l; 19
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 21
return ap0 ; 22
0
------------------------------
272 /home/SySeVR/data/CVE_2013_0874_VULN_doubles2str.c strlen 7
static char *CVE_2013_0874_VULN_doubles2str(double *dp, int count, const char *sep) 1
int component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15 + strlen ( sep ); 7
ap = av_malloc ( component_len * count ); 8
if ( ! ap )  9
ap0 = ap; 11
ap [ 0 ] = '\0'; 12
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 14
if ( l >= component_len )  15
av_free ( ap0 ); 16
ap += l; 19
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 21
return ap0 ; 22
0
------------------------------
273 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c strlen 261
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * attribute_value ; 8
gint sdp_media_attrbute_code ; 11
const char * msrp_res = "msrp://" ; 12
const char * h324ext_h223lcparm = "h324ext/h223lcparm" ; 13
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
attribute_value = tvb_get_ephemeral_string ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 44
switch ( sdp_media_attrbute_code )  51
if ( strncmp ( ( char * ) attribute_value , h324ext_h223lcparm , strlen ( msrp_res ) ) == 0 )  251
gint len ; 258
len = ( gint ) strlen ( attribute_value ); 261
h245_tvb = ascii_bytes_to_tvb ( tvb , pinfo , len , attribute_value ); 262
if ( h245_tvb )  267
dissect_h245_H223LogicalChannelParameters ( h245_tvb , 0 , & actx , sdp_media_attribute_tree , hf_SDPh223LogicalChannelParameters ); 269
0
------------------------------
274 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c strlen 251
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * attribute_value ; 8
gint sdp_media_attrbute_code ; 11
const char * msrp_res = "msrp://" ; 12
const char * h324ext_h223lcparm = "h324ext/h223lcparm" ; 13
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
attribute_value = tvb_get_ephemeral_string ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 44
switch ( sdp_media_attrbute_code )  51
if ( strncmp ( ( char * ) attribute_value , h324ext_h223lcparm , strlen ( msrp_res ) ) == 0 )  251
0
------------------------------
275 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c strlen 228
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 * attribute_value ; 8
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
const char * msrp_res = "msrp://" ; 12
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
attribute_value = tvb_get_ephemeral_string ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 44
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
if ( strncmp ( ( char * ) attribute_value , msrp_res , strlen ( msrp_res ) ) == 0 )  224
int address_offset , port_offset , port_end_offset ; 225
address_offset = offset + ( int ) strlen ( msrp_res ); 228
port_offset = tvb_find_guint8 ( tvb , address_offset , - 1 , ':' ); 231
if ( port_offset != - 1 )  233
port_end_offset = tvb_find_guint8 ( tvb , port_offset , - 1 , '/' ); 235
if ( inet_pton ( AF_INET , ( char * ) tvb_get_ephemeral_string ( tvb , address_offset , port_offset - address_offset ) , & msrp_ipaddr ) > 0 )  238
msrp_port_number = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , port_offset + 1 , port_end_offset - port_offset - 1 ) ); 242
0
------------------------------
276 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c strlen 224
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * attribute_value ; 8
gint sdp_media_attrbute_code ; 11
const char * msrp_res = "msrp://" ; 12
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
attribute_value = tvb_get_ephemeral_string ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 44
switch ( sdp_media_attrbute_code )  51
if ( strncmp ( ( char * ) attribute_value , msrp_res , strlen ( msrp_res ) ) == 0 )  224
0
------------------------------
277 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c strlen 64
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
location += len + 1; 57
if ( len >= 64 )  58
len = strlen ( location ); 64
location += len + 1; 66
if ( len >= 32 )  67
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
278 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c strlen 55
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
location += len + 1; 57
if ( len >= 64 )  58
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
location += len + 1; 66
if ( len >= 32 )  67
infoBlock -> MARChannelID = NULL; 68
infoBlock -> productVersion = NULL; 69
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
279 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c strlen 64
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
location += len + 1; 57
if ( len >= 64 )  58
len = strlen ( location ); 64
location += len + 1; 66
if ( len >= 32 )  67
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
280 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c strlen 55
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
const char * location ; 35
int len ; 36
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
location += len + 1; 57
if ( len >= 64 )  58
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
location += len + 1; 66
if ( len >= 32 )  67
infoBlock -> MARChannelID = NULL; 68
infoBlock -> productVersion = NULL; 69
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
281 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_add_notunderstood_response.c strlen 8
static int CVE_2013_2850_PATCHED_iscsi_add_notunderstood_response(
char *key,
char *value,
struct iscsi_param_list *param_list) 4
if ( strlen ( value ) > VALUE_MAXLEN )  8
0
------------------------------
282 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_decode_text_input.c strlen 55
int CVE_2013_2850_PATCHED_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 40
if ( ! param )  41
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  42
start += strlen ( key ) + strlen ( value ) + 2; 47
if ( iscsi_check_value ( param , value ) < 0 )  50
start += strlen ( key ) + strlen ( value ) + 2; 55
if ( IS_PSTATE_PROPOSER ( param ) )  57
if ( iscsi_check_proposer_state ( param , value ) < 0 )  58
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  64
0
------------------------------
283 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_decode_text_input.c strlen 55
int CVE_2013_2850_PATCHED_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 40
if ( ! param )  41
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  42
start += strlen ( key ) + strlen ( value ) + 2; 47
if ( iscsi_check_value ( param , value ) < 0 )  50
start += strlen ( key ) + strlen ( value ) + 2; 55
if ( IS_PSTATE_PROPOSER ( param ) )  57
if ( iscsi_check_proposer_state ( param , value ) < 0 )  58
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  64
0
------------------------------
284 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_decode_text_input.c strlen 47
int CVE_2013_2850_PATCHED_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 40
if ( ! param )  41
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  42
start += strlen ( key ) + strlen ( value ) + 2; 47
if ( iscsi_check_value ( param , value ) < 0 )  50
start += strlen ( key ) + strlen ( value ) + 2; 55
if ( IS_PSTATE_PROPOSER ( param ) )  57
if ( iscsi_check_proposer_state ( param , value ) < 0 )  58
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  64
0
------------------------------
285 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_decode_text_input.c strlen 47
int CVE_2013_2850_PATCHED_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 40
if ( ! param )  41
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  42
start += strlen ( key ) + strlen ( value ) + 2; 47
if ( iscsi_check_value ( param , value ) < 0 )  50
start += strlen ( key ) + strlen ( value ) + 2; 55
if ( IS_PSTATE_PROPOSER ( param ) )  57
if ( iscsi_check_proposer_state ( param , value ) < 0 )  58
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  64
0
------------------------------
286 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_add_notunderstood_response.c strlen 23
static int CVE_2013_2850_VULN_iscsi_add_notunderstood_response(
char *key,
char *value,
struct iscsi_param_list *param_list) 4
struct iscsi_extra_response * extra_response ; 6
if ( strlen ( value ) > VALUE_MAXLEN )  8
extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ); 14
if ( ! extra_response )  15
strncpy ( extra_response -> key , key , strlen ( key ) + 1 ); 22
strncpy ( extra_response -> value , NOTUNDERSTOOD , strlen ( NOTUNDERSTOOD ) + 1 ); 23
list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ); 26
0
------------------------------
287 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_add_notunderstood_response.c strlen 22
static int CVE_2013_2850_VULN_iscsi_add_notunderstood_response(
char *key,
char *value,
struct iscsi_param_list *param_list) 4
struct iscsi_extra_response * extra_response ; 6
if ( strlen ( value ) > VALUE_MAXLEN )  8
extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ); 14
if ( ! extra_response )  15
strncpy ( extra_response -> key , key , strlen ( key ) + 1 ); 22
strncpy ( extra_response -> value , NOTUNDERSTOOD , strlen ( NOTUNDERSTOOD ) + 1 ); 23
list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ); 26
0
------------------------------
288 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_add_notunderstood_response.c strlen 8
static int CVE_2013_2850_VULN_iscsi_add_notunderstood_response(
char *key,
char *value,
struct iscsi_param_list *param_list) 4
if ( strlen ( value ) > VALUE_MAXLEN )  8
0
------------------------------
289 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c strlen 57
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 42
if ( ! param )  43
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  44
start += strlen ( key ) + strlen ( value ) + 2; 49
if ( iscsi_check_value ( param , value ) < 0 )  52
start += strlen ( key ) + strlen ( value ) + 2; 57
if ( IS_PSTATE_PROPOSER ( param ) )  59
if ( iscsi_check_proposer_state ( param , value ) < 0 )  60
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  66
0
------------------------------
290 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c strlen 57
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 42
if ( ! param )  43
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  44
start += strlen ( key ) + strlen ( value ) + 2; 49
if ( iscsi_check_value ( param , value ) < 0 )  52
start += strlen ( key ) + strlen ( value ) + 2; 57
if ( IS_PSTATE_PROPOSER ( param ) )  59
if ( iscsi_check_proposer_state ( param , value ) < 0 )  60
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  66
0
------------------------------
291 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c strlen 49
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 42
if ( ! param )  43
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  44
start += strlen ( key ) + strlen ( value ) + 2; 49
if ( iscsi_check_value ( param , value ) < 0 )  52
start += strlen ( key ) + strlen ( value ) + 2; 57
if ( IS_PSTATE_PROPOSER ( param ) )  59
if ( iscsi_check_proposer_state ( param , value ) < 0 )  60
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  66
0
------------------------------
292 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c strlen 49
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
param = iscsi_check_key ( key , phase , sender , param_list ); 42
if ( ! param )  43
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  44
start += strlen ( key ) + strlen ( value ) + 2; 49
if ( iscsi_check_value ( param , value ) < 0 )  52
start += strlen ( key ) + strlen ( value ) + 2; 57
if ( IS_PSTATE_PROPOSER ( param ) )  59
if ( iscsi_check_proposer_state ( param , value ) < 0 )  60
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  66
0
------------------------------
293 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c strlen 35
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
char * tmpptr = key + strlen ( key ) ; 35
* tmpptr = '='; 36
param = iscsi_check_key ( key , phase , sender , param_list ); 42
if ( ! param )  43
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  44
start += strlen ( key ) + strlen ( value ) + 2; 49
if ( iscsi_check_value ( param , value ) < 0 )  52
start += strlen ( key ) + strlen ( value ) + 2; 57
if ( IS_PSTATE_PROPOSER ( param ) )  59
if ( iscsi_check_proposer_state ( param , value ) < 0 )  60
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  66
0
------------------------------
294 /home/SySeVR/data/CVE_2013_4247_PATCHED_build_unc_path_to_root.c strlen 6
static char *
CVE_2013_4247_PATCHED_build_unc_path_to_root(const struct smb_vol *vol,
const struct cifs_sb_info *cifs_sb) 3
unsigned int pplen = vol -> prepath ? strlen ( vol -> prepath ) + 1 : 0 ; 6
full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ); 9
if ( full_path == NULL )  10
strncpy ( full_path , vol -> UNC , unc_len ); 13
pos = full_path + unc_len; 14
if ( pplen )  16
* pos = CIFS_DIR_SEP ( cifs_sb ); 17
strncpy ( pos + 1 , vol -> prepath , pplen ); 18
pos += pplen; 19
* pos = '\0'; 22
convert_delimiter ( full_path , CIFS_DIR_SEP ( cifs_sb ) ); 23
cFYI ( 1 , "%s: full_path=%s" , __func__ , full_path ); 24
return full_path ; 25
0
------------------------------
295 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c strlen 95
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
if ( ! ast_strlen_zero ( __get_header ( req , "via" , & via_pos ) ) )  79
if ( p -> ocseq && ( p -> ocseq < seqno ) )  83
if ( p -> owner )  91
struct ast_control_pvt_cause_code * cause_code ; 92
int data_size = sizeof ( * cause_code ) ; 93
data_size += 4 + strlen ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 95
cause_code = ast_alloca ( data_size ); 96
ast_copy_string ( cause_code -> chan_name , ast_channel_name ( p -> owner ) , AST_CHANNEL_NAME ); 98
snprintf ( cause_code -> code , data_size - sizeof ( * cause_code ) + 1 , "SIP %s" , REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 100
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
0
------------------------------
296 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c strlen 721
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int sendonly = - 1 ; 52
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
if ( ! p -> owner )  691
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_CALL_ONHOLD ) && ( ! ast_sockaddr_isnull ( sa ) || ! ast_sockaddr_isnull ( vsa ) || ! ast_sockaddr_isnull ( tsa ) || ! ast_sockaddr_isnull ( isa ) ) && ( ! sendonly || sendonly == - 1 ) )  715
if ( ( sockaddr_is_null_or_any ( sa ) && sockaddr_is_null_or_any ( vsa ) && sockaddr_is_null_or_any ( tsa ) && sockaddr_is_null_or_any ( isa ) ) || ( sendonly && sendonly != - 1 ) )  720
ast_queue_control_data ( p -> owner , AST_CONTROL_HOLD , S_OR ( p -> mohsuggest , NULL ) , ! ast_strlen_zero ( p -> mohsuggest ) ? strlen ( p -> mohsuggest ) + 1 : 0 ); 721
0
------------------------------
297 /home/SySeVR/data/CVE_2014_6427_PATCHED_is_rtsp_request_or_reply.c strlen 35
static gboolean
CVE_2014_6427_PATCHED_is_rtsp_request_or_reply(const guchar *line, size_t linelen, rtsp_type_t *type) 2
guint ii ; 4
if ( linelen >= 5 && g_ascii_strncasecmp ( "RTSP/" , line , 5 ) == 0 )  10
for (ii = 0; ii < RTSP_NMETHODS; ii++) 34
size_t len = strlen ( rtsp_methods [ ii ] ) ; 35
if ( linelen >= len && g_ascii_strncasecmp ( rtsp_methods [ ii ] , line , len ) == 0 && ( len == linelen || isspace ( line [ len ] ) ) )  36
rtsp_stat_info -> request_method = wmem_strndup ( wmem_packet_scope ( ) , rtsp_methods [ ii ] , len + 1 ); 41
0
------------------------------
298 /home/SySeVR/data/CVE_2014_7145_PATCHED_SMB2_tcon.c strlen 28
int
CVE_2014_7145_PATCHED_SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,
struct cifs_tcon *tcon, const struct nls_table *cp) 3
int unc_path_len ; 10
if ( ( ses -> server ) && tree )  16
if ( tcon && tcon -> bad_network_name )  21
unc_path = kmalloc ( MAX_SHARENAME_LENGTH * 2 , GFP_KERNEL ); 24
if ( unc_path == NULL )  25
unc_path_len = cifs_strtoUTF16 ( unc_path , tree , strlen ( tree ) , cp ) + 1; 28
unc_path_len *= 2; 29
if ( unc_path_len < 2 )  30
req -> PathLength = cpu_to_le16 ( unc_path_len - 2 ); 55
iov [ 1 ] . iov_len = unc_path_len; 57
inc_rfc1001_len ( req , unc_path_len - 1 ); 59
rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ); 61
rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base; 62
if ( rc != 0 )  64
ses -> ipc_tid = rsp -> hdr . TreeId; 73
if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK )  77
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE )  79
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT )  82
cifs_dbg ( VFS , "unknown share type %d\n" , rsp -> ShareType ); 86
tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ); 91
tcon -> capabilities = rsp -> Capabilities; 92
tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ); 93
tcon -> tidStatus = CifsGood; 94
tcon -> need_reconnect = false; 95
tcon -> tid = rsp -> hdr . TreeId; 96
strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ); 97
if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) )  99
init_copy_chunk_defaults ( tcon ); 102
if ( tcon -> ses -> server -> ops -> validate_negotiate )  103
rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ); 104
free_rsp_buf ( resp_buftype , rsp ); 106
return rc ; 108
if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME )  111
0
------------------------------
299 /home/SySeVR/data/CVE_2014_7145_VULN_SMB2_tcon.c strlen 28
int
CVE_2014_7145_VULN_SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,
struct cifs_tcon *tcon, const struct nls_table *cp) 3
int unc_path_len ; 10
if ( ( ses -> server ) && tree )  16
if ( tcon && tcon -> bad_network_name )  21
unc_path = kmalloc ( MAX_SHARENAME_LENGTH * 2 , GFP_KERNEL ); 24
if ( unc_path == NULL )  25
unc_path_len = cifs_strtoUTF16 ( unc_path , tree , strlen ( tree ) , cp ) + 1; 28
unc_path_len *= 2; 29
if ( unc_path_len < 2 )  30
req -> PathLength = cpu_to_le16 ( unc_path_len - 2 ); 55
iov [ 1 ] . iov_len = unc_path_len; 57
inc_rfc1001_len ( req , unc_path_len - 1 ); 59
rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ); 61
rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base; 62
if ( rc != 0 )  64
ses -> ipc_tid = rsp -> hdr . TreeId; 73
if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK )  77
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE )  79
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT )  82
cifs_dbg ( VFS , "unknown share type %d\n" , rsp -> ShareType ); 86
tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ); 91
tcon -> capabilities = rsp -> Capabilities; 92
tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ); 93
tcon -> tidStatus = CifsGood; 94
tcon -> need_reconnect = false; 95
tcon -> tid = rsp -> hdr . TreeId; 96
strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ); 97
if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) )  99
init_copy_chunk_defaults ( tcon ); 102
if ( tcon -> ses -> server -> ops -> validate_negotiate )  103
rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ); 104
free_rsp_buf ( resp_buftype , rsp ); 106
return rc ; 108
if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME )  111
0
------------------------------
300 /home/SySeVR/data/CVE_2014_8713_VULN_build_expert_data.c strlen 79
static void
CVE_2014_8713_VULN_build_expert_data(proto_tree *ncp_tree, const char *hf_name, char *buffer,
size_t buffer_size, int repeat_lookup,
gboolean search_structs) 4
proto_tree * tree_pointer ; 6
proto_tree * tree_loc ; 7
proto_tree * struct_tree_pointer = NULL ; 8
char temp_buffer [ 256 ] = "\0" ; 9
gboolean in_struct = FALSE ; 10
tree_loc = ncp_tree -> first_child; 12
for (tree_pointer=tree_loc; tree_pointer!=NULL; tree_pointer=tree_pointer->next) 13
if ( tree_pointer -> first_child && ! in_struct && search_structs )  16
struct_tree_pointer = tree_pointer; 17
tree_pointer = tree_pointer -> first_child; 18
in_struct = TRUE; 19
if ( strcmp ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> abbrev , hf_name ) == 0 )  21
switch ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> type )  23
if ( repeat_lookup > 0 )  39
if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 )  40
repeat_lookup --; 42
if ( repeat_lookup == 0 )  70
if ( tree_pointer -> next == NULL && in_struct && search_structs )  74
tree_pointer = struct_tree_pointer; 75
in_struct = FALSE; 76
if ( strlen ( buffer ) == 0 )  79
0
------------------------------
301 /home/SySeVR/data/CVE_2014_8713_VULN_build_expert_data.c strlen 40
static void
CVE_2014_8713_VULN_build_expert_data(proto_tree *ncp_tree, const char *hf_name, char *buffer,
size_t buffer_size, int repeat_lookup,
gboolean search_structs) 4
proto_tree * tree_pointer ; 6
proto_tree * tree_loc ; 7
proto_tree * struct_tree_pointer = NULL ; 8
char temp_buffer [ 256 ] = "\0" ; 9
gboolean in_struct = FALSE ; 10
tree_loc = ncp_tree -> first_child; 12
for (tree_pointer=tree_loc; tree_pointer!=NULL; tree_pointer=tree_pointer->next) 13
if ( tree_pointer -> first_child && ! in_struct && search_structs )  16
struct_tree_pointer = tree_pointer; 17
tree_pointer = tree_pointer -> first_child; 18
in_struct = TRUE; 19
if ( strcmp ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> abbrev , hf_name ) == 0 )  21
switch ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> type )  23
if ( repeat_lookup > 0 )  39
if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 )  40
repeat_lookup --; 42
if ( repeat_lookup == 0 )  70
if ( tree_pointer -> next == NULL && in_struct && search_structs )  74
tree_pointer = struct_tree_pointer; 75
in_struct = FALSE; 76
0
------------------------------
302 /home/SySeVR/data/CVE_2014_8713_VULN_build_expert_data.c strlen 40
static void
CVE_2014_8713_VULN_build_expert_data(proto_tree *ncp_tree, const char *hf_name, char *buffer,
size_t buffer_size, int repeat_lookup,
gboolean search_structs) 4
proto_tree * tree_pointer ; 6
proto_tree * tree_loc ; 7
proto_tree * struct_tree_pointer = NULL ; 8
char temp_buffer [ 256 ] = "\0" ; 9
gboolean in_struct = FALSE ; 10
tree_loc = ncp_tree -> first_child; 12
for (tree_pointer=tree_loc; tree_pointer!=NULL; tree_pointer=tree_pointer->next) 13
if ( tree_pointer -> first_child && ! in_struct && search_structs )  16
struct_tree_pointer = tree_pointer; 17
tree_pointer = tree_pointer -> first_child; 18
in_struct = TRUE; 19
if ( strcmp ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> abbrev , hf_name ) == 0 )  21
switch ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> type )  23
if ( repeat_lookup > 0 )  39
if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 )  40
repeat_lookup --; 42
if ( repeat_lookup == 0 )  70
if ( tree_pointer -> next == NULL && in_struct && search_structs )  74
tree_pointer = struct_tree_pointer; 75
in_struct = FALSE; 76
0
------------------------------
303 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
304 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
305 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
306 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
307 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
308 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
309 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
310 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c unlink 123
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
if ( bs -> is_temporary )  107
bs -> backing_hd -> keep_read_only = bs -> keep_read_only; 111
if ( bs -> is_temporary )  122
unlink ( filename ); 123
0
------------------------------
311 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c execv 14
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( getenv ( "LD_PRELOAD" ) )  4
execv ( argv [ 0 ] , argv ); 14
0
------------------------------
312 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c memchr 20
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
result_len = opt - data; 28
opt ++; 29
kdebug ( "options: '%s'" , opt ); 30
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
tmp = opt_vlen >= 0 ? opt_vlen : 0; 49
kdebug ( "option '%*.*s' val '%*.*s'" , opt_nlen , opt_nlen , opt , tmp , tmp , eq ); 50
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
printk ( KERN_WARNING
"Option '%*.*s' to dns_resolver key %d:"
" bad/missing value\n" ,
opt_nlen , opt_nlen , opt , key -> serial ) 77
while ( opt = next_opt + 1 , opt < end )  79
ret = key_payload_reserve ( key , result_len ); 90
if ( ret < 0 )  91
upayload = kmalloc ( sizeof ( * upayload ) + result_len + 1 , GFP_KERNEL ); 94
if ( ! upayload )  95
upayload -> datalen = result_len; 100
memcpy ( upayload -> data , data , result_len ); 101
upayload -> data [ result_len ] = '\0'; 102
rcu_assign_pointer ( key -> payload . data , upayload ); 103
0
------------------------------
313 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c sprintf 83
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
314 /home/SySeVR/data/CVE_2009_2484_VULN_Win32AddConnection.c sprintf 41
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char psz_remote [ MAX_PATH ] , psz_server [ MAX_PATH ] , psz_share [ MAX_PATH ] ; 6
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_share [ 0 ] = 0; 32
sprintf ( psz_remote , "\\\\%s\\%s" , psz_server , psz_share ); 41
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
msg_Dbg ( p_access , "connected to %s" , psz_remote ); 48
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
msg_Dbg ( p_access , "already connected to %s" , psz_remote ); 53
msg_Dbg ( p_access , "failed to connect to %s" , psz_remote ); 57
0
------------------------------
315 /home/SySeVR/data/CVE_2013_1792_PATCHED_install_user_keyrings.c sprintf 44
int CVE_2013_1792_PATCHED_install_user_keyrings(void) 1
struct user_struct * user ; 3
const struct cred * cred ; 4
struct key * uid_keyring , * session_keyring ; 5
char buf [ 20 ] ; 6
uid_t uid ; 8
cred = current_cred ( ); 10
user = cred -> user; 11
uid = from_kuid ( cred -> user_ns , user -> uid ); 12
if ( user -> uid_keyring && user -> session_keyring )  16
if ( ! user -> uid_keyring )  24
sprintf ( buf , "_uid.%u" , uid ); 29
uid_keyring = find_keyring_by_name ( buf , true ); 31
if ( IS_ERR ( uid_keyring ) )  32
uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , KEY_ALLOC_IN_QUOTA , NULL ); 33
if ( IS_ERR ( uid_keyring ) )  36
sprintf ( buf , "_uid_ses.%u" , uid ); 44
session_keyring = find_keyring_by_name ( buf , true ); 46
if ( IS_ERR ( session_keyring ) )  47
session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , KEY_ALLOC_IN_QUOTA , NULL ); 48
if ( IS_ERR ( session_keyring ) )  51
ret = PTR_ERR ( session_keyring ); 52
ret = key_link ( session_keyring , uid_keyring ); 58
if ( ret < 0 )  59
user -> session_keyring = session_keyring; 65
key_put ( session_keyring ); 73
kleave ( " = %d" , ret ); 78
return ret ; 79
0
------------------------------
316 /home/SySeVR/data/CVE_2013_1792_PATCHED_install_user_keyrings.c sprintf 29
int CVE_2013_1792_PATCHED_install_user_keyrings(void) 1
struct user_struct * user ; 3
const struct cred * cred ; 4
char buf [ 20 ] ; 6
uid_t uid ; 8
cred = current_cred ( ); 10
user = cred -> user; 11
uid = from_kuid ( cred -> user_ns , user -> uid ); 12
if ( user -> uid_keyring && user -> session_keyring )  16
if ( ! user -> uid_keyring )  24
sprintf ( buf , "_uid.%u" , uid ); 29
uid_keyring = find_keyring_by_name ( buf , true ); 31
if ( IS_ERR ( uid_keyring ) )  32
uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , KEY_ALLOC_IN_QUOTA , NULL ); 33
if ( IS_ERR ( uid_keyring ) )  36
ret = PTR_ERR ( uid_keyring ); 37
ret = key_link ( session_keyring , uid_keyring ); 58
if ( ret < 0 )  59
user -> uid_keyring = uid_keyring; 64
user -> session_keyring = session_keyring; 65
key_put ( uid_keyring ); 75
kleave ( " = %d" , ret ); 78
return ret ; 79
0
------------------------------
317 /home/SySeVR/data/CVE_2010_2431_VULN_cupsFileOpen.c strrchr 46
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
char hostname [ 1024 ] , * portname ; 9
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  46
* portname ++ = '\0'; 47
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  55
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
httpAddrFreeList ( addrlist ); 64
httpAddrFreeList ( addrlist ); 68
0
------------------------------
318 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c free 113
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
if ( s -> outputstr )  94
free ( s -> outputstr ); 113
0
------------------------------
319 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c free 112
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
0
------------------------------
320 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 38
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
free ( p_sys ); 38
0
------------------------------
321 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 36
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
free ( p_sys -> p_index ); 36
0
------------------------------
322 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 35
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
free ( p_sys -> psz_description ); 35
0
------------------------------
323 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 34
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
free ( p_sys -> psz_copyright ); 34
0
------------------------------
324 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 33
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
free ( p_sys -> psz_artist ); 33
0
------------------------------
325 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 32
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
free ( p_sys -> psz_title ); 32
0
------------------------------
326 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 30
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
if ( p_sys -> i_track > 0 )  29
free ( p_sys -> track ); 30
0
------------------------------
327 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 27
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
for( int i = 0; i < p_sys->i_track; i++ ) 9
real_track_t * tk = p_sys -> track [ i ] ; 11
free ( tk ); 27
0
------------------------------
328 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 24
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
for( int i = 0; i < p_sys->i_track; i++ ) 9
real_track_t * tk = p_sys -> track [ i ] ; 11
free ( tk -> p_subpackets_timecode ); 24
0
------------------------------
329 /home/SySeVR/data/CVE_2010_3907_PATCHED_Close.c free 23
static void CVE_2010_3907_PATCHED_Close( vlc_object_t *p_this ) 4
demux_t * p_demux = ( demux_t * ) p_this ; 6
demux_sys_t * p_sys = p_demux -> p_sys ; 7
for( int i = 0; i < p_sys->i_track; i++ ) 9
real_track_t * tk = p_sys -> track [ i ] ; 11
free ( tk -> p_subpackets ); 23
0
------------------------------
330 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c free 111
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )  100
p_stream -> i_headers = 0; 103
p_stream -> p_headers = NULL; 104
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
free ( p_stream -> fmt . p_extra ); 111
0
------------------------------
331 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c free 97
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
void * p_org = p_stream -> p_headers ; 84
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
free ( p_org ); 97
0
------------------------------
332 /home/SySeVR/data/CVE_2012_5532_VULN_main.c free 160
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
333 /home/SySeVR/data/CVE_2012_5532_VULN_main.c free 141
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
free ( if_name ); 141
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
334 /home/SySeVR/data/CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph.c free 187
static cairo_status_t
CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
unsigned char * data ; 8
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
scaled_glyph = * pscaled_glyph; 33
glyph_surface = scaled_glyph -> surface; 34
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format ); 46
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ; 51
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )  64
cairo_surface_t * tmp_surface ; 65
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 ); 67
status = tmp_surface -> status; 68
if ( unlikely ( status ) )  69
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 72
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 73
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 75
if ( glyph_surface -> format != glyphset_info -> format )  82
cairo_surface_pattern_t pattern ; 83
cairo_surface_t * tmp_surface ; 84
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height ); 86
status = tmp_surface -> status; 89
if ( unlikely ( status ) )  90
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 93
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 94
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL ); 97
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 102
if ( unlikely ( status ) )  104
data = glyph_surface -> data; 116
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )  119
if ( _native_byte_order_lsb ( ) != ( BitmapBitOrder ( display -> display ) == LSBFirst ) )  122
if ( _native_byte_order_lsb ( ) != ( ImageByteOrder ( display -> display ) == LSBFirst ) )  147
if ( data != glyph_surface -> data )  186
free ( data ); 187
0
------------------------------
335 /home/SySeVR/data/CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph.c free 178
static cairo_status_t
CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
unsigned char * data ; 8
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
scaled_glyph = * pscaled_glyph; 33
glyph_surface = scaled_glyph -> surface; 34
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format ); 46
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ; 51
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )  64
cairo_surface_t * tmp_surface ; 65
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 ); 67
status = tmp_surface -> status; 68
if ( unlikely ( status ) )  69
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 72
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 73
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 75
if ( glyph_surface -> format != glyphset_info -> format )  82
cairo_surface_pattern_t pattern ; 83
cairo_surface_t * tmp_surface ; 84
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height ); 86
status = tmp_surface -> status; 89
if ( unlikely ( status ) )  90
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 93
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 94
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL ); 97
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 102
if ( unlikely ( status ) )  104
data = glyph_surface -> data; 116
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )  119
if ( _native_byte_order_lsb ( ) != ( BitmapBitOrder ( display -> display ) == LSBFirst ) )  122
if ( _native_byte_order_lsb ( ) != ( ImageByteOrder ( display -> display ) == LSBFirst ) )  147
if ( data != glyph_surface -> data )  177
free ( data ); 178
0
------------------------------
336 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c free 441
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( useService )  300
BOOL isLocal = FALSE ; 301
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 302
if ( useService )  311
BOOL unpromptedElevation ; 312
if ( IsUnpromptedElevation ( unpromptedElevation ) )  313
useService = ! unpromptedElevation; 314
if ( useService )  320
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 321
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
HKEY baseKey ; 323
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  324
useService = testOnlyFallbackKeyExists; 330
useService = false; 336
if ( useService )  349
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 352
useService = ( ret == ERROR_SUCCESS ); 353
if ( useService )  355
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 377
if ( lastState != SERVICE_STOPPED )  378
useService = false; 382
if ( ! useService && sBackgroundUpdate )  393
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
free ( cmdLine ); 441
0
------------------------------
337 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c free 441
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( useService )  300
BOOL isLocal = FALSE ; 301
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 302
if ( useService )  311
BOOL unpromptedElevation ; 312
if ( IsUnpromptedElevation ( unpromptedElevation ) )  313
useService = ! unpromptedElevation; 314
if ( useService )  320
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 321
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
HKEY baseKey ; 323
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  324
useService = testOnlyFallbackKeyExists; 330
useService = false; 336
if ( useService )  349
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 352
useService = ( ret == ERROR_SUCCESS ); 353
if ( useService )  355
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 377
if ( lastState != SERVICE_STOPPED )  378
useService = false; 382
if ( ! useService && sBackgroundUpdate )  393
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
free ( cmdLine ); 441
0
------------------------------
338 /home/SySeVR/data/CVE_2014_9743_PATCHED_httpd_HtmlError.c free 24
static size_t CVE_2014_9743_PATCHED_httpd_HtmlError (char **body, int code, const char *url) 1
char * url_Encoded = convert_xml_special_chars ( url ? url : "" ) ; 6
free ( url_Encoded ); 24
0
------------------------------
339 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c free 488
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
useService = testOnlyFallbackKeyExists; 379
useService = false; 385
if ( useService )  398
DWORD ret = LaunchServiceSoftwareUpdateCommand ( argc , ( LPCWSTR * ) argv ) ; 401
useService = ( ret == ERROR_SUCCESS ); 402
if ( useService )  404
lastState = WaitForServiceStop ( SVC_NAME , 1 ); 426
if ( lastState != SERVICE_STOPPED )  427
useService = false; 431
if ( ! useService && sStagedUpdate )  441
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
free ( cmdLine ); 488
0
------------------------------
340 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c rand 33
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
AST_LIST_INSERT_HEAD ( & sessions , s , list ); 35
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
ast_atomic_fetchadd_int ( & s -> eventq -> usecount , 1 ); 41
time ( & s -> sessiontimeout ); 46
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
ast_mutex_unlock ( & s -> __lock ); 51
if ( s )  53
if ( process_message ( s , & m ) )  66
if ( s -> authenticated )  67
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ) 70
ast_log ( LOG_EVENT , "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ); 72
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Connect attempt from '%s' unable to authenticate\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ) 76
ast_log ( LOG_EVENT , "HTTP Failed attempt from %s\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ); 78
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
ast_mutex_lock ( & s -> __lock ); 93
if ( s -> outputstr )  94
tmp = xml_translate ( s -> outputstr -> str , params ); 97
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
free ( s -> outputstr ); 113
s -> outputstr = NULL; 114
ast_mutex_unlock ( & s -> __lock ); 116
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
ast_mutex_lock ( & s -> __lock ); 127
if ( s -> needdestroy )  128
if ( s -> inuse == 1 )  129
if ( s -> waiting_thread != AST_PTHREADT_NULL )  134
pthread_kill ( s -> waiting_thread , SIGURG ); 135
s -> inuse --; 136
s -> inuse --; 139
ast_mutex_unlock ( & s -> __lock ); 140
destroy_session ( s ); 143
return retval ; 147
0
------------------------------
341 /home/SySeVR/data/CVE_2010_2431_VULN_cupsFileOpen.c open 41
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE | O_BINARY , 0666 ); 41
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
closesocket ( fd ); 85
close ( fd ); 87
return ( fp ) ; 94
0
------------------------------
342 /home/SySeVR/data/CVE_2010_2431_VULN_cupsFileOpen.c open 37
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDONLY | O_LARGEFILE | O_BINARY , 0 ); 37
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
closesocket ( fd ); 85
close ( fd ); 87
return ( fp ) ; 94
0
------------------------------
343 /home/SySeVR/data/CVE_2010_2431_VULN_cupsFileOpen.c open 33
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
int fd ; 8
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY , 0666 ); 33
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
closesocket ( fd ); 85
close ( fd ); 87
return ( fp ) ; 94
0
------------------------------
344 /home/SySeVR/data/CVE_2004_1151_PATCHED_sys32_ni_syscall.c strncpy 9
int CVE_2004_1151_PATCHED_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ sizeof ( me -> comm ) ] ; 4
if ( strncmp ( lastcomm , me -> comm , sizeof ( lastcomm ) ) )  6
strncpy ( lastcomm , me -> comm , sizeof ( lastcomm ) ); 9
0
------------------------------
345 /home/SySeVR/data/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c strncpy 89
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
if ( ! info && ctrl )  64
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , skb -> data [ CAPI_MSG_BASELEN + 14 ] ); 65
if ( ! info && ctrl )  75
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 76
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 77
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 78
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 79
if ( ! info && ctrl )  87
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 88
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , skb -> data [ CAPI_MSG_BASELEN + 16 ] ); 89
0
------------------------------
346 /home/SySeVR/data/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c strncpy 65
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
if ( ! info && ctrl )  64
strncpy ( ctrl -> manu , skb -> data + CAPI_MSG_BASELEN + 15 , skb -> data [ CAPI_MSG_BASELEN + 14 ] ); 65
if ( ! info && ctrl )  75
ctrl -> version . majorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 16 ); 76
ctrl -> version . minorversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 20 ); 77
ctrl -> version . majormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 24 ); 78
ctrl -> version . minormanuversion = CAPIMSG_U32 ( skb -> data , CAPI_MSG_BASELEN + 28 ); 79
if ( ! info && ctrl )  87
memset ( ctrl -> serial , 0 , CAPI_SERIAL_LEN ); 88
strncpy ( ctrl -> serial , skb -> data + CAPI_MSG_BASELEN + 17 , skb -> data [ CAPI_MSG_BASELEN + 16 ] ); 89
0
------------------------------
347 /home/SySeVR/data/CVE_2009_1439_PATCHED_CIFSTCon.c strncpy 151
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
bcc_ptr += length + 1; 121
if ( smb_buffer -> Flags2 & SMBFLG2_UNICODE )  123
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
348 /home/SySeVR/data/CVE_2009_1439_PATCHED_CIFSTCon.c strncpy 122
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
tcon -> tidStatus = CifsGood; 103
tcon -> need_reconnect = false; 104
tcon -> tid = smb_buffer_response -> Tid; 105
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
tcon -> ipc = 1; 113
strncpy ( tcon -> treeName , tree , MAX_TREE_SIZE ); 122
kfree ( tcon -> nativeFileSystem ); 128
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
0
------------------------------
349 /home/SySeVR/data/CVE_2009_1439_VULN_CIFSTCon.c strncpy 151
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
bcc_ptr += length + 1; 121
if ( smb_buffer -> Flags2 & SMBFLG2_UNICODE )  123
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
350 /home/SySeVR/data/CVE_2009_1439_VULN_CIFSTCon.c strncpy 122
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
struct smb_hdr * smb_buffer_response ; 7
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer_response = smb_buffer; 22
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  68
smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; 70
if ( ses -> capabilities & CAP_STATUS32 )  72
smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; 73
if ( ses -> capabilities & CAP_DFS )  75
smb_buffer -> Flags2 |= SMBFLG2_DFS; 76
if ( ses -> capabilities & CAP_UNICODE )  78
smb_buffer -> Flags2 |= SMBFLG2_UNICODE; 79
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); 97
if ( ( rc == 0 ) && ( tcon != NULL ) )  102
tcon -> tidStatus = CifsGood; 103
tcon -> need_reconnect = false; 104
tcon -> tid = smb_buffer_response -> Tid; 105
bcc_ptr = pByteArea ( smb_buffer_response ); 106
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
tcon -> ipc = 1; 113
strncpy ( tcon -> treeName , tree , MAX_TREE_SIZE ); 122
kfree ( tcon -> nativeFileSystem ); 128
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
0
------------------------------
351 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c strncpy 111
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
char * p ; 4
int cipher_key_bytes ; 9
int fn_cipher_key_bytes ; 11
struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; 13
substring_t args [ MAX_OPT_ARGS ] ; 15
int token ; 16
char * sig_src ; 17
char * fn_cipher_name_dst ; 20
char * fn_cipher_name_src ; 21
char * cipher_key_bytes_src ; 24
char * fn_cipher_key_bytes_src ; 25
if ( ! options )  29
while ( ( p = strsep ( & options , "," ) ) != NULL )  34
if ( ! * p )  35
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
fn_cipher_name_src = args [ 0 ] . from; 108
fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name; 109
strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ); 111
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
0
------------------------------
352 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c strncpy 89
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
char * p ; 4
int cipher_key_bytes ; 9
int fn_cipher_key_bytes ; 11
struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; 13
substring_t args [ MAX_OPT_ARGS ] ; 15
int token ; 16
char * sig_src ; 17
char * fnek_dst ; 22
char * fnek_src ; 23
char * cipher_key_bytes_src ; 24
char * fn_cipher_key_bytes_src ; 25
if ( ! options )  29
while ( ( p = strsep ( & options , "," ) ) != NULL )  34
if ( ! * p )  35
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
fnek_src = args [ 0 ] . from; 86
fnek_dst = mount_crypt_stat -> global_default_fnek_sig; 87
strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ); 89
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
0
------------------------------
353 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c strncpy 57
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
char * p ; 4
int cipher_key_bytes ; 9
int fn_cipher_key_bytes ; 11
struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; 13
substring_t args [ MAX_OPT_ARGS ] ; 15
int token ; 16
char * sig_src ; 17
char * cipher_name_dst ; 18
char * cipher_name_src ; 19
char * cipher_key_bytes_src ; 24
char * fn_cipher_key_bytes_src ; 25
if ( ! options )  29
while ( ( p = strsep ( & options , "," ) ) != NULL )  34
if ( ! * p )  35
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
cipher_name_src = args [ 0 ] . from; 53
cipher_name_dst = mount_crypt_stat -> global_default_cipher_name; 54
strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ); 57
cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 59
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
0
------------------------------
354 /home/SySeVR/data/CVE_2012_6538_PATCHED_copy_to_user_auth.c strncpy 12
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
0
------------------------------
355 /home/SySeVR/data/CVE_2013_2547_PATCHED_crypto_report_one.c strncpy 20
static int CVE_2013_2547_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) )  15
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL )  17
struct crypto_report_larval rl ; 18
strncpy ( rl . type , "larval" , sizeof ( rl . type ) ); 20
if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) )  21
0
------------------------------
356 /home/SySeVR/data/CVE_2013_2547_PATCHED_crypto_report_one.c strncpy 7
static int CVE_2013_2547_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ); 7
ualg -> cru_type = 0; 10
ualg -> cru_mask = 0; 11
ualg -> cru_flags = alg -> cra_flags; 12
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 13
0
------------------------------
357 /home/SySeVR/data/CVE_2013_2547_PATCHED_crypto_report_one.c strncpy 5
static int CVE_2013_2547_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ); 7
ualg -> cru_type = 0; 10
ualg -> cru_mask = 0; 11
ualg -> cru_flags = alg -> cra_flags; 12
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 13
0
------------------------------
358 /home/SySeVR/data/CVE_2013_2547_PATCHED_crypto_report_one.c strncpy 4
static int CVE_2013_2547_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ); 7
ualg -> cru_type = 0; 10
ualg -> cru_mask = 0; 11
ualg -> cru_flags = alg -> cra_flags; 12
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 13
0
------------------------------
359 /home/SySeVR/data/CVE_2013_2548_PATCHED_crypto_report_one.c strncpy 20
static int CVE_2013_2548_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) )  15
if ( alg -> cra_flags & CRYPTO_ALG_LARVAL )  17
struct crypto_report_larval rl ; 18
strncpy ( rl . type , "larval" , sizeof ( rl . type ) ); 20
if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) )  21
0
------------------------------
360 /home/SySeVR/data/CVE_2013_2548_PATCHED_crypto_report_one.c strncpy 7
static int CVE_2013_2548_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ); 7
ualg -> cru_type = 0; 10
ualg -> cru_mask = 0; 11
ualg -> cru_flags = alg -> cra_flags; 12
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 13
0
------------------------------
361 /home/SySeVR/data/CVE_2013_2548_PATCHED_crypto_report_one.c strncpy 5
static int CVE_2013_2548_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ); 7
ualg -> cru_type = 0; 10
ualg -> cru_mask = 0; 11
ualg -> cru_flags = alg -> cra_flags; 12
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 13
0
------------------------------
362 /home/SySeVR/data/CVE_2013_2548_PATCHED_crypto_report_one.c strncpy 4
static int CVE_2013_2548_PATCHED_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ); 7
ualg -> cru_type = 0; 10
ualg -> cru_mask = 0; 11
ualg -> cru_flags = alg -> cra_flags; 12
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 13
0
------------------------------
363 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_add_notunderstood_response.c strncpy 23
static int CVE_2013_2850_VULN_iscsi_add_notunderstood_response(
char *key,
char *value,
struct iscsi_param_list *param_list) 4
struct iscsi_extra_response * extra_response ; 6
if ( strlen ( value ) > VALUE_MAXLEN )  8
extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ); 14
if ( ! extra_response )  15
strncpy ( extra_response -> key , key , strlen ( key ) + 1 ); 22
strncpy ( extra_response -> value , NOTUNDERSTOOD , strlen ( NOTUNDERSTOOD ) + 1 ); 23
list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ); 26
0
------------------------------
364 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_add_notunderstood_response.c strncpy 22
static int CVE_2013_2850_VULN_iscsi_add_notunderstood_response(
char *key,
char *value,
struct iscsi_param_list *param_list) 4
struct iscsi_extra_response * extra_response ; 6
if ( strlen ( value ) > VALUE_MAXLEN )  8
extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ); 14
if ( ! extra_response )  15
strncpy ( extra_response -> key , key , strlen ( key ) + 1 ); 22
strncpy ( extra_response -> value , NOTUNDERSTOOD , strlen ( NOTUNDERSTOOD ) + 1 ); 23
list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ); 26
0
------------------------------
365 /home/SySeVR/data/CVE_2013_4247_PATCHED_build_unc_path_to_root.c strncpy 18
static char *
CVE_2013_4247_PATCHED_build_unc_path_to_root(const struct smb_vol *vol,
const struct cifs_sb_info *cifs_sb) 3
char * full_path , * pos ; 5
unsigned int pplen = vol -> prepath ? strlen ( vol -> prepath ) + 1 : 0 ; 6
unsigned int unc_len = strnlen ( vol -> UNC , MAX_TREE_SIZE + 1 ) ; 7
full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ); 9
if ( full_path == NULL )  10
strncpy ( full_path , vol -> UNC , unc_len ); 13
pos = full_path + unc_len; 14
if ( pplen )  16
* pos = CIFS_DIR_SEP ( cifs_sb ); 17
strncpy ( pos + 1 , vol -> prepath , pplen ); 18
pos += pplen; 19
* pos = '\0'; 22
0
------------------------------
366 /home/SySeVR/data/CVE_2013_4247_PATCHED_build_unc_path_to_root.c strncpy 13
static char *
CVE_2013_4247_PATCHED_build_unc_path_to_root(const struct smb_vol *vol,
const struct cifs_sb_info *cifs_sb) 3
char * full_path , * pos ; 5
unsigned int pplen = vol -> prepath ? strlen ( vol -> prepath ) + 1 : 0 ; 6
unsigned int unc_len = strnlen ( vol -> UNC , MAX_TREE_SIZE + 1 ) ; 7
full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ); 9
if ( full_path == NULL )  10
strncpy ( full_path , vol -> UNC , unc_len ); 13
pos = full_path + unc_len; 14
* pos = CIFS_DIR_SEP ( cifs_sb ); 17
strncpy ( pos + 1 , vol -> prepath , pplen ); 18
pos += pplen; 19
* pos = '\0'; 22
convert_delimiter ( full_path , CIFS_DIR_SEP ( cifs_sb ) ); 23
cFYI ( 1 , "%s: full_path=%s" , __func__ , full_path ); 24
return full_path ; 25
0
------------------------------
367 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcmp 101
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
0
------------------------------
368 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcmp 101
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
0
------------------------------
369 /home/SySeVR/data/CVE_2009_2844_PATCHED_cmp_ies.c memcmp 12
static int CVE_2009_2844_PATCHED_cmp_ies(u8 num, u8 *ies1, size_t len1, u8 *ies2, size_t len2) 1
const u8 * ie1 = find_ie ( num , ies1 , len1 ) ; 3
const u8 * ie2 = find_ie ( num , ies2 , len2 ) ; 4
int r ; 5
if ( ! ie1 && ! ie2 )  7
if ( ! ie1 || ! ie2 )  9
r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ); 12
if ( r == 0 && ie1 [ 1 ] != ie2 [ 1 ] )  13
return r ; 15
0
------------------------------
370 /home/SySeVR/data/CVE_2009_2844_VULN_cmp_ies.c memcmp 12
static int CVE_2009_2844_VULN_cmp_ies(u8 num, u8 *ies1, size_t len1, u8 *ies2, size_t len2) 1
const u8 * ie1 = find_ie ( num , ies1 , len1 ) ; 3
const u8 * ie2 = find_ie ( num , ies2 , len2 ) ; 4
int r ; 5
if ( ! ie1 && ! ie2 )  7
if ( ! ie1 )  9
r = memcmp ( ie1 + 2 , ie2 + 2 , min ( ie1 [ 1 ] , ie2 [ 1 ] ) ); 12
if ( r == 0 && ie1 [ 1 ] != ie2 [ 1 ] )  13
return r ; 15
0
------------------------------
371 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c memcmp 145
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
char * elf_interpreter = NULL ; 6
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
int retval , i ; 10
unsigned int size ; 11
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
if ( elf_interpreter )  142
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
0
------------------------------
372 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c memcmp 34
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
0
------------------------------
373 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c memcmp 55
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
unsigned long derrno ; 5
int ret ; 6
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
end = data + datalen; 19
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
const char * next_opt ; 26
opt ++; 29
const char * eq ; 32
int opt_len , opt_nlen , opt_vlen , tmp ; 33
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
if ( derrno < 1 || derrno > 511 )  65
while ( opt = next_opt + 1 , opt < end )  79
0
------------------------------
374 /home/SySeVR/data/CVE_2011_4594_PATCHED___sys_sendmsg.c memcmp 90
static int CVE_2011_4594_PATCHED___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
struct msghdr *msg_sys, unsigned flags,
struct used_address *used_address) 3
struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; 5
struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; 8
unsigned char * ctl_buf = ctl ; 12
int err , ctl_len , iov_size , total_len ; 13
err = - EFAULT; 15
if ( MSG_CMSG_COMPAT & flags )  16
if ( get_compat_msghdr ( msg_sys , msg_compat ) )  17
if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) )  19
err = - EMSGSIZE; 23
if ( msg_sys -> msg_iovlen > UIO_MAXIOV )  24
iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ); 29
if ( msg_sys -> msg_iovlen > UIO_FASTIOV )  30
iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ); 31
if ( ! iov )  32
if ( MSG_CMSG_COMPAT & flags )  37
err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 38
err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 42
if ( err < 0 )  45
err = - ENOBUFS; 49
if ( msg_sys -> msg_controllen > INT_MAX )  51
ctl_len = msg_sys -> msg_controllen; 53
if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len )  54
err = cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , sizeof ( ctl ) ); 55
if ( err )  58
if ( ctl_len )  62
if ( ctl_len > sizeof ( ctl ) )  63
ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ); 64
if ( ctl_buf == NULL )  65
if ( copy_from_user ( ctl_buf , ( void __user __force * ) msg_sys -> msg_control , ctl_len ) )  74
msg_sys -> msg_control = ctl_buf; 78
msg_sys -> msg_flags = flags; 80
if ( sock -> file -> f_flags & O_NONBLOCK )  82
msg_sys -> msg_flags |= MSG_DONTWAIT; 83
if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) )  90
0
------------------------------
375 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c memcmp 25
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
0
------------------------------
376 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c memcmp 19
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
0
------------------------------
377 /home/SySeVR/data/CVE_2013_4933_PATCHED_netmon_open.c memcmp 28
int CVE_2013_4933_PATCHED_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
0
------------------------------
378 /home/SySeVR/data/CVE_2013_4933_PATCHED_netmon_open.c memcmp 28
int CVE_2013_4933_PATCHED_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
0
------------------------------
379 /home/SySeVR/data/CVE_2013_4933_VULN_netmon_open.c memcmp 28
int CVE_2013_4933_VULN_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
0
------------------------------
380 /home/SySeVR/data/CVE_2013_4933_VULN_netmon_open.c memcmp 28
int CVE_2013_4933_VULN_netmon_open(wtap *wth, int *err, gchar **err_info) 1
int bytes_read ; 3
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
0
------------------------------
381 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memcmp 95
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
0
------------------------------
382 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memcmp 95
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
0
------------------------------
383 /home/SySeVR/data/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c memcmp 64
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = scatterwalk_map ( & src_sg_walk ); 39
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
0
------------------------------
384 /home/SySeVR/data/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c memcmp 64
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = scatterwalk_map ( & src_sg_walk ); 39
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
0
------------------------------
385 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c memcmp 292
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
0
------------------------------
386 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c memcmp 290
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
0
------------------------------
387 /home/SySeVR/data/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c copy 47
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
const uint8_t * srcPtr = src [ 0 ] ; 4
uint8_t * dstY = dst [ 0 ] ; 5
uint8_t * dstU = dst [ 1 ] ; 6
uint8_t * dstV = dst [ 2 ] ; 7
int i ; 8
switch ( c -> srcFormat )  12
srcPtr += 2 * srcStride [ 0 ]; 34
dstY += 2 * dstStride [ 0 ]; 35
dstU += dstStride [ 1 ]; 36
dstV += dstStride [ 1 ]; 37
for (i = 2; i < srcSliceH - 2; i += 2) 39
srcPtr += 2 * srcStride [ 0 ]; 41
dstY += 2 * dstStride [ 0 ]; 42
dstU += dstStride [ 1 ]; 43
dstV += dstStride [ 1 ]; 44
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
0
------------------------------
388 /home/SySeVR/data/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c copy 33
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
const uint8_t * srcPtr = src [ 0 ] ; 4
uint8_t * dstY = dst [ 0 ] ; 5
uint8_t * dstU = dst [ 1 ] ; 6
uint8_t * dstV = dst [ 2 ] ; 7
switch ( c -> srcFormat )  12
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
0
------------------------------
389 /home/SySeVR/data/CVE_2013_0799_VULN_GetInstallationDir.c wcscpy 7
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
if ( argcTmp < 2 )  4
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
0
------------------------------
390 /home/SySeVR/data/CVE_2007_1217_PATCHED_bufprint.c vsnprintf 32
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
size_t ns = 2 * cdb -> size ; 14
u_char * nb ; 15
while ( ( ns - cdb -> pos ) <= n )  17
ns *= 2; 18
nb = kmalloc ( ns , GFP_ATOMIC ); 19
if ( ! nb )  20
memcpy ( nb , cdb -> buf , cdb -> pos ); 24
nb [ cdb -> pos ] = 0; 26
cdb -> buf = nb; 27
cdb -> p = cdb -> buf + cdb -> pos; 28
cdb -> size = ns; 29
r = cdb -> size - cdb -> pos; 31
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
0
------------------------------
391 /home/SySeVR/data/CVE_2007_1217_PATCHED_bufprint.c vsnprintf 10
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
while ( ( ns - cdb -> pos ) <= n )  17
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
0
------------------------------
392 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcpy 110
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
0
------------------------------
393 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c memcpy 109
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
0
------------------------------
394 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c memcpy 114
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
if ( best_bytestream != original_bytestream )  113
memcpy ( original_bytestream , best_bytestream , best_bytestream_size ); 114
0
------------------------------
395 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c memcpy 74
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
av_frame_free ( & diffFrame ); 120
return ret ; 121
0
------------------------------
396 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c memcpy 61
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
memcpy ( diffFrame -> data [ 0 ] , s -> last_frame -> data [ 0 ] , s -> last_frame -> linesize [ 0 ] * s -> last_frame -> height ); 61
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
0
------------------------------
397 /home/SySeVR/data/CVE-2016-4002_VULN_mipsnet_receive.c memcpy 14
static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size) 1
MIPSnetState * s = qemu_get_nic_opaque ( nc ) ; 3
if ( ! mipsnet_can_receive ( nc ) )  6
s -> busy = 1; 9
memcpy ( s -> rx_buffer , buf , size ); 14
s -> rx_count = size; 16
s -> rx_read = 0; 17
s -> intctl |= MIPSNET_INTCTL_RXDONE; 20
mipsnet_update_irq ( s ); 21
0
------------------------------
398 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memcpy 170
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; 5
struct brcmf_if * ifp = netdev_priv ( ndev ) ; 6
const struct brcmf_tlv * ssid_ie ; 7
const struct brcmf_tlv * country_ie ; 8
struct brcmf_ssid_le ssid_le ; 9
const struct brcmf_tlv * rsn_ie ; 11
const struct brcmf_vs_tlv * wpa_ie ; 12
struct brcmf_join_params join_params ; 13
enum nl80211_iftype dev_role ; 14
u16 chanspec ; 16
bool mbss ; 17
int is_11d ; 18
dev_role = ifp -> vif -> wdev . iftype; 27
mbss = ifp -> vif -> mbss; 28
country_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_COUNTRY ); 32
is_11d = country_ie ? 1 : 0; 35
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
memcpy ( ssid_le . SSID , settings -> ssid , settings -> ssid_len ); 51
ssid_le . SSID_len = cpu_to_le32 ( ( u32 ) settings -> ssid_len ); 52
rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); 61
wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); 65
if ( wpa_ie != NULL || rsn_ie != NULL )  68
if ( wpa_ie != NULL )  70
err = brcmf_configure_wpaie ( ifp , wpa_ie , false ); 72
if ( err < 0 )  73
struct brcmf_vs_tlv * tmp_ie ; 76
tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; 78
err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); 81
if ( err < 0 )  82
if ( ! mbss )  92
chanspec = chandef_to_chanspec ( & cfg -> d11inf , & settings -> chandef ); 93
err = brcmf_fil_iovar_int_set ( ifp , "chanspec" , chanspec ); 95
if ( err < 0 )  96
if ( is_11d != ifp -> vif -> is_11d )  102
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_REGULATORY , is_11d ); 103
if ( err < 0 )  105
if ( settings -> beacon_interval )  110
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_BCNPRD , settings -> beacon_interval ); 111
if ( err < 0 )  113
if ( settings -> dtim_period )  119
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_DTIMPRD , settings -> dtim_period ); 120
if ( err < 0 )  122
if ( ( dev_role == NL80211_IFTYPE_AP ) && ( ( ifp -> ifidx == 0 ) || ! brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_RSDB ) ) )  128
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_DOWN , 1 ); 131
if ( err < 0 )  132
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_INFRA , 1 ); 139
if ( err < 0 )  140
if ( WARN_ON ( is_11d != ifp -> vif -> is_11d ) )  144
if ( dev_role == NL80211_IFTYPE_AP )  149
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_SET_AP , 1 ); 153
if ( err < 0 )  154
err = brcmf_fil_cmd_int_set ( ifp , BRCMF_C_UP , 1 ); 158
if ( err < 0 )  159
memset ( & join_params , 0 , sizeof ( join_params ) ); 168
memcpy ( & join_params . ssid_le , & ssid_le , sizeof ( ssid_le ) ); 170
err = brcmf_fil_cmd_data_set ( ifp , BRCMF_C_SET_SSID , & join_params , sizeof ( join_params ) ); 172
if ( err < 0 )  174
brcmf_err ( "SET SSID error (%d)\n" , err ); 175
if ( ( err ) && ( ! mbss ) )  201
return err ; 205
0
------------------------------
399 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memcpy 51
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
struct brcmf_ssid_le ssid_le ; 9
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
memcpy ( ssid_le . SSID , settings -> ssid , settings -> ssid_len ); 51
ssid_le . SSID_len = cpu_to_le32 ( ( u32 ) settings -> ssid_len ); 52
memcpy ( & join_params . ssid_le , & ssid_le , sizeof ( ssid_le ) ); 170
err = brcmf_fil_cmd_data_set ( ifp , BRCMF_C_SET_SSID , & join_params , sizeof ( join_params ) ); 172
if ( err < 0 )  174
brcmf_err ( "SET SSID error (%d)\n" , err ); 175
err = brcmf_fil_bsscfg_data_set ( ifp , "ssid" , & ssid_le , sizeof ( ssid_le ) ); 180
if ( err < 0 )  182
brcmf_err ( "setting ssid failed %d\n" , err ); 183
if ( ( err ) && ( ! mbss ) )  201
return err ; 205
0
------------------------------
400 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c memcpy 47
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
const struct brcmf_tlv * ssid_ie ; 7
struct brcmf_ssid_le ssid_le ; 9
memset ( & ssid_le , 0 , sizeof ( ssid_le ) ); 37
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ); 47
ssid_le . SSID_len = cpu_to_le32 ( ssid_ie -> len ); 48
brcmf_dbg ( TRACE , "SSID is (%s) in Head\n" , ssid_le . SSID ); 49
0
------------------------------
401 /home/SySeVR/data/CVE_2006_2935_VULN_dvd_read_bca.c memcpy 21
static int CVE_2006_2935_VULN_dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s) 1
int ret ; 3
u_char buf [ 4 + 188 ] ; 4
struct packet_command cgc ; 5
struct cdrom_device_ops * cdo = cdi -> ops ; 6
cgc . cmd [ 0 ] = GPCMD_READ_DVD_STRUCTURE; 9
cgc . cmd [ 7 ] = s -> type; 10
cgc . cmd [ 9 ] = cgc . buflen = 0xff; 11
if ( ret = cdo -> generic_packet ( cdi , & cgc ) )  13
s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ]; 16
if ( s -> bca . len < 12 || s -> bca . len > 188 )  17
memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ); 21
0
------------------------------
402 /home/SySeVR/data/CVE_2006_6106_VULN_cmtp_recv_interopmsg.c memcpy 52
static void CVE_2006_6106_VULN_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb) 1
struct capi_ctr * ctrl = & session -> ctrl ; 3
__u16 appl , msgnum , func , info ; 5
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )  10
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 5 ); 12
info = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 8 ); 13
switch ( func )  15
msgnum = CAPIMSG_MSGID ( skb -> data ); 17
msgnum = CAPIMSG_MSGID ( skb -> data ); 43
if ( ! info && ( msgnum == CMTP_INITIAL_MSGNUM ) )  45
if ( ! info && ctrl )  51
memcpy ( & ctrl -> profile , skb -> data + CAPI_MSG_BASELEN + 11 , sizeof ( capi_profile ) ); 52
capi_ctr_ready ( ctrl ); 56
0
------------------------------
403 /home/SySeVR/data/CVE_2007_1217_PATCHED_bufprint.c memcpy 24
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
size_t ns = 2 * cdb -> size ; 14
u_char * nb ; 15
while ( ( ns - cdb -> pos ) <= n )  17
ns *= 2; 18
nb = kmalloc ( ns , GFP_ATOMIC ); 19
if ( ! nb )  20
memcpy ( nb , cdb -> buf , cdb -> pos ); 24
nb [ cdb -> pos ] = 0; 26
cdb -> buf = nb; 27
cdb -> p = cdb -> buf + cdb -> pos; 28
cdb -> size = ns; 29
r = cdb -> size - cdb -> pos; 31
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
0
------------------------------
404 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 155
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
if ( rowSize % 4 )  147
rowSize += ( 4 - ( rowSize % 4 ) ); 148
PRUint32 toCopy ; 149
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
if ( ! mDecoded )  161
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 162
if ( ! mDecoded )  163
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
if ( mCurLine == 0 )  225
mRowBytes = 0; 228
while ( aCount > 0 )  231
0
------------------------------
405 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 128
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
0
------------------------------
406 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 30
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
0
------------------------------
407 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c memcpy 12
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
0
------------------------------
408 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c memcpy 26
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
ast_mutex_init ( & s -> __lock ); 30
ast_mutex_lock ( & s -> __lock ); 31
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
AST_LIST_INSERT_HEAD ( & sessions , s , list ); 35
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
ast_atomic_fetchadd_int ( & s -> eventq -> usecount , 1 ); 41
time ( & s -> sessiontimeout ); 46
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
ast_mutex_unlock ( & s -> __lock ); 51
if ( s )  53
if ( process_message ( s , & m ) )  66
if ( s -> authenticated )  67
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ) 70
ast_log ( LOG_EVENT , "HTTP Manager '%s' logged off from %s\n" , s -> username , ast_inet_ntoa ( s -> sin . sin_addr ) ); 72
ast_verbose ( VERBOSE_PREFIX_2 "HTTP Connect attempt from '%s' unable to authenticate\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ) 76
ast_log ( LOG_EVENT , "HTTP Failed attempt from %s\n" , ast_inet_ntoa ( s -> sin . sin_addr ) ); 78
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
ast_mutex_lock ( & s -> __lock ); 93
if ( s -> outputstr )  94
tmp = xml_translate ( s -> outputstr -> str , params ); 97
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
free ( s -> outputstr ); 113
s -> outputstr = NULL; 114
ast_mutex_unlock ( & s -> __lock ); 116
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
ast_mutex_lock ( & s -> __lock ); 127
if ( s -> needdestroy )  128
if ( s -> inuse == 1 )  129
if ( s -> waiting_thread != AST_PTHREADT_NULL )  134
pthread_kill ( s -> waiting_thread , SIGURG ); 135
s -> inuse --; 136
s -> inuse --; 139
ast_mutex_unlock ( & s -> __lock ); 140
destroy_session ( s ); 143
return retval ; 147
0
------------------------------
409 /home/SySeVR/data/CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old.c memcpy 77
static int CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
int addrlen ; 12
void * addrs ; 14
void * buf ; 15
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 || getaddrs . addr_num >= ( INT_MAX / sizeof ( union sctp_addr ) ) )  25
if ( 0 == getaddrs . assoc_id )  34
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 35
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 37
if ( ! asoc )  38
bp = & asoc -> base . bind_addr; 40
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 49
if ( ! addrs )  51
if ( sctp_list_single_entry ( & bp -> address_list ) )  57
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 59
if ( sctp_is_any ( & addr -> a ) )  60
buf = addrs; 68
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 74
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 76
memcpy ( buf , & temp , addrlen ); 77
buf += addrlen; 78
0
------------------------------
410 /home/SySeVR/data/CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old.c memcpy 74
static int CVE_2008_2826_PATCHED_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
void * addrs ; 14
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 || getaddrs . addr_num >= ( INT_MAX / sizeof ( union sctp_addr ) ) )  25
if ( 0 == getaddrs . assoc_id )  34
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 35
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 37
if ( ! asoc )  38
bp = & asoc -> base . bind_addr; 40
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 49
if ( ! addrs )  51
if ( sctp_list_single_entry ( & bp -> address_list ) )  57
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 59
if ( sctp_is_any ( & addr -> a ) )  60
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 74
sctp_get_pf_specific ( sk -> sk_family ) -> addr_v4map ( sp , & temp ); 75
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 76
memcpy ( buf , & temp , addrlen ); 77
buf += addrlen; 78
bytes_copied += addrlen; 79
if ( copy_to_user ( to , addrs , bytes_copied ) )  86
0
------------------------------
411 /home/SySeVR/data/CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old.c memcpy 75
static int CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
int addrlen ; 12
void * addrs ; 14
void * buf ; 15
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 )  25
if ( 0 == getaddrs . assoc_id )  32
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 33
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 35
if ( ! asoc )  36
bp = & asoc -> base . bind_addr; 38
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 47
if ( ! addrs )  49
if ( sctp_list_single_entry ( & bp -> address_list ) )  55
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 57
if ( sctp_is_any ( & addr -> a ) )  58
buf = addrs; 66
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 72
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 74
memcpy ( buf , & temp , addrlen ); 75
buf += addrlen; 76
0
------------------------------
412 /home/SySeVR/data/CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old.c memcpy 72
static int CVE_2008_2826_VULN_sctp_getsockopt_local_addrs_old(struct sock *sk, int len,
char __user *optval, int __user *optlen) 2
struct sctp_bind_addr * bp ; 4
struct sctp_association * asoc ; 5
struct sctp_getaddrs_old getaddrs ; 7
struct sctp_sockaddr_entry * addr ; 8
union sctp_addr temp ; 10
void * addrs ; 14
if ( len < sizeof ( struct sctp_getaddrs_old ) )  18
len = sizeof ( struct sctp_getaddrs_old ); 21
if ( copy_from_user ( & getaddrs , optval , len ) )  22
if ( getaddrs . addr_num <= 0 )  25
if ( 0 == getaddrs . assoc_id )  32
bp = & sctp_sk ( sk ) -> ep -> base . bind_addr; 33
asoc = sctp_id2assoc ( sk , getaddrs . assoc_id ); 35
if ( ! asoc )  36
bp = & asoc -> base . bind_addr; 38
addrs = kmalloc ( sizeof ( union sctp_addr ) * getaddrs . addr_num , GFP_KERNEL ); 47
if ( ! addrs )  49
if ( sctp_list_single_entry ( & bp -> address_list ) )  55
addr = list_entry ( bp -> address_list . next ,
struct sctp_sockaddr_entry , list ) 57
if ( sctp_is_any ( & addr -> a ) )  58
memcpy ( & temp , & addr -> a , sizeof ( temp ) ); 72
sctp_get_pf_specific ( sk -> sk_family ) -> addr_v4map ( sp , & temp ); 73
addrlen = sctp_get_af_specific ( temp . sa . sa_family ) -> sockaddr_len; 74
memcpy ( buf , & temp , addrlen ); 75
buf += addrlen; 76
bytes_copied += addrlen; 77
if ( copy_to_user ( to , addrs , bytes_copied ) )  84
0
------------------------------
413 /home/SySeVR/data/CVE_2008_3527_PATCHED_sysenter_setup.c memcpy 18
int __init CVE_2008_3527_PATCHED_sysenter_setup(void) 1
void * syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; 3
if ( ! boot_cpu_has ( X86_FEATURE_SEP ) )  11
memcpy ( syscall_page , & vsyscall_sysenter_start , & vsyscall_sysenter_end - & vsyscall_sysenter_start ); 18
0
------------------------------
414 /home/SySeVR/data/CVE_2008_3527_PATCHED_sysenter_setup.c memcpy 12
int __init CVE_2008_3527_PATCHED_sysenter_setup(void) 1
void * syscall_page = ( void * ) get_zeroed_page ( GFP_ATOMIC ) ; 3
if ( ! boot_cpu_has ( X86_FEATURE_SEP ) )  11
memcpy ( syscall_page , & vsyscall_int80_start , & vsyscall_int80_end - & vsyscall_int80_start ); 12
0
------------------------------
415 /home/SySeVR/data/CVE_2008_4302_PATCHED_pipe_to_file.c memcpy 69
static int CVE_2008_4302_PATCHED_pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
struct splice_desc *sd) 2
struct file * file = sd -> file ; 4
struct address_space * mapping = file -> f_mapping ; 5
unsigned int offset , this_len ; 6
struct page * page ; 7
pgoff_t index ; 8
int ret ; 9
ret = buf -> ops -> pin ( pipe , buf ); 14
if ( unlikely ( ret ) )  15
index = sd -> pos >> PAGE_CACHE_SHIFT; 18
offset = sd -> pos & ~PAGE_CACHE_MASK; 19
this_len = sd -> len; 21
if ( this_len + offset > PAGE_CACHE_SIZE )  22
this_len = PAGE_CACHE_SIZE - offset; 23
page = find_lock_page ( mapping , index ); 26
if ( ! page )  27
page = page_cache_alloc_cold ( mapping ); 29
if ( unlikely ( ! page ) )  30
ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ); 36
if ( unlikely ( ret ) )  38
ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ); 42
if ( unlikely ( ret ) )  43
if ( ret == AOP_TRUNCATED_PAGE )  49
if ( buf -> page != page )  62
char * src = buf -> ops -> map ( pipe , buf , 1 ) ; 66
char * dst = kmap_atomic ( page , KM_USER1 ) ; 67
memcpy ( dst + offset , src + buf -> offset , this_len ); 69
kunmap_atomic ( dst , KM_USER1 ); 71
ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ); 75
if ( ret )  76
if ( ret == AOP_TRUNCATED_PAGE )  77
0
------------------------------
416 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 198
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
memcpy ( bss -> rsn_ie , elem , bss -> rsn_ie_len ); 198
lbs_deb_hex ( LBS_DEB_SCAN , "process_bss: RSN_IE" , bss -> rsn_ie , elem -> len ); 199
pos += elem -> len + 2; 209
bss -> last_scanned = jiffies; 213
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
0
------------------------------
417 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 179
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
pos += elem -> len + 2; 209
0
------------------------------
418 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 171
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
got_basic_rates = 1; 104
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( ! got_basic_rates )  161
n_ex_rates = elem -> len; 166
if ( n_basic_rates + n_ex_rates > MAX_RATES )  167
n_ex_rates = MAX_RATES - n_basic_rates; 168
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
419 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 149
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
pos += elem -> len + 2; 209
0
------------------------------
420 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 125
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
421 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 118
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
422 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 103
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
423 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 95
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
memcpy ( bss -> ssid , elem -> data , bss -> ssid_len ); 95
lbs_deb_scan ( "got SSID IE: '%s', len %u\n" , escape_essid ( bss -> ssid , bss -> ssid_len ) , bss -> ssid_len ); 96
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
pos += elem -> len + 2; 209
0
------------------------------
424 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memcpy 39
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
lbs_deb_scan ( "process_bss: BSSID %s\n" , print_mac ( mac , bss -> bssid ) ); 40
bss -> rssi = * pos; 55
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
bss -> capability = get_unaligned_le16 ( pos ); 67
lbs_deb_scan ( "process_bss: capabilities 0x%04x\n" , bss -> capability ); 68
if ( bss -> capability & WLAN_CAPABILITY_PRIVACY )  71
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
0
------------------------------
425 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 198
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
memcpy ( bss -> rsn_ie , elem , bss -> rsn_ie_len ); 198
lbs_deb_hex ( LBS_DEB_SCAN , "process_bss: RSN_IE" , bss -> rsn_ie , elem -> len ); 199
pos += elem -> len + 2; 209
bss -> last_scanned = jiffies; 213
lbs_unset_basic_rate_flags ( bss -> rates , sizeof ( bss -> rates ) ); 214
0
------------------------------
426 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 179
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
memcpy ( bss -> wpa_ie , elem , bss -> wpa_ie_len ); 179
lbs_deb_hex ( LBS_DEB_SCAN , "WPA IE" , bss -> wpa_ie , elem -> len ); 181
pos += elem -> len + 2; 209
0
------------------------------
427 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 171
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
got_basic_rates = 1; 104
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( ! got_basic_rates )  161
n_ex_rates = elem -> len; 166
if ( n_basic_rates + n_ex_rates > MAX_RATES )  167
n_ex_rates = MAX_RATES - n_basic_rates; 168
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
428 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 149
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
429 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 125
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
430 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 118
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
431 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 103
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
432 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 95
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
lbs_deb_scan ( "got SSID IE: '%s', len %u\n" , escape_essid ( bss -> ssid , bss -> ssid_len ) , bss -> ssid_len ); 96
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
pos += elem -> len + 2; 209
0
------------------------------
433 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memcpy 39
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
lbs_deb_scan ( "process_bss: BSSID %s\n" , print_mac ( mac , bss -> bssid ) ); 40
bss -> rssi = * pos; 55
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
bss -> capability = get_unaligned_le16 ( pos ); 67
lbs_deb_scan ( "process_bss: capabilities 0x%04x\n" , bss -> capability ); 68
if ( bss -> capability & WLAN_CAPABILITY_PRIVACY )  71
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
lbs_deb_scan ( "got DS IE, channel %d\n" , bss -> channel ); 120
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
0
------------------------------
434 /home/SySeVR/data/CVE_2009_1336_PATCHED_nfs_create_server.c memcpy 42
struct nfs_server *CVE_2009_1336_PATCHED_nfs_create_server(const struct nfs_mount_data *data,
struct nfs_fh *mntfh) 2
struct nfs_server * server ; 4
struct nfs_fattr fattr ; 5
int error ; 6
server = nfs_alloc_server ( ); 8
if ( ! server )  9
error = nfs_init_server ( server , data ); 13
if ( error < 0 )  14
error = nfs_probe_fsinfo ( server , mntfh , & fattr ); 22
if ( error < 0 )  23
if ( server -> nfs_client -> rpc_ops -> version == 3 )  25
if ( server -> namelen == 0 || server -> namelen > NFS3_MAXNAMLEN )  26
server -> namelen = NFS3_MAXNAMLEN; 27
if ( ! ( data -> flags & NFS_MOUNT_NORDIRPLUS ) )  28
server -> caps |= NFS_CAP_READDIRPLUS; 29
if ( server -> namelen == 0 || server -> namelen > NFS2_MAXNAMLEN )  31
server -> namelen = NFS2_MAXNAMLEN; 32
if ( ! ( fattr . valid & NFS_ATTR_FATTR ) )  35
error = server -> nfs_client -> rpc_ops -> getattr ( server , mntfh , & fattr ); 36
if ( error < 0 )  37
memcpy ( & server -> fsid , & fattr . fsid , sizeof ( server -> fsid ) ); 42
dprintk ( "Server FSID: %llx:%llx\n" , ( unsigned long long ) server -> fsid . major , ( unsigned long long ) server -> fsid . minor ); 44
BUG_ON ( ! server -> nfs_client ); 48
BUG_ON ( ! server -> nfs_client -> rpc_ops ); 49
BUG_ON ( ! server -> nfs_client -> rpc_ops -> file_inode_ops ); 50
list_add_tail ( & server -> client_link , & server -> nfs_client -> cl_superblocks ); 53
list_add_tail ( & server -> master_link , & nfs_volume_list ); 54
server -> mount_time = jiffies; 57
return server ; 58
nfs_free_server ( server ); 61
0
------------------------------
435 /home/SySeVR/data/CVE_2009_2287_VULN_kvm_arch_vcpu_ioctl_set_sregs.c memcpy 42
int CVE_2009_2287_VULN_kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
struct kvm_sregs *sregs) 2
vcpu -> arch . cr2 = sregs -> cr2; 17
vcpu -> arch . cr3 = sregs -> cr3; 19
vcpu -> arch . cr0 = sregs -> cr0; 31
if ( ! irqchip_in_kernel ( vcpu -> kvm ) )  41
memcpy ( vcpu -> arch . irq_pending , sregs -> interrupt_bitmap , sizeof vcpu -> arch . irq_pending ); 42
vcpu -> arch . irq_summary = 0; 44
for (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i) 45
if ( vcpu -> arch . irq_pending [ i ] )  46
__set_bit ( i , & vcpu -> arch . irq_summary ); 47
kvm_set_segment ( vcpu , & sregs -> cs , VCPU_SREG_CS ); 62
kvm_set_segment ( vcpu , & sregs -> ds , VCPU_SREG_DS ); 63
kvm_set_segment ( vcpu , & sregs -> es , VCPU_SREG_ES ); 64
kvm_set_segment ( vcpu , & sregs -> fs , VCPU_SREG_FS ); 65
kvm_set_segment ( vcpu , & sregs -> gs , VCPU_SREG_GS ); 66
kvm_set_segment ( vcpu , & sregs -> ss , VCPU_SREG_SS ); 67
kvm_set_segment ( vcpu , & sregs -> tr , VCPU_SREG_TR ); 69
kvm_set_segment ( vcpu , & sregs -> ldt , VCPU_SREG_LDTR ); 70
if ( vcpu -> vcpu_id == 0 && kvm_rip_read ( vcpu ) == 0xfff0 && sregs -> cs . selector == 0xf000 && sregs -> cs . base == 0xffff0000 && ! ( vcpu -> arch . cr0 & X86_CR0_PE ) )  73
vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE; 76
vcpu_put ( vcpu ); 78
0
------------------------------
436 /home/SySeVR/data/CVE_2009_3080_PATCHED_gdth_read_event.c memcpy 27
static int CVE_2009_3080_PATCHED_gdth_read_event(gdth_ha_str *ha, int handle, gdth_evt_str *estr) 1
gdth_evt_str * e ; 3
int eindex ; 4
if ( handle == - 1 )  9
eindex = eoldidx; 10
eindex = handle; 12
estr -> event_source = 0; 13
if ( eindex < 0 || eindex >= MAX_EVENTS )  15
e = & ebuffer [ eindex ]; 19
if ( e -> event_source != 0 )  20
memcpy ( estr , e , sizeof ( gdth_evt_str ) ); 27
0
------------------------------
437 /home/SySeVR/data/CVE_2010_0437_VULN_ip6_dst_lookup_tail.c memcpy 49
static int CVE_2010_0437_VULN_ip6_dst_lookup_tail(struct sock *sk,
struct dst_entry **dst, struct flowi *fl) 2
int err ; 4
struct net * net = sock_net ( sk ) ; 5
if ( * dst == NULL )  7
* dst = ip6_route_output ( net , sk , fl ); 8
if ( err = ( * dst ) -> error )  10
if ( ipv6_addr_any ( & fl -> fl6_src ) )  13
err = ipv6_dev_get_saddr ( ip6_dst_idev ( * dst ) -> dev , & fl -> fl6_dst , sk ? inet6_sk ( sk ) -> srcprefs : 0 , & fl -> fl6_src ); 14
if ( err )  18
if ( ! ( ( * dst ) -> neighbour -> nud_state & NUD_VALID ) )  31
struct inet6_ifaddr * ifp ; 32
struct flowi fl_gw ; 33
int redirect ; 34
ifp = ipv6_get_ifaddr ( net , & fl -> fl6_src , ( * dst ) -> dev , 1 ); 36
redirect = ( ifp && ifp -> flags & IFA_F_OPTIMISTIC ); 39
if ( redirect )  43
memcpy ( & fl_gw , fl , sizeof ( struct flowi ) ); 49
memset ( & fl_gw . fl6_dst , 0 , sizeof ( struct in6_addr ) ); 50
* dst = ip6_route_output ( net , sk , & fl_gw ); 51
if ( err = ( * dst ) -> error )  52
if ( err == - ENETUNREACH )  61
dst_release ( * dst ); 63
return err ; 65
0
------------------------------
438 /home/SySeVR/data/CVE_2010_2521_PATCHED_read_buf.c memcpy 38
static __be32 *CVE_2010_2521_PATCHED_read_buf(struct nfsd4_compoundargs *argp, u32 nbytes) 1
unsigned int avail = ( char * ) argp -> end - ( char * ) argp -> p ; 6
__be32 * p ; 7
if ( avail + argp -> pagelen < nbytes )  8
if ( avail + PAGE_SIZE < nbytes )  10
if ( nbytes <= sizeof ( argp -> tmp ) )  13
p = argp -> tmp; 14
p = argp -> tmpp = kmalloc ( nbytes , GFP_KERNEL ); 17
if ( ! p )  18
memcpy ( p , argp -> p , avail ); 27
argp -> p = page_address ( argp -> pagelist [ 0 ] ); 29
argp -> pagelist ++; 30
if ( argp -> pagelen < PAGE_SIZE )  31
argp -> end = argp -> p + ( argp -> pagelen >> 2 ); 32
argp -> pagelen = 0; 33
argp -> end = argp -> p + ( PAGE_SIZE >> 2 ); 35
argp -> pagelen -= PAGE_SIZE; 36
memcpy ( ( ( char * ) p ) + avail , argp -> p , ( nbytes - avail ) ); 38
0
------------------------------
439 /home/SySeVR/data/CVE_2010_2521_PATCHED_read_buf.c memcpy 27
static __be32 *CVE_2010_2521_PATCHED_read_buf(struct nfsd4_compoundargs *argp, u32 nbytes) 1
unsigned int avail = ( char * ) argp -> end - ( char * ) argp -> p ; 6
__be32 * p ; 7
if ( avail + argp -> pagelen < nbytes )  8
if ( avail + PAGE_SIZE < nbytes )  10
if ( nbytes <= sizeof ( argp -> tmp ) )  13
p = argp -> tmp; 14
p = argp -> tmpp = kmalloc ( nbytes , GFP_KERNEL ); 17
if ( ! p )  18
memcpy ( p , argp -> p , avail ); 27
memcpy ( ( ( char * ) p ) + avail , argp -> p , ( nbytes - avail ) ); 38
return p ; 40
0
------------------------------
440 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c memcpy 293
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
compressed_lines --; 134
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ); 293
s -> frame . palette_has_changed = 1; 295
s -> new_palette = 0; 296
* ( AVFrame * ) data = s -> frame; 300
0
------------------------------
441 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c memcpy 265
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
compressed_lines --; 134
pixel_ptr = y_ptr; 135
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_ptr += pixel_skip; 141
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
pixels [ pixel_ptr ++ ] = palette_idx1; 150
pixels [ pixel_ptr ++ ] = palette_idx2; 151
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
pixels [ pixel_ptr ++ ] = palette_idx1; 157
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_ptr = y_ptr; 177
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_ptr += pixel_skip; 185
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
pixels [ pixel_ptr ++ ] = palette_idx1; 192
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
pixels [ pixel_ptr ++ ] = palette_idx1; 199
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 212
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
pixel_ptr = y_ptr; 221
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixels [ pixel_ptr ++ ] = palette_idx1; 232
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixels [ pixel_ptr ++ ] = palette_idx1; 243
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 265
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
0
------------------------------
442 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c memcpy 289
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
for (j = 0; j < byte_run; j++) 227
pixel_countdown --; 229
byte_run = - byte_run; 235
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixel_countdown --; 240
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
frame_size -= chunk_size; 278
num_chunks --; 279
memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ); 289
s -> frame . palette_has_changed = 1; 291
s -> new_palette = 0; 292
* ( AVFrame * ) data = s -> frame; 296
0
------------------------------
443 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c memcpy 261
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_ptr = y_ptr; 133
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_ptr += pixel_skip; 138
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
pixels [ pixel_ptr ++ ] = palette_idx1; 147
pixels [ pixel_ptr ++ ] = palette_idx2; 148
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
pixels [ pixel_ptr ++ ] = palette_idx1; 154
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_ptr = y_ptr; 174
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_ptr += pixel_skip; 181
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
pixels [ pixel_ptr ++ ] = palette_idx1; 188
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
pixels [ pixel_ptr ++ ] = palette_idx1; 195
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 208
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
pixel_ptr = y_ptr; 217
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
for (j = 0; j < byte_run; j++) 227
pixels [ pixel_ptr ++ ] = palette_idx1; 228
pixel_countdown --; 229
byte_run = - byte_run; 235
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixels [ pixel_ptr ++ ] = palette_idx1; 239
pixel_countdown --; 240
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 261
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
frame_size -= chunk_size; 278
num_chunks --; 279
0
------------------------------
444 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c memcpy 178
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
445 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c memcpy 149
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
446 /home/SySeVR/data/CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext.c memcpy 98
int CVE_2010_3864_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
OPENSSL_free ( s -> session -> tlsext_hostname ); 101
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
447 /home/SySeVR/data/CVE_2010_3875_PATCHED_ax25_getname.c memcpy 35
static int CVE_2010_3875_PATCHED_ax25_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddr_len, int peer) 2
struct full_sockaddr_ax25 * fsa = ( struct full_sockaddr_ax25 * ) uaddr ; 4
struct sock * sk = sock -> sk ; 5
ax25_cb * ax25 ; 7
ax25 = ax25_sk ( sk ); 12
if ( peer != 0 )  14
fsa -> fsa_ax25 . sax25_family = AF_AX25; 31
fsa -> fsa_ax25 . sax25_call = ax25 -> source_addr; 32
fsa -> fsa_ax25 . sax25_ndigis = 1; 33
if ( ax25 -> ax25_dev != NULL )  34
memcpy ( & fsa -> fsa_digipeater [ 0 ] , ax25 -> ax25_dev -> dev -> dev_addr , AX25_ADDR_LEN ); 35
0
------------------------------
448 /home/SySeVR/data/CVE_2010_3876_VULN_packet_getname.c memcpy 20
static int CVE_2010_3876_VULN_packet_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddr_len, int peer) 2
struct net_device * dev ; 4
struct sock * sk = sock -> sk ; 5
struct packet_sock * po = pkt_sk ( sk ) ; 6
if ( peer )  9
sll -> sll_family = AF_PACKET; 12
sll -> sll_ifindex = po -> ifindex; 13
sll -> sll_protocol = po -> num; 14
dev = dev_get_by_index_rcu ( sock_net ( sk ) , po -> ifindex ); 16
if ( dev )  17
sll -> sll_hatype = dev -> type; 18
sll -> sll_halen = dev -> addr_len; 19
memcpy ( sll -> sll_addr , dev -> dev_addr , dev -> addr_len ); 20
0
------------------------------
449 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c memcpy 98
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
struct tcp_sock * tp = tcp_sk ( sk ) ; 4
switch ( optname )  10
struct tcp_cookie_transactions ctd ; 29
struct tcp_cookie_values * cvp = NULL ; 30
if ( sizeof ( ctd ) > optlen )  32
if ( copy_from_user ( & ctd , optval , sizeof ( ctd ) ) )  34
if ( ctd . tcpct_used > sizeof ( ctd . tcpct_value ) || ctd . tcpct_s_data_desired > TCP_MSS_DESIRED )  37
if ( ctd . tcpct_cookie_desired == 0 )  41
if ( ( 0x1 & ctd . tcpct_cookie_desired ) || ctd . tcpct_cookie_desired > TCP_COOKIE_MAX || ctd . tcpct_cookie_desired < TCP_COOKIE_MIN )  43
if ( TCP_COOKIE_OUT_NEVER & ctd . tcpct_flags )  49
if ( ctd . tcpct_used > 0 || ( tp -> cookie_values == NULL && ( sysctl_tcp_cookie_size > 0 || ctd . tcpct_cookie_desired > 0 || ctd . tcpct_s_data_desired > 0 ) ) )  65
cvp = kzalloc ( sizeof ( * cvp ) + ctd . tcpct_used , GFP_KERNEL ); 70
if ( cvp == NULL )  72
tp -> rx_opt . cookie_in_always = ( TCP_COOKIE_IN_ALWAYS & ctd . tcpct_flags ); 76
tp -> rx_opt . cookie_out_never = 0; 78
if ( tp -> cookie_values != NULL )  80
if ( cvp != NULL )  81
cvp = tp -> cookie_values; 91
if ( cvp != NULL )  94
cvp -> cookie_desired = ctd . tcpct_cookie_desired; 95
if ( ctd . tcpct_used > 0 )  97
memcpy ( cvp -> s_data_payload , ctd . tcpct_value , ctd . tcpct_used ); 98
cvp -> s_data_desired = ctd . tcpct_used; 100
cvp -> s_data_constant = 1; 101
0
------------------------------
450 /home/SySeVR/data/CVE_2010_4342_PATCHED_aun_incoming.c memcpy 28
static void CVE_2010_4342_PATCHED_aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len) 1
struct iphdr * ip = ip_hdr ( skb ) ; 3
unsigned char stn = ntohl ( ip -> saddr ) & 0xff ; 4
struct dst_entry * dst = skb_dst ( skb ) ; 5
struct ec_device * edev = NULL ; 6
struct sk_buff * newskb ; 8
if ( dst )  10
edev = dst -> dev -> ec_ptr; 11
if ( ! edev )  13
if ( ( sk = ec_listening_socket ( ah -> port , stn , edev -> net ) ) == NULL )  16
newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ); 19
if ( newskb == NULL )  21
memcpy ( skb_put ( newskb , len - sizeof ( struct aunhdr ) ) , ( void * ) ( ah + 1 ) , len - sizeof ( struct aunhdr ) ); 28
0
------------------------------
451 /home/SySeVR/data/CVE_2010_4342_VULN_aun_incoming.c memcpy 24
static void CVE_2010_4342_VULN_aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len) 1
struct iphdr * ip = ip_hdr ( skb ) ; 3
unsigned char stn = ntohl ( ip -> saddr ) & 0xff ; 4
struct sk_buff * newskb ; 6
struct ec_device * edev = skb -> dev -> ec_ptr ; 7
if ( ! edev )  9
if ( ( sk = ec_listening_socket ( ah -> port , stn , edev -> net ) ) == NULL )  12
newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ); 15
if ( newskb == NULL )  17
memcpy ( skb_put ( newskb , len - sizeof ( struct aunhdr ) ) , ( void * ) ( ah + 1 ) , len - sizeof ( struct aunhdr ) ); 24
0
------------------------------
452 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c memcpy 178
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
453 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c memcpy 149
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
0
------------------------------
454 /home/SySeVR/data/CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext.c memcpy 98
int CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( s -> tlsext_debug_cb )  29
s -> tlsext_debug_cb ( s , 0 , type , data , size , s -> tlsext_debug_arg ); 30
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
OPENSSL_free ( s -> session -> tlsext_hostname ); 101
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( s -> session -> tlsext_ecpointformatlist != NULL )  142
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 142
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( s -> session -> tlsext_ellipticcurvelist != NULL )  171
OPENSSL_free ( s -> session -> tlsext_ellipticcurvelist ); 171
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_PATCHED_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
n2s ( sdata , s -> s3 -> client_opaque_prf_input_len ); 199
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input != NULL )  206
OPENSSL_free ( s -> s3 -> client_opaque_prf_input ); 207
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
size -= 2 + idsize; 269
if ( dsize < 0 )  270
sdata = data; 275
data += idsize; 276
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 277
if ( ! id )  279
if ( data != sdata )  284
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  290
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  298
if ( size < 2 )  308
size -= 2; 314
if ( dsize != size )  315
sdata = data; 320
if ( dsize > 0 )  321
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 323
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  326
s -> tlsext_status_type = - 1; 338
data += size; 342
if ( ! renegotiate_seen && s -> new_session && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  351
0
------------------------------
455 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c memcpy 178
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
456 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c memcpy 149
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
0
------------------------------
457 /home/SySeVR/data/CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext.c memcpy 98
int CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short type ; 3
unsigned short size ; 4
unsigned short len ; 5
unsigned char * data = * p ; 6
s -> servername_done = 0; 9
s -> tlsext_status_type = - 1; 10
if ( data >= ( d + n - 2 ) )  12
if ( data > ( d + n - len ) )  16
while ( data <= ( d + n - 4 ) )  19
if ( data + size > ( d + n ) )  24
if ( s -> tlsext_debug_cb )  29
s -> tlsext_debug_cb ( s , 0 , type , data , size , s -> tlsext_debug_arg ); 30
if ( type == TLSEXT_TYPE_server_name )  55
unsigned char * sdata ; 57
int servname_type ; 58
int dsize ; 59
if ( size < 2 )  61
size -= 2; 67
if ( dsize > size )  68
sdata = data; 74
while ( dsize > 3 )  75
servname_type = * ( sdata ++ ); 77
dsize -= 3; 79
if ( len > dsize )  81
if ( s -> servername_done == 0 )  86
switch ( servname_type )  87
if ( s -> session -> tlsext_hostname == NULL )  90
if ( len > TLSEXT_MAXLEN_host_name || ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) == NULL ) )  92
memcpy ( s -> session -> tlsext_hostname , sdata , len ); 98
s -> session -> tlsext_hostname [ len ] = '\0'; 99
if ( strlen ( s -> session -> tlsext_hostname ) != len )  100
OPENSSL_free ( s -> session -> tlsext_hostname ); 101
s -> session -> tlsext_hostname = NULL; 102
s -> servername_done = 1; 106
s -> servername_done = strlen ( s -> session -> tlsext_hostname ) == len && strncmp ( s -> session -> tlsext_hostname , ( char * ) sdata , len ) == 0; 110
dsize -= len; 119
if ( dsize != 0 )  121
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  130
unsigned char * sdata = data ; 133
int ecpointformatlist_length = * ( sdata ++ ) ; 134
if ( ecpointformatlist_length != size - 1 )  136
s -> session -> tlsext_ecpointformatlist_length = 0; 141
if ( s -> session -> tlsext_ecpointformatlist != NULL )  142
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 142
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  143
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 148
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 149
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) " , s -> session -> tlsext_ecpointformatlist_length ); 151
sdata = s -> session -> tlsext_ecpointformatlist; 152
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 153
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 154
fprintf ( stderr , "\n" ); 155
if ( type == TLSEXT_TYPE_elliptic_curves && s -> version != DTLS1_VERSION )  158
unsigned char * sdata = data ; 161
int ellipticcurvelist_length = ( * ( sdata ++ ) << 8 ) ; 162
ellipticcurvelist_length += ( * ( sdata ++ ) ); 163
if ( ellipticcurvelist_length != size - 2 )  165
s -> session -> tlsext_ellipticcurvelist_length = 0; 170
if ( s -> session -> tlsext_ellipticcurvelist != NULL )  171
OPENSSL_free ( s -> session -> tlsext_ellipticcurvelist ); 171
if ( ( s -> session -> tlsext_ellipticcurvelist = OPENSSL_malloc ( ellipticcurvelist_length ) ) == NULL )  172
s -> session -> tlsext_ellipticcurvelist_length = ellipticcurvelist_length; 177
memcpy ( s -> session -> tlsext_ellipticcurvelist , sdata , ellipticcurvelist_length ); 178
fprintf ( stderr , "CVE_2011_0014_VULN_ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) " , s -> session -> tlsext_ellipticcurvelist_length ); 180
sdata = s -> session -> tlsext_ellipticcurvelist; 181
for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) 182
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 183
fprintf ( stderr , "\n" ); 184
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  189
unsigned char * sdata = data ; 192
if ( size < 2 )  194
n2s ( sdata , s -> s3 -> client_opaque_prf_input_len ); 199
if ( s -> s3 -> client_opaque_prf_input_len != size - 2 )  200
if ( s -> s3 -> client_opaque_prf_input != NULL )  206
OPENSSL_free ( s -> s3 -> client_opaque_prf_input ); 207
if ( s -> s3 -> client_opaque_prf_input_len == 0 )  208
s -> s3 -> client_opaque_prf_input = OPENSSL_malloc ( 1 ); 209
s -> s3 -> client_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> client_opaque_prf_input_len ); 211
if ( s -> s3 -> client_opaque_prf_input == NULL )  212
if ( type == TLSEXT_TYPE_session_ticket )  219
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  221
if ( type == TLSEXT_TYPE_renegotiate )  228
if ( ! ssl_parse_clienthello_renegotiate_ext ( s , data , size , al ) )  230
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION && s -> ctx -> tlsext_status_cb )  234
if ( size < 5 )  238
s -> tlsext_status_type = * data ++; 244
size --; 245
if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp )  246
const unsigned char * sdata ; 248
int dsize ; 249
size -= 2; 252
if ( dsize > size )  253
while ( dsize > 0 )  258
OCSP_RESPID * id ; 260
int idsize ; 261
if ( dsize < 4 )  262
dsize -= 2 + idsize; 268
if ( dsize < 0 )  269
sdata = data; 274
data += idsize; 275
id = d2i_OCSP_RESPID ( NULL , & sdata , idsize ); 276
if ( ! id )  278
if ( data != sdata )  283
if ( ! s -> tlsext_ocsp_ids && ! ( s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ) )  289
if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) )  297
size -= 2; 308
if ( dsize > size )  309
sdata = data; 314
if ( dsize > 0 )  315
s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & sdata , dsize ); 317
if ( ! s -> tlsext_ocsp_exts || ( data + dsize != sdata ) )  320
s -> tlsext_status_type = - 1; 332
data += size; 336
if ( ! renegotiate_seen && s -> new_session && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  345
0
------------------------------
458 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeScroll.c memcpy 41
static int CVE_2011_0021_PATCHED_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ; 3
int i_shifth ; 6
int i_shiftv ; 7
p_cdg -> i_offseth = p_data [ 1 ] & 0x7; 11
if ( p_cdg -> i_offseth >= CDG_SCREEN_BORDER_WIDTH )  12
p_cdg -> i_offseth = CDG_SCREEN_BORDER_WIDTH - 1; 13
p_cdg -> i_offsetv = p_data [ 2 ] & 0xf; 15
if ( p_cdg -> i_offsetv >= CDG_SCREEN_BORDER_HEIGHT )  16
p_cdg -> i_offsetv = CDG_SCREEN_BORDER_HEIGHT - 1; 17
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) ); 41
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
0
------------------------------
459 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c memcpy 41
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ; 3
int i_shifth ; 6
int i_shiftv ; 7
p_cdg -> i_offseth = p_data [ 1 ] & 0x7; 11
if ( p_cdg -> i_offseth >= CDG_SCREEN_BORDER_WIDTH )  12
p_cdg -> i_offseth = CDG_SCREEN_BORDER_WIDTH - 1; 13
p_cdg -> i_offsetv = p_data [ 2 ] & 0xf; 15
if ( p_cdg -> i_offsetv >= CDG_SCREEN_BORDER_HEIGHT )  16
p_cdg -> i_offsetv = CDG_SCREEN_BORDER_HEIGHT - 1; 17
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) ); 41
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
0
------------------------------
460 /home/SySeVR/data/CVE_2011_0521_VULN_dvb_ca_ioctl.c memcpy 51
static int CVE_2011_0521_VULN_dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg) 1
struct dvb_device * dvbdev = file -> private_data ; 3
struct av7110 * av7110 = dvbdev -> priv ; 4
switch ( cmd )  9
ca_caps_t cap ; 15
cap . slot_num = 2; 17
cap . slot_type = ( FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI ) | CA_DESCR; 18
cap . descr_num = 16; 20
cap . descr_type = CA_ECD; 21
memcpy ( parg , & cap , sizeof ( cap ) ); 22
ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; 28
if ( info -> num > 1 )  30
av7110 -> ci_slot [ info -> num ] . num = info -> num; 32
av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI; 33
memcpy ( info , & av7110 -> ci_slot [ info -> num ] , sizeof ( ca_slot_info_t ) ); 35
ca_descr_info_t info ; 47
info . num = 16; 49
info . type = CA_ECD; 50
memcpy ( parg , & info , sizeof ( info ) ); 51
ca_descr_t * descr = ( ca_descr_t * ) parg ; 57
if ( descr -> index >= 16 )  59
if ( descr -> parity > 1 )  61
av7110_fw_cmd ( av7110 , COMTYPE_PIDFILTER , SetDescr , 5 , ( descr -> index << 8 ) | descr -> parity , ( descr -> cw [ 0 ] << 8 ) | descr -> cw [ 1 ] , ( descr -> cw [ 2 ] << 8 ) | descr -> cw [ 3 ] , ( descr -> cw [ 4 ] << 8 ) | descr -> cw [ 5 ] , ( descr -> cw [ 6 ] << 8 ) | descr -> cw [ 7 ] ); 63
0
------------------------------
461 /home/SySeVR/data/CVE_2011_0521_VULN_dvb_ca_ioctl.c memcpy 35
static int CVE_2011_0521_VULN_dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg) 1
struct dvb_device * dvbdev = file -> private_data ; 3
struct av7110 * av7110 = dvbdev -> priv ; 4
switch ( cmd )  9
ca_caps_t cap ; 15
cap . slot_num = 2; 17
cap . slot_type = ( FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI ) | CA_DESCR; 18
cap . descr_num = 16; 20
cap . descr_type = CA_ECD; 21
memcpy ( parg , & cap , sizeof ( cap ) ); 22
ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; 28
if ( info -> num > 1 )  30
av7110 -> ci_slot [ info -> num ] . num = info -> num; 32
av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI; 33
memcpy ( info , & av7110 -> ci_slot [ info -> num ] , sizeof ( ca_slot_info_t ) ); 35
info . num = 16; 49
info . type = CA_ECD; 50
memcpy ( parg , & info , sizeof ( info ) ); 51
ca_descr_t * descr = ( ca_descr_t * ) parg ; 57
if ( descr -> index >= 16 )  59
if ( descr -> parity > 1 )  61
av7110_fw_cmd ( av7110 , COMTYPE_PIDFILTER , SetDescr , 5 , ( descr -> index << 8 ) | descr -> parity , ( descr -> cw [ 0 ] << 8 ) | descr -> cw [ 1 ] , ( descr -> cw [ 2 ] << 8 ) | descr -> cw [ 3 ] , ( descr -> cw [ 4 ] << 8 ) | descr -> cw [ 5 ] , ( descr -> cw [ 6 ] << 8 ) | descr -> cw [ 7 ] ); 63
0
------------------------------
462 /home/SySeVR/data/CVE_2011_0521_VULN_dvb_ca_ioctl.c memcpy 22
static int CVE_2011_0521_VULN_dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg) 1
struct dvb_device * dvbdev = file -> private_data ; 3
struct av7110 * av7110 = dvbdev -> priv ; 4
switch ( cmd )  9
ca_caps_t cap ; 15
cap . slot_num = 2; 17
cap . slot_type = ( FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI ) | CA_DESCR; 18
cap . descr_num = 16; 20
cap . descr_type = CA_ECD; 21
memcpy ( parg , & cap , sizeof ( cap ) ); 22
ca_slot_info_t * info = ( ca_slot_info_t * ) parg ; 28
if ( info -> num > 1 )  30
av7110 -> ci_slot [ info -> num ] . num = info -> num; 32
av7110 -> ci_slot [ info -> num ] . type = FW_CI_LL_SUPPORT ( av7110 -> arm_app ) ? CA_CI_LINK : CA_CI; 33
memcpy ( info , & av7110 -> ci_slot [ info -> num ] , sizeof ( ca_slot_info_t ) ); 35
info . num = 16; 49
info . type = CA_ECD; 50
memcpy ( parg , & info , sizeof ( info ) ); 51
ca_descr_t * descr = ( ca_descr_t * ) parg ; 57
if ( descr -> index >= 16 )  59
if ( descr -> parity > 1 )  61
av7110_fw_cmd ( av7110 , COMTYPE_PIDFILTER , SetDescr , 5 , ( descr -> index << 8 ) | descr -> parity , ( descr -> cw [ 0 ] << 8 ) | descr -> cw [ 1 ] , ( descr -> cw [ 2 ] << 8 ) | descr -> cw [ 3 ] , ( descr -> cw [ 4 ] << 8 ) | descr -> cw [ 5 ] , ( descr -> cw [ 6 ] << 8 ) | descr -> cw [ 7 ] ); 63
0
------------------------------
463 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c memcpy 101
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
struct user_key_payload * upayload ; 4
unsigned long derrno ; 5
int ret ; 6
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
end = data + datalen; 19
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
result_len = datalen; 24
const char * next_opt ; 26
result_len = opt - data; 28
opt ++; 29
const char * eq ; 32
int opt_len , opt_nlen , opt_vlen , tmp ; 33
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
if ( derrno < 1 || derrno > 511 )  65
key -> type_data . x [ 0 ] = - derrno; 69
while ( opt = next_opt + 1 , opt < end )  79
if ( key -> type_data . x [ 0 ] )  84
ret = key_payload_reserve ( key , result_len ); 90
if ( ret < 0 )  91
upayload = kmalloc ( sizeof ( * upayload ) + result_len + 1 , GFP_KERNEL ); 94
if ( ! upayload )  95
upayload -> datalen = result_len; 100
memcpy ( upayload -> data , data , result_len ); 101
upayload -> data [ result_len ] = '\0'; 102
rcu_assign_pointer ( key -> payload . data , upayload ); 103
0
------------------------------
464 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c memcpy 295
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
int i ; 6
guint8 hc1_encoding ; 7
guint8 hc_udp_encoding = 0 ; 8
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
struct lowpan_nhdr * nhdr_list ; 16
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
hc_udp_encoding = tvb_get_guint8 ( tvb , offset ); 49
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
bit_offset += LOWPAN_IPV6_HOP_LIMIT_BITS; 87
offset = bit_offset; 93
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_PREFIX ) )  94
for (i=0; i<8; i++, bit_offset += 8) 95
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 96
memcpy ( ipv6 . ip6_src . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); 100
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_IFC ) )  102
for (i=8; i<16; i++, bit_offset += 8) 103
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 104
if ( pinfo -> src . type == AT_EUI64 )  108
memcpy ( & ipv6 . ip6_src . bytes [ 8 ] , pinfo -> src . data , 8 ); 109
offset = bit_offset; 130
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_PREFIX ) )  131
for (i=0; i<8; i++, bit_offset += 8) 132
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 133
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_IFC ) )  139
for (i=8; i<16; i++, bit_offset += 8) 140
if ( ! ( hc1_encoding & LOWPAN_HC1_TRAFFIC_CLASS ) )  166
bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; 173
bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; 181
if ( next_header == LOWPAN_HC1_NEXT_UDP )  187
if ( next_header == LOWPAN_HC1_NEXT_ICMP )  190
if ( next_header == LOWPAN_HC1_NEXT_TCP )  193
bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; 204
if ( ( hc1_encoding & LOWPAN_HC1_MORE ) && ( next_header == LOWPAN_HC1_NEXT_UDP ) )  211
struct udp_hdr udp ; 212
gint length ; 213
offset = bit_offset; 216
if ( hc_udp_encoding & LOWPAN_HC2_UDP_SRCPORT )  217
udp . src_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; 218
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 219
udp . src_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); 222
bit_offset += LOWPAN_UDP_PORT_BITS; 223
udp . src_port = g_ntohs ( udp . src_port ); 229
offset = bit_offset; 232
if ( hc_udp_encoding & LOWPAN_HC2_UDP_DSTPORT )  233
udp . dst_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; 234
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 235
udp . dst_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); 238
bit_offset += LOWPAN_UDP_PORT_BITS; 239
udp . dst_port = g_ntohs ( udp . dst_port ); 245
if ( ! ( hc_udp_encoding & LOWPAN_HC2_UDP_LENGTH ) )  248
udp . length = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_LENGTH_BITS , FALSE ); 249
bit_offset += LOWPAN_UDP_LENGTH_BITS; 255
if ( dgram_size >= 0 )  258
if ( dgram_size < ( gint ) sizeof ( struct ip6_hdr ) )  259
udp . length = dgram_size - ( gint ) sizeof ( struct ip6_hdr ); 266
udp . length = tvb_reported_length ( tvb ); 270
udp . length -= BITS_TO_BYTE_LEN ( 0 , bit_offset + LOWPAN_UDP_CHECKSUM_BITS ); 271
udp . length += sizeof ( struct udp_hdr ); 272
udp . length = g_ntohs ( udp . length ); 274
udp . checksum = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_CHECKSUM_BITS , FALSE ); 277
bit_offset += LOWPAN_UDP_CHECKSUM_BITS; 282
udp . checksum = g_ntohs ( udp . checksum ); 283
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 286
length = tvb_length_remaining ( tvb , offset ); 287
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ); 288
nhdr_list -> next = NULL; 289
nhdr_list -> proto = IP_PROTO_UDP; 290
nhdr_list -> length = length + sizeof ( struct udp_hdr ); 291
nhdr_list -> reported = g_ntohs ( udp . length ); 292
memcpy ( LOWPAN_NHDR_DATA ( nhdr_list ) , & udp , sizeof ( struct udp_hdr ) ); 295
0
------------------------------
465 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c memcpy 146
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
guint8 hc1_encoding ; 7
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_IFC ) )  139
if ( pinfo -> dst . type == AT_EUI64 )  145
memcpy ( & ipv6 . ip6_dst . bytes [ 8 ] , pinfo -> dst . data , 8 ); 146
proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , ( guint8 * ) & ipv6 . ip6_dst ); 154
ipv6 . ip6_flow = 0; 165
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS , FALSE ); 176
proto_tree_add_uint ( tree , hf_6lowpan_flow_label , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS ) , ipv6 . ip6_flow ); 178
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ) ); 183
ipv6 . ip6_vfc = ( ( 0x6 << 4 ) | ( ipv6_class >> 4 ) ); 184
ipv6 . ip6_nxt = IP_PROTO_UDP; 188
ipv6 . ip6_nxt = IP_PROTO_ICMPV6; 191
ipv6 . ip6_nxt = IP_PROTO_TCP; 194
ipv6 . ip6_nxt = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ); 198
proto_tree_add_uint_format ( tree , hf_6lowpan_next_header , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ) , ipv6 . ip6_nxt , "Next header: %s (0x%02x)" , ipprotostr ( ipv6 . ip6_nxt ) , ipv6 . ip6_nxt ); 200
nhdr_list -> proto = ipv6 . ip6_nxt; 306
nhdr_list -> length = tvb_length_remaining ( tvb , offset ); 307
nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); 309
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 314
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 318
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 319
return ipv6_tvb ; 320
0
------------------------------
466 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c memcpy 137
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
guint8 hc1_encoding ; 7
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_PREFIX ) )  131
memcpy ( ipv6 . ip6_dst . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); 137
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 141
0
------------------------------
467 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c memcpy 109
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
guint8 hc1_encoding ; 7
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_IFC ) )  102
if ( pinfo -> src . type == AT_EUI64 )  108
memcpy ( & ipv6 . ip6_src . bytes [ 8 ] , pinfo -> src . data , 8 ); 109
proto_tree_add_ipv6 ( tree , hf_6lowpan_source , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , ( guint8 * ) & ipv6 . ip6_src ); 117
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 133
for (i=8; i<16; i++, bit_offset += 8) 140
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 141
proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , ( guint8 * ) & ipv6 . ip6_dst ); 154
ipv6_class = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_TRAFFIC_CLASS_BITS ); 168
proto_tree_add_uint ( tree , hf_6lowpan_traffic_class , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_TRAFFIC_CLASS_BITS ) , ipv6_class ); 170
bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; 173
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS , FALSE ); 176
proto_tree_add_uint ( tree , hf_6lowpan_flow_label , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS ) , ipv6 . ip6_flow ); 178
bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; 181
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ) ); 183
ipv6 . ip6_vfc = ( ( 0x6 << 4 ) | ( ipv6_class >> 4 ) ); 184
ipv6 . ip6_nxt = IP_PROTO_UDP; 188
ipv6 . ip6_nxt = IP_PROTO_ICMPV6; 191
ipv6 . ip6_nxt = IP_PROTO_TCP; 194
ipv6 . ip6_nxt = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ); 198
proto_tree_add_uint_format ( tree , hf_6lowpan_next_header , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ) , ipv6 . ip6_nxt , "Next header: %s (0x%02x)" , ipprotostr ( ipv6 . ip6_nxt ) , ipv6 . ip6_nxt ); 200
bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; 204
offset = bit_offset; 216
udp . src_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; 218
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 219
udp . src_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); 222
bit_offset += LOWPAN_UDP_PORT_BITS; 223
proto_tree_add_uint ( tree , hf_6lowpan_udp_src , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , udp . src_port ); 226
udp . src_port = g_ntohs ( udp . src_port ); 229
offset = bit_offset; 232
udp . dst_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; 234
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 235
udp . dst_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); 238
bit_offset += LOWPAN_UDP_PORT_BITS; 239
proto_tree_add_uint ( tree , hf_6lowpan_udp_dst , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , udp . dst_port ); 242
udp . dst_port = g_ntohs ( udp . dst_port ); 245
udp . length = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_LENGTH_BITS , FALSE ); 249
proto_tree_add_uint ( tree , hf_6lowpan_udp_len , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_UDP_LENGTH_BITS ) , udp . length ); 251
bit_offset += LOWPAN_UDP_LENGTH_BITS; 255
udp . length = dgram_size - ( gint ) sizeof ( struct ip6_hdr ); 266
udp . length = tvb_reported_length ( tvb ); 270
udp . length -= BITS_TO_BYTE_LEN ( 0 , bit_offset + LOWPAN_UDP_CHECKSUM_BITS ); 271
udp . length += sizeof ( struct udp_hdr ); 272
udp . length = g_ntohs ( udp . length ); 274
udp . checksum = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_CHECKSUM_BITS , FALSE ); 277
proto_tree_add_uint ( tree , hf_6lowpan_udp_checksum , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_UDP_CHECKSUM_BITS ) , udp . checksum ); 279
bit_offset += LOWPAN_UDP_CHECKSUM_BITS; 282
udp . checksum = g_ntohs ( udp . checksum ); 283
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 286
length = tvb_length_remaining ( tvb , offset ); 287
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ); 288
nhdr_list -> next = NULL; 289
nhdr_list -> proto = IP_PROTO_UDP; 290
nhdr_list -> length = length + sizeof ( struct udp_hdr ); 291
nhdr_list -> reported = g_ntohs ( udp . length ); 292
memcpy ( LOWPAN_NHDR_DATA ( nhdr_list ) , & udp , sizeof ( struct udp_hdr ) ); 295
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) + sizeof ( struct udp_hdr ) , offset , length ); 296
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 303
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + tvb_length_remaining ( tvb , offset ) ); 304
nhdr_list -> next = NULL; 305
nhdr_list -> proto = ipv6 . ip6_nxt; 306
nhdr_list -> length = tvb_length_remaining ( tvb , offset ); 307
nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); 309
nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); 312
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 314
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 318
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 319
return ipv6_tvb ; 320
0
------------------------------
468 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c memcpy 100
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
guint8 hc1_encoding ; 7
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_PREFIX ) )  94
memcpy ( ipv6 . ip6_src . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); 100
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 104
for (i=0; i<8; i++, bit_offset += 8) 132
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 133
for (i=8; i<16; i++, bit_offset += 8) 140
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 141
proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , ( guint8 * ) & ipv6 . ip6_dst ); 154
ipv6_class = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_TRAFFIC_CLASS_BITS ); 168
proto_tree_add_uint ( tree , hf_6lowpan_traffic_class , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_TRAFFIC_CLASS_BITS ) , ipv6_class ); 170
bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; 173
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS , FALSE ); 176
proto_tree_add_uint ( tree , hf_6lowpan_flow_label , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS ) , ipv6 . ip6_flow ); 178
bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; 181
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ) ); 183
ipv6 . ip6_vfc = ( ( 0x6 << 4 ) | ( ipv6_class >> 4 ) ); 184
ipv6 . ip6_nxt = IP_PROTO_UDP; 188
ipv6 . ip6_nxt = IP_PROTO_ICMPV6; 191
ipv6 . ip6_nxt = IP_PROTO_TCP; 194
ipv6 . ip6_nxt = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ); 198
proto_tree_add_uint_format ( tree , hf_6lowpan_next_header , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ) , ipv6 . ip6_nxt , "Next header: %s (0x%02x)" , ipprotostr ( ipv6 . ip6_nxt ) , ipv6 . ip6_nxt ); 200
bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; 204
offset = bit_offset; 216
udp . src_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; 218
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 219
udp . src_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); 222
bit_offset += LOWPAN_UDP_PORT_BITS; 223
proto_tree_add_uint ( tree , hf_6lowpan_udp_src , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , udp . src_port ); 226
udp . src_port = g_ntohs ( udp . src_port ); 229
offset = bit_offset; 232
udp . dst_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; 234
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 235
udp . dst_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); 238
bit_offset += LOWPAN_UDP_PORT_BITS; 239
proto_tree_add_uint ( tree , hf_6lowpan_udp_dst , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , udp . dst_port ); 242
udp . dst_port = g_ntohs ( udp . dst_port ); 245
udp . length = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_LENGTH_BITS , FALSE ); 249
proto_tree_add_uint ( tree , hf_6lowpan_udp_len , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_UDP_LENGTH_BITS ) , udp . length ); 251
bit_offset += LOWPAN_UDP_LENGTH_BITS; 255
udp . length = dgram_size - ( gint ) sizeof ( struct ip6_hdr ); 266
udp . length = tvb_reported_length ( tvb ); 270
udp . length -= BITS_TO_BYTE_LEN ( 0 , bit_offset + LOWPAN_UDP_CHECKSUM_BITS ); 271
udp . length += sizeof ( struct udp_hdr ); 272
udp . length = g_ntohs ( udp . length ); 274
udp . checksum = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_CHECKSUM_BITS , FALSE ); 277
proto_tree_add_uint ( tree , hf_6lowpan_udp_checksum , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_UDP_CHECKSUM_BITS ) , udp . checksum ); 279
bit_offset += LOWPAN_UDP_CHECKSUM_BITS; 282
udp . checksum = g_ntohs ( udp . checksum ); 283
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 286
length = tvb_length_remaining ( tvb , offset ); 287
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ); 288
nhdr_list -> next = NULL; 289
nhdr_list -> proto = IP_PROTO_UDP; 290
nhdr_list -> length = length + sizeof ( struct udp_hdr ); 291
nhdr_list -> reported = g_ntohs ( udp . length ); 292
memcpy ( LOWPAN_NHDR_DATA ( nhdr_list ) , & udp , sizeof ( struct udp_hdr ) ); 295
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) + sizeof ( struct udp_hdr ) , offset , length ); 296
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 303
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + tvb_length_remaining ( tvb , offset ) ); 304
nhdr_list -> next = NULL; 305
nhdr_list -> proto = ipv6 . ip6_nxt; 306
nhdr_list -> length = tvb_length_remaining ( tvb , offset ); 307
nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); 309
nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); 312
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 314
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 318
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 319
return ipv6_tvb ; 320
0
------------------------------
469 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c memcpy 131
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int i ; 5
int x ; 10
int ptr ; 13
int seq_no ; 16
const uint8_t * data ; 18
int ifp_len ; 19
int repaired [ 16 ] ; 20
int span ; 23
int entries ; 24
ptr = 0; 27
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
for ( ; seq_no > s->rx_seq_no; s->rx_seq_no++) 89
x = s -> rx_seq_no & UDPTL_BUF_MASK; 90
s -> rx [ x ] . buf_len = - 1; 91
s -> rx [ x ] . fec_len [ 0 ] = 0; 92
s -> rx [ x ] . fec_span = 0; 93
s -> rx [ x ] . fec_entries = 0; 94
x = seq_no & UDPTL_BUF_MASK; 97
memset ( repaired , 0 , sizeof ( repaired ) ); 99
s -> rx [ x ] . buf_len = ifp_len; 103
repaired [ x ] = TRUE; 104
if ( ptr + 2 > len )  109
if ( buf [ ptr ++ ] != 1 )  111
span = buf [ ptr ++ ]; 113
s -> rx [ x ] . fec_span = span; 114
if ( ptr + 1 > len )  118
entries = buf [ ptr ++ ]; 120
s -> rx [ x ] . fec_entries = entries; 121
for (i = 0; i < entries; i++) 124
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
memcpy ( s -> rx [ x ] . fec [ i ] , data , s -> rx [ x ] . fec_len [ i ] ); 131
0
------------------------------
470 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c memcpy 102
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int x ; 10
int ptr ; 13
int seq_no ; 16
const uint8_t * ifp ; 17
int ifp_len ; 19
ptr = 0; 27
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
for ( ; seq_no > s->rx_seq_no; s->rx_seq_no++) 89
x = s -> rx_seq_no & UDPTL_BUF_MASK; 90
s -> rx [ x ] . buf_len = - 1; 91
s -> rx [ x ] . fec_len [ 0 ] = 0; 92
s -> rx [ x ] . fec_span = 0; 93
s -> rx [ x ] . fec_entries = 0; 94
x = seq_no & UDPTL_BUF_MASK; 97
memcpy ( s -> rx [ x ] . buf , ifp , ifp_len ); 102
0
------------------------------
471 /home/SySeVR/data/CVE_2011_1495_PATCHED__ctl_do_mpt_command.c memcpy 104
static long
CVE_2011_1495_PATCHED__ctl_do_mpt_command(struct MPT2SAS_ADAPTER *ioc,
struct mpt2_ioctl_command karg, void __user *mf, enum block_state state) 3
u32 ioc_state ; 7
u16 smid ; 9
u16 wait_state_count ; 22
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )  26
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )  28
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )  31
wait_state_count = 0; 38
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 39
while ( ioc_state != MPI2_IOC_STATE_OPERATIONAL )  40
if ( wait_state_count ++ == 10 )  41
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 49
mpi_request = kzalloc ( ioc -> request_sz , GFP_KERNEL ); 58
if ( ! mpi_request )  59
if ( karg . data_sge_offset * 4 > ioc -> request_sz || karg . data_sge_offset > ( UINT_MAX / 4 ) )  67
if ( copy_from_user ( mpi_request , mf , karg . data_sge_offset * 4 ) )  74
if ( mpi_request -> Function == MPI2_FUNCTION_SCSI_TASK_MGMT )  81
smid = mpt2sas_base_get_smid_hpr ( ioc , ioc -> ctl_cb_idx ); 82
if ( ! smid )  83
smid = mpt2sas_base_get_smid_scsiio ( ioc , ioc -> ctl_cb_idx , NULL ); 91
if ( ! smid )  92
ioc -> ctl_cmds . status = MPT2_CMD_PENDING; 101
request = mpt2sas_base_get_msg_frame ( ioc , smid ); 103
memcpy ( request , mpi_request , karg . data_sge_offset * 4 ); 104
0
------------------------------
472 /home/SySeVR/data/CVE_2011_2587_VULN_DemuxAudioSipr.c memcpy 17
static void CVE_2011_2587_VULN_DemuxAudioSipr( demux_t *p_demux, real_track_t *tk, mtime_t i_pts ) 1
demux_sys_t * p_sys = p_demux -> p_sys ; 3
block_t * p_block = tk -> p_sipr_packet ; 4
if ( p_sys -> i_buffer < tk -> i_frame_size )  6
if ( ! p_block )  9
p_block = block_New ( p_demux , tk -> i_frame_size * tk -> i_subpacket_h ); 11
if ( ! p_block )  12
tk -> p_sipr_packet = p_block; 14
memcpy ( p_block -> p_buffer + tk -> i_sipr_subpacket_count * tk -> i_frame_size , p_sys -> buffer , tk -> i_frame_size ); 17
p_block -> i_dts = p_block -> i_pts = i_pts; 21
SiprPacketReorder ( p_block -> p_buffer , tk -> i_subpacket_h , tk -> i_frame_size ); 28
CheckPcr ( p_demux , tk , p_block -> i_pts ); 29
es_out_Send ( p_demux -> out , tk -> p_es , p_block ); 30
0
------------------------------
473 /home/SySeVR/data/CVE_2011_2588_PATCHED_AVI_ChunkRead_strf.c memcpy 88
static int CVE_2011_2588_PATCHED_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( * p_chk -> strf . vids . p_bih ) ) ); 69
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  82
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 84
if ( p_chk -> common . i_chunk_size > sizeof ( BITMAPINFOHEADER ) )  86
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 88
p_chk -> strf . common . i_cat = UNKNOWN_ES; 104
0
------------------------------
474 /home/SySeVR/data/CVE_2011_2588_PATCHED_AVI_ChunkRead_strf.c memcpy 52
static int CVE_2011_2588_PATCHED_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
msg_Dbg ( ( vlc_object_t * ) s , "strf: audio:0x%4.4x channels:%d %dHz %dbits/sample %dkb/s" , p_chk -> strf . auds . p_wf -> wFormatTag , p_chk -> strf . auds . p_wf -> nChannels , p_chk -> strf . auds . p_wf -> nSamplesPerSec , p_chk -> strf . auds . p_wf -> wBitsPerSample , p_chk -> strf . auds . p_wf -> nAvgBytesPerSec * 8 / 1024 ); 57
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( * p_chk -> strf . vids . p_bih ) ) ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 72
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 74
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 75
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 80
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 81
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  82
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 84
if ( p_chk -> common . i_chunk_size > sizeof ( BITMAPINFOHEADER ) )  86
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 88
p_chk -> strf . common . i_cat = UNKNOWN_ES; 104
0
------------------------------
475 /home/SySeVR/data/CVE_2011_2588_VULN_AVI_ChunkRead_strf.c memcpy 87
static int CVE_2011_2588_VULN_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ); 69
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  81
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 83
if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 )  85
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 87
p_chk -> strf . common . i_cat = UNKNOWN_ES; 103
0
------------------------------
476 /home/SySeVR/data/CVE_2011_2588_VULN_AVI_ChunkRead_strf.c memcpy 52
static int CVE_2011_2588_VULN_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
msg_Dbg ( ( vlc_object_t * ) s , "strf: audio:0x%4.4x channels:%d %dHz %dbits/sample %dkb/s" , p_chk -> strf . auds . p_wf -> wFormatTag , p_chk -> strf . auds . p_wf -> nChannels , p_chk -> strf . auds . p_wf -> nSamplesPerSec , p_chk -> strf . auds . p_wf -> wBitsPerSample , p_chk -> strf . auds . p_wf -> nAvgBytesPerSec * 8 / 1024 ); 57
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 70
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 72
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 74
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 75
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 80
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  81
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 83
if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 )  85
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 87
p_chk -> strf . common . i_cat = UNKNOWN_ES; 103
0
------------------------------
477 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c memcpy 511
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
x = result; 527
op = ( REOp ) * pc ++; 532
0
------------------------------
478 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c memcpy 506
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
0
------------------------------
479 /home/SySeVR/data/CVE_2011_3003_PATCHED_CopyDataIfElementArray.c memcpy 8
PRBool CVE_2011_3003_PATCHED_CopyDataIfElementArray(const void* data) 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER )  2
mData = realloc ( mData , mByteLength ); 3
if ( ! mData )  4
memcpy ( mData , data , mByteLength ); 8
0
------------------------------
480 /home/SySeVR/data/CVE_2011_3003_PATCHED_CopySubDataIfElementArray.c memcpy 3
void CVE_2011_3003_PATCHED_CopySubDataIfElementArray(GLuint byteOffset, GLuint byteLength, const void* data) 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER && mByteLength )  2
memcpy ( ( void * ) ( size_t ( mData ) + byteOffset ) , data , byteLength ); 3
0
------------------------------
481 /home/SySeVR/data/CVE_2011_3003_VULN_CopyDataIfElementArray.c memcpy 6
PRBool CVE_2011_3003_VULN_CopyDataIfElementArray(const void* data) 1
if ( mTarget == LOCAL_GL_ELEMENT_ARRAY_BUFFER )  2
mData = realloc ( mData , mByteLength ); 3
if ( ! mData )  4
memcpy ( mData , data , mByteLength ); 6
0
------------------------------
482 /home/SySeVR/data/CVE_2011_3934_PATCHED_vp3_update_thread_context.c memcpy 42
static int CVE_2011_3934_PATCHED_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ]; 25
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
for (i = 0; i < 3; i++) 34
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
483 /home/SySeVR/data/CVE_2011_3934_PATCHED_vp3_update_thread_context.c memcpy 37
static int CVE_2011_3934_PATCHED_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ]; 25
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
for (i = 0; i < 3; i++) 34
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
484 /home/SySeVR/data/CVE_2011_3934_PATCHED_vp3_update_thread_context.c memcpy 27
static int CVE_2011_3934_PATCHED_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ]; 25
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
copy_fields ( s , s1 , golden_frame , dsp ); 31
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
485 /home/SySeVR/data/CVE_2011_3934_PATCHED_vp3_update_thread_context.c memcpy 26
static int CVE_2011_3934_PATCHED_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
copy_fields ( s , s1 , golden_frame , dsp ); 31
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
486 /home/SySeVR/data/CVE_2011_3934_VULN_vp3_update_thread_context.c memcpy 42
static int CVE_2011_3934_VULN_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ]; 25
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
for (i = 0; i < 3; i++) 34
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
487 /home/SySeVR/data/CVE_2011_3934_VULN_vp3_update_thread_context.c memcpy 37
static int CVE_2011_3934_VULN_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ]; 25
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
for (i = 0; i < 3; i++) 34
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
488 /home/SySeVR/data/CVE_2011_3934_VULN_vp3_update_thread_context.c memcpy 27
static int CVE_2011_3934_VULN_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ]; 25
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
copy_fields ( s , s1 , golden_frame , dsp ); 31
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
489 /home/SySeVR/data/CVE_2011_3934_VULN_vp3_update_thread_context.c memcpy 26
static int CVE_2011_3934_VULN_vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) 1
Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; 3
if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height )  8
if ( s != s1 )  16
if ( ! s -> current_frame . data [ 0 ] )  18
int y_fragment_count , c_fragment_count ; 19
s -> avctx = dst; 20
err = allocate_tables ( dst ); 21
if ( err )  22
y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ]; 24
memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ); 26
memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ); 27
copy_fields ( s , s1 , golden_frame , dsp ); 31
if ( s -> qps [ i ] != s1 -> qps [ 1 ] )  35
memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ); 37
if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] )  41
memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ); 42
copy_fields ( s , s1 , qps , superblock_count ); 45
0
------------------------------
490 /home/SySeVR/data/CVE_2011_4101_VULN_dissect_infiniband_common.c memcpy 184
static void
CVE_2011_4101_VULN_dissect_infiniband_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean starts_with_grh) 2
gint offset = 0 ; 26
dst_addr = ep_alloc ( ADDR_MAX_LEN ); 44
if ( tree && tree -> parent )  61
tree = tree -> parent; 64
if ( 0 && ! tree )  74
if ( starts_with_grh )  88
lnh_val = IBA_GLOBAL; 90
offset += 1; 108
lnh_val = tvb_get_guint8 ( tvb , offset ); 116
lnh_val = lnh_val & 0x03; 117
offset += 1; 118
* ( ( guint16 * ) dst_addr ) = tvb_get_ntohs ( tvb , offset ); 125
switch ( lnh_val )  150
memcpy ( dst_addr , & DSTgid , GID_SIZE ); 184
SET_ADDRESS ( & pinfo -> dst , AT_IB , GID_SIZE , dst_addr ); 185
g_snprintf ( dst_addr , ADDR_MAX_LEN , "IPv6 over IB Packet" ); 226
SET_ADDRESS ( & pinfo -> dst , AT_STRINGZ , ( int ) strlen ( dst_addr ) + 1 , dst_addr ); 227
0
------------------------------
491 /home/SySeVR/data/CVE_2011_4101_VULN_dissect_infiniband_common.c memcpy 174
static void
CVE_2011_4101_VULN_dissect_infiniband_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean starts_with_grh) 2
gint offset = 0 ; 26
src_addr = ep_alloc ( ADDR_MAX_LEN ); 43
if ( tree && tree -> parent )  61
tree = tree -> parent; 64
if ( 0 && ! tree )  74
if ( starts_with_grh )  88
lnh_val = IBA_GLOBAL; 90
offset += 1; 108
lnh_val = tvb_get_guint8 ( tvb , offset ); 116
lnh_val = lnh_val & 0x03; 117
offset += 1; 118
offset += 2; 128
offset += 2; 137
* ( ( guint16 * ) src_addr ) = tvb_get_ntohs ( tvb , offset ); 141
switch ( lnh_val )  150
memcpy ( src_addr , & SRCgid , GID_SIZE ); 174
SET_ADDRESS ( & pinfo -> src , AT_IB , GID_SIZE , src_addr ); 175
0
------------------------------
492 /home/SySeVR/data/CVE_2011_4594_PATCHED___sys_sendmsg.c memcpy 105
static int CVE_2011_4594_PATCHED___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
struct msghdr *msg_sys, unsigned flags,
struct used_address *used_address) 3
struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; 5
struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; 8
unsigned char * ctl_buf = ctl ; 12
int err , ctl_len , iov_size , total_len ; 13
err = - EFAULT; 15
if ( MSG_CMSG_COMPAT & flags )  16
if ( get_compat_msghdr ( msg_sys , msg_compat ) )  17
if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) )  19
err = - EMSGSIZE; 23
if ( msg_sys -> msg_iovlen > UIO_MAXIOV )  24
iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ); 29
if ( msg_sys -> msg_iovlen > UIO_FASTIOV )  30
iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ); 31
if ( ! iov )  32
if ( MSG_CMSG_COMPAT & flags )  37
err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 38
err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 42
if ( err < 0 )  45
total_len = err; 47
err = - ENOBUFS; 49
if ( msg_sys -> msg_controllen > INT_MAX )  51
ctl_len = msg_sys -> msg_controllen; 53
if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len )  54
err = cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , sizeof ( ctl ) ); 55
if ( err )  58
if ( ctl_len )  62
if ( ctl_len > sizeof ( ctl ) )  63
ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ); 64
if ( ctl_buf == NULL )  65
if ( copy_from_user ( ctl_buf , ( void __user __force * ) msg_sys -> msg_control , ctl_len ) )  74
msg_sys -> msg_control = ctl_buf; 78
msg_sys -> msg_flags = flags; 80
if ( sock -> file -> f_flags & O_NONBLOCK )  82
msg_sys -> msg_flags |= MSG_DONTWAIT; 83
if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) )  90
err = sock_sendmsg ( sock , msg_sys , total_len ); 97
if ( used_address && err >= 0 )  102
used_address -> name_len = msg_sys -> msg_namelen; 103
if ( msg_sys -> msg_name )  104
memcpy ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ); 105
0
------------------------------
493 /home/SySeVR/data/CVE_2012_3364_PATCHED_nci_extract_activation_params_iso_dep.c memcpy 23
static int CVE_2012_3364_PATCHED_nci_extract_activation_params_iso_dep(struct nci_dev *ndev,
struct nci_rf_intf_activated_ntf *ntf, __u8 *data) 2
struct activation_params_nfca_poll_iso_dep * nfca_poll ; 4
struct activation_params_nfcb_poll_iso_dep * nfcb_poll ; 5
switch ( ntf -> activation_rf_tech_and_mode )  7
nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep; 9
nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ); 10
nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep; 19
nfcb_poll -> attrib_res_len = min_t ( __u8 , * data ++ , 50 ); 20
if ( nfcb_poll -> attrib_res_len > 0 )  22
memcpy ( nfcb_poll -> attrib_res , data , nfcb_poll -> attrib_res_len ); 23
0
------------------------------
494 /home/SySeVR/data/CVE_2012_3364_PATCHED_nci_extract_activation_params_iso_dep.c memcpy 13
static int CVE_2012_3364_PATCHED_nci_extract_activation_params_iso_dep(struct nci_dev *ndev,
struct nci_rf_intf_activated_ntf *ntf, __u8 *data) 2
struct activation_params_nfca_poll_iso_dep * nfca_poll ; 4
switch ( ntf -> activation_rf_tech_and_mode )  7
nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep; 9
nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ); 10
if ( nfca_poll -> rats_res_len > 0 )  12
memcpy ( nfca_poll -> rats_res , data , nfca_poll -> rats_res_len ); 13
0
------------------------------
495 /home/SySeVR/data/CVE_2012_3364_VULN_nci_extract_rf_params_nfca_passive_poll.c memcpy 13
static __u8 *CVE_2012_3364_VULN_nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,
struct rf_tech_specific_params_nfca_poll *nfca_poll,
__u8 *data) 3
nfca_poll -> sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ); 5
data += 2; 6
nfca_poll -> nfcid1_len = * data ++; 8
memcpy ( nfca_poll -> nfcid1 , data , nfca_poll -> nfcid1_len ); 13
data += nfca_poll -> nfcid1_len; 14
nfca_poll -> sel_res_len = * data ++; 16
if ( nfca_poll -> sel_res_len != 0 )  18
nfca_poll -> sel_res = * data ++; 19
pr_debug ( "sel_res_len %d, sel_res 0x%x\n" , nfca_poll -> sel_res_len , nfca_poll -> sel_res ); 21
return data ; 25
0
------------------------------
496 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c memcpy 309
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
block_t * p_block ; 6
bool b_selected ; 7
int i_header_len = 0 ; 8
mtime_t i_pts = - 1 , i_interpolated_pts ; 9
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )  100
p_stream -> i_headers = 0; 103
p_stream -> p_headers = NULL; 104
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
p_stream -> fmt . i_extra = p_stream -> i_headers; 113
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers ); 114
if ( p_stream -> fmt . p_extra )  115
p_stream -> fmt . i_extra = 0; 119
b_selected = false; 134
if ( p_stream -> fmt . i_codec == VLC_CODEC_VORBIS || p_stream -> fmt . i_codec == VLC_CODEC_SPEEX || p_stream -> fmt . i_codec == VLC_CODEC_FLAC )  138
if ( p_stream -> i_pcr >= 0 )  142
p_stream -> i_previous_pcr = p_stream -> i_pcr; 156
i_pts = p_stream -> i_pcr; 159
i_interpolated_pts = p_stream -> i_interpolated_pcr; 164
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> i_pcr >= 0 )  185
p_stream -> i_previous_pcr = p_stream -> i_pcr; 190
i_pts = p_stream -> i_pcr; 193
if ( ! b_selected )  196
if ( p_oggpacket -> bytes <= 0 )  203
if ( ! ( p_block = block_New ( p_demux , p_oggpacket -> bytes ) ) )  206
if ( p_stream -> i_skip_frames > 0 )  210
p_block -> i_flags |= BLOCK_FLAG_PREROLL; 212
p_stream -> i_skip_frames --; 213
if ( i_pts == 0 )  218
i_pts = VLC_TS_0; 218
if ( i_pts == - 1 && i_interpolated_pts == 0 )  219
i_pts = VLC_TS_0; 219
if ( i_pts == - 1 )  220
i_pts = VLC_TS_INVALID; 220
if ( p_stream -> fmt . i_cat == AUDIO_ES )  222
p_block -> i_dts = p_block -> i_pts = i_pts; 223
if ( p_stream -> fmt . i_cat == SPU_ES )  224
p_block -> i_dts = p_block -> i_pts = i_pts; 226
p_block -> i_length = 0; 227
if ( p_stream -> fmt . i_codec == VLC_CODEC_THEORA )  229
p_block -> i_dts = p_block -> i_pts = i_pts; 231
if ( ( p_oggpacket -> granulepos & ( ( 1 << p_stream -> i_granule_shift ) - 1 ) ) == 0 )  232
p_block -> i_flags |= BLOCK_FLAG_TYPE_I; 234
if ( p_stream -> fmt . i_codec == VLC_CODEC_DIRAC )  237
ogg_int64_t dts = p_oggpacket -> granulepos >> 31 ; 239
ogg_int64_t delay = ( p_oggpacket -> granulepos >> 9 ) & 0x1fff ; 240
uint64_t u_pnum = dts + delay ; 242
p_block -> i_dts = p_stream -> i_pcr; 244
p_block -> i_pts = VLC_TS_INVALID; 245
if ( - 1 != p_oggpacket -> granulepos )  249
p_block -> i_pts = u_pnum * INT64_C ( 1000000 ) / p_stream -> f_rate / 2; 250
p_block -> i_dts = i_pts; 254
p_block -> i_pts = VLC_TS_INVALID; 255
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> fmt . i_codec != VLC_CODEC_TARKIN && p_stream -> fmt . i_codec != VLC_CODEC_THEORA && p_stream -> fmt . i_codec != VLC_CODEC_CMML && p_stream -> fmt . i_codec != VLC_CODEC_DIRAC && p_stream -> fmt . i_codec != VLC_CODEC_KATE )  258
i_header_len = ( * p_oggpacket -> packet & PACKET_LEN_BITS01 ) >> 6; 268
i_header_len |= ( * p_oggpacket -> packet & PACKET_LEN_BITS2 ) << 1; 269
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT )  271
int i , lenbytes = 0 ; 274
if ( i_header_len > 0 && p_oggpacket -> bytes >= i_header_len + 1 )  276
for( i = 0, lenbytes = 0; i < i_header_len; i++ ) 278
lenbytes = lenbytes << 8; 280
lenbytes += * ( p_oggpacket -> packet + i_header_len - i ); 281
if ( p_oggpacket -> bytes - 1 - i_header_len > 2 || ( p_oggpacket -> packet [ i_header_len + 1 ] != ' ' && p_oggpacket -> packet [ i_header_len + 1 ] != 0 && p_oggpacket -> packet [ i_header_len + 1 ] != '\n' && p_oggpacket -> packet [ i_header_len + 1 ] != '\r' ) )  284
p_block -> i_length = ( mtime_t ) lenbytes * 1000; 290
i_header_len ++; 294
if ( p_block -> i_buffer >= ( unsigned int ) i_header_len )  295
p_block -> i_buffer -= i_header_len; 296
p_block -> i_buffer = 0; 298
memcpy ( p_block -> p_buffer , p_oggpacket -> packet + i_header_len , p_oggpacket -> bytes - i_header_len ); 309
es_out_Send ( p_demux -> out , p_stream -> p_es , p_block ); 312
0
------------------------------
497 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c memcpy 116
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )  100
p_stream -> i_headers = 0; 103
p_stream -> p_headers = NULL; 104
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
p_stream -> fmt . i_extra = p_stream -> i_headers; 113
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers ); 114
if ( p_stream -> fmt . p_extra )  115
memcpy ( p_stream -> fmt . p_extra , p_stream -> p_headers , p_stream -> i_headers ); 116
0
------------------------------
498 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c memcpy 89
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
memcpy ( ( unsigned char * ) p_stream -> p_headers + p_stream -> i_headers - p_oggpacket -> bytes , p_oggpacket -> packet , p_stream -> i_headers ); 89
0
------------------------------
499 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
0
------------------------------
500 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
501 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
502 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 234
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
0
------------------------------
503 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 232
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
504 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c memcpy 230
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
int bytes_written = 0 ; 4
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
bytes_written += 2; 181
bytes_written += 2; 183
bytes_written += 2; 185
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 187
bytes_written += 2; 188
bytes_written += 4; 190
bytes_written += 2; 192
bytes_written += 2; 194
bytes_written += 4; 196
bytes_written += 4; 198
bytes_written += 8; 200
bytes_written += 8; 202
bytes_written += 4; 204
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 206
bytes_written += 4; 207
bytes_written += 2; 211
bytes_written += 2; 213
bytes_written += 2; 215
memset ( & data_ptr [ bytes_written ] , 0 , 2 ); 217
bytes_written += 2; 218
bytes_written += 4; 220
bytes_written += 4; 222
memset ( & data_ptr [ bytes_written ] , 0 , 4 ); 224
bytes_written += 4; 225
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
0
------------------------------
505 /home/SySeVR/data/CVE_2012_6538_PATCHED_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_PATCHED_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
0
------------------------------
506 /home/SySeVR/data/CVE_2012_6538_VULN_copy_to_user_auth.c memcpy 13
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
0
------------------------------
507 /home/SySeVR/data/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 36
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
0
------------------------------
508 /home/SySeVR/data/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 30
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( ! llc -> sap )  24
sllc . sllc_sap = llc -> sap -> laddr . lsap; 26
if ( llc -> dev )  28
sllc . sllc_arphrd = llc -> dev -> type; 29
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 30
sllc . sllc_family = AF_LLC; 35
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 36
0
------------------------------
509 /home/SySeVR/data/CVE_2012_6542_PATCHED_llc_ui_getname.c memcpy 21
static int CVE_2012_6542_PATCHED_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  14
if ( sk -> sk_state != TCP_ESTABLISHED )  16
if ( llc -> dev )  18
sllc . sllc_arphrd = llc -> dev -> type; 19
sllc . sllc_sap = llc -> daddr . lsap; 20
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 21
0
------------------------------
510 /home/SySeVR/data/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 37
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
0
------------------------------
511 /home/SySeVR/data/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 31
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( ! llc -> sap )  25
sllc . sllc_sap = llc -> sap -> laddr . lsap; 27
if ( llc -> dev )  29
sllc . sllc_arphrd = llc -> dev -> type; 30
memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ); 31
sllc . sllc_family = AF_LLC; 36
memcpy ( uaddr , & sllc , sizeof ( sllc ) ); 37
0
------------------------------
512 /home/SySeVR/data/CVE_2012_6542_VULN_llc_ui_getname.c memcpy 22
static int CVE_2012_6542_VULN_llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer) 2
struct sockaddr_llc sllc ; 4
struct sock * sk = sock -> sk ; 5
struct llc_sock * llc = llc_sk ( sk ) ; 6
memset ( & sllc , 0 , sizeof ( sllc ) ); 9
if ( sock_flag ( sk , SOCK_ZAPPED ) )  11
if ( peer )  15
if ( sk -> sk_state != TCP_ESTABLISHED )  17
if ( llc -> dev )  19
sllc . sllc_arphrd = llc -> dev -> type; 20
sllc . sllc_sap = llc -> daddr . lsap; 21
memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ); 22
0
------------------------------
513 /home/SySeVR/data/CVE_2012_6547_PATCHED___tun_chr_ioctl.c memcpy 129
static long CVE_2012_6547_PATCHED___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  19
tun = __tun_get ( tfile ); 30
if ( cmd == TUNSETIFF && ! tun )  31
if ( ! tun )  45
switch ( cmd )  51
if ( tun -> dev -> flags & IFF_UP )  99
tun -> dev -> type = ( int ) arg; 104
tun -> debug = arg; 112
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 129
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 130
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  131
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 138
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 140
return ret ; 206
0
------------------------------
514 /home/SySeVR/data/CVE_2012_6547_VULN___tun_chr_ioctl.c memcpy 127
static long CVE_2012_6547_VULN___tun_chr_ioctl(struct file *file, unsigned int cmd,
unsigned long arg, int ifreq_len) 2
struct tun_file * tfile = file -> private_data ; 4
struct tun_struct * tun ; 5
void __user * argp = ( void __user * ) arg ; 6
struct ifreq ifr ; 8
if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  13
if ( copy_from_user ( & ifr , argp , ifreq_len ) )  14
if ( cmd == TUNGETFEATURES )  17
tun = __tun_get ( tfile ); 28
if ( cmd == TUNSETIFF && ! tun )  29
if ( ! tun )  43
switch ( cmd )  49
memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ); 127
ifr . ifr_hwaddr . sa_family = tun -> dev -> type; 128
if ( copy_to_user ( argp , & ifr , ifreq_len ) )  129
DBG ( KERN_DEBUG "%s: set hw address: %pM\n" ,
tun -> dev -> name , ifr . ifr_hwaddr . sa_data ) 136
ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ); 138
return ret ; 204
0
------------------------------
515 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c memcpy 74
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
drow_end = mGIFStruct . height - 1; 29
if ( drow_start < 0 )  32
drow_start = 0; 33
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
drow_end = mGIFStruct . height - 1; 35
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
if ( drow_end > drow_start )  70
for (int r = drow_start; r <= drow_end; r++) 72
if ( r != int ( mGIFStruct . irow ) )  73
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 74
0
------------------------------
516 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c memcpy 29
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* outString = temp; 22
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
0
------------------------------
517 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c memcpy 287
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
0
------------------------------
518 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c memcpy 287
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
memcpy ( c , h -> s . thread_context [ i ] , sizeof ( MpegEncContext ) ); 287
memset ( & c -> s + 1 , 0 , sizeof ( H264Context ) - sizeof ( MpegEncContext ) ); 288
c -> h264dsp = h -> h264dsp; 289
c -> sps = h -> sps; 290
c -> pps = h -> pps; 291
c -> pixel_shift = h -> pixel_shift; 292
c -> cur_chroma_format_idc = h -> cur_chroma_format_idc; 293
init_scan_tables ( c ); 294
clone_tables ( c , h , i ); 295
0
------------------------------
519 /home/SySeVR/data/CVE_2013_0856_PATCHED_lpc_prediction.c memcpy 15
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ); 15
0
------------------------------
520 /home/SySeVR/data/CVE_2013_0868_PATCHED_read_old_huffman_tables.c memcpy 25
static int CVE_2013_0868_PATCHED_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  9
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  14
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 17
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 18
if ( s -> bitstream_bpp >= 24 )  20
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 21
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 22
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 24
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 25
ff_free_vlc ( & s -> vlc [ i ] ); 28
if ( ( ret = init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ) < 0 )  29
return ret ; 31
generate_joint_tables ( s ); 34
0
------------------------------
521 /home/SySeVR/data/CVE_2013_0868_PATCHED_read_old_huffman_tables.c memcpy 24
static int CVE_2013_0868_PATCHED_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  9
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  14
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 17
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 18
if ( s -> bitstream_bpp >= 24 )  20
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 21
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 22
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 24
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 25
ff_free_vlc ( & s -> vlc [ i ] ); 28
if ( ( ret = init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ) < 0 )  29
return ret ; 31
generate_joint_tables ( s ); 34
0
------------------------------
522 /home/SySeVR/data/CVE_2013_0868_PATCHED_read_old_huffman_tables.c memcpy 22
static int CVE_2013_0868_PATCHED_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  9
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  14
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 17
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 18
if ( s -> bitstream_bpp >= 24 )  20
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 21
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 22
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 24
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 25
ff_free_vlc ( & s -> vlc [ i ] ); 28
if ( ( ret = init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ) < 0 )  29
return ret ; 31
generate_joint_tables ( s ); 34
0
------------------------------
523 /home/SySeVR/data/CVE_2013_0868_PATCHED_read_old_huffman_tables.c memcpy 21
static int CVE_2013_0868_PATCHED_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  9
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  14
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 17
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 18
if ( s -> bitstream_bpp >= 24 )  20
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 21
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 22
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 24
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 25
ff_free_vlc ( & s -> vlc [ i ] ); 28
if ( ( ret = init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ) ) < 0 )  29
return ret ; 31
generate_joint_tables ( s ); 34
0
------------------------------
524 /home/SySeVR/data/CVE_2013_0868_VULN_read_old_huffman_tables.c memcpy 24
static int CVE_2013_0868_VULN_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  8
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  13
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 16
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 17
if ( s -> bitstream_bpp >= 24 )  19
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 20
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 21
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 23
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 24
ff_free_vlc ( & s -> vlc [ i ] ); 27
init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ); 28
generate_joint_tables ( s ); 32
0
------------------------------
525 /home/SySeVR/data/CVE_2013_0868_VULN_read_old_huffman_tables.c memcpy 23
static int CVE_2013_0868_VULN_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  8
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  13
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 16
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 17
if ( s -> bitstream_bpp >= 24 )  19
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 20
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 21
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 23
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 24
ff_free_vlc ( & s -> vlc [ i ] ); 27
init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ); 28
generate_joint_tables ( s ); 32
0
------------------------------
526 /home/SySeVR/data/CVE_2013_0868_VULN_read_old_huffman_tables.c memcpy 21
static int CVE_2013_0868_VULN_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  8
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  13
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 16
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 17
if ( s -> bitstream_bpp >= 24 )  19
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 20
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 21
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 23
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 24
ff_free_vlc ( & s -> vlc [ i ] ); 27
init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ); 28
generate_joint_tables ( s ); 32
0
------------------------------
527 /home/SySeVR/data/CVE_2013_0868_VULN_read_old_huffman_tables.c memcpy 20
static int CVE_2013_0868_VULN_read_old_huffman_tables(HYuvContext *s) 1
GetBitContext gb ; 3
int i ; 4
if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 )  8
if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 )  13
for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i]; 16
for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i]; 17
if ( s -> bitstream_bpp >= 24 )  19
memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ); 20
memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ); 21
memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ); 23
memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ); 24
ff_free_vlc ( & s -> vlc [ i ] ); 27
init_vlc ( & s -> vlc [ i ] , VLC_BITS , 256 , s -> len [ i ] , 1 , 1 , s -> bits [ i ] , 4 , 4 , 0 ); 28
generate_joint_tables ( s ); 32
0
------------------------------
528 /home/SySeVR/data/CVE_2013_1828_VULN_sctp_getsockopt_assoc_stats.c memcpy 39
static int CVE_2013_1828_VULN_sctp_getsockopt_assoc_stats(struct sock *sk, int len,
char __user *optval,
int __user *optlen) 3
struct sctp_assoc_stats sas ; 5
if ( len < sizeof ( sctp_assoc_t ) )  9
if ( copy_from_user ( & sas , optval , len ) )  12
asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ); 15
if ( ! asoc )  16
sas . sas_rtxchunks = asoc -> stats . rtxchunks; 19
sas . sas_gapcnt = asoc -> stats . gapcnt; 20
sas . sas_outofseqtsns = asoc -> stats . outofseqtsns; 21
sas . sas_osacks = asoc -> stats . osacks; 22
sas . sas_isacks = asoc -> stats . isacks; 23
sas . sas_octrlchunks = asoc -> stats . octrlchunks; 24
sas . sas_ictrlchunks = asoc -> stats . ictrlchunks; 25
sas . sas_oodchunks = asoc -> stats . oodchunks; 26
sas . sas_iodchunks = asoc -> stats . iodchunks; 27
sas . sas_ouodchunks = asoc -> stats . ouodchunks; 28
sas . sas_iuodchunks = asoc -> stats . iuodchunks; 29
sas . sas_idupchunks = asoc -> stats . idupchunks; 30
sas . sas_opackets = asoc -> stats . opackets; 31
sas . sas_ipackets = asoc -> stats . ipackets; 32
sas . sas_maxrto = asoc -> stats . max_obs_rto; 38
memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ); 39
SCTP_DEBUG_PRINTK ( "sctp_getsockopt_assoc_stat(%d): %d\n" , len , sas . sas_assoc_id ); 51
if ( copy_to_user ( optval , & sas , len ) )  54
0
------------------------------
529 /home/SySeVR/data/CVE_2013_2547_VULN_crypto_report_one.c memcpy 7
static int CVE_2013_2547_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , CRYPTO_MAX_ALG_NAME ); 7
ualg -> cru_flags = alg -> cra_flags; 10
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 11
0
------------------------------
530 /home/SySeVR/data/CVE_2013_2547_VULN_crypto_report_one.c memcpy 5
static int CVE_2013_2547_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , CRYPTO_MAX_ALG_NAME ); 7
ualg -> cru_flags = alg -> cra_flags; 10
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 11
0
------------------------------
531 /home/SySeVR/data/CVE_2013_2547_VULN_crypto_report_one.c memcpy 4
static int CVE_2013_2547_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , CRYPTO_MAX_ALG_NAME ); 7
ualg -> cru_flags = alg -> cra_flags; 10
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 11
0
------------------------------
532 /home/SySeVR/data/CVE_2013_2548_VULN_crypto_report_one.c memcpy 7
static int CVE_2013_2548_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , CRYPTO_MAX_ALG_NAME ); 7
ualg -> cru_flags = alg -> cra_flags; 10
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 11
0
------------------------------
533 /home/SySeVR/data/CVE_2013_2548_VULN_crypto_report_one.c memcpy 5
static int CVE_2013_2548_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , CRYPTO_MAX_ALG_NAME ); 7
ualg -> cru_flags = alg -> cra_flags; 10
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 11
0
------------------------------
534 /home/SySeVR/data/CVE_2013_2548_VULN_crypto_report_one.c memcpy 4
static int CVE_2013_2548_VULN_crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb) 2
memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ); 4
memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ); 5
memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , CRYPTO_MAX_ALG_NAME ); 7
ualg -> cru_flags = alg -> cra_flags; 10
ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ); 11
0
------------------------------
535 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_decode_text_input.c memcpy 17
int CVE_2013_2850_PATCHED_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
kfree ( tmpbuf ); 27
kfree ( tmpbuf ); 35
kfree ( tmpbuf ); 44
start += strlen ( key ) + strlen ( value ) + 2; 47
kfree ( tmpbuf ); 51
start += strlen ( key ) + strlen ( value ) + 2; 55
kfree ( tmpbuf ); 59
kfree ( tmpbuf ); 65
kfree ( tmpbuf ); 72
0
------------------------------
536 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c memcpy 17
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
kfree ( tmpbuf ); 27
kfree ( tmpbuf ); 37
kfree ( tmpbuf ); 46
start += strlen ( key ) + strlen ( value ) + 2; 49
kfree ( tmpbuf ); 53
start += strlen ( key ) + strlen ( value ) + 2; 57
kfree ( tmpbuf ); 61
kfree ( tmpbuf ); 67
kfree ( tmpbuf ); 74
0
------------------------------
537 /home/SySeVR/data/CVE_2013_3670_PATCHED_rle_unpack.c memcpy 29
static int CVE_2013_3670_PATCHED_rle_unpack(const unsigned char *src, int src_len, int src_count,
unsigned char *dest, int dest_len) 2
const unsigned char * ps ; 4
const unsigned char * ps_end ; 5
unsigned char * pd ; 6
int i , j , l ; 7
unsigned char * dest_end = dest + dest_len ; 8
ps = src; 10
ps_end = src + src_len; 11
pd = dest; 12
if ( src_count & 1 )  13
if ( ps_end - ps < 1 )  14
* pd ++ = * ps ++; 16
src_count >>= 1; 19
i = 0; 20
if ( ps_end - ps < 1 )  22
l = * ps ++; 24
if ( l & 0x80 )  25
l = ( l & 0x7F ) * 2; 26
if ( dest_end - pd < l || ps_end - ps < l )  27
memcpy ( pd , ps , l ); 29
ps += l; 30
pd += l; 31
if ( dest_end - pd < 2 * l || ps_end - ps < 2 )  33
for (j = 0; j < l; j++) 35
* pd ++ = ps [ 0 ]; 36
* pd ++ = ps [ 1 ]; 37
ps += 2; 39
i += l; 41
while ( i < src_count )  42
0
------------------------------
538 /home/SySeVR/data/CVE_2013_3670_VULN_rle_unpack.c memcpy 29
static int CVE_2013_3670_VULN_rle_unpack(const unsigned char *src, int src_len, int src_count,
unsigned char *dest, int dest_len) 2
const unsigned char * ps ; 4
const unsigned char * ps_end ; 5
unsigned char * pd ; 6
int i , l ; 7
unsigned char * dest_end = dest + dest_len ; 8
ps = src; 10
ps_end = src + src_len; 11
pd = dest; 12
if ( src_count & 1 )  13
if ( ps_end - ps < 1 )  14
* pd ++ = * ps ++; 16
src_count >>= 1; 19
i = 0; 20
if ( ps_end - ps < 1 )  22
l = * ps ++; 24
if ( l & 0x80 )  25
l = ( l & 0x7F ) * 2; 26
if ( dest_end - pd < l || ps_end - ps < l )  27
memcpy ( pd , ps , l ); 29
ps += l; 30
pd += l; 31
if ( dest_end - pd < i || ps_end - ps < 2 )  33
for (i = 0; i < l; i++) 35
* pd ++ = ps [ 0 ]; 36
* pd ++ = ps [ 1 ]; 37
ps += 2; 39
i += l; 41
while ( i < src_count )  42
0
------------------------------
539 /home/SySeVR/data/CVE_2013_4514_VULN_wvlan_set_station_nickname.c memcpy 19
int CVE_2013_4514_VULN_wvlan_set_station_nickname(struct net_device *dev,
struct iw_request_info *info,
union iwreq_data *wrqu,
char *extra) 4
struct wl_private * lp = wl_priv ( dev ) ; 6
memset ( lp -> StationName , 0 , sizeof ( lp -> StationName ) ); 17
memcpy ( lp -> StationName , extra , wrqu -> data . length ); 19
wl_apply ( lp ); 22
wl_unlock ( lp , & flags ); 23
0
------------------------------
540 /home/SySeVR/data/CVE_2013_4516_PATCHED_mp_get_count.c memcpy 8
static int CVE_2013_4516_PATCHED_mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt) 1
struct sb_uart_icount cnow ; 4
struct sb_uart_port * port = state -> port ; 5
memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ); 8
icount . cts = cnow . cts; 11
icount . dsr = cnow . dsr; 12
icount . rng = cnow . rng; 13
icount . dcd = cnow . dcd; 14
icount . rx = cnow . rx; 15
icount . tx = cnow . tx; 16
icount . frame = cnow . frame; 17
icount . overrun = cnow . overrun; 18
icount . parity = cnow . parity; 19
icount . brk = cnow . brk; 20
icount . buf_overrun = cnow . buf_overrun; 21
return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; 23
0
------------------------------
541 /home/SySeVR/data/CVE_2013_4516_VULN_mp_get_count.c memcpy 8
static int CVE_2013_4516_VULN_mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt) 1
struct sb_uart_icount cnow ; 4
struct sb_uart_port * port = state -> port ; 5
memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ); 8
icount . cts = cnow . cts; 11
icount . dsr = cnow . dsr; 12
icount . rng = cnow . rng; 13
icount . dcd = cnow . dcd; 14
icount . rx = cnow . rx; 15
icount . tx = cnow . tx; 16
icount . frame = cnow . frame; 17
icount . overrun = cnow . overrun; 18
icount . parity = cnow . parity; 19
icount . brk = cnow . brk; 20
icount . buf_overrun = cnow . buf_overrun; 21
return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; 23
0
------------------------------
542 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c memcpy 180
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
u32 data_dir ; 13
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 55
if ( ! user_srbcmd )  56
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  61
flags = user_srbcmd -> flags; 69
switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  82
data_dir = DMA_TO_DEVICE; 84
data_dir = DMA_BIDIRECTIONAL; 87
data_dir = DMA_FROM_DEVICE; 90
data_dir = DMA_NONE; 93
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); 101
actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); 103
if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  106
if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  117
if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  123
struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; 124
if ( actual_fibsize64 == fibsize )  130
struct user_sgmap * usg ; 172
usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); 173
if ( ! usg )  175
memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); 180
for (i = 0; i < usg->count; i++) 184
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
kfree ( usg ); 192
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" ,
usg -> sg [ i ] . count , i , usg -> count ) ) 200
kfree ( usg ); 201
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
kfree ( usg ); 211
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
kfree ( usg ); 224
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
dprintk ( ( KERN_DEBUG "aacraid: Could not send raw srb fib to hba\n" ) ) 322
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
dprintk ( ( KERN_DEBUG "aacraid: Could not copy sg data to user\n" ) ) 334
dprintk ( ( KERN_DEBUG "aacraid: Could not copy reply to user\n" ) ) 344
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
0
------------------------------
543 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c memcpy 80
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
srbfib -> hw_fib_va -> header . XferState &= ~cpu_to_le32 ( FastResponseCapable ); 38
srbcmd = ( struct aac_srb * ) fib_data ( srbfib ); 40
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 55
if ( ! user_srbcmd )  56
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  61
flags = user_srbcmd -> flags; 69
srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ); 72
srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ); 73
srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ); 74
srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ); 75
srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ); 76
srbcmd -> flags = cpu_to_le32 ( flags ); 77
srbcmd -> retry_limit = 0; 78
srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ); 79
memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ); 80
0
------------------------------
544 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c memcpy 179
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
u32 data_dir ; 13
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 54
if ( ! user_srbcmd )  55
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  60
flags = user_srbcmd -> flags; 68
switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  81
data_dir = DMA_TO_DEVICE; 83
data_dir = DMA_BIDIRECTIONAL; 86
data_dir = DMA_FROM_DEVICE; 89
data_dir = DMA_NONE; 92
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); 100
actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); 102
if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  105
if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  116
if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  122
struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; 123
if ( actual_fibsize64 == fibsize )  129
struct user_sgmap * usg ; 171
usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); 172
if ( ! usg )  174
memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); 179
for (i = 0; i < usg->count; i++) 183
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
kfree ( usg ); 191
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" ,
usg -> sg [ i ] . count , i , usg -> count ) ) 199
kfree ( usg ); 200
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
kfree ( usg ); 210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
kfree ( usg ); 223
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
dprintk ( ( KERN_DEBUG "aacraid: Could not send raw srb fib to hba\n" ) ) 321
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
dprintk ( ( KERN_DEBUG "aacraid: Could not copy sg data to user\n" ) ) 333
dprintk ( ( KERN_DEBUG "aacraid: Could not copy reply to user\n" ) ) 343
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
0
------------------------------
545 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c memcpy 79
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
srbfib -> hw_fib_va -> header . XferState &= ~cpu_to_le32 ( FastResponseCapable ); 38
srbcmd = ( struct aac_srb * ) fib_data ( srbfib ); 40
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 54
if ( ! user_srbcmd )  55
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  60
flags = user_srbcmd -> flags; 68
srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ); 71
srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ); 72
srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ); 73
srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ); 74
srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ); 75
srbcmd -> flags = cpu_to_le32 ( flags ); 76
srbcmd -> retry_limit = 0; 77
srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ); 78
memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ); 79
dprintk ( ( KERN_DEBUG "aacraid: too many sg entries %d\n" ,
le32_to_cpu ( srbcmd -> sg . count ) ) ) 96
0
------------------------------
546 /home/SySeVR/data/CVE_2013_6381_PATCHED_qeth_snmp_command.c memcpy 42
int CVE_2013_6381_PATCHED_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_ipa_cmd * cmd ; 4
struct qeth_snmp_ureq * ureq ; 5
unsigned int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) )  22
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 26
if ( IS_ERR ( ureq ) )  27
qinfo . udata_len = ureq -> hdr . data_len; 31
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 32
if ( ! qinfo . udata )  33
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 39
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 41
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 42
0
------------------------------
547 /home/SySeVR/data/CVE_2013_6381_VULN_qeth_snmp_command.c memcpy 38
int CVE_2013_6381_VULN_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_ipa_cmd * cmd ; 4
struct qeth_snmp_ureq * ureq ; 5
int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 22
if ( IS_ERR ( ureq ) )  23
qinfo . udata_len = ureq -> hdr . data_len; 27
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 28
if ( ! qinfo . udata )  29
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 35
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 37
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 38
0
------------------------------
548 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c memcpy 180
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
int i , j , context_count = - 1 ; 4
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
context_count = f -> context_count [ idx ]; 178
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( f -> version <= 2 )  183
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
0
------------------------------
549 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c memcpy 176
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
0
------------------------------
550 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c memcpy 44
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
if ( next > - FF_INPUT_BUFFER_PADDING_SIZE )  43
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
* buf = pc -> buffer; 47
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 60
0
------------------------------
551 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c memcpy 28
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
* buf = pc -> buffer; 47
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 60
0
------------------------------
552 /home/SySeVR/data/CVE_2013_7268_PATCHED_ipx_recvmsg.c memcpy 58
static int CVE_2013_7268_PATCHED_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; 6
struct sk_buff * skb ; 8
int copied , rc ; 9
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
rc = - ENETDOWN; 20
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
rc = - ENOTCONN; 32
if ( sock_flag ( sk , SOCK_ZAPPED ) )  33
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
copied = size; 44
msg -> msg_flags |= MSG_TRUNC; 45
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( sipx )  55
sipx -> sipx_family = AF_IPX; 56
sipx -> sipx_port = ipx -> ipx_source . sock; 57
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 58
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 59
sipx -> sipx_type = ipx -> ipx_type; 60
sipx -> sipx_zero = 0; 61
msg -> msg_namelen = sizeof ( * sipx ); 62
0
------------------------------
553 /home/SySeVR/data/CVE_2013_7268_PATCHED_ipx_recvmsg.c memcpy 23
static int CVE_2013_7268_PATCHED_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( skb -> tstamp . tv64 )  52
sk -> sk_stamp = skb -> tstamp; 53
sipx -> sipx_port = ipx -> ipx_source . sock; 57
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 58
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 59
sipx -> sipx_type = ipx -> ipx_type; 60
sipx -> sipx_zero = 0; 61
msg -> msg_namelen = sizeof ( * sipx ); 62
rc = copied; 64
skb_free_datagram ( sk , skb ); 67
release_sock ( sk ); 69
return rc ; 70
0
------------------------------
554 /home/SySeVR/data/CVE_2013_7268_VULN_ipx_recvmsg.c memcpy 60
static int CVE_2013_7268_VULN_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; 6
struct sk_buff * skb ; 8
int copied , rc ; 9
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
rc = - ENETDOWN; 20
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
rc = - ENOTCONN; 32
if ( sock_flag ( sk , SOCK_ZAPPED ) )  33
skb = skb_recv_datagram ( sk , flags & ~MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ); 36
if ( ! skb )  38
ipx = ipx_hdr ( skb ); 41
copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ); 42
if ( copied > size )  43
copied = size; 44
msg -> msg_flags |= MSG_TRUNC; 45
rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ); 48
if ( rc )  50
if ( sipx )  57
sipx -> sipx_family = AF_IPX; 58
sipx -> sipx_port = ipx -> ipx_source . sock; 59
memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ); 60
sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net; 61
sipx -> sipx_type = ipx -> ipx_type; 62
sipx -> sipx_zero = 0; 63
0
------------------------------
555 /home/SySeVR/data/CVE_2013_7268_VULN_ipx_recvmsg.c memcpy 23
static int CVE_2013_7268_VULN_ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t size, int flags) 2
struct sock * sk = sock -> sk ; 4
struct ipx_sock * ipxs = ipx_sk ( sk ) ; 5
if ( ! ipxs -> port )  13
struct sockaddr_ipx uaddr ; 14
uaddr . sipx_port = 0; 16
uaddr . sipx_network = 0; 17
if ( ! ipxs -> intrfc )  21
memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ); 23
rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ); 26
if ( rc )  28
return rc ; 71
0
------------------------------
556 /home/SySeVR/data/CVE_2013_7270_PATCHED_packet_recvmsg.c memcpy 116
static int CVE_2013_7270_PATCHED_packet_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len, int flags) 2
struct sock * sk = sock -> sk ; 4
struct sk_buff * skb ; 5
int copied , err ; 6
err = - EINVAL; 9
if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) )  10
if ( pkt_sk ( sk ) -> ifindex < 0 )  15
if ( flags & MSG_ERRQUEUE )  19
skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); 33
if ( skb == NULL )  41
if ( pkt_sk ( sk ) -> has_vnet_hdr )  44
struct virtio_net_hdr vnet_hdr = { 0 } ; 45
vnet_hdr_len = sizeof ( vnet_hdr ); 48
if ( len < vnet_hdr_len )  49
len -= vnet_hdr_len; 52
if ( skb_is_gso ( skb ) )  54
struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; 55
vnet_hdr . hdr_len = skb_headlen ( skb ); 58
vnet_hdr . gso_size = sinfo -> gso_size; 59
if ( sinfo -> gso_type & SKB_GSO_TCPV4 )  60
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4; 61
if ( sinfo -> gso_type & SKB_GSO_TCPV6 )  62
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6; 63
if ( sinfo -> gso_type & SKB_GSO_UDP )  64
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP; 65
if ( sinfo -> gso_type & SKB_GSO_FCOE )  66
if ( sinfo -> gso_type & SKB_GSO_TCP_ECN )  70
vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN; 71
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE; 73
if ( skb -> ip_summed == CHECKSUM_PARTIAL )  75
if ( skb -> ip_summed == CHECKSUM_UNNECESSARY )  79
vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID; 80
err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ); 83
if ( err < 0 )  85
copied = skb -> len; 93
if ( copied > len )  94
copied = len; 95
msg -> msg_flags |= MSG_TRUNC; 96
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 99
if ( err )  100
if ( msg -> msg_name )  105
if ( sock -> type == SOCK_PACKET )  109
msg -> msg_namelen = sizeof ( struct sockaddr_pkt ); 110
msg -> msg_namelen = sll -> sll_halen +
offsetof ( struct sockaddr_ll , sll_addr ) 114
memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ); 116
put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ); 137
0
------------------------------
557 /home/SySeVR/data/CVE_2013_7270_VULN_packet_recvmsg.c memcpy 119
static int CVE_2013_7270_VULN_packet_recvmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len, int flags) 2
struct sock * sk = sock -> sk ; 4
struct sk_buff * skb ; 5
int copied , err ; 6
struct sockaddr_ll * sll ; 7
err = - EINVAL; 10
if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) )  11
if ( pkt_sk ( sk ) -> ifindex < 0 )  16
if ( flags & MSG_ERRQUEUE )  20
skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); 34
if ( skb == NULL )  42
if ( pkt_sk ( sk ) -> has_vnet_hdr )  45
struct virtio_net_hdr vnet_hdr = { 0 } ; 46
err = - EINVAL; 48
vnet_hdr_len = sizeof ( vnet_hdr ); 49
if ( len < vnet_hdr_len )  50
len -= vnet_hdr_len; 53
if ( skb_is_gso ( skb ) )  55
struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; 56
vnet_hdr . hdr_len = skb_headlen ( skb ); 59
vnet_hdr . gso_size = sinfo -> gso_size; 60
if ( sinfo -> gso_type & SKB_GSO_TCPV4 )  61
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4; 62
if ( sinfo -> gso_type & SKB_GSO_TCPV6 )  63
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6; 64
if ( sinfo -> gso_type & SKB_GSO_UDP )  65
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP; 66
if ( sinfo -> gso_type & SKB_GSO_FCOE )  67
if ( sinfo -> gso_type & SKB_GSO_TCP_ECN )  71
vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN; 72
vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE; 74
if ( skb -> ip_summed == CHECKSUM_PARTIAL )  76
if ( skb -> ip_summed == CHECKSUM_UNNECESSARY )  80
vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID; 81
err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ); 84
if ( err < 0 )  86
sll = & PACKET_SKB_CB ( skb ) -> sa . ll; 95
if ( sock -> type == SOCK_PACKET )  96
msg -> msg_namelen = sizeof ( struct sockaddr_pkt ); 97
msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) 99
copied = skb -> len; 106
if ( copied > len )  107
copied = len; 108
msg -> msg_flags |= MSG_TRUNC; 109
err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); 112
if ( err )  113
if ( msg -> msg_name )  118
memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ); 119
put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ); 139
0
------------------------------
558 /home/SySeVR/data/CVE_2014_0160_PATCHED_tls1_process_heartbeat.c memcpy 38
int
CVE_2014_0160_PATCHED_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
if ( 1 + 2 + 16 > s -> s3 -> rrec . length )  15
hbtype = * p ++; 17
if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length )  19
pl = p; 21
if ( hbtype == TLS1_HB_REQUEST )  23
unsigned char * buffer , * bp ; 25
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 32
bp = buffer; 33
* bp ++ = TLS1_HB_RESPONSE; 36
memcpy ( bp , pl , payload ); 38
bp += payload; 39
RAND_pseudo_bytes ( bp , padding ); 41
0
------------------------------
559 /home/SySeVR/data/CVE_2014_0160_VULN_dtls1_process_heartbeat.c memcpy 34
int
CVE_2014_0160_VULN_dtls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
pl = p; 12
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
bp = buffer; 29
* bp ++ = TLS1_HB_RESPONSE; 32
memcpy ( bp , pl , payload ); 34
bp += payload; 35
RAND_pseudo_bytes ( bp , padding ); 37
0
------------------------------
560 /home/SySeVR/data/CVE_2014_0160_VULN_tls1_process_heartbeat.c memcpy 34
int
CVE_2014_0160_VULN_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
pl = p; 12
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
bp = buffer; 29
* bp ++ = TLS1_HB_RESPONSE; 32
memcpy ( bp , pl , payload ); 34
bp += payload; 35
RAND_pseudo_bytes ( bp , padding ); 37
0
------------------------------
561 /home/SySeVR/data/CVE_2014_1509_VULN__cairo_dwrite_load_truetype_table.c memcpy 27
cairo_int_status_t
CVE_2014_1509_VULN__cairo_dwrite_load_truetype_table(void                 *scaled_font,
unsigned long         tag,
long                  offset,
unsigned char        *buffer,
unsigned long        *length) 6
const void * data ; 11
UINT32 size ; 12
BOOL exists ; 14
if ( ! exists )  21
if ( buffer )  26
memcpy ( buffer , data , size ); 27
0
------------------------------
562 /home/SySeVR/data/CVE_2014_3183_VULN_logi_dj_ll_raw_request.c memcpy 23
static int CVE_2014_3183_VULN_logi_dj_ll_raw_request(struct hid_device *hid,
unsigned char reportnum, __u8 *buf,
size_t count, unsigned char report_type,
int reqtype) 4
struct dj_device * djdev = hid -> driver_data ; 6
u8 * out_buf ; 8
if ( buf [ 0 ] != REPORT_TYPE_LEDS )  11
out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ); 14
if ( ! out_buf )  15
if ( count < DJREPORT_SHORT_LENGTH - 2 )  18
count = DJREPORT_SHORT_LENGTH - 2; 19
out_buf [ 0 ] = REPORT_ID_DJ_SHORT; 21
out_buf [ 1 ] = djdev -> device_index; 22
memcpy ( out_buf + 2 , buf , count ); 23
ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ); 25
kfree ( out_buf ); 28
return ret ; 29
0
------------------------------
563 /home/SySeVR/data/CVE_2014_3185_PATCHED_command_port_read_callback.c memcpy 40
static void CVE_2014_3185_PATCHED_command_port_read_callback(struct urb *urb) 1
struct usb_serial_port * command_port = urb -> context ; 3
struct whiteheat_command_private * command_info ; 4
int status = urb -> status ; 5
unsigned char * data = urb -> transfer_buffer ; 6
command_info = usb_get_serial_port_data ( command_port ); 9
if ( ! command_info )  10
if ( ! urb -> actual_length )  14
if ( status )  18
if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE )  28
if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE )  31
if ( data [ 0 ] == WHITEHEAT_EVENT )  34
if ( ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) )  38
memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ); 40
command_info -> command_finished = WHITEHEAT_CMD_COMPLETE; 42
wake_up ( & command_info -> wait_command ); 43
0
------------------------------
564 /home/SySeVR/data/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c memcpy 177
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( s -> tlsext_debug_cb )  37
s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ); 38
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( s -> session -> tlsext_ecpointformatlist != NULL )  66
OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ); 66
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
n2s ( sdata , s -> s3 -> server_opaque_prf_input_len ); 112
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input != NULL )  119
OPENSSL_free ( s -> s3 -> server_opaque_prf_input ); 120
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
if ( ! s -> hit && tlsext_servername == 1 )  221
if ( s -> tlsext_hostname )  223
if ( s -> session -> tlsext_hostname == NULL )  225
s -> session -> tlsext_hostname = BUF_strdup ( s -> tlsext_hostname ); 227
if ( ! s -> session -> tlsext_hostname )  228
if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) )  253
0
------------------------------
565 /home/SySeVR/data/CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext.c memcpy 73
int CVE_2014_3509_PATCHED_ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) 1
unsigned short length ; 3
unsigned short type ; 4
unsigned short size ; 5
unsigned char * data = * p ; 6
s -> s3 -> next_proto_neg_seen = 0; 11
s -> tlsext_heartbeat &= ~ ( SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS ); 15
if ( data >= ( d + n - 2 ) )  19
if ( data + length != d + n )  23
while ( data <= ( d + n - 4 ) )  29
if ( data + size > ( d + n ) )  34
if ( type == TLSEXT_TYPE_server_name )  41
if ( s -> tlsext_hostname == NULL || size > 0 )  43
if ( type == TLSEXT_TYPE_ec_point_formats && s -> version != DTLS1_VERSION )  52
unsigned char * sdata = data ; 55
int ecpointformatlist_length = * ( sdata ++ ) ; 56
if ( ecpointformatlist_length != size - 1 )  58
if ( ! s -> hit )  63
s -> session -> tlsext_ecpointformatlist_length = 0; 65
if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL )  67
s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length; 72
memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ); 73
sdata = s -> session -> tlsext_ecpointformatlist; 77
for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) 78
fprintf ( stderr , "%i " , * ( sdata ++ ) ); 79
if ( type == TLSEXT_TYPE_session_ticket )  85
if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) )  87
if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) )  93
s -> tlsext_ticket_expected = 1; 99
if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION )  102
unsigned char * sdata = data ; 105
if ( size < 2 )  107
if ( s -> s3 -> server_opaque_prf_input_len != size - 2 )  113
if ( s -> s3 -> server_opaque_prf_input_len == 0 )  121
s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ); 122
s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ); 124
if ( s -> s3 -> server_opaque_prf_input == NULL )  126
if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION )  133
if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) )  139
s -> tlsext_status_expected = 1; 145
if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 )  148
unsigned char * selected ; 151
unsigned char selected_len ; 152
if ( s -> ctx -> next_proto_select_cb == NULL )  155
if ( ! ssl_next_proto_validate ( data , size ) )  161
if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK )  166
s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ); 171
if ( ! s -> next_proto_negotiated )  172
memcpy ( s -> next_proto_negotiated , selected , selected_len ); 177
s -> next_proto_negotiated_len = selected_len; 178
s -> s3 -> next_proto_neg_seen = 1; 179
if ( type == TLSEXT_TYPE_renegotiate )  182
if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) )  184
if ( type == TLSEXT_TYPE_heartbeat )  189
switch ( data [ 0 ] )  191
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 194
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; 197
s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; 198
if ( type == TLSEXT_TYPE_use_srtp )  205
if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) )  207
data += size; 212
if ( s -> session -> tlsext_hostname == NULL )  225
s -> session -> tlsext_hostname = BUF_strdup ( s -> tlsext_hostname ); 227
if ( ! s -> session -> tlsext_hostname )  228
0
------------------------------
566 /home/SySeVR/data/CVE_2014_3631_PATCHED_assoc_array_gc.c memcpy 45
int CVE_2014_3631_PATCHED_assoc_array_gc(struct assoc_array *array,
const struct assoc_array_ops *ops,
bool (*iterator)(void *object, void *iterator_data),
void *iterator_data) 4
struct assoc_array_shortcut * shortcut , * new_s ; 6
struct assoc_array_node * node , * new_n ; 7
struct assoc_array_edit * edit ; 8
struct assoc_array_ptr * cursor , * ptr ; 9
struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; 10
int keylen , slot , nr_free , next_slot , i ; 12
if ( ! array -> root )  16
edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ); 19
if ( ! edit )  20
new_root = new_parent = NULL; 28
new_ptr_pp = & new_root; 29
cursor = array -> root; 30
if ( assoc_array_ptr_is_shortcut ( cursor ) )  36
shortcut = assoc_array_ptr_to_shortcut ( cursor ); 37
keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ); 38
keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; 39
new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ); 40
if ( ! new_s )  42
pr_devel ( "dup shortcut %p -> %p\n" , shortcut , new_s ); 44
memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ); 45
new_s -> back_pointer = new_parent; 47
new_s -> parent_slot = shortcut -> parent_slot; 48
* new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ); 49
new_ptr_pp = & new_s -> next_node; 50
cursor = shortcut -> next_node; 51
node = assoc_array_ptr_to_node ( cursor ); 55
new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ); 56
if ( ! new_n )  57
pr_devel ( "dup node %p -> %p\n" , node , new_n ); 59
new_n -> back_pointer = new_parent; 60
new_n -> parent_slot = node -> parent_slot; 61
* new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ); 62
slot = 0; 64
for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) 68
ptr = node -> slots [ slot ]; 69
if ( ! ptr )  70
if ( assoc_array_ptr_is_leaf ( ptr ) )  73
if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) )  74
new_n -> slots [ slot ] = ptr; 79
new_ptr_pp = & new_n -> slots [ slot ]; 83
cursor = ptr; 84
pr_devel ( "-- compress node %p --\n" , new_n ); 88
new_n -> nr_leaves_on_branch = 0; 93
nr_free = 0; 94
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 95
ptr = new_n -> slots [ slot ]; 96
if ( ! ptr )  97
nr_free ++; 98
if ( assoc_array_ptr_is_leaf ( ptr ) )  99
new_n -> nr_leaves_on_branch ++; 100
pr_devel ( "free=%d, leaves=%lu\n" , nr_free , new_n -> nr_leaves_on_branch ); 102
next_slot = 0; 105
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 106
struct assoc_array_shortcut * s ; 107
struct assoc_array_node * child ; 108
ptr = new_n -> slots [ slot ]; 110
if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) )  111
s = NULL; 114
if ( assoc_array_ptr_is_shortcut ( ptr ) )  115
s = assoc_array_ptr_to_shortcut ( ptr ); 116
ptr = s -> next_node; 117
child = assoc_array_ptr_to_node ( ptr ); 120
new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch; 121
if ( child -> nr_leaves_on_branch <= nr_free + 1 )  123
pr_devel ( "[%d] fold node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 125
BUG_ON ( s ); 132
new_n -> slots [ slot ] = NULL; 134
nr_free ++; 135
if ( slot < next_slot )  136
next_slot = slot; 137
for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) 138
struct assoc_array_ptr * p = child -> slots [ i ] ; 139
if ( ! p )  140
BUG_ON ( assoc_array_ptr_is_meta ( p ) ); 142
while ( new_n -> slots [ next_slot ] )  143
next_slot ++; 144
BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ); 145
new_n -> slots [ next_slot ++ ] = p; 146
nr_free --; 147
kfree ( child ); 149
pr_devel ( "[%d] retain node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 151
pr_devel ( "after: %lu\n" , new_n -> nr_leaves_on_branch ); 157
nr_leaves_on_tree = new_n -> nr_leaves_on_branch; 159
if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 )  162
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 163
if ( ptr = new_n -> slots [ slot ] )  164
if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) )  167
pr_devel ( "excise node %p with 1 shortcut\n" , new_n ); 169
new_s = assoc_array_ptr_to_shortcut ( ptr ); 170
new_parent = new_n -> back_pointer; 171
slot = new_n -> parent_slot; 172
kfree ( new_n ); 173
if ( ! new_parent )  174
new_s -> back_pointer = NULL; 175
new_s -> parent_slot = 0; 176
new_root = ptr; 177
if ( assoc_array_ptr_is_shortcut ( new_parent ) )  181
struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; 183
new_parent = new_s -> back_pointer = s -> back_pointer; 188
slot = new_s -> parent_slot = s -> parent_slot; 189
kfree ( s ); 190
if ( ! new_parent )  191
new_s -> back_pointer = NULL; 192
new_s -> parent_slot = 0; 193
new_root = ptr; 194
new_s -> back_pointer = new_parent; 199
new_s -> parent_slot = slot; 200
new_n = assoc_array_ptr_to_node ( new_parent ); 201
new_n -> slots [ slot ] = ptr; 202
ptr = new_n -> back_pointer; 210
if ( ! ptr )  211
if ( assoc_array_ptr_is_shortcut ( ptr ) )  214
new_s = assoc_array_ptr_to_shortcut ( ptr ); 215
new_parent = new_s -> back_pointer; 216
slot = new_s -> parent_slot; 217
if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT )  219
struct assoc_array_node * n ; 220
new_n -> back_pointer = new_parent; 223
new_n -> parent_slot = slot; 224
kfree ( new_s ); 225
if ( ! new_parent )  226
new_root = assoc_array_node_to_ptr ( new_n ); 227
n = assoc_array_ptr_to_node ( new_parent ); 231
n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ); 232
new_parent = ptr; 235
new_n = assoc_array_ptr_to_node ( new_parent ); 237
ptr = node -> back_pointer; 240
if ( assoc_array_ptr_is_shortcut ( ptr ) )  241
shortcut = assoc_array_ptr_to_shortcut ( ptr ); 242
slot = shortcut -> parent_slot; 243
cursor = shortcut -> back_pointer; 244
if ( ! cursor )  245
slot = node -> parent_slot; 248
cursor = ptr; 249
BUG_ON ( ! cursor ); 251
node = assoc_array_ptr_to_node ( cursor ); 252
slot ++; 253
edit -> set [ 0 ] . to = new_root; 257
assoc_array_apply_edit ( edit ); 258
edit -> array -> nr_leaves_on_tree = nr_leaves_on_tree; 259
0
------------------------------
567 /home/SySeVR/data/CVE_2014_4654_VULN_snd_ctl_elem_add.c memcpy 36
static int CVE_2014_4654_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
info -> id . numid = 0; 19
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
_kctl = snd_ctl_find_id ( card , & info -> id ); 22
err = 0; 23
if ( _kctl )  24
if ( replace )  25
err = snd_ctl_remove ( card , _kctl ); 26
err = - EBUSY; 28
if ( replace )  30
err = - ENOENT; 31
if ( err < 0 )  34
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
0
------------------------------
568 /home/SySeVR/data/CVE_2014_4655_PATCHED_snd_ctl_elem_add.c memcpy 29
static int CVE_2014_4655_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( info -> count < 1 )  11
info -> id . numid = 0; 17
memset ( & kctl , 0 , sizeof ( kctl ) ); 18
if ( replace )  20
err = snd_ctl_remove_user_ctl ( file , & info -> id ); 21
if ( err )  22
if ( card -> user_ctl_count >= MAX_USER_CONTROLS )  26
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 29
kctl . count = info -> owner ? info -> owner : 1; 30
kctl . info = snd_ctl_elem_user_enum_info; 33
kctl . info = snd_ctl_elem_user_info; 35
kctl . get = snd_ctl_elem_user_get; 37
kctl . put = snd_ctl_elem_user_put; 39
kctl . tlv . c = snd_ctl_elem_user_tlv; 41
kctl . private_free = snd_ctl_elem_user_free; 89
_kctl = snd_ctl_new ( & kctl , access ); 90
if ( _kctl == NULL )  91
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
0
------------------------------
569 /home/SySeVR/data/CVE_2014_4655_VULN_snd_ctl_elem_add.c memcpy 36
static int CVE_2014_4655_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
int idx , err ; 9
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
info -> id . numid = 0; 19
memset ( & kctl , 0 , sizeof ( kctl ) ); 20
_kctl = snd_ctl_find_id ( card , & info -> id ); 22
err = 0; 23
if ( _kctl )  24
if ( replace )  25
err = snd_ctl_remove ( card , _kctl ); 26
err = - EBUSY; 28
if ( replace )  30
err = - ENOENT; 31
if ( err < 0 )  34
memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ); 36
kctl . count = info -> owner ? info -> owner : 1; 37
kctl . info = snd_ctl_elem_user_enum_info; 40
kctl . info = snd_ctl_elem_user_info; 42
kctl . get = snd_ctl_elem_user_get; 44
kctl . put = snd_ctl_elem_user_put; 46
kctl . tlv . c = snd_ctl_elem_user_tlv; 48
kctl . private_free = snd_ctl_elem_user_free; 96
_kctl = snd_ctl_new ( & kctl , access ); 97
if ( _kctl == NULL )  98
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
0
------------------------------
570 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memcpy 111
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
if ( s -> ham )  108
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
memcpy ( s -> ham_buf , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 111
buf += avctx -> width + ( avctx -> width & 1 ); 112
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
0
------------------------------
571 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memcpy 105
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 104
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
buf += avctx -> width + ( avctx -> width % 2 ); 106
0
------------------------------
572 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c memcpy 64
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; 59
int raw_width = avctx -> width * ( av_get_bits_per_pixel ( desc ) >> 3 ) ; 60
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 63
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
buf += raw_width; 65
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
0
------------------------------
573 /home/SySeVR/data/CVE_2014_5472_PATCHED_isofs_read_inode.c memcpy 40
static int CVE_2014_5472_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
bh = sb_bread ( inode -> i_sb , ++ block ); 37
if ( ! bh )  38
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
0
------------------------------
574 /home/SySeVR/data/CVE_2014_5472_PATCHED_isofs_read_inode.c memcpy 35
static int CVE_2014_5472_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
0
------------------------------
575 /home/SySeVR/data/CVE_2014_6427_PATCHED_is_rtsp_request_or_reply.c memcpy 21
static gboolean
CVE_2014_6427_PATCHED_is_rtsp_request_or_reply(const guchar *line, size_t linelen, rtsp_type_t *type) 2
const guchar * token , * next_token ; 5
int tokenlen ; 6
gchar response_chars [ 4 ] ; 7
if ( linelen >= 5 && g_ascii_strncasecmp ( "RTSP/" , line , 5 ) == 0 )  10
tokenlen = get_token_len ( line , line + 5 , & token ); 16
if ( tokenlen != 0 )  17
tokenlen = get_token_len ( token , line + linelen , & next_token ); 19
if ( tokenlen >= 3 )  20
memcpy ( response_chars , token , 3 ); 21
response_chars [ 3 ] = '\0'; 22
rtsp_stat_info -> response_code = ( guint ) strtoul ( response_chars , NULL , 10 ); 23
0
------------------------------
576 /home/SySeVR/data/CVE_2014_6429_VULN_SnifferDecompress.c memcpy 169
static int
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
577 /home/SySeVR/data/CVE_2014_6429_VULN_SnifferDecompress.c memcpy 140
static int
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
578 /home/SySeVR/data/CVE_2014_6431_VULN_SnifferDecompress.c memcpy 169
static int
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
579 /home/SySeVR/data/CVE_2014_6431_VULN_SnifferDecompress.c memcpy 140
static int
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
580 /home/SySeVR/data/CVE_2014_6432_PATCHED_SnifferDecompress.c memcpy 192
static int
CVE_2014_6432_PATCHED_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( pin < pin_end )  22
bit_mask = bit_mask >> 1; 25
if ( 0 == bit_mask )  28
if ( pin + 2 >= pin_end )  33
bit_mask = 0x8000; 38
bit_value = pletoh16 ( pin ); 39
pin += 2; 40
if ( ! ( bit_mask & bit_value ) )  44
if ( pout + 1 > pout_end )  49
* ( pout ++ ) = * ( pin ++ ); 54
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 61
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 62
pin ++; 63
if ( pin >= pin_end )  64
switch ( code_type )  71
length = code_low + 3; 79
if ( pout + length > pout_end )  81
memset ( pout , * pin ++ , length ); 88
pout += length; 89
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 99
if ( pin >= pin_end )  102
if ( pout + length > pout_end )  108
memset ( pout , * pin ++ , length ); 115
pout += length; 116
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 126
if ( pin >= pin_end )  129
if ( pout - offset < outbuf )  135
length = ( unsigned int ) ( * pin ++ ) + 16; 142
if ( pout + length > pout_end )  143
if ( pout - offset + length > pout )  149
memcpy ( pout , pout - offset , length ); 157
pout += length; 158
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 168
if ( pout - offset < outbuf )  170
length = code_type; 177
if ( pout + length > pout_end )  178
if ( pout - offset + length > pout )  184
memcpy ( pout , pout - offset , length ); 192
pout += length; 193
return ( int ) ( pout - outbuf ) ; 199
0
------------------------------
581 /home/SySeVR/data/CVE_2014_6432_PATCHED_SnifferDecompress.c memcpy 157
static int
CVE_2014_6432_PATCHED_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( pin < pin_end )  22
bit_mask = bit_mask >> 1; 25
if ( 0 == bit_mask )  28
if ( pin + 2 >= pin_end )  33
bit_mask = 0x8000; 38
bit_value = pletoh16 ( pin ); 39
pin += 2; 40
if ( ! ( bit_mask & bit_value ) )  44
if ( pout + 1 > pout_end )  49
* ( pout ++ ) = * ( pin ++ ); 54
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 61
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 62
pin ++; 63
if ( pin >= pin_end )  64
switch ( code_type )  71
length = code_low + 3; 79
if ( pout + length > pout_end )  81
memset ( pout , * pin ++ , length ); 88
pout += length; 89
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 99
if ( pin >= pin_end )  102
if ( pout + length > pout_end )  108
memset ( pout , * pin ++ , length ); 115
pout += length; 116
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 126
if ( pin >= pin_end )  129
if ( pout - offset < outbuf )  135
length = ( unsigned int ) ( * pin ++ ) + 16; 142
if ( pout + length > pout_end )  143
if ( pout - offset + length > pout )  149
memcpy ( pout , pout - offset , length ); 157
pout += length; 158
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 168
if ( pout - offset < outbuf )  170
length = code_type; 177
if ( pout + length > pout_end )  178
if ( pout - offset + length > pout )  184
memcpy ( pout , pout - offset , length ); 192
pout += length; 193
return ( int ) ( pout - outbuf ) ; 199
0
------------------------------
582 /home/SySeVR/data/CVE_2014_6432_VULN_SnifferDecompress.c memcpy 169
static int
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
583 /home/SySeVR/data/CVE_2014_6432_VULN_SnifferDecompress.c memcpy 140
static int
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pout = outbuf ; 6
unsigned char * pin_end = pin + inlen ; 7
unsigned char * pout_end = pout + outlen ; 8
unsigned int bit_mask ; 9
unsigned int bit_value = 0 ; 10
unsigned int code_type ; 11
unsigned int code_low ; 12
int length ; 13
int offset ; 14
if ( inlen > G_MAXUINT16 )  16
bit_mask = 0; 20
while ( 1 )  21
bit_mask = bit_mask >> 1; 24
if ( 0 == bit_mask )  27
bit_mask = 0x8000; 29
bit_value = pletoh16 ( pin ); 30
pin += 2; 31
if ( pin >= pin_end )  32
if ( ! ( bit_mask & bit_value ) )  40
* ( pout ++ ) = * ( pin ++ ); 43
code_type = ( unsigned int ) ( ( * pin ) >> 4 ) & 0xF; 50
code_low = ( unsigned int ) ( ( * pin ) & 0xF ); 51
pin ++; 52
if ( pin >= pin_end )  53
switch ( code_type )  60
length = code_low + 3; 68
if ( pout + length > pout_end )  70
memset ( pout , * pin ++ , length ); 77
pout += length; 78
length = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 19; 88
if ( pin >= pin_end )  91
if ( pout + length > pout_end )  97
memset ( pout , * pin ++ , length ); 104
pout += length; 105
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 115
if ( pin >= pin_end )  118
if ( pout - offset < outbuf )  124
length = ( unsigned int ) ( * pin ++ ) + 16; 131
if ( pout + length > pout_end )  132
memcpy ( pout , pout - offset , length ); 140
pout += length; 141
offset = code_low + ( ( unsigned int ) ( * pin ++ ) << 4 ) + 3; 151
if ( pout - offset < outbuf )  153
length = code_type; 160
if ( pout + length > pout_end )  161
memcpy ( pout , pout - offset , length ); 169
pout += length; 170
if ( pin >= pin_end )  176
return ( int ) ( pout - outbuf ) ; 180
0
------------------------------
584 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memcpy 102
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
return ret ; 119
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 139
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
switch ( pix_fmt_id )  163
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
if ( pix_fmt_id == 0x42111100 )  270
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); 283
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 319
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 324
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 328
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
av_freep ( & s -> blocks [ i ] ); 338
av_freep ( & s -> last_nnz [ i ] ); 339
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
0
------------------------------
585 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c memcpy 101
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
return ret ; 119
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 139
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
switch ( pix_fmt_id )  163
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
if ( pix_fmt_id == 0x42111100 )  270
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); 283
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 319
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 324
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 328
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
av_freep ( & s -> blocks [ i ] ); 338
av_freep ( & s -> last_nnz [ i ] ); 339
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
0
------------------------------
586 /home/SySeVR/data/CVE_2014_8545_VULN_decode_frame.c memcpy 171
static int CVE_2014_8545_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
PNGDecContext * const s = avctx -> priv_data 5
AVFrame * p ; 8
uint32_t tag , length ; 10
int64_t sig ; 11
int ret ; 12
p = s -> picture . f; 16
sig = bytestream2_get_be64 ( & s -> gb ); 21
if ( sig != PNGSIG && sig != MNGSIG )  22
s -> y = s -> state = 0; 28
s -> zstream . zalloc = ff_png_zalloc; 31
s -> zstream . zfree = ff_png_zfree; 32
s -> zstream . opaque = NULL; 33
ret = inflateInit ( & s -> zstream ); 34
if ( ret != Z_OK )  35
if ( bytestream2_get_bytes_left ( & s -> gb ) <= 0 )  40
length = bytestream2_get_be32 ( & s -> gb ); 48
if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) )  49
if ( length != 13 )  62
s -> width = bytestream2_get_be32 ( & s -> gb ); 64
s -> height = bytestream2_get_be32 ( & s -> gb ); 65
if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) )  66
s -> bit_depth = bytestream2_get_byte ( & s -> gb ); 71
s -> color_type = bytestream2_get_byte ( & s -> gb ); 72
s -> compression_type = bytestream2_get_byte ( & s -> gb ); 73
s -> filter_type = bytestream2_get_byte ( & s -> gb ); 74
s -> interlace_type = bytestream2_get_byte ( & s -> gb ); 75
s -> state |= PNG_IHDR; 77
if ( s -> state & PNG_IDAT )  85
avctx -> sample_aspect_ratio . num = bytestream2_get_be32 ( & s -> gb ); 89
avctx -> sample_aspect_ratio . den = bytestream2_get_be32 ( & s -> gb ); 90
if ( avctx -> sample_aspect_ratio . num < 0 || avctx -> sample_aspect_ratio . den < 0 )  91
avctx -> sample_aspect_ratio = ( AVRational ) 0 , 1 92
if ( ! ( s -> state & PNG_IHDR ) )  97
if ( ! ( s -> state & PNG_IDAT ) )  101
avctx -> width = s -> width; 103
avctx -> height = s -> height; 104
s -> channels = ff_png_get_nb_channels ( s -> color_type ); 106
s -> bits_per_pixel = s -> bit_depth * s -> channels; 107
s -> bpp = ( s -> bits_per_pixel + 7 ) >> 3; 108
s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3; 109
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB )  111
avctx -> pix_fmt = AV_PIX_FMT_RGB24; 113
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  114
avctx -> pix_fmt = AV_PIX_FMT_RGBA; 116
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_GRAY )  117
avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 119
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY )  120
avctx -> pix_fmt = AV_PIX_FMT_GRAY16BE; 122
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB )  123
avctx -> pix_fmt = AV_PIX_FMT_RGB48BE; 125
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  126
avctx -> pix_fmt = AV_PIX_FMT_RGBA64BE; 128
if ( ( s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && s -> color_type == PNG_COLOR_TYPE_PALETTE )  129
avctx -> pix_fmt = AV_PIX_FMT_PAL8; 131
if ( s -> bit_depth == 1 )  132
avctx -> pix_fmt = AV_PIX_FMT_MONOBLACK; 133
if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )  134
avctx -> pix_fmt = AV_PIX_FMT_YA8; 136
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )  137
avctx -> pix_fmt = AV_PIX_FMT_YA16BE; 139
if ( ff_thread_get_buffer ( avctx , & s -> picture , AV_GET_BUFFER_FLAG_REF ) < 0 )  147
p -> pict_type = AV_PICTURE_TYPE_I; 151
p -> key_frame = 1; 152
p -> interlaced_frame = ! ! s -> interlace_type; 153
if ( ! s -> interlace_type )  156
s -> crow_size = s -> row_size + 1; 157
s -> pass = 0; 159
s -> pass_row_size = ff_png_pass_row_size ( s -> pass , s -> bits_per_pixel , s -> width ); 160
s -> crow_size = s -> pass_row_size + 1; 163
s -> image_buf = p -> data [ 0 ]; 167
s -> image_linesize = p -> linesize [ 0 ]; 168
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  170
memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ); 171
if ( ! s -> last_row )  174
if ( s -> interlace_type || s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  176
if ( ! s -> tmp_row )  179
if ( ! s -> buffer )  184
s -> crow_buf = s -> buffer + 15; 188
s -> zstream . avail_out = s -> crow_size; 189
s -> zstream . next_out = s -> crow_buf; 190
s -> state |= PNG_IDAT; 192
if ( png_decode_idat ( s , length ) < 0 )  193
0
------------------------------
587 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 116
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip0; 103
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
if ( s -> palette_video )  122
ip0 += 4; 123
ip0 += 12; 126
0
------------------------------
588 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 115
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip0; 103
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
if ( s -> palette_video )  122
ip0 += 4; 123
ip0 += 12; 126
0
------------------------------
589 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 114
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip1; 98
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
if ( s -> palette_video )  122
ip1 += 4; 123
ip1 += 12; 126
0
------------------------------
590 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 113
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip1; 98
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
if ( s -> palette_video )  122
ip1 += 4; 123
ip1 += 12; 126
0
------------------------------
591 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 112
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip2; 93
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
if ( s -> palette_video )  122
ip2 += 4; 124
ip2 += 12; 127
0
------------------------------
592 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 111
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip2; 93
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
if ( s -> palette_video )  122
ip2 += 4; 124
ip2 += 12; 127
0
------------------------------
593 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 110
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip3; 88
* p ++ = cb2 [ 6 ]; 89
* p ++ = cb2 [ 9 ]; 90
* p ++ = cb3 [ 6 ]; 91
* p = cb3 [ 9 ]; 92
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
if ( s -> palette_video )  122
ip3 += 4; 124
ip3 += 12; 127
0
------------------------------
594 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 109
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
p = ip3; 88
* p ++ = cb2 [ 6 ]; 89
* p ++ = cb2 [ 9 ]; 90
* p ++ = cb3 [ 6 ]; 91
* p = cb3 [ 9 ]; 92
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
if ( s -> palette_video )  122
ip3 += 4; 124
ip3 += 12; 127
0
------------------------------
595 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 75
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
p += 3; 73
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
if ( s -> palette_video )  122
ip0 += 4; 123
ip0 += 12; 126
0
------------------------------
596 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 75
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
p += 3; 73
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
if ( s -> palette_video )  122
ip0 += 4; 123
ip0 += 12; 126
0
------------------------------
597 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 74
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
p += 3; 73
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
if ( s -> palette_video )  122
ip1 += 4; 123
ip1 += 12; 126
0
------------------------------
598 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 74
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
p += 3; 73
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
if ( s -> palette_video )  122
ip1 += 4; 123
ip1 += 12; 126
0
------------------------------
599 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 72
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
if ( s -> palette_video )  122
ip0 += 4; 123
ip0 += 12; 126
0
------------------------------
600 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 72
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
if ( s -> palette_video )  122
ip0 += 4; 123
ip0 += 12; 126
0
------------------------------
601 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 71
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
if ( s -> palette_video )  122
ip1 += 4; 123
ip1 += 12; 126
0
------------------------------
602 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 71
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
p += 3; 67
p -= 9; 70
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
if ( s -> palette_video )  122
ip1 += 4; 123
ip1 += 12; 126
0
------------------------------
603 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 69
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
p += 3; 67
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
if ( s -> palette_video )  122
ip2 += 4; 124
ip2 += 12; 127
0
------------------------------
604 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 69
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
p += 3; 67
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
if ( s -> palette_video )  122
ip2 += 4; 124
ip2 += 12; 127
0
------------------------------
605 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 68
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
p += 3; 67
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
if ( s -> palette_video )  122
ip3 += 4; 124
ip3 += 12; 127
0
------------------------------
606 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 68
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
p += 3; 67
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
if ( s -> palette_video )  122
ip3 += 4; 124
ip3 += 12; 127
0
------------------------------
607 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 66
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
if ( s -> palette_video )  122
ip2 += 4; 124
ip2 += 12; 127
0
------------------------------
608 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 66
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
if ( s -> palette_video )  122
ip2 += 4; 124
ip2 += 12; 127
0
------------------------------
609 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 65
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
if ( s -> palette_video )  122
ip3 += 4; 124
ip3 += 12; 127
0
------------------------------
610 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c memcpy 65
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
if ( s -> palette_video )  58
p += 6; 64
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
if ( s -> palette_video )  86
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
if ( s -> palette_video )  122
ip3 += 4; 124
ip3 += 12; 127
0
------------------------------
611 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c memcpy 50
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int pos = hdrlen + per_fragm ; 9
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
0
------------------------------
612 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c memcpy 49
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
0
------------------------------
613 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c memcpy 35
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
info = IEEE80211_SKB_CB ( tmp ); 37
info -> flags &= ~ ( IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT ); 38
info -> flags |= IEEE80211_TX_CTL_MORE_FRAMES; 42
skb_copy_queue_mapping ( tmp , skb ); 44
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
0
------------------------------
614 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c memcpy 50
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int pos = hdrlen + per_fragm ; 9
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
0
------------------------------
615 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c memcpy 49
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
0
------------------------------
616 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c memcpy 35
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
info = IEEE80211_SKB_CB ( tmp ); 37
info -> flags &= ~ ( IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT ); 38
info -> flags |= IEEE80211_TX_CTL_MORE_FRAMES; 42
skb_copy_queue_mapping ( tmp , skb ); 44
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
0
------------------------------
617 /home/SySeVR/data/CVE_2014_9374_PATCHED_AST_OPTIONAL_API_NAME.c memcpy 124
int CVE_2014_9374_PATCHED_AST_OPTIONAL_API_NAME(ast_websocket_read)(struct ast_websocket *session, char **payload, uint64_t *payload_len, enum ast_websocket_opcode *opcode, int *fragmented) 1
char buf [ MAXIMUM_FRAME_SIZE ] = "" ; 3
size_t options_len = 0 , frame_size = 0 ; 7
* payload_len = 0; 10
if ( ws_safe_read ( session , & buf [ 0 ] , MIN_WS_HDR_SZ , opcode ) )  13
frame_size += MIN_WS_HDR_SZ; 16
* opcode = buf [ 0 ] & 0xf; 19
* payload_len = buf [ 1 ] & 0x7f; 20
if ( * opcode == AST_WEBSOCKET_OPCODE_TEXT || * opcode == AST_WEBSOCKET_OPCODE_BINARY || * opcode == AST_WEBSOCKET_OPCODE_CONTINUATION || * opcode == AST_WEBSOCKET_OPCODE_PING || * opcode == AST_WEBSOCKET_OPCODE_PONG )  21
if ( * opcode == AST_WEBSOCKET_OPCODE_CLOSE )  117
if ( ( * payload_len ) && ( new_payload = ast_realloc ( session -> payload , * payload_len ) ) )  119
if ( ws_safe_read ( session , & buf [ frame_size ] , ( * payload_len ) , opcode ) )  120
session -> payload = new_payload; 123
memcpy ( session -> payload , & buf [ frame_size ] , * payload_len ); 124
* payload = session -> payload; 125
session -> closing = 1; 129
0
------------------------------
618 /home/SySeVR/data/CVE_2014_9374_PATCHED_AST_OPTIONAL_API_NAME.c memcpy 88
int CVE_2014_9374_PATCHED_AST_OPTIONAL_API_NAME(ast_websocket_read)(struct ast_websocket *session, char **payload, uint64_t *payload_len, enum ast_websocket_opcode *opcode, int *fragmented) 1
char buf [ MAXIMUM_FRAME_SIZE ] = "" ; 3
size_t options_len = 0 , frame_size = 0 ; 7
* payload = NULL; 9
* payload_len = 0; 10
if ( ws_safe_read ( session , & buf [ 0 ] , MIN_WS_HDR_SZ , opcode ) )  13
frame_size += MIN_WS_HDR_SZ; 16
* opcode = buf [ 0 ] & 0xf; 19
* payload_len = buf [ 1 ] & 0x7f; 20
if ( * opcode == AST_WEBSOCKET_OPCODE_TEXT || * opcode == AST_WEBSOCKET_OPCODE_BINARY || * opcode == AST_WEBSOCKET_OPCODE_CONTINUATION || * opcode == AST_WEBSOCKET_OPCODE_PING || * opcode == AST_WEBSOCKET_OPCODE_PONG )  21
mask_present = ( buf [ 1 ] >> 7 ) & 1; 24
options_len += mask_present ? 4 : 0; 27
options_len += ( * payload_len == 126 ) ? 2 : ( * payload_len == 127 ) ? 8 : 0; 28
if ( options_len )  29
if ( ws_safe_read ( session , & buf [ frame_size ] , options_len , opcode ) )  31
frame_size += options_len; 34
if ( * payload_len == 126 )  37
* payload_len = ntohs ( get_unaligned_uint16 ( & buf [ 2 ] ) ); 39
mask = & buf [ 4 ]; 40
if ( * payload_len == 127 )  41
* payload_len = ntohl ( get_unaligned_uint64 ( & buf [ 2 ] ) ); 43
mask = & buf [ 10 ]; 44
mask = & buf [ 2 ]; 47
* payload = & buf [ frame_size ]; 51
frame_size = frame_size + ( * payload_len ); 52
if ( frame_size > MAXIMUM_FRAME_SIZE )  53
if ( ws_safe_read ( session , ( * payload ) , ( * payload_len ) , opcode ) )  60
if ( mask_present )  64
unsigned int pos ; 65
for (pos = 0; pos < *payload_len; pos++) 66
( * payload ) [ pos ] ^= mask [ pos % 4 ]; 67
if ( ( * opcode == AST_WEBSOCKET_OPCODE_PING ) && ( ast_websocket_write ( session , AST_WEBSOCKET_OPCODE_PONG , * payload , * payload_len ) ) )  72
* payload_len = 0; 73
if ( * payload_len )  78
if ( ! ( new_payload = ast_realloc ( session -> payload , ( session -> payload_len + * payload_len ) ) ) )  79
* payload_len = 0; 82
session -> payload = new_payload; 87
memcpy ( ( session -> payload + session -> payload_len ) , ( * payload ) , ( * payload_len ) ); 88
session -> payload_len += * payload_len; 89
if ( ! fin && session -> reconstruct && ( session -> payload_len < session -> reconstruct ) )  95
* opcode = session -> opcode; 110
* payload_len = session -> payload_len; 113
* payload = session -> payload; 114
0
------------------------------
619 /home/SySeVR/data/CVE_2014_9428_VULN_batadv_frag_merge_packets.c memcpy 42
static struct sk_buff *
CVE_2014_9428_VULN_batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb) 2
struct batadv_frag_packet * packet ; 4
struct batadv_frag_list_entry * entry ; 5
int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; 7
packet = ( struct batadv_frag_packet * ) skb -> data; 10
size = ntohs ( packet -> total_size ); 11
if ( size > batadv_frag_size_limit ( ) )  12
entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) 18
skb_out = entry -> skb; 20
if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 )  24
memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ); 34
size = entry -> skb -> len - hdr_size; 41
memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ); 42
0
------------------------------
620 /home/SySeVR/data/CVE_2014_9679_PATCHED_cupsRasterReadPixels.c memcpy 182
unsigned				/* O - Number of bytes read */
CVE_2014_9679_PATCHED_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
* temp = * ( temp - r -> bpp ); 132
temp += 1; 133
count -= 1; 134
cups_swap ( ptr , bytes ); 147
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ptr != p )  170
memcpy ( p , ptr , bytes ); 171
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
0
------------------------------
621 /home/SySeVR/data/CVE_2014_9679_PATCHED_cupsRasterReadPixels.c memcpy 171
unsigned				/* O - Number of bytes read */
CVE_2014_9679_PATCHED_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
* temp = * ( temp - r -> bpp ); 132
temp += 1; 133
count -= 1; 134
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ptr != p )  170
memcpy ( p , ptr , bytes ); 171
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
0
------------------------------
622 /home/SySeVR/data/CVE_2014_9679_VULN_cupsRasterReadPixels.c memcpy 182
unsigned				/* O - Number of bytes read */
CVE_2014_9679_VULN_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
memcpy ( temp , temp - r -> bpp , r -> bpp ); 132
temp += r -> bpp; 133
count -= r -> bpp; 134
cups_swap ( ptr , bytes ); 147
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ptr != p )  170
memcpy ( p , ptr , bytes ); 171
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
0
------------------------------
623 /home/SySeVR/data/CVE_2014_9679_VULN_cupsRasterReadPixels.c memcpy 171
unsigned				/* O - Number of bytes read */
CVE_2014_9679_VULN_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
memcpy ( temp , temp - r -> bpp , r -> bpp ); 132
temp += r -> bpp; 133
count -= r -> bpp; 134
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ptr != p )  170
memcpy ( p , ptr , bytes ); 171
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
0
------------------------------
624 /home/SySeVR/data/CVE_2014_9679_VULN_cupsRasterReadPixels.c memcpy 132
unsigned				/* O - Number of bytes read */
CVE_2014_9679_VULN_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
memcpy ( temp , temp - r -> bpp , r -> bpp ); 132
temp += r -> bpp; 133
count -= r -> bpp; 134
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
0
------------------------------
625 /home/SySeVR/data/CVE_2015_2922_PATCHED_ndisc_router_discovery.c memcpy 260
static void CVE_2015_2922_PATCHED_ndisc_router_discovery(struct sk_buff *skb) 1
struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; 3
struct neighbour * neigh = NULL ; 4
struct inet6_dev * in6_dev ; 5
int lifetime ; 7
struct ndisc_options ndopts ; 8
int optlen ; 9
__u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; 12
optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ); 14
if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) )  16
if ( optlen < 0 )  20
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST )  26
in6_dev = __in6_dev_get ( skb -> dev ); 36
if ( in6_dev == NULL )  37
if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) )  43
if ( ! accept_ra ( in6_dev ) )  48
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  53
if ( in6_dev -> if_flags & IF_RS_SENT )  57
in6_dev -> if_flags |= IF_RA_RCVD; 62
in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ); 69
if ( ! in6_dev -> cnf . accept_ra_defrtr )  76
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  79
lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ); 82
pref = ra_msg -> icmph . icmp6_router_pref; 85
if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref )  87
pref = ICMPV6_ROUTER_PREF_MEDIUM; 89
rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ); 92
if ( rt )  94
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 95
if ( ! neigh )  96
if ( rt && lifetime == 0 )  104
rt = NULL; 106
if ( rt == NULL && lifetime )  109
rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ); 112
if ( rt == NULL )  113
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 120
if ( neigh == NULL )  121
neigh -> flags |= NTF_ROUTER; 128
if ( ra_msg -> icmph . icmp6_hop_limit )  135
if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit )  139
in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit; 140
if ( in6_dev -> nd_parms )  155
unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; 156
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ )  158
rtime = ( rtime * HZ ) / 1000; 159
if ( rtime < HZ / 10 )  160
rtime = HZ / 10; 161
in6_dev -> nd_parms -> retrans_time = rtime; 162
in6_dev -> tstamp = jiffies; 163
rtime = ntohl ( ra_msg -> reachable_time ); 167
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) )  168
rtime = ( rtime * HZ ) / 1000; 169
if ( rtime < HZ / 10 )  171
rtime = HZ / 10; 172
if ( rtime != in6_dev -> nd_parms -> base_reachable_time )  174
in6_dev -> nd_parms -> base_reachable_time = rtime; 175
in6_dev -> nd_parms -> gc_staletime = 3 * rtime; 176
in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ); 177
in6_dev -> tstamp = jiffies; 178
if ( ! neigh )  190
neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ); 191
if ( neigh )  193
if ( ndopts . nd_opts_src_lladdr )  195
lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ); 196
if ( ! lladdr )  198
if ( ! accept_ra ( in6_dev ) )  211
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  241
if ( ndopts . nd_opts_mtu )  256
__be32 n ; 257
memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ); 260
mtu = ntohl ( n ); 261
if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu )  263
ND_PRINTK ( 2 , warn , "RA: invalid mtu: %d\n" , mtu ); 264
if ( in6_dev -> cnf . mtu6 != mtu )  265
in6_dev -> cnf . mtu6 = mtu; 266
dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ); 269
rt6_mtu_change ( skb -> dev , mtu ); 271
0
------------------------------
626 /home/SySeVR/data/CVE_2015_3811_PATCHED_wcp_uncompress.c memcpy 195
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
int len , i ; 8
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
guint8 * dst , * src , * buf_start , * buf_end , comp_flag_bits = 0 ; 11
guint16 data_offset , data_cnt ; 12
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
wcp_pdata_t * pdata_ptr ; 16
buf_ptr = get_wcp_window_ptr ( pinfo ); 18
buf_start = buf_ptr -> buffer; 20
buf_end = buf_start + MAX_WIN_BUF_LEN; 21
if ( cnt - offset > MAX_WCP_BUF_LEN )  26
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
dst = buf_ptr -> buf_cur; 41
len = 0; 42
i = - 1; 43
while ( offset < cnt )  45
if ( -- i >= 0 )  47
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
src += 3; 87
offset += 3; 88
data_cnt = ( * src >> 4 ) + 1; 96
src += 2; 106
offset += 2; 107
if ( data_offset + 1 > buf_ptr -> initialized )  109
if ( data_offset + 1 < data_cnt )  116
if ( ! pinfo -> fd -> flags . visited )  122
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_ptr ); 123
if ( dst == NULL )  126
if ( ++ len > MAX_WCP_BUF_LEN )  139
if ( ! pinfo -> fd -> flags . visited )  147
* dst = * src; 153
if ( dst ++ == buf_end )  154
dst = buf_start; 155
if ( buf_ptr -> initialized < MAX_WIN_BUF_LEN )  156
buf_ptr -> initialized ++; 157
comp_flag_bits <<= 1; 164
comp_flag_bits = * src ++; 172
offset ++; 176
i = 8; 178
if ( pinfo -> fd -> flags . visited )  182
pdata_ptr = wmem_new ( wmem_file_scope ( ) , wcp_pdata_t ); 194
memcpy ( & pdata_ptr -> buffer , buf_ptr -> buf_cur , len ); 195
pdata_ptr -> len = len; 196
p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_wcp , 0 , ( void * ) pdata_ptr ); 198
tvb = tvb_new_child_real_data ( src_tvb , pdata_ptr -> buffer , pdata_ptr -> len , pdata_ptr -> len ); 203
add_new_data_source ( pinfo , tvb , "Uncompressed WCP" ); 206
return tvb ; 207
0
------------------------------
627 /home/SySeVR/data/CVE_2015_3811_VULN_wcp_uncompress.c memcpy 180
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
int len , i ; 8
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
guint8 * dst , * src , * buf_start , * buf_end , comp_flag_bits = 0 ; 11
guint16 data_offset , data_cnt ; 12
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
wcp_pdata_t * pdata_ptr ; 16
buf_ptr = get_wcp_window_ptr ( pinfo ); 18
buf_start = buf_ptr -> buffer; 20
buf_end = buf_start + MAX_WIN_BUF_LEN; 21
if ( cnt - offset > MAX_WCP_BUF_LEN )  26
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
dst = buf_ptr -> buf_cur; 41
len = 0; 42
i = - 1; 43
while ( offset < cnt )  45
if ( -- i >= 0 )  47
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
src += 3; 87
offset += 3; 88
data_cnt = ( * src >> 4 ) + 1; 96
src += 2; 106
offset += 2; 107
if ( ! pinfo -> fd -> flags . visited )  109
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_start , buf_end ); 110
if ( dst == NULL )  113
if ( ++ len > MAX_WCP_BUF_LEN )  126
if ( ! pinfo -> fd -> flags . visited )  134
* dst = * src; 140
if ( dst ++ == buf_end )  141
dst = buf_start; 142
comp_flag_bits <<= 1; 149
comp_flag_bits = * src ++; 157
offset ++; 161
i = 8; 163
if ( pinfo -> fd -> flags . visited )  167
pdata_ptr = wmem_new ( wmem_file_scope ( ) , wcp_pdata_t ); 179
memcpy ( & pdata_ptr -> buffer , buf_ptr -> buf_cur , len ); 180
pdata_ptr -> len = len; 181
p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_wcp , 0 , ( void * ) pdata_ptr ); 183
tvb = tvb_new_child_real_data ( src_tvb , pdata_ptr -> buffer , pdata_ptr -> len , pdata_ptr -> len ); 188
add_new_data_source ( pinfo , tvb , "Uncompressed WCP" ); 191
return tvb ; 192
0
------------------------------
628 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c memcpy 306
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
0
------------------------------
629 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c memcpy 304
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
0
------------------------------
630 /home/SySeVR/data/CVE_2010_2431_VULN_cupsFileOpen.c close 87
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
cups_file_t * fp ; 7
int fd ; 8
char hostname [ 1024 ] , * portname ; 9
http_addrlist_t * addrlist ; 11
if ( ! filename || ! mode || ( * mode != 'r' && * mode != 'w' && * mode != 'a' && * mode != 's' ) || ( * mode == 'a' && isdigit ( mode [ 1 ] & 255 ) ) )  21
switch ( * mode )  30
fd = open ( filename , O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE | O_BINARY , 0666 ); 33
fd = open ( filename , O_RDONLY | O_LARGEFILE | O_BINARY , 0 ); 37
fd = open ( filename , O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE | O_BINARY , 0666 ); 41
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  46
* portname ++ = '\0'; 47
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  55
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
if ( fd < 0 )  75
if ( ( fp = cupsFileOpenFd ( fd , mode ) ) == NULL )  82
if ( * mode == 's' )  84
close ( fd ); 87
0
------------------------------
631 /home/SySeVR/data/CVE_2011_1175_VULN_handle_tcptls_connection.c close 89
static void *CVE_2011_1175_VULN_handle_tcptls_connection(void *data) 1
struct ast_tcptls_session_instance * tcptls_session = data ; 3
int ( * ssl_setup ) ( SSL * ) = ( tcptls_session -> client ) ? SSL_connect : SSL_accept 5
int ret ; 6
if ( ! tcptls_session -> parent -> tls_cfg )  13
tcptls_session -> f = fdopen ( tcptls_session -> fd , "w+" ); 14
if ( tcptls_session -> ssl = SSL_new ( tcptls_session -> parent -> tls_cfg -> ssl_ctx ) )  18
if ( ( ret = ssl_setup ( tcptls_session -> ssl ) ) <= 0 )  20
tcptls_session -> f = funopen ( tcptls_session -> ssl , ssl_read , ssl_write , NULL , ssl_close ); 24
if ( ( tcptls_session -> client && ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_DONT_VERIFY_SERVER ) ) || ( ! tcptls_session -> client && ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_VERIFY_CLIENT ) ) )  35
X509 * peer ; 37
peer = SSL_get_peer_certificate ( tcptls_session -> ssl ); 39
if ( ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_IGNORE_COMMON_NAME ) )  45
unsigned char * str2 ; 47
X509_NAME * name = X509_get_subject_name ( peer ) ; 48
int pos = - 1 ; 49
int found = 0 ; 50
pos = X509_NAME_get_index_by_NID ( name , NID_commonName , pos ); 55
if ( pos < 0 )  56
if ( str2 )  60
if ( ! strcasecmp ( tcptls_session -> parent -> hostname , ( char * ) str2 ) )  61
found = 1; 62
if ( found )  66
if ( ! found )  69
if ( ! tcptls_session -> f )  88
close ( tcptls_session -> fd ); 89
0
------------------------------
632 /home/SySeVR/data/CVE_2011_1175_VULN_handle_tcptls_connection.c close 73
static void *CVE_2011_1175_VULN_handle_tcptls_connection(void *data) 1
struct ast_tcptls_session_instance * tcptls_session = data ; 3
int ( * ssl_setup ) ( SSL * ) = ( tcptls_session -> client ) ? SSL_connect : SSL_accept 5
int ret ; 6
if ( ! tcptls_session -> parent -> tls_cfg )  13
if ( tcptls_session -> ssl = SSL_new ( tcptls_session -> parent -> tls_cfg -> ssl_ctx ) )  18
if ( ( ret = ssl_setup ( tcptls_session -> ssl ) ) <= 0 )  20
tcptls_session -> f = funopen ( tcptls_session -> ssl , ssl_read , ssl_write , NULL , ssl_close ); 24
if ( ( tcptls_session -> client && ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_DONT_VERIFY_SERVER ) ) || ( ! tcptls_session -> client && ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_VERIFY_CLIENT ) ) )  35
X509 * peer ; 37
peer = SSL_get_peer_certificate ( tcptls_session -> ssl ); 39
if ( ! ast_test_flag ( & tcptls_session -> parent -> tls_cfg -> flags , AST_SSL_IGNORE_COMMON_NAME ) )  45
unsigned char * str2 ; 47
X509_NAME * name = X509_get_subject_name ( peer ) ; 48
int pos = - 1 ; 49
int found = 0 ; 50
pos = X509_NAME_get_index_by_NID ( name , NID_commonName , pos ); 55
if ( pos < 0 )  56
if ( str2 )  60
if ( ! strcasecmp ( tcptls_session -> parent -> hostname , ( char * ) str2 ) )  61
found = 1; 62
if ( found )  66
if ( ! found )  69
close ( tcptls_session -> fd ); 73
0
------------------------------
633 /home/SySeVR/data/CVE_2012_2669_VULN_main.c close 76
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
close ( fd ); 76
0
------------------------------
634 /home/SySeVR/data/CVE_2012_2669_VULN_main.c close 61
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
if ( len < 0 )  59
close ( fd ); 61
0
------------------------------
635 /home/SySeVR/data/CVE_2012_2669_VULN_main.c close 41
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
addr . nl_family = AF_NETLINK; 32
addr . nl_pad = 0; 33
addr . nl_pid = 0; 34
addr . nl_groups = CN_KVP_IDX; 35
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 38
if ( error < 0 )  39
close ( fd ); 41
0
------------------------------
636 /home/SySeVR/data/CVE_2012_5532_VULN_main.c close 84
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
0
------------------------------
637 /home/SySeVR/data/CVE_2012_5532_VULN_main.c close 65
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
close ( fd ); 65
0
------------------------------
638 /home/SySeVR/data/CVE_2012_5532_VULN_main.c close 45
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
close ( fd ); 45
0
------------------------------
639 /home/SySeVR/data/CVE_2009_2484_VULN_Win32AddConnection.c strchr 36
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char * psz_parser ; 9
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_parser = strchr ( psz_path , '/' ); 33
if ( psz_parser )  34
char * psz_parser2 = strchr ( ++ psz_parser , '/' ) ; 36
if ( psz_parser2 )  37
0
------------------------------
640 /home/SySeVR/data/CVE_2009_2484_VULN_Win32AddConnection.c strchr 33
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char * psz_parser ; 9
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
psz_parser = strchr ( psz_path , '/' ); 33
if ( psz_parser )  34
char * psz_parser2 = strchr ( ++ psz_parser , '/' ) ; 36
if ( psz_parser2 )  37
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ); 38
0
------------------------------
641 /home/SySeVR/data/CVE_2010_1224_PATCHED_ast_append_ha.c strchr 29
struct ast_ha *CVE_2010_1224_PATCHED_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
0
------------------------------
642 /home/SySeVR/data/CVE_2010_1224_PATCHED_ast_append_ha.c strchr 20
struct ast_ha *CVE_2010_1224_PATCHED_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
if ( ! inet_aton ( nm , & ha -> netmask ) )  46
0
------------------------------
643 /home/SySeVR/data/CVE_2010_1224_VULN_ast_append_ha.c strchr 29
struct ast_ha *CVE_2010_1224_VULN_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
0
------------------------------
644 /home/SySeVR/data/CVE_2010_1224_VULN_ast_append_ha.c strchr 20
struct ast_ha *CVE_2010_1224_VULN_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
if ( ! inet_aton ( nm , & ha -> netmask ) )  39
0
------------------------------
645 /home/SySeVR/data/CVE_2011_3000_PATCHED_nsHttpHeaderArray__ParseHeaderLine.c strchr 20
void
CVE_2011_3000_PATCHED_nsHttpHeaderArray::ParseHeaderLine(const char *line,
nsHttpAtom *hdr,
char **val) 4
char * p = ( char * ) strchr ( line , ':' ) ; 20
if ( ! p )  21
if ( ! nsHttp :: IsValidToken ( line , p ) )  27
* p = 0; 32
p = net_FindCharNotInSet ( ++ p , HTTP_LWS ); 41
char * p2 = net_RFindCharNotInSet ( p , HTTP_LWS ) ; 44
* ++ p2 = 0; 46
* val = p; 52
SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE , PR_FALSE ); 55
0
------------------------------
646 /home/SySeVR/data/CVE_2011_3000_VULN_nsHttpHeaderArray__ParseHeaderLine.c strchr 20
void
CVE_2011_3000_VULN_nsHttpHeaderArray::ParseHeaderLine(const char *line,
nsHttpAtom *hdr,
char **val) 4
char * p = ( char * ) strchr ( line , ':' ) ; 20
if ( ! p )  21
if ( ! nsHttp :: IsValidToken ( line , p ) )  27
* p = 0; 32
p = net_FindCharNotInSet ( ++ p , HTTP_LWS ); 41
char * p2 = net_RFindCharNotInSet ( p , HTTP_LWS ) ; 44
* ++ p2 = 0; 46
* val = p; 52
SetHeader ( atom , nsDependentCString ( p , p2 - p ) , PR_TRUE ); 55
0
------------------------------
647 /home/SySeVR/data/CVE_2012_4530_PATCHED_load_script.c strchr 22
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
0
------------------------------
648 /home/SySeVR/data/CVE_2012_4530_VULN_load_script.c strchr 22
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
0
------------------------------
649 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strchr 10
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
end --; 14
while ( isspace ( * end ) )  15
end --; 15
end [ 1 ] = '\0'; 16
0
------------------------------
650 /home/SySeVR/data/CVE_2013_6378_PATCHED_lbs_debugfs_write.c strchr 36
static ssize_t CVE_2013_6378_PATCHED_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
char * p2 ; 9
struct debug_data * d = f -> private_data ; 10
if ( cnt == 0 )  12
pdata = kmalloc ( cnt + 1 , GFP_KERNEL ); 15
if ( pdata == NULL )  16
if ( copy_from_user ( pdata , buf , cnt ) )  19
pdata [ cnt ] = '\0'; 24
p0 = pdata; 26
for (i = 0; i < num_of_items; i++) 27
p = strstr ( p0 , d [ i ] . name ); 29
if ( p == NULL )  30
p1 = strchr ( p , '\n' ); 32
if ( p1 == NULL )  33
p0 = p1 ++; 35
p2 = strchr ( p , '=' ); 36
if ( ! p2 )  37
p2 ++; 39
r = simple_strtoul ( p2 , NULL , 0 ); 40
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 42
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 44
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 46
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 48
while ( 1 )  50
0
------------------------------
651 /home/SySeVR/data/CVE_2013_6378_PATCHED_lbs_debugfs_write.c strchr 32
static ssize_t CVE_2013_6378_PATCHED_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
if ( cnt == 0 )  12
pdata = kmalloc ( cnt + 1 , GFP_KERNEL ); 15
if ( pdata == NULL )  16
if ( copy_from_user ( pdata , buf , cnt ) )  19
pdata [ cnt ] = '\0'; 24
p0 = pdata; 26
for (i = 0; i < num_of_items; i++) 27
p = strstr ( p0 , d [ i ] . name ); 29
if ( p == NULL )  30
p1 = strchr ( p , '\n' ); 32
if ( p1 == NULL )  33
p0 = p1 ++; 35
p2 = strchr ( p , '=' ); 36
if ( ! p2 )  37
p2 ++; 39
r = simple_strtoul ( p2 , NULL , 0 ); 40
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 42
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 44
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 46
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 48
while ( 1 )  50
0
------------------------------
652 /home/SySeVR/data/CVE_2013_6378_VULN_lbs_debugfs_write.c strchr 32
static ssize_t CVE_2013_6378_VULN_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
char * p2 ; 9
struct debug_data * d = f -> private_data ; 10
pdata = kmalloc ( cnt , GFP_KERNEL ); 12
if ( pdata == NULL )  13
if ( copy_from_user ( pdata , buf , cnt ) )  16
p0 = pdata; 22
for (i = 0; i < num_of_items; i++) 23
p = strstr ( p0 , d [ i ] . name ); 25
if ( p == NULL )  26
p1 = strchr ( p , '\n' ); 28
if ( p1 == NULL )  29
p0 = p1 ++; 31
p2 = strchr ( p , '=' ); 32
if ( ! p2 )  33
p2 ++; 35
r = simple_strtoul ( p2 , NULL , 0 ); 36
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 38
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 40
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 42
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 44
while ( 1 )  46
0
------------------------------
653 /home/SySeVR/data/CVE_2013_6378_VULN_lbs_debugfs_write.c strchr 28
static ssize_t CVE_2013_6378_VULN_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
pdata = kmalloc ( cnt , GFP_KERNEL ); 12
if ( pdata == NULL )  13
if ( copy_from_user ( pdata , buf , cnt ) )  16
p0 = pdata; 22
for (i = 0; i < num_of_items; i++) 23
p = strstr ( p0 , d [ i ] . name ); 25
if ( p == NULL )  26
p1 = strchr ( p , '\n' ); 28
if ( p1 == NULL )  29
p0 = p1 ++; 31
p2 = strchr ( p , '=' ); 32
if ( ! p2 )  33
p2 ++; 35
r = simple_strtoul ( p2 , NULL , 0 ); 36
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 38
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 40
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 42
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 44
while ( 1 )  46
0
------------------------------
654 /home/SySeVR/data/CVE_2014_1642_VULN_pirq_guest_bind.c xmalloc 36
int CVE_2014_1642_VULN_pirq_guest_bind(struct vcpu *v, struct pirq *pirq, int will_share) 1
struct irq_desc * desc ; 4
irq_guest_action_t * action , * newaction = NULL ; 5
desc = pirq_spin_lock_irq_desc ( pirq , NULL ); 12
if ( desc == NULL )  13
action = ( irq_guest_action_t * ) desc -> action; 19
if ( ! ( desc -> status & IRQ_GUEST ) )  22
if ( desc -> action != NULL )  24
if ( newaction == NULL )  33
if ( ( newaction = xmalloc ( irq_guest_action_t ) ) != NULL && zalloc_cpumask_var ( & newaction -> cpu_eoi_map ) )  36
xfree ( newaction ); 39
action = newaction; 47
desc -> action = ( struct irqaction * ) action; 48
action -> nr_guests = 0; 51
action -> in_flight = 0; 52
action -> shareable = will_share; 53
action -> ack_type = pirq_acktype ( v -> domain , pirq -> pirq ); 54
init_timer ( & action -> eoi_timer , irq_guest_eoi_timer_fn , desc , 0 ); 55
desc -> status |= IRQ_GUEST; 57
desc -> status &= ~IRQ_DISABLED; 58
desc -> handler -> startup ( desc ); 59
if ( ! opt_noirqbalance && ( desc -> handler -> set_affinity != NULL ) )  62
desc -> handler -> set_affinity ( desc , cpumask_of ( v -> processor ) ); 63
if ( ! will_share || ! action -> shareable )  65
if ( action -> nr_guests == 0 )  74
if ( action -> nr_guests == IRQ_MAX_GUESTS )  87
action -> guest [ action -> nr_guests ++ ] = v -> domain; 96
if ( action -> ack_type != ACKTYPE_NONE )  98
if ( newaction != NULL )  106
free_cpumask_var ( newaction -> cpu_eoi_map ); 108
xfree ( newaction ); 109
0
------------------------------
655 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c alloca 61
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
0
------------------------------
656 /home/SySeVR/data/CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric.c assert 43
void CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
if ( count == 0 )  7
if ( count == 1 )  14
if ( count == 2 )  21
if ( count == 3 )  28
if ( count == 4 )  35
assert ( 0 && "invalid parametric function type." ); 43
0
------------------------------
657 /home/SySeVR/data/CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric.c assert 43
void CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
if ( count == 0 )  7
if ( count == 1 )  14
if ( count == 2 )  21
if ( count == 3 )  28
if ( count == 4 )  35
assert ( 0 && "invalid parametric function type." ); 43
0
------------------------------
658 /home/SySeVR/data/CVE_2012_2797_PATCHED_decode_frame_mp3on4.c assert 36
static int CVE_2012_2797_PATCHED_decode_frame_mp3on4(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
MP3On4DecodeContext * s = avctx -> priv_data ; 6
MPADecodeContext * m ; 7
int fsize , len = buf_size , out_size = 0 ; 8
uint32_t header ; 9
int fr , j , n , ch , ret ; 12
s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE; 15
if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 )  16
if ( buf_size < HEADER_SIZE )  23
avctx -> bit_rate = 0; 29
ch = 0; 31
for (fr = 0; fr < s->frames; fr++) 32
fsize = AV_RB16 ( buf ) >> 4; 33
fsize = FFMIN3 ( fsize , len , MPA_MAX_CODED_FRAME_SIZE ); 34
m = s -> mp3decctx [ fr ]; 35
assert ( m != NULL ); 36
if ( fsize < HEADER_SIZE )  38
header = ( AV_RB32 ( buf ) & 0x000fffff ) | s -> syncword; 42
if ( ff_mpa_check_header ( header ) < 0 )  44
if ( ch + m -> nb_channels > avctx -> channels )  49
ch += m -> nb_channels; 54
buf += fsize; 57
len -= fsize; 58
avctx -> bit_rate += m -> bit_rate; 77
0
------------------------------
659 /home/SySeVR/data/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 164
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
assert ( 0 && "unexpected colorspace" ); 164
0
------------------------------
660 /home/SySeVR/data/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 139
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in -> color_space == GRAY_SIGNATURE )  136
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  137
assert ( 0 && "input type" ); 139
0
------------------------------
661 /home/SySeVR/data/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 67
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
if ( precache )  44
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  49
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  56
if ( in -> color_space == RGB_SIGNATURE )  62
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  65
assert ( 0 && "input type" ); 67
0
------------------------------
662 /home/SySeVR/data/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 37
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in_type == QCMS_DATA_RGB_8 || in_type == QCMS_DATA_RGBA_8 ) && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  26
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 35
if ( ! result )  36
assert ( 0 && "precacheLUT failed" ); 37
0
------------------------------
663 /home/SySeVR/data/CVE_2013_0792_PATCHED_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_PATCHED_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
0
------------------------------
664 /home/SySeVR/data/CVE_2013_0792_VULN_qcms_transform_create.c assert 160
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
assert ( 0 && "unexpected colorspace" ); 160
0
------------------------------
665 /home/SySeVR/data/CVE_2013_0792_VULN_qcms_transform_create.c assert 135
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in -> color_space == GRAY_SIGNATURE )  132
if ( in_type != QCMS_DATA_GRAY_8 && in_type != QCMS_DATA_GRAYA_8 )  133
assert ( 0 && "input type" ); 135
0
------------------------------
666 /home/SySeVR/data/CVE_2013_0792_VULN_qcms_transform_create.c assert 63
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
bool precache = false ; 6
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( out -> output_table_r && out -> output_table_g && out -> output_table_b )  19
precache = true; 22
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
if ( precache )  40
if ( ! out -> redTRC || ! out -> greenTRC || ! out -> blueTRC )  45
if ( ! transform -> output_gamma_lut_r || ! transform -> output_gamma_lut_g || ! transform -> output_gamma_lut_b )  52
if ( in -> color_space == RGB_SIGNATURE )  58
if ( in_type != QCMS_DATA_RGB_8 && in_type != QCMS_DATA_RGBA_8 )  61
assert ( 0 && "input type" ); 63
0
------------------------------
667 /home/SySeVR/data/CVE_2013_0792_VULN_qcms_transform_create.c assert 33
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
if ( qcms_supports_iccv4 && ( in -> A2B0 || out -> B2A0 || in -> mAB || out -> mAB ) )  25
qcms_transform * result = qcms_transform_precacheLUT_float ( transform , in , out , 33 , in_type ) ; 31
if ( ! result )  32
assert ( 0 && "precacheLUT failed" ); 33
0
------------------------------
668 /home/SySeVR/data/CVE_2013_0792_VULN_qcms_transform_create.c assert 14
qcms_transform* CVE_2013_0792_VULN_qcms_transform_create(
qcms_profile *in, qcms_data_type in_type,
qcms_profile *out, qcms_data_type out_type,
qcms_intent intent) 4
qcms_transform * transform = transform_alloc ( ) ; 8
if ( ! transform )  9
if ( out_type != QCMS_DATA_RGB_8 && out_type != QCMS_DATA_RGBA_8 )  12
assert ( 0 && "output type" ); 14
0
------------------------------
669 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 520
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
0
------------------------------
670 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 510
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
0
------------------------------
671 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 469
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
0
------------------------------
672 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 468
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
0
------------------------------
673 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 467
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
0
------------------------------
674 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 372
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
0
------------------------------
675 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 371
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
0
------------------------------
676 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c assert 370
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
0
------------------------------
677 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 520
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
0
------------------------------
678 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 510
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
0
------------------------------
679 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 469
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 469
0
------------------------------
680 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 468
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 468
0
------------------------------
681 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 467
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( s0 -> first_field )  466
assert ( s0 -> current_picture_ptr ); 467
0
------------------------------
682 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 372
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 372
0
------------------------------
683 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 371
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 371
0
------------------------------
684 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c assert 370
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( h0 -> current_slice != 0 )  335
if ( s0 -> first_field )  369
assert ( s0 -> current_picture_ptr ); 370
0
------------------------------
685 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c assert 360
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 360
0
------------------------------
686 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c assert 359
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 359
0
------------------------------
687 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c assert 358
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( s0 -> first_field )  357
assert ( s0 -> current_picture_ptr ); 358
0
------------------------------
688 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c assert 261
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 261
0
------------------------------
689 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c assert 260
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 260
0
------------------------------
690 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c assert 259
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( h0 -> current_slice != 0 )  219
if ( s0 -> first_field )  258
assert ( s0 -> current_picture_ptr ); 259
0
------------------------------
691 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c assert 359
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( s0 -> first_field )  356
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 359
0
------------------------------
692 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c assert 358
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( s0 -> first_field )  356
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 358
0
------------------------------
693 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c assert 357
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( s0 -> first_field )  356
assert ( s0 -> current_picture_ptr ); 357
0
------------------------------
694 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c assert 260
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
if ( h -> sps . frame_mbs_only_flag )  202
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( h0 -> current_slice != 0 )  218
if ( s0 -> first_field )  257
assert ( s0 -> current_picture_ptr -> f . reference != DELAYED_PIC_REF ); 260
0
------------------------------
695 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c assert 259
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
if ( h -> sps . frame_mbs_only_flag )  202
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( h0 -> current_slice != 0 )  218
if ( s0 -> first_field )  257
assert ( s0 -> current_picture_ptr -> f . data [ 0 ] ); 259
0
------------------------------
696 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c assert 258
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
if ( h -> sps . frame_mbs_only_flag )  202
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( h0 -> current_slice != 0 )  218
if ( s0 -> first_field )  257
assert ( s0 -> current_picture_ptr ); 258
0
------------------------------
697 /home/SySeVR/data/CVE_2013_4534_PATCHED_openpic_load.c assert 20
static int CVE_2013_4534_PATCHED_openpic_load(QEMUFile* f, void *opaque, int version_id) 1
OpenPICState * opp = ( OpenPICState * ) opaque ; 3
unsigned int i , nb_cpus ; 4
if ( version_id != 1 )  6
if ( opp -> nb_cpus != nb_cpus )  17
assert ( nb_cpus > 0 && nb_cpus <= MAX_CPU ); 20
0
------------------------------
698 /home/SySeVR/data/CVE_2014_9743_PATCHED_httpd_HtmlError.c assert 4
static size_t CVE_2014_9743_PATCHED_httpd_HtmlError (char **body, int code, const char *url) 1
const char * errname = httpd_ReasonFromCode ( code ) ; 3
assert ( errname != NULL ); 4
0
------------------------------
699 /home/SySeVR/data/CVE_2014_9743_VULN_httpd_HtmlError.c assert 4
static size_t CVE_2014_9743_VULN_httpd_HtmlError (char **body, int code, const char *url) 1
const char * errname = httpd_ReasonFromCode ( code ) ; 3
assert ( errname != NULL ); 4
0
------------------------------
700 /home/SySeVR/data/CVE_2007_1217_VULN_bufprint.c vsprintf 5
static void CVE_2007_1217_VULN_bufprint(char *fmt,...) 1
va_list f ; 3
vsprintf ( p , fmt , f ); 5
p += strlen ( p ); 7
0
------------------------------
701 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c malloc 162
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
if ( rowSize % 4 )  147
rowSize += ( 4 - ( rowSize % 4 ) ); 148
PRUint32 toCopy ; 149
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
aCount -= toCopy; 156
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
if ( ! mDecoded )  161
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 162
if ( ! mDecoded )  163
PRUint8 * d = mDecoded ; 168
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
if ( mCurLine == 0 )  225
mRowBytes = 0; 228
while ( aCount > 0 )  231
0
------------------------------
702 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c malloc 103
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
703 /home/SySeVR/data/CVE_2011_2588_PATCHED_AVI_ChunkRead_strf.c malloc 69
static int CVE_2011_2588_PATCHED_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( * p_chk -> strf . vids . p_bih ) ) ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 72
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 74
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 75
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 80
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 81
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  82
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 84
if ( p_chk -> common . i_chunk_size > sizeof ( BITMAPINFOHEADER ) )  86
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 88
p_chk -> strf . common . i_cat = UNKNOWN_ES; 104
0
------------------------------
704 /home/SySeVR/data/CVE_2011_2588_PATCHED_AVI_ChunkRead_strf.c malloc 21
static int CVE_2011_2588_PATCHED_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> wFormatTag ); 22
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> nChannels ); 23
AVI_READ4BYTES ( p_chk -> strf . auds . p_wf -> nSamplesPerSec ); 24
AVI_READ4BYTES ( p_chk -> strf . auds . p_wf -> nAvgBytesPerSec ); 25
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> nBlockAlign ); 26
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> wBitsPerSample ); 27
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> cbSize ); 31
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
if ( p_chk -> strf . auds . p_wf -> wFormatTag == WAVE_FORMAT_EXTENSIBLE )  39
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
msg_Dbg ( ( vlc_object_t * ) s , "strf: audio:0x%4.4x channels:%d %dHz %dbits/sample %dkb/s" , p_chk -> strf . auds . p_wf -> wFormatTag , p_chk -> strf . auds . p_wf -> nChannels , p_chk -> strf . auds . p_wf -> nSamplesPerSec , p_chk -> strf . auds . p_wf -> wBitsPerSample , p_chk -> strf . auds . p_wf -> nAvgBytesPerSec * 8 / 1024 ); 57
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( * p_chk -> strf . vids . p_bih ) ) ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 72
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 74
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 75
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 80
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 81
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  82
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 84
if ( p_chk -> common . i_chunk_size > sizeof ( BITMAPINFOHEADER ) )  86
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 88
p_chk -> strf . common . i_cat = UNKNOWN_ES; 104
0
------------------------------
705 /home/SySeVR/data/CVE_2011_2588_VULN_AVI_ChunkRead_strf.c malloc 69
static int CVE_2011_2588_VULN_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 70
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 72
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 74
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 75
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 80
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  81
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 83
if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 )  85
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 87
p_chk -> strf . common . i_cat = UNKNOWN_ES; 103
0
------------------------------
706 /home/SySeVR/data/CVE_2011_2588_VULN_AVI_ChunkRead_strf.c malloc 21
static int CVE_2011_2588_VULN_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> wFormatTag ); 22
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> nChannels ); 23
AVI_READ4BYTES ( p_chk -> strf . auds . p_wf -> nSamplesPerSec ); 24
AVI_READ4BYTES ( p_chk -> strf . auds . p_wf -> nAvgBytesPerSec ); 25
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> nBlockAlign ); 26
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> wBitsPerSample ); 27
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
AVI_READ2BYTES ( p_chk -> strf . auds . p_wf -> cbSize ); 31
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
if ( p_chk -> strf . auds . p_wf -> wFormatTag == WAVE_FORMAT_EXTENSIBLE )  39
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
msg_Dbg ( ( vlc_object_t * ) s , "strf: audio:0x%4.4x channels:%d %dHz %dbits/sample %dkb/s" , p_chk -> strf . auds . p_wf -> wFormatTag , p_chk -> strf . auds . p_wf -> nChannels , p_chk -> strf . auds . p_wf -> nSamplesPerSec , p_chk -> strf . auds . p_wf -> wBitsPerSample , p_chk -> strf . auds . p_wf -> nAvgBytesPerSec * 8 / 1024 ); 57
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 70
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 72
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 74
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 75
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 80
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  81
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 83
if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 )  85
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 87
p_chk -> strf . common . i_cat = UNKNOWN_ES; 103
0
------------------------------
707 /home/SySeVR/data/CVE_2011_3002_VULN_GrowAtomTable.c malloc 11
static int CVE_2011_3002_VULN_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newrev = malloc ( sizeof ( int ) * size ); 11
if ( ! newmap || ! newrev )  14
if ( newrev )  18
atable -> arev = newrev; 19
memset ( & newrev [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 23
atable -> arev = newrev; 25
atable -> size = size; 26
0
------------------------------
708 /home/SySeVR/data/CVE_2011_3002_VULN_GrowAtomTable.c malloc 10
static int CVE_2011_3002_VULN_GrowAtomTable(AtomTable *atable, int size) 1
int * newmap , * newrev ; 3
if ( atable -> size < size )  5
if ( atable -> amap )  6
newmap = malloc ( sizeof ( int ) * size ); 10
if ( ! newmap || ! newrev )  14
if ( newmap )  16
atable -> amap = newmap; 17
atable -> arev = newrev; 19
memset ( & newmap [ atable -> size ] , 0 , ( size - atable -> size ) * sizeof ( int ) ); 22
atable -> amap = newmap; 24
atable -> arev = newrev; 25
atable -> size = size; 26
0
------------------------------
709 /home/SySeVR/data/CVE_2012_1960_PATCHED_build_input_gamma_table.c malloc 6
float *CVE_2012_1960_PATCHED_build_input_gamma_table(struct curveType *TRC) 1
float * gamma_table ; 3
if ( ! TRC )  5
gamma_table = malloc ( sizeof ( float ) * 256 ); 6
if ( gamma_table )  7
compute_curve_gamma_table_type_parametric ( gamma_table , TRC -> parameter , TRC -> count ); 9
compute_curve_gamma_table_type0 ( gamma_table ); 12
compute_curve_gamma_table_type1 ( gamma_table , TRC -> data [ 0 ] ); 14
compute_curve_gamma_table_type2 ( gamma_table , TRC -> data , TRC -> count ); 16
return gamma_table ; 20
0
------------------------------
710 /home/SySeVR/data/CVE_2012_2669_VULN_main.c malloc 91
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 94
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_value , os_build ); 180
strcpy ( key_value , os_name ); 184
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
711 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c malloc 114
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )  100
p_stream -> i_headers = 0; 103
p_stream -> p_headers = NULL; 104
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
p_stream -> fmt . i_extra = p_stream -> i_headers; 113
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers ); 114
if ( p_stream -> fmt . p_extra )  115
memcpy ( p_stream -> fmt . p_extra , p_stream -> p_headers , p_stream -> i_headers ); 116
p_stream -> fmt . i_extra = 0; 119
if ( Ogg_LogicalStreamResetEsFormat ( p_demux , p_stream ) )  121
es_out_Control ( p_demux -> out , ES_OUT_SET_ES_FMT , p_stream -> p_es , & p_stream -> fmt ); 122
if ( p_stream -> i_headers > 0 )  125
Ogg_ExtractMeta ( p_demux , p_stream -> fmt . i_codec , p_stream -> p_headers , p_stream -> i_headers ); 126
if ( p_stream -> fmt . i_codec == VLC_CODEC_VORBIS || p_stream -> fmt . i_codec == VLC_CODEC_SPEEX || p_stream -> fmt . i_codec == VLC_CODEC_FLAC )  138
if ( p_stream -> i_pcr >= 0 )  142
if ( p_stream -> i_previous_pcr == 0 && p_stream -> i_pcr > 3 * DEFAULT_PTS_DELAY )  146
es_out_Control ( p_demux -> out , ES_OUT_SET_PCR , VLC_TS_0 + p_stream -> i_pcr ); 152
p_stream -> i_previous_pcr = p_stream -> i_pcr; 156
i_pts = p_stream -> i_pcr; 159
i_interpolated_pts = p_stream -> i_interpolated_pcr; 164
Ogg_UpdatePCR ( p_stream , p_oggpacket ); 165
if ( p_stream -> fmt . i_cat != SPU_ES )  168
if ( p_stream -> i_pcr >= 0 )  170
if ( p_stream -> i_previous_pcr == 0 && p_stream -> i_pcr > 3 * DEFAULT_PTS_DELAY )  174
es_out_Control ( p_demux -> out , ES_OUT_SET_PCR , VLC_TS_0 + p_stream -> i_pcr ); 180
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> i_pcr >= 0 )  185
p_stream -> i_previous_pcr = p_stream -> i_pcr; 190
i_pts = p_stream -> i_pcr; 193
if ( p_stream -> i_skip_frames > 0 )  210
p_stream -> i_skip_frames --; 213
if ( i_pts == 0 )  218
if ( i_pts == - 1 && i_interpolated_pts == 0 )  219
if ( i_pts == - 1 )  220
if ( p_stream -> fmt . i_cat == AUDIO_ES )  222
p_block -> i_dts = p_block -> i_pts = i_pts; 223
if ( p_stream -> fmt . i_cat == SPU_ES )  224
p_block -> i_dts = p_block -> i_pts = i_pts; 226
p_block -> i_length = 0; 227
if ( p_stream -> fmt . i_codec == VLC_CODEC_THEORA )  229
p_block -> i_dts = p_block -> i_pts = i_pts; 231
if ( ( p_oggpacket -> granulepos & ( ( 1 << p_stream -> i_granule_shift ) - 1 ) ) == 0 )  232
p_block -> i_flags |= BLOCK_FLAG_TYPE_I; 234
if ( p_stream -> fmt . i_codec == VLC_CODEC_DIRAC )  237
p_block -> i_dts = p_stream -> i_pcr; 244
p_block -> i_pts = VLC_TS_INVALID; 245
p_block -> i_pts = u_pnum * INT64_C ( 1000000 ) / p_stream -> f_rate / 2; 250
p_block -> i_dts = i_pts; 254
p_block -> i_pts = VLC_TS_INVALID; 255
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> fmt . i_codec != VLC_CODEC_TARKIN && p_stream -> fmt . i_codec != VLC_CODEC_THEORA && p_stream -> fmt . i_codec != VLC_CODEC_CMML && p_stream -> fmt . i_codec != VLC_CODEC_DIRAC && p_stream -> fmt . i_codec != VLC_CODEC_KATE )  258
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT )  271
p_block -> i_length = ( mtime_t ) lenbytes * 1000; 290
if ( p_block -> i_buffer >= ( unsigned int ) i_header_len )  295
p_block -> i_buffer -= i_header_len; 296
if ( p_stream -> fmt . i_codec == VLC_CODEC_TARKIN )  301
msg_Warn ( p_demux , "tarkin pts: %" PRId64 ", granule: %" PRId64 ,
p_block -> i_pts , p_block -> i_dts ) 305
memcpy ( p_block -> p_buffer , p_oggpacket -> packet + i_header_len , p_oggpacket -> bytes - i_header_len ); 309
es_out_Send ( p_demux -> out , p_stream -> p_es , p_block ); 312
0
------------------------------
712 /home/SySeVR/data/CVE_2012_5532_VULN_main.c malloc 108
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
713 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c malloc 536
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar * c = destpath ; 540
NS_tstrcpy ( c , gDestinationPath ); 541
c += NS_tstrlen ( gDestinationPath ); 542
NS_tstrcat ( c , NS_T ( "/" ) ); 545
c += NS_tstrlen ( NS_T ( "/" ) ); 546
* c = NS_T ( '\0' ); 548
c ++; 549
gDestPath = destpath; 551
0
------------------------------
714 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c malloc 536
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar * c = destpath ; 540
NS_tstrcpy ( c , gDestinationPath ); 541
c += NS_tstrlen ( gDestinationPath ); 542
NS_tstrcat ( c , NS_T ( "/" ) ); 545
c += NS_tstrlen ( NS_T ( "/" ) ); 546
* c = NS_T ( '\0' ); 548
c ++; 549
gDestPath = destpath; 551
0
------------------------------
715 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c malloc 580
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar * c = destpath ; 584
NS_tstrcpy ( c , gWorkingDirPath ); 585
c += NS_tstrlen ( gWorkingDirPath ); 586
NS_tstrcat ( c , NS_T ( "/" ) ); 589
c += NS_tstrlen ( NS_T ( "/" ) ); 590
* c = NS_T ( '\0' ); 592
c ++; 593
gDestPath = destpath; 595
0
------------------------------
716 /home/SySeVR/data/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
0
------------------------------
717 /home/SySeVR/data/CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
0
------------------------------
718 /home/SySeVR/data/CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand.c LoadLibraryEx 95
BOOL
CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
FreeLibrary ( updaterModule ); 113
0
------------------------------
719 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c calloc 252
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
mDecoding = mDecoded; 255
SetPixel ( mDecoding , byte , mColors ); 285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mDecoding = mDecoded; 305
mDecoding += byte * GFXBYTESPERPIXEL; 356
SetPixel ( mDecoding , byte , mColors ); 383
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
0
------------------------------
720 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c calloc 245
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mAlphaPtr = mAlpha; 304
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
while ( aCount > 0 && mStateData > 0 )  380
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
0
------------------------------
721 /home/SySeVR/data/CVE_2013_6378_PATCHED_lbs_debugfs_write.c strstr 29
static ssize_t CVE_2013_6378_PATCHED_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
if ( cnt == 0 )  12
pdata = kmalloc ( cnt + 1 , GFP_KERNEL ); 15
if ( pdata == NULL )  16
if ( copy_from_user ( pdata , buf , cnt ) )  19
pdata [ cnt ] = '\0'; 24
p0 = pdata; 26
for (i = 0; i < num_of_items; i++) 27
p = strstr ( p0 , d [ i ] . name ); 29
if ( p == NULL )  30
p1 = strchr ( p , '\n' ); 32
if ( p1 == NULL )  33
p0 = p1 ++; 35
p2 = strchr ( p , '=' ); 36
if ( ! p2 )  37
p2 ++; 39
r = simple_strtoul ( p2 , NULL , 0 ); 40
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 42
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 44
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 46
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 48
while ( 1 )  50
0
------------------------------
722 /home/SySeVR/data/CVE_2013_6378_VULN_lbs_debugfs_write.c strstr 25
static ssize_t CVE_2013_6378_VULN_lbs_debugfs_write(struct file *f, const char __user *buf,
size_t cnt, loff_t *ppos) 2
int r , i ; 4
char * pdata ; 5
char * p ; 6
char * p0 ; 7
char * p1 ; 8
struct debug_data * d = f -> private_data ; 10
pdata = kmalloc ( cnt , GFP_KERNEL ); 12
if ( pdata == NULL )  13
if ( copy_from_user ( pdata , buf , cnt ) )  16
p0 = pdata; 22
for (i = 0; i < num_of_items; i++) 23
p = strstr ( p0 , d [ i ] . name ); 25
if ( p == NULL )  26
p1 = strchr ( p , '\n' ); 28
if ( p1 == NULL )  29
p0 = p1 ++; 31
p2 = strchr ( p , '=' ); 32
if ( ! p2 )  33
p2 ++; 35
r = simple_strtoul ( p2 , NULL , 0 ); 36
* ( ( u8 * ) d [ i ] . addr ) = ( u8 ) r; 38
* ( ( u16 * ) d [ i ] . addr ) = ( u16 ) r; 40
* ( ( u32 * ) d [ i ] . addr ) = ( u32 ) r; 42
* ( ( u64 * ) d [ i ] . addr ) = ( u64 ) r; 44
while ( 1 )  46
0
------------------------------
723 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memmove 133
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
724 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c memmove 110
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
725 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memmove 133
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_cfparamset * pCF ; 6
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pCF = ( struct ieeetypes_cfparamset * ) pos; 124
memcpy ( & bss -> ssparamset . cfparamset , pCF , sizeof ( struct ieeetypes_cfparamset ) ); 125
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
memmove ( & bss -> ssparamset . ibssparamset , pibss , sizeof ( struct ieeetypes_ibssparamset ) ); 133
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
726 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c memmove 110
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_fhparamset * pFH ; 4
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
pFH = ( struct ieeetypes_fhparamset * ) pos; 109
memmove ( & bss -> phyparamset . fhparamset , pFH , sizeof ( struct ieeetypes_fhparamset ) ); 110
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
memcpy ( & bss -> phyparamset . dsparamset , pDS , sizeof ( struct ieeetypes_dsparamset ) ); 118
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
0
------------------------------
727 /home/SySeVR/data/CVE_2013_4563_PATCHED_udp6_ufo_fragment.c memmove 61
static struct sk_buff *CVE_2013_4563_PATCHED_udp6_ufo_fragment(struct sk_buff *skb,
netdev_features_t features) 2
unsigned int mss ; 5
unsigned int unfrag_ip6hlen , unfrag_len ; 6
u8 * packet_start , * prevhdr ; 8
u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; 10
int offset ; 11
__wsum csum ; 12
int tnl_hlen ; 13
mss = skb_shinfo ( skb ) -> gso_size; 15
if ( unlikely ( skb -> len <= mss ) )  16
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )  19
offset = skb_checksum_start_offset ( skb ); 39
csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ); 40
offset += skb -> csum_offset; 41
* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ); 42
skb -> ip_summed = CHECKSUM_NONE; 43
tnl_hlen = skb_tnl_header_len ( skb ); 46
if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) )  47
if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) )  48
unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ); 55
unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen; 58
packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset; 60
memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ); 61
0
------------------------------
728 /home/SySeVR/data/CVE_2014_9428_VULN_batadv_frag_merge_packets.c memmove 34
static struct sk_buff *
CVE_2014_9428_VULN_batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb) 2
struct batadv_frag_packet * packet ; 4
struct batadv_frag_list_entry * entry ; 5
packet = ( struct batadv_frag_packet * ) skb -> data; 10
size = ntohs ( packet -> total_size ); 11
if ( size > batadv_frag_size_limit ( ) )  12
entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) 18
skb_out = entry -> skb; 20
if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 )  24
memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ); 34
skb_set_mac_header ( skb_out , - ETH_HLEN ); 35
skb_reset_network_header ( skb_out ); 36
skb_reset_transport_header ( skb_out ); 37
memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ); 42
return skb_out ; 49
0
------------------------------
729 /home/SySeVR/data/CVE_2004_1151_VULN_sys32_ni_syscall.c strcmp 5
int CVE_2004_1151_VULN_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ 8 ] ; 4
if ( strcmp ( lastcomm , me -> comm ) )  5
0
------------------------------
730 /home/SySeVR/data/CVE_2010_1437_PATCHED_find_keyring_by_name.c strcmp 27
struct key *CVE_2010_1437_PATCHED_find_keyring_by_name(const char *name, bool skip_perm_check) 1
struct key * keyring ; 3
int bucket ; 4
keyring = ERR_PTR ( - EINVAL ); 6
if ( ! name )  7
bucket = keyring_hash ( name ); 10
if ( keyring_name_hash [ bucket ] . next )  14
if ( strcmp ( keyring -> description , name ) != 0 )  27
0
------------------------------
731 /home/SySeVR/data/CVE_2011_1010_VULN_mac_partition.c strcmp 73
int CVE_2011_1010_VULN_mac_partition(struct parsed_partitions *state) 1
unsigned char * data ; 5
int blk , blocks_in_map ; 6
unsigned secsize ; 7
struct CVE_2011_1010_VULN_mac_partition * part ; 12
struct mac_driver_desc * md ; 13
md = read_part_sector ( state , 0 , & sect ); 16
if ( ! md )  17
if ( be16_to_cpu ( md -> signature ) != MAC_DRIVER_MAGIC )  19
secsize = be16_to_cpu ( md -> block_size ); 23
data = read_part_sector ( state , secsize / 512 , & sect ); 25
if ( ! data )  26
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + secsize % 512 ); 28
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  29
blocks_in_map = be32_to_cpu ( part -> map_count ); 34
for (blk = 1; blk <= blocks_in_map; ++blk) 35
int pos = blk * secsize ; 36
data = read_part_sector ( state , pos / 512 , & sect ); 38
if ( ! data )  39
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + pos % 512 ); 41
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  42
if ( machine_is ( powermac ) )  55
if ( strcasecmp ( part -> type , "Apple_UNIX_SVR2" ) == 0 || ( strnicmp ( part -> type , "Linux" , 5 ) == 0 && strcasecmp ( part -> type , "Linux_swap" ) != 0 ) )  66
if ( strcmp ( part -> name , "/" ) == 0 )  73
0
------------------------------
732 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 39
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) )  34
if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) )  39
0
------------------------------
733 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 39
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) )  34
if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) )  39
0
------------------------------
734 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 34
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) )  34
0
------------------------------
735 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 34
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) )  34
0
------------------------------
736 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 34
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) )  34
0
------------------------------
737 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 34
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) )  34
0
------------------------------
738 /home/SySeVR/data/CVE_2011_2518_PATCHED_tomoyo_mount_acl.c strcmp 32
static int CVE_2011_2518_PATCHED_tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
struct path *dir, char *type, unsigned long flags) 2
requested_type = tomoyo_encode ( type ); 16
if ( ! requested_type )  17
requested_dir_name = tomoyo_realpath_from_path ( dir ); 23
if ( ! requested_dir_name )  24
if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) )  32
0
------------------------------
739 /home/SySeVR/data/CVE_2011_3192_VULN_ap_set_byterange.c strcmp 54
static int CVE_2011_3192_VULN_ap_set_byterange(request_rec *r) 1
const char * range ; 3
const char * if_range ; 4
const char * match ; 5
const char * ct ; 6
if ( r -> assbackwards )  9
if ( ! ( range = apr_table_get ( r -> headers_in , "Range" ) ) )  23
range = apr_table_get ( r -> headers_in , "Request-Range" ); 24
if ( ! range || strncasecmp ( range , "bytes=" , 6 ) || r -> status != HTTP_OK )  27
if ( apr_table_get ( r -> headers_out , "Content-Range" ) )  32
if ( ( ct = apr_table_get ( r -> headers_out , "Content-Type" ) ) && ( ! strncasecmp ( ct , "multipart/byteranges" , 20 ) || ! strncasecmp ( ct , "multipart/x-byteranges" , 22 ) ) )  37
if ( if_range = apr_table_get ( r -> headers_in , "If-Range" ) )  47
if ( if_range [ 0 ] == '"' )  48
if ( ! ( match = apr_table_get ( r -> headers_out , "Last-Modified" ) ) || ( strcmp ( if_range , match ) != 0 ) )  54
0
------------------------------
740 /home/SySeVR/data/CVE_2011_3192_VULN_ap_set_byterange.c strcmp 49
static int CVE_2011_3192_VULN_ap_set_byterange(request_rec *r) 1
const char * range ; 3
const char * if_range ; 4
const char * match ; 5
const char * ct ; 6
if ( r -> assbackwards )  9
if ( ! ( range = apr_table_get ( r -> headers_in , "Range" ) ) )  23
range = apr_table_get ( r -> headers_in , "Request-Range" ); 24
if ( ! range || strncasecmp ( range , "bytes=" , 6 ) || r -> status != HTTP_OK )  27
if ( apr_table_get ( r -> headers_out , "Content-Range" ) )  32
if ( ( ct = apr_table_get ( r -> headers_out , "Content-Type" ) ) && ( ! strncasecmp ( ct , "multipart/byteranges" , 20 ) || ! strncasecmp ( ct , "multipart/x-byteranges" , 22 ) ) )  37
if ( if_range = apr_table_get ( r -> headers_in , "If-Range" ) )  47
if ( if_range [ 0 ] == '"' )  48
if ( ! ( match = apr_table_get ( r -> headers_out , "Etag" ) ) || ( strcmp ( if_range , match ) != 0 ) )  49
0
------------------------------
741 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 109
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
0
------------------------------
742 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
0
------------------------------
743 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 107
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
0
------------------------------
744 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c strcmp 19
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
0
------------------------------
745 /home/SySeVR/data/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
0
------------------------------
746 /home/SySeVR/data/CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
0
------------------------------
747 /home/SySeVR/data/CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand.c strcmp 109
BOOL
CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
0
------------------------------
748 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 43
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
if ( strcmp ( keyAlg , "ec-sign-nonrepudiation" ) == 0 )  33
if ( strcmp ( keyAlg , "ec-nonrepudiation" ) == 0 )  35
if ( strcmp ( keyAlg , "dsa-sign-nonrepudiation" ) == 0 )  37
if ( strcmp ( keyAlg , "dsa-sign" ) == 0 )  39
if ( strcmp ( keyAlg , "dsa-nonrepudiation" ) == 0 )  41
if ( strcmp ( keyAlg , "dh-ex" ) == 0 )  43
0
------------------------------
749 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 41
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
if ( strcmp ( keyAlg , "ec-sign-nonrepudiation" ) == 0 )  33
if ( strcmp ( keyAlg , "ec-nonrepudiation" ) == 0 )  35
if ( strcmp ( keyAlg , "dsa-sign-nonrepudiation" ) == 0 )  37
if ( strcmp ( keyAlg , "dsa-sign" ) == 0 )  39
if ( strcmp ( keyAlg , "dsa-nonrepudiation" ) == 0 )  41
0
------------------------------
750 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 39
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
if ( strcmp ( keyAlg , "ec-sign-nonrepudiation" ) == 0 )  33
if ( strcmp ( keyAlg , "ec-nonrepudiation" ) == 0 )  35
if ( strcmp ( keyAlg , "dsa-sign-nonrepudiation" ) == 0 )  37
if ( strcmp ( keyAlg , "dsa-sign" ) == 0 )  39
0
------------------------------
751 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 37
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
if ( strcmp ( keyAlg , "ec-sign-nonrepudiation" ) == 0 )  33
if ( strcmp ( keyAlg , "ec-nonrepudiation" ) == 0 )  35
if ( strcmp ( keyAlg , "dsa-sign-nonrepudiation" ) == 0 )  37
0
------------------------------
752 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 35
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
if ( strcmp ( keyAlg , "ec-sign-nonrepudiation" ) == 0 )  33
if ( strcmp ( keyAlg , "ec-nonrepudiation" ) == 0 )  35
0
------------------------------
753 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 33
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
if ( strcmp ( keyAlg , "ec-sign-nonrepudiation" ) == 0 )  33
0
------------------------------
754 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 31
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
if ( strcmp ( keyAlg , "ec-sign" ) == 0 )  31
0
------------------------------
755 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 29
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
if ( strcmp ( keyAlg , "ec-dual-use" ) == 0 )  29
0
------------------------------
756 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 27
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
if ( strcmp ( keyAlg , "ec-ex" ) == 0 )  27
0
------------------------------
757 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 25
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
if ( strcmp ( keyAlg , "rsa-nonrepudiation" ) == 0 )  25
0
------------------------------
758 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 23
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
if ( strcmp ( keyAlg , "rsa-sign-nonrepudiation" ) == 0 )  23
0
------------------------------
759 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 21
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
if ( strcmp ( keyAlg , "rsa-sign" ) == 0 )  21
0
------------------------------
760 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 19
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
if ( strcmp ( keyAlg , "rsa-dual-use" ) == 0 )  19
0
------------------------------
761 /home/SySeVR/data/CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type.c strcmp 17
static nsKeyGenType
CVE_2013_1705_VULN_cryptojs_interpret_key_gen_type(char *keyAlg) 2
char * end ; 4
if ( keyAlg == nullptr )  5
while ( isspace ( keyAlg [ 0 ] ) )  9
keyAlg ++; 9
end = strchr ( keyAlg , '\0' ); 10
if ( end == nullptr )  11
if ( strcmp ( keyAlg , "rsa-ex" ) == 0 )  17
0
------------------------------
762 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c strcmp 656
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( p -> udptl )  627
if ( udptlportno > 0 )  628
if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  647
if ( ( t38action == SDP_T38_INITIATE ) && p -> owner && p -> lastinvite )  650
if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_FAX_DETECT_T38 ) )  654
if ( strcmp ( p -> owner -> exten , "fax" ) )  656
0
------------------------------
763 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c strcmp 225
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
764 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c strcmp 223
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
765 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c strcmp 173
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
766 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c strcmp 171
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
767 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c strcmp 50
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
if ( strcmp ( accf_name , "connect" ) == 0 )  48
if ( strcmp ( accf_name , "none" ) == 0 )  50
0
------------------------------
768 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c strcmp 48
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
if ( strcmp ( accf_name , "connect" ) == 0 )  48
0
------------------------------
769 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c strcmp 46
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
core_server_config * core_sconf ; 23
const char * accf_name ; 24
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
0
------------------------------
770 /home/SySeVR/data/CVE_2014_8643_VULN_XRE_InitChildProcess.c strcmp 224
nsresult
CVE_2014_8643_VULN_XRE_InitChildProcess(int aArgc,
char* aArgv[]) 3
if ( aArgc < 1 )  42
const int kTimeoutMs = 1000 ; 46
MachSendMessage child_message ( 0 ) ; 48
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( mach_task_self ( ) ) ) )  49
ReceivePort child_recv_port ; 54
mach_port_t raw_child_recv_port = child_recv_port . GetPort ( ) ; 55
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( raw_child_recv_port ) ) )  56
MachPortSender child_sender ( mach_port_name ) ; 61
kern_return_t err = child_sender . SendMessage ( child_message , kTimeoutMs ) ; 62
if ( err != KERN_SUCCESS )  63
MachReceiveMessage parent_message ; 68
err = child_recv_port . WaitForMessage ( & parent_message , kTimeoutMs ); 69
if ( err != KERN_SUCCESS )  70
if ( parent_message . GetTranslatedPort ( 0 ) == MACH_PORT_NULL )  75
err = task_set_bootstrap_port ( mach_task_self ( ) , parent_message . GetTranslatedPort ( 0 ) ); 79
if ( err != KERN_SUCCESS )  81
if ( aArgc < 1 )  90
nsresult rv = XRE_InitCommandLine ( aArgc , aArgv ) ; 177
if ( NS_FAILED ( rv ) )  178
switch ( XRE_GetProcessType ( ) )  210
for (int idx = aArgc; idx > 0; idx--) 223
if ( aArgv [ idx ] && ! strcmp ( aArgv [ idx ] , "-appdir" ) )  224
0
------------------------------
771 /home/SySeVR/data/CVE_2014_8643_VULN_XRE_InitChildProcess.c strcmp 106
nsresult
CVE_2014_8643_VULN_XRE_InitChildProcess(int aArgc,
char* aArgv[]) 3
if ( aArgc < 1 )  42
const int kTimeoutMs = 1000 ; 46
MachSendMessage child_message ( 0 ) ; 48
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( mach_task_self ( ) ) ) )  49
ReceivePort child_recv_port ; 54
mach_port_t raw_child_recv_port = child_recv_port . GetPort ( ) ; 55
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( raw_child_recv_port ) ) )  56
MachPortSender child_sender ( mach_port_name ) ; 61
kern_return_t err = child_sender . SendMessage ( child_message , kTimeoutMs ) ; 62
if ( err != KERN_SUCCESS )  63
MachReceiveMessage parent_message ; 68
err = child_recv_port . WaitForMessage ( & parent_message , kTimeoutMs ); 69
if ( err != KERN_SUCCESS )  70
if ( parent_message . GetTranslatedPort ( 0 ) == MACH_PORT_NULL )  75
err = task_set_bootstrap_port ( mach_task_self ( ) , parent_message . GetTranslatedPort ( 0 ) ); 79
if ( err != KERN_SUCCESS )  81
if ( aArgc < 1 )  90
const char * const crashReporterArg = aArgv [ -- aArgc ] 92
if ( 0 != strcmp ( "false" , crashReporterArg ) && ! XRE_SetRemoteExceptionHandler ( nullptr ) )  106
0
------------------------------
772 /home/SySeVR/data/CVE_2014_8643_VULN_XRE_InitChildProcess.c strcmp 98
nsresult
CVE_2014_8643_VULN_XRE_InitChildProcess(int aArgc,
char* aArgv[]) 3
if ( aArgc < 1 )  42
const int kTimeoutMs = 1000 ; 46
MachSendMessage child_message ( 0 ) ; 48
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( mach_task_self ( ) ) ) )  49
ReceivePort child_recv_port ; 54
mach_port_t raw_child_recv_port = child_recv_port . GetPort ( ) ; 55
if ( ! child_message . AddDescriptor ( MachMsgPortDescriptor ( raw_child_recv_port ) ) )  56
MachPortSender child_sender ( mach_port_name ) ; 61
kern_return_t err = child_sender . SendMessage ( child_message , kTimeoutMs ) ; 62
if ( err != KERN_SUCCESS )  63
MachReceiveMessage parent_message ; 68
err = child_recv_port . WaitForMessage ( & parent_message , kTimeoutMs ); 69
if ( err != KERN_SUCCESS )  70
if ( parent_message . GetTranslatedPort ( 0 ) == MACH_PORT_NULL )  75
err = task_set_bootstrap_port ( mach_task_self ( ) , parent_message . GetTranslatedPort ( 0 ) ); 79
if ( err != KERN_SUCCESS )  81
if ( aArgc < 1 )  90
const char * const crashReporterArg = aArgv [ -- aArgc ] 92
if ( 0 != strcmp ( "-" , crashReporterArg ) && ! XRE_SetRemoteExceptionHandler ( crashReporterArg ) )  98
0
------------------------------
773 /home/SySeVR/data/CVE_2014_8713_VULN_build_expert_data.c strcmp 21
static void
CVE_2014_8713_VULN_build_expert_data(proto_tree *ncp_tree, const char *hf_name, char *buffer,
size_t buffer_size, int repeat_lookup,
gboolean search_structs) 4
proto_tree * tree_pointer ; 6
proto_tree * tree_loc ; 7
proto_tree * struct_tree_pointer = NULL ; 8
char temp_buffer [ 256 ] = "\0" ; 9
gboolean in_struct = FALSE ; 10
tree_loc = ncp_tree -> first_child; 12
for (tree_pointer=tree_loc; tree_pointer!=NULL; tree_pointer=tree_pointer->next) 13
if ( tree_pointer -> first_child && ! in_struct && search_structs )  16
struct_tree_pointer = tree_pointer; 17
tree_pointer = tree_pointer -> first_child; 18
in_struct = TRUE; 19
if ( strcmp ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> abbrev , hf_name ) == 0 )  21
switch ( PTREE_FINFO ( tree_pointer ) -> hfinfo -> type )  23
if ( repeat_lookup > 0 )  39
if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 )  40
repeat_lookup --; 42
if ( repeat_lookup == 0 )  70
if ( tree_pointer -> next == NULL && in_struct && search_structs )  74
tree_pointer = struct_tree_pointer; 75
in_struct = FALSE; 76
0
------------------------------
774 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c strcmp 152
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
0
------------------------------
775 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c strcmp 152
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
mime_type_t * filetype ; 12
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
int compression ; 20
compression = CUPS_FILE_NONE; 31
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
compression = CUPS_FILE_GZIP; 52
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
ipp_attribute_t * doc_name ; 133
doc_name = ippFindAttribute ( con -> request , "document-name" , IPP_TAG_NAME ); 138
filetype = mimeFileType ( MimeDatabase , con -> filename , doc_name ? doc_name -> values [ 0 ] . string . text : NULL , & compression ); 139
if ( ! filetype )  143
filetype = mimeType ( MimeDatabase , super , type ); 144
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
0
------------------------------
776 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c strcmp 127
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
0
------------------------------
777 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c strcmp 127
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
0
------------------------------
778 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c strcmp 51
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "gzip" ) )  51
0
------------------------------
779 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 661
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  649
if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  661
0
------------------------------
780 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 657
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  649
if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , "none" ) )  657
0
------------------------------
781 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 649
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) )  649
0
------------------------------
782 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 641
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
0
------------------------------
783 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 641
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) )  641
0
------------------------------
784 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
0
------------------------------
785 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
0
------------------------------
786 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
0
------------------------------
787 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 620
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) )  620
0
------------------------------
788 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 602
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
0
------------------------------
789 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 602
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
0
------------------------------
790 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 602
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) )  602
0
------------------------------
791 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 587
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
0
------------------------------
792 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 587
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 534
job -> state_value = IPP_JOB_HELD; 535
if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB )  539
job -> hold_until = time ( NULL ) + MultipleOperationTimeout; 541
job -> state -> values [ 0 ] . integer = IPP_JOB_HELD; 542
job -> state_value = IPP_JOB_HELD; 543
job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING; 547
job -> state_value = IPP_JOB_PENDING; 548
if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification )  553
if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL )  559
attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ); 566
attr -> values [ 0 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 0 ] ); 568
attr -> values [ 1 ] . string . text = _cupsStrRetain ( printer -> job_sheets [ 1 ] ); 569
if ( Classification )  578
if ( ClassifyOverride )  585
if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) )  587
0
------------------------------
793 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 526
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
switch ( attr -> value_tag )  431
for (i = 0; i < attr->num_values; i ++) 448
attr -> values [ i ] . string . text = NULL; 451
if ( attr -> values [ i ] . string . language )  452
attr -> values [ i ] . string . language = NULL; 455
attr -> value_tag = IPP_TAG_NAME; 467
attr -> num_values = 1; 468
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( con -> http -> hostname ); 469
attr -> group_tag = IPP_TAG_JOB; 472
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-processing" , 0 ); 487
attr -> value_tag = IPP_TAG_NOVALUE; 489
attr = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-completed" , 0 ); 490
attr -> value_tag = IPP_TAG_NOVALUE; 492
job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ); 499
job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer; 501
job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ); 502
job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ); 504
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  509
attr -> values [ 0 ] . integer = 0; 510
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  514
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 516
if ( ! attr )  517
if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL )  519
val = "no-hold"; 521
attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ); 523
if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) )  526
0
------------------------------
794 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 422
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
const char * val ; 12
int priority ; 13
cupsd_job_t * job ; 14
int i ; 17
int lowerpagerange ; 18
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL )  206
if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 )  209
if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL )  224
for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) 227
if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper )  229
lowerpagerange = attr -> values [ i ] . range . upper + 1; 239
if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs )  295
if ( ( i = check_quotas ( con , printer ) ) < 0 )  301
if ( i == 0 )  306
if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL )  316
priority = attr -> values [ 0 ] . integer; 318
if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL )  321
priority = atoi ( val ); 323
priority = 50; 325
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL )  331
if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 )  333
if ( ! ippValidateAttribute ( attr ) )  343
if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  352
job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ); 360
job -> attrs = con -> request; 361
job -> dirty = 1; 362
con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ); 363
attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ); 370
if ( ! attr )  390
attr -> group_tag = IPP_TAG_JOB; 395
attr -> name = _cupsStrAlloc ( "job-originating-user-name" ); 397
if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL )  412
if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL )  415
if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) )  422
0
------------------------------
795 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 197
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL )  165
if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies )  168
if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL )  178
if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME )  181
if ( attr -> num_values > 2 )  188
for (i = 0; i < attr->num_values; i ++) 196
if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) )  197
0
------------------------------
796 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c strcmp 67
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
0
------------------------------
797 /home/SySeVR/data/CVE_2015_1158_VULN_authenticate_job.c strcmp 122
static void
CVE_2015_1158_VULN_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
ipp_attribute_t * attr , * auth_info ; 7
int jobid ; 9
cupsd_job_t * job ; 10
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 11
con -> response -> request . status . status_code = IPP_OK; 29
if ( ! strcmp ( uri -> name , "printer-uri" ) )  35
if ( ( attr = ippFindAttribute ( con -> request , "job-id" , IPP_TAG_INTEGER ) ) == NULL )  41
jobid = attr -> values [ 0 ] . integer; 49
if ( strncmp ( resource , "/jobs/" , 6 ) )  61
jobid = atoi ( resource + 6 ); 72
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  79
if ( job -> state_value != IPP_JOB_HELD )  93
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 109
if ( ! con -> username [ 0 ] && ! auth_info )  111
cupsd_printer_t * printer ; 113
printer = cupsdFindDest ( job -> dest ); 120
if ( printer && printer -> num_auth_info_required > 0 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) )  122
0
------------------------------
798 /home/SySeVR/data/CVE_2015_1158_VULN_authenticate_job.c strcmp 35
static void
CVE_2015_1158_VULN_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  35
0
------------------------------
799 /home/SySeVR/data/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 263
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
ipp_attribute_t * charset ; 9
ipp_attribute_t * language ; 10
ipp_attribute_t * username ; 12
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
charset = attr; 119
charset = NULL; 121
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
language = attr; 130
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
con -> language = cupsLangGet ( attr -> values [ 0 ] . string . text ); 140
language = NULL; 144
if ( ( attr = ippFindAttribute ( con -> request , "printer-uri" , IPP_TAG_URI ) ) != NULL )  146
uri = attr; 148
if ( ( attr = ippFindAttribute ( con -> request , "job-uri" , IPP_TAG_URI ) ) != NULL )  149
uri = attr; 151
if ( con -> request -> request . op . operation_id == CUPS_GET_PPD )  152
uri = ippFindAttribute ( con -> request , "ppd-name" , IPP_TAG_NAME ); 153
uri = NULL; 155
if ( charset && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "us-ascii" ) && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "utf-8" ) )  173
if ( ! charset || ! language || ( ! uri && con -> request -> request . op . operation_id != CUPS_GET_DEFAULT && con -> request -> request . op . operation_id != CUPS_GET_PRINTERS && con -> request -> request . op . operation_id != CUPS_GET_CLASSES && con -> request -> request . op . operation_id != CUPS_GET_DEVICES && con -> request -> request . op . operation_id != CUPS_GET_PPDS ) )  191
if ( ( username = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ) != NULL )  256
if ( ! strcmp ( username -> values [ 0 ] . string . text , "root" ) && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && strcmp ( con -> username , "root" ) )  263
0
------------------------------
800 /home/SySeVR/data/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 263
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
ipp_attribute_t * charset ; 9
ipp_attribute_t * language ; 10
ipp_attribute_t * username ; 12
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
charset = attr; 119
charset = NULL; 121
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
language = attr; 130
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
con -> language = cupsLangGet ( attr -> values [ 0 ] . string . text ); 140
language = NULL; 144
if ( ( attr = ippFindAttribute ( con -> request , "printer-uri" , IPP_TAG_URI ) ) != NULL )  146
uri = attr; 148
if ( ( attr = ippFindAttribute ( con -> request , "job-uri" , IPP_TAG_URI ) ) != NULL )  149
uri = attr; 151
if ( con -> request -> request . op . operation_id == CUPS_GET_PPD )  152
uri = ippFindAttribute ( con -> request , "ppd-name" , IPP_TAG_NAME ); 153
uri = NULL; 155
if ( charset && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "us-ascii" ) && _cups_strcasecmp ( charset -> values [ 0 ] . string . text , "utf-8" ) )  173
if ( ! charset || ! language || ( ! uri && con -> request -> request . op . operation_id != CUPS_GET_DEFAULT && con -> request -> request . op . operation_id != CUPS_GET_PRINTERS && con -> request -> request . op . operation_id != CUPS_GET_CLASSES && con -> request -> request . op . operation_id != CUPS_GET_DEVICES && con -> request -> request . op . operation_id != CUPS_GET_PPDS ) )  191
if ( ( username = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ) != NULL )  256
if ( ! strcmp ( username -> values [ 0 ] . string . text , "root" ) && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && strcmp ( con -> username , "root" ) )  263
0
------------------------------
801 /home/SySeVR/data/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 136
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
if ( ! con -> language || strcmp ( attr -> values [ 0 ] . string . text , con -> language -> language ) )  136
0
------------------------------
802 /home/SySeVR/data/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 126
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr )  123
attr = attr -> next; 124
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-natural-language" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_LANGUAGE )  126
0
------------------------------
803 /home/SySeVR/data/CVE_2015_1158_VULN_cupsdProcessIPPRequest.c strcmp 116
int					/* O - 1 on success, 0 on failure */
CVE_2015_1158_VULN_cupsdProcessIPPRequest(
cupsd_client_t *con)		/* I - Client connection */ 6
ipp_tag_t group ; 7
ipp_attribute_t * attr ; 8
con -> response = ippNew ( ); 24
con -> response -> request . status . version [ 0 ] = con -> request -> request . op . version [ 0 ]; 26
con -> response -> request . status . version [ 1 ] = con -> request -> request . op . version [ 1 ]; 28
con -> response -> request . status . request_id = con -> request -> request . op . request_id; 30
if ( con -> request -> request . any . version [ 0 ] != 1 && con -> request -> request . any . version [ 0 ] != 2 )  37
if ( con -> request -> request . any . request_id < 1 )  55
if ( ! con -> request -> attrs )  69
for (attr = con->request->attrs, group = attr->group_tag;
attr;
attr = attr->next) 86
if ( attr -> group_tag < group && attr -> group_tag != IPP_TAG_ZERO )  87
group = attr -> group_tag; 103
if ( ! attr )  105
attr = con -> request -> attrs; 115
if ( attr && attr -> name && ! strcmp ( attr -> name , "attributes-charset" ) && ( attr -> value_tag & IPP_TAG_MASK ) == IPP_TAG_CHARSET )  116
0
------------------------------
804 /home/SySeVR/data/CVE_2015_1158_VULN_release_job.c strcmp 24
static void
CVE_2015_1158_VULN_release_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job or Printer URI */ 6
if ( ! strcmp ( uri -> name , "printer-uri" ) )  24
0
------------------------------
805 /home/SySeVR/data/CVE_2012_2669_VULN_main.c socket 27
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
if ( fd < 0 )  28
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 29
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 38
if ( error < 0 )  39
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 40
close ( fd ); 41
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 45
len = netlink_send ( fd , message ); 58
if ( len < 0 )  59
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 60
close ( fd ); 61
pfd . fd = fd; 65
pfd . events = POLLIN; 68
pfd . revents = 0; 69
poll ( & pfd , 1 , - 1 ); 70
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
syslog ( LOG_ERR , "recv failed; error:%d" , len ); 75
close ( fd ); 76
len = netlink_send ( fd , incoming_cn_msg ); 223
if ( len < 0 )  224
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 225
0
------------------------------
806 /home/SySeVR/data/CVE_2012_5532_VULN_main.c socket 31
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
if ( fd < 0 )  32
syslog ( LOG_ERR , "netlink socket creation failed; error:%d" , fd ); 33
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
if ( error < 0 )  43
syslog ( LOG_ERR , "bind failed; error:%d" , error ); 44
close ( fd ); 45
setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ); 49
len = netlink_send ( fd , message ); 62
if ( len < 0 )  63
syslog ( LOG_ERR , "netlink_send failed; error:%d" , len ); 64
close ( fd ); 65
pfd . fd = fd; 69
pfd . events = POLLIN; 74
pfd . revents = 0; 75
poll ( & pfd , 1 , - 1 ); 76
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
close ( fd ); 84
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
switch ( op )  119
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
free ( if_name ); 160
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 217
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
strcpy ( key_name , "NetworkAddressIPv4" ); 228
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_value , os_build ); 236
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_value , os_name ); 240
strcpy ( key_name , "OSName" ); 241
strcpy ( key_value , os_major ); 244
strcpy ( key_name , "OSMajorVersion" ); 245
strcpy ( key_value , os_minor ); 248
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_value , os_build ); 252
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_value , processor_arch ); 256
strcpy ( key_name , "ProcessorArchitecture" ); 257
len = netlink_send ( fd , incoming_cn_msg ); 275
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
0
------------------------------
807 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c socket 158
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
apr_bucket_free ( buf ); 326
context -> overlapped . Pointer = NULL; 328
if ( context -> accept_socket != INVALID_SOCKET )  334
closesocket ( context -> accept_socket ); 335
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 402
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
CloseHandle ( events [ 2 ] ); 448
0
------------------------------
808 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c socket 152
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
apr_bucket_free ( buf ); 326
context -> overlapped . Pointer = NULL; 328
if ( context -> accept_socket != INVALID_SOCKET )  334
closesocket ( context -> accept_socket ); 335
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 402
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
CloseHandle ( events [ 2 ] ); 448
0
------------------------------
809 /home/SySeVR/data/CVE_2004_1151_VULN_sys32_ni_syscall.c strcpy 8
int CVE_2004_1151_VULN_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ 8 ] ; 4
if ( strcmp ( lastcomm , me -> comm ) )  5
strcpy ( lastcomm , me -> comm ); 8
0
------------------------------
810 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strcpy 106
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
811 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c strcpy 105
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
0
------------------------------
812 /home/SySeVR/data/CVE_2009_1439_PATCHED_CIFSTCon.c strcpy 90
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
813 /home/SySeVR/data/CVE_2009_1439_PATCHED_CIFSTCon.c strcpy 87
int
CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( 2 * ( length + 1 ) , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
814 /home/SySeVR/data/CVE_2009_1439_VULN_CIFSTCon.c strcpy 90
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
int length ; 12
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); 80
bcc_ptr += 2 * length; 84
bcc_ptr += 2; 85
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
815 /home/SySeVR/data/CVE_2009_1439_VULN_CIFSTCon.c strcpy 87
int
CVE_2009_1439_VULN_CIFSTCon(unsigned int xid, struct cifsSesInfo *ses,
const char *tree, struct cifsTconInfo *tcon,
const struct nls_table *nls_codepage) 4
struct smb_hdr * smb_buffer ; 6
TCONX_REQ * pSMB ; 8
unsigned char * bcc_ptr ; 10
if ( ses == NULL )  15
smb_buffer = cifs_buf_get ( ); 18
if ( smb_buffer == NULL )  19
smb_buffer -> Mid = GetNextMid ( ses -> server ); 27
smb_buffer -> Uid = ses -> Suid; 28
pSMB = ( TCONX_REQ * ) smb_buffer; 29
pSMB -> AndXCommand = 0xFF; 32
pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); 33
bcc_ptr = & pSMB -> Password [ 0 ]; 34
if ( ( ses -> server -> secMode ) & SECMODE_USER )  35
* bcc_ptr = 0; 37
bcc_ptr ++; 38
bcc_ptr += CIFS_SESS_KEY_SIZE; 60
if ( ses -> capabilities & CAP_UNICODE )  61
* bcc_ptr = 0; 63
bcc_ptr ++; 64
if ( ses -> capabilities & CAP_UNICODE )  78
strcpy ( bcc_ptr , tree ); 87
bcc_ptr += strlen ( tree ) + 1; 88
strcpy ( bcc_ptr , "?????" ); 90
bcc_ptr += strlen ( "?????" ); 91
bcc_ptr += 1; 92
count = bcc_ptr - & pSMB -> Password [ 0 ]; 93
pSMB -> hdr . smb_buf_length += count; 94
pSMB -> ByteCount = cpu_to_le16 ( count ); 95
length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); 107
if ( length == 3 )  109
if ( ( bcc_ptr [ 0 ] == 'I' ) && ( bcc_ptr [ 1 ] == 'P' ) && ( bcc_ptr [ 2 ] == 'C' ) )  110
if ( length == 2 )  115
if ( ( bcc_ptr [ 0 ] == 'A' ) && ( bcc_ptr [ 1 ] == ':' ) )  116
bcc_ptr += length + 1; 121
length = UniStrnlen ( ( wchar_t * ) bcc_ptr , 512 ); 124
if ( ( bcc_ptr + ( 2 * length ) ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  125
tcon -> nativeFileSystem = kzalloc ( length + 2 , GFP_KERNEL ); 129
if ( tcon -> nativeFileSystem )  131
cifs_strfromUCS_le ( tcon -> nativeFileSystem , ( __le16 * ) bcc_ptr , length , nls_codepage ); 132
bcc_ptr += 2 * length; 136
bcc_ptr [ 0 ] = 0; 137
bcc_ptr [ 1 ] = 0; 138
bcc_ptr += 2; 139
length = strnlen ( bcc_ptr , 1024 ); 143
if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  144
tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); 148
if ( tcon -> nativeFileSystem )  150
strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); 151
tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); 159
cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 162
0
------------------------------
816 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c strcpy 159
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
char * p ; 4
int sig_set = 0 ; 6
int cipher_name_set = 0 ; 7
int fn_cipher_name_set = 0 ; 8
int cipher_key_bytes ; 9
int fn_cipher_key_bytes ; 11
struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; 13
substring_t args [ MAX_OPT_ARGS ] ; 15
int token ; 16
char * sig_src ; 17
char * cipher_key_bytes_src ; 24
char * fn_cipher_key_bytes_src ; 25
if ( ! options )  29
while ( ( p = strsep ( & options , "," ) ) != NULL )  34
if ( ! * p )  35
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
sig_set = 1; 49
cipher_name_set = 1; 60
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_name_set = 1; 115
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
if ( ! sig_set )  143
if ( ! cipher_name_set )  150
strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ); 154
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set )  157
strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ); 159
mount_crypt_stat -> global_default_cipher_key_size = 0; 162
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set )  163
mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size; 165
if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) )  168
rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ); 170
if ( rc )  173
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) )  185
rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ); 188
if ( rc )  191
0
------------------------------
817 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c strcpy 154
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
char * p ; 4
int sig_set = 0 ; 6
int cipher_name_set = 0 ; 7
int cipher_key_bytes ; 9
int fn_cipher_key_bytes ; 11
struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; 13
substring_t args [ MAX_OPT_ARGS ] ; 15
int token ; 16
char * sig_src ; 17
char * cipher_key_bytes_src ; 24
char * fn_cipher_key_bytes_src ; 25
if ( ! options )  29
while ( ( p = strsep ( & options , "," ) ) != NULL )  34
if ( ! * p )  35
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
sig_set = 1; 49
cipher_name_set = 1; 60
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
if ( ! sig_set )  143
if ( ! cipher_name_set )  150
strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ); 154
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set )  157
strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ); 159
mount_crypt_stat -> global_default_cipher_key_size = 0; 162
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set )  163
mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size; 165
if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) )  168
rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ); 170
if ( rc )  173
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) )  185
rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ); 188
if ( rc )  191
0
------------------------------
818 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 208
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
819 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 204
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , os_major ); 188
strcpy ( key_value , os_minor ); 192
strcpy ( key_value , os_build ); 196
strcpy ( key_value , processor_arch ); 200
strcpy ( key_value , "Unknown Key" ); 204
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
820 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 201
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
821 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 200
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , os_major ); 188
strcpy ( key_value , os_minor ); 192
strcpy ( key_value , os_build ); 196
strcpy ( key_value , processor_arch ); 200
strcpy ( key_value , "Unknown Key" ); 204
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
822 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 197
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
823 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 196
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , os_major ); 188
strcpy ( key_value , os_minor ); 192
strcpy ( key_value , os_build ); 196
strcpy ( key_value , processor_arch ); 200
strcpy ( key_value , "Unknown Key" ); 204
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
824 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 193
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
825 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 192
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , os_major ); 188
strcpy ( key_value , os_minor ); 192
strcpy ( key_value , os_build ); 196
strcpy ( key_value , processor_arch ); 200
strcpy ( key_value , "Unknown Key" ); 204
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
826 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 189
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
827 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 188
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , os_major ); 188
strcpy ( key_value , os_minor ); 192
strcpy ( key_value , os_build ); 196
strcpy ( key_value , processor_arch ); 200
strcpy ( key_value , "Unknown Key" ); 204
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
828 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 185
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_name , "NetworkAddressIPv4" ); 172
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_name , "OSName" ); 185
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
829 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 184
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , lic_version ); 167
strcpy ( key_value , os_build ); 180
strcpy ( key_value , os_name ); 184
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
830 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 181
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_name , "NetworkAddressIPv4" ); 172
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_name , "OSName" ); 185
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
831 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 180
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , lic_version ); 167
strcpy ( key_value , os_build ); 180
strcpy ( key_value , os_name ); 184
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
832 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 177
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_name , "NetworkAddressIPv4" ); 172
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_name , "OSName" ); 185
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
833 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 172
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_name , "NetworkAddressIPv4" ); 172
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_name , "OSName" ); 185
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
834 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 167
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_value , os_build ); 180
strcpy ( key_value , os_name ); 184
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
835 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 166
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_name , "NetworkAddressIPv4" ); 172
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_name , "OSName" ); 185
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
836 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 163
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE )  137
if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO )  145
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 155
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
switch ( hv_msg -> body . kvp_enum_data . index )  159
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_name , "NetworkAddressIPv4" ); 172
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_name , "OSName" ); 185
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
837 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 130
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
kvp_pool_enumerate ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 146
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 161
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
strcpy ( key_name , "NetworkAddressIPv4" ); 172
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_value , os_build ); 180
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_value , os_name ); 184
strcpy ( key_name , "OSName" ); 185
strcpy ( key_value , os_major ); 188
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_value , os_minor ); 192
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_value , os_build ); 196
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_value , processor_arch ); 200
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_value , "Unknown Key" ); 204
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
838 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 123
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
kvp_pool_enumerate ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 146
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 161
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
strcpy ( key_name , "NetworkAddressIPv4" ); 172
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_value , os_build ); 180
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_value , os_name ); 184
strcpy ( key_name , "OSName" ); 185
strcpy ( key_value , os_major ); 188
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_value , os_minor ); 192
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_value , os_build ); 196
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_value , processor_arch ); 200
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_value , "Unknown Key" ); 204
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
839 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 114
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  109
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 114
if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  118
strcpy ( hv_msg -> body . kvp_set . data . key , "" ); 123
if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  127
strcpy ( hv_msg -> body . kvp_delete . key , "" ); 130
kvp_pool_enumerate ( hv_msg -> kvp_hdr . pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 146
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 156
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 157
switch ( hv_msg -> body . kvp_enum_data . index )  159
kvp_get_domain_name ( key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 161
strcpy ( key_name , "FullyQualifiedDomainName" ); 163
strcpy ( key_name , "IntegrationServicesVersion" ); 166
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
strcpy ( key_name , "NetworkAddressIPv4" ); 172
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_name , "NetworkAddressIPv6" ); 177
strcpy ( key_value , os_build ); 180
strcpy ( key_name , "OSBuildNumber" ); 181
strcpy ( key_value , os_name ); 184
strcpy ( key_name , "OSName" ); 185
strcpy ( key_value , os_major ); 188
strcpy ( key_name , "OSMajorVersion" ); 189
strcpy ( key_value , os_minor ); 192
strcpy ( key_name , "OSMinorVersion" ); 193
strcpy ( key_value , os_build ); 196
strcpy ( key_name , "OSVersion" ); 197
strcpy ( key_value , processor_arch ); 200
strcpy ( key_name , "ProcessorArchitecture" ); 201
strcpy ( key_value , "Unknown Key" ); 204
strcpy ( key_name , "" ); 208
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
840 /home/SySeVR/data/CVE_2012_2669_VULN_main.c strcpy 93
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
hv_msg = ( struct hv_kvp_msg * ) message -> data; 53
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER; 54
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 80
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 81
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 82
switch ( hv_msg -> kvp_hdr . operation )  84
p = ( char * ) hv_msg -> body . kvp_register . version; 90
lic_version = malloc ( strlen ( p ) + 1 ); 91
if ( lic_version )  92
strcpy ( lic_version , p ); 93
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 94
strcpy ( key_value , lic_version ); 167
kvp_get_ip_address ( AF_INET , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 170
kvp_get_ip_address ( AF_INET6 , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 175
strcpy ( key_value , os_build ); 180
strcpy ( key_value , os_name ); 184
incoming_cn_msg -> id . idx = CN_KVP_IDX; 218
incoming_cn_msg -> id . val = CN_KVP_VAL; 219
incoming_cn_msg -> ack = 0; 220
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 221
0
------------------------------
841 /home/SySeVR/data/CVE_2012_4530_PATCHED_load_script.c strcpy 43
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
0
------------------------------
842 /home/SySeVR/data/CVE_2012_4530_VULN_load_script.c strcpy 43
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
char interp [ BINPRM_BUF_SIZE ] ; 5
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
strcpy ( interp , i_name ); 43
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
0
------------------------------
843 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 257
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
844 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 256
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
845 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 253
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
846 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 252
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
847 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 249
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "OSMinorVersion" ); 249
strcpy ( key_name , "OSVersion" ); 253
strcpy ( key_name , "ProcessorArchitecture" ); 257
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
848 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 248
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , os_minor ); 248
strcpy ( key_value , os_build ); 252
strcpy ( key_value , processor_arch ); 256
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
849 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 245
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
850 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 244
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
851 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 241
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
852 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 240
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
853 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 237
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
854 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 236
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
855 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 233
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
856 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 228
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
857 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 223
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
char * key_value ; 11
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value; 213
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_value , lic_version ); 223
kvp_get_ip_info ( AF_INET , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 226
kvp_get_ip_info ( AF_INET6 , NULL , KVP_OP_ENUMERATE , key_value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ); 231
strcpy ( key_value , os_build ); 236
strcpy ( key_value , os_name ); 240
strcpy ( key_value , os_major ); 244
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
858 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 222
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
859 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 219
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * key_name ; 12
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key; 212
switch ( hv_msg -> body . kvp_enum_data . index )  215
strcpy ( key_name , "FullyQualifiedDomainName" ); 219
strcpy ( key_name , "IntegrationServicesVersion" ); 222
strcpy ( key_name , "NetworkAddressIPv4" ); 228
strcpy ( key_name , "NetworkAddressIPv6" ); 233
strcpy ( key_name , "OSBuildNumber" ); 237
strcpy ( key_name , "OSName" ); 241
strcpy ( key_name , "OSMajorVersion" ); 245
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
860 /home/SySeVR/data/CVE_2012_5532_VULN_main.c strcpy 110
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
int error ; 4
struct cn_msg * message ; 5
struct nlmsghdr * incoming_msg ; 7
struct cn_msg * incoming_cn_msg ; 8
struct hv_kvp_msg * hv_msg ; 9
char * p ; 10
int op ; 13
int pool ; 14
char * if_name ; 15
struct hv_kvp_ipaddr_value * kvp_ip_val ; 16
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ); 42
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
hv_msg = ( struct hv_kvp_msg * ) message -> data; 57
hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER1; 58
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer; 88
incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ); 89
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 90
op = hv_msg -> kvp_hdr . operation; 97
pool = hv_msg -> kvp_hdr . pool; 98
hv_msg -> error = HV_S_OK; 99
if ( ( in_hand_shake ) && ( op == KVP_OP_REGISTER1 ) )  101
in_hand_shake = 0; 106
p = ( char * ) hv_msg -> body . kvp_register . version; 107
lic_version = malloc ( strlen ( p ) + 1 ); 108
if ( lic_version )  109
strcpy ( lic_version , p ); 110
syslog ( LOG_INFO , "KVP LIC Version: %s" , lic_version ); 111
switch ( op )  119
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 121
if_name = kvp_mac_to_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 122
if ( if_name == NULL )  125
hv_msg -> error = HV_E_FAIL; 130
error = kvp_get_ip_info ( 0 , if_name , KVP_OP_GET_IP_INFO , kvp_ip_val , ( MAX_IP_ADDR_SIZE * 2 ) ); 133
if ( error )  138
hv_msg -> error = error; 139
kvp_ip_val = & hv_msg -> body . kvp_ip_val; 145
if_name = kvp_get_if_name ( ( char * ) kvp_ip_val -> adapter_id ); 146
if ( if_name == NULL )  148
hv_msg -> error = HV_GUID_NOTFOUND; 153
error = kvp_set_ip_info ( if_name , kvp_ip_val ); 156
if ( error )  157
hv_msg -> error = error; 158
if ( kvp_key_add_or_modify ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  164
hv_msg -> error = HV_S_CONT; 169
if ( kvp_get_value ( pool , hv_msg -> body . kvp_set . data . key , hv_msg -> body . kvp_set . data . key_size , hv_msg -> body . kvp_set . data . value , hv_msg -> body . kvp_set . data . value_size ) )  173
hv_msg -> error = HV_S_CONT; 178
if ( kvp_key_delete ( pool , hv_msg -> body . kvp_delete . key , hv_msg -> body . kvp_delete . key_size ) )  182
hv_msg -> error = HV_S_CONT; 185
if ( op != KVP_OP_ENUMERATE )  192
if ( pool != KVP_POOL_AUTO )  200
if ( kvp_pool_enumerate ( pool , hv_msg -> body . kvp_enum_data . index , hv_msg -> body . kvp_enum_data . data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE , hv_msg -> body . kvp_enum_data . data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) )  201
hv_msg -> error = HV_S_CONT; 207
hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data; 211
switch ( hv_msg -> body . kvp_enum_data . index )  215
hv_msg -> error = HV_S_CONT; 260
incoming_cn_msg -> id . idx = CN_KVP_IDX; 270
incoming_cn_msg -> id . val = CN_KVP_VAL; 271
incoming_cn_msg -> ack = 0; 272
incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ); 273
0
------------------------------
861 /home/SySeVR/data/CVE_2012_6538_VULN_copy_to_user_auth.c strcpy 12
static int CVE_2012_6538_VULN_copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) 1
struct xfrm_algo * algo ; 3
struct nlattr * nla ; 4
nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ); 6
if ( ! nla )  8
algo = nla_data ( nla ); 11
strcpy ( algo -> alg_name , auth -> alg_name ); 12
memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ); 13
algo -> alg_key_len = auth -> alg_key_len; 14
0
------------------------------
862 /home/SySeVR/data/CVE_2011_2980_PATCHED_ThinkPadSensor__Startup.c LoadLibraryW 7
PRBool
CVE_2011_2980_PATCHED_ThinkPadSensor::Startup() 2
WCHAR path [ MAX_PATH + sizeof ( "sensor.dll" ) ] ; 4
if ( GetSystemDirectoryW ( path , MAX_PATH ) )  5
mLibrary = LoadLibraryW ( path ); 7
if ( ! mLibrary )  9
gShockproofGetAccelerometerData = ( ShockproofGetAccelerometerData ) GetProcAddress ( mLibrary , "ShockproofGetAccelerometerData" ); 12
if ( ! gShockproofGetAccelerometerData )  14
FreeLibrary ( mLibrary ); 15
0
------------------------------
863 /home/SySeVR/data/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c LoadLibraryW 32
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
if ( systemDirectory [ systemDirLen - 1 ] != L '\\' && systemDirLen )
systemDirectory [ systemDirLen ] = L '\\' 16
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
systemDirectory [ systemDirLen + fileLen ] = L '\0' 27
systemDirectory [ MAX_PATH ] = L '\0' 29
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
0
------------------------------
864 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c fopen 182
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
FILE * fs = fopen ( "/proc/self/oom_score_adj" , "w" ) ; 182
if ( fs )  183
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
0
------------------------------
865 /home/SySeVR/data/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 23
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
static LPCWSTR delayDLLs [ ] = L "wsock32.dll" , L "crypt32.dll" ,
L "cryptsp.dll" , L "cryptbase.dll" ,
L "msasn1.dll" , L "userenv.dll" ,
L "secur32.dll" 6
for (size_t i = 0; i < sizeof(delayDLLs) / sizeof(delayDLLs[0]); ++i) 22
size_t fileLen = wcslen ( delayDLLs [ i ] ) ; 23
if ( systemDirLen + fileLen <= MAX_PATH )  26
0
------------------------------
866 /home/SySeVR/data/CVE_2013_0797_PATCHED_AutoLoadSystemDependencies.c wcslen 12
CVE_2013_0797_PATCHED_AutoLoadSystemDependencies() 1
WCHAR systemDirectory [ MAX_PATH + 1 ] = L '\0' 8
size_t systemDirLen = wcslen ( systemDirectory ) ; 12
wcsncpy ( systemDirectory + systemDirLen , delayDLLs [ i ] , MAX_PATH - systemDirLen ); 24
if ( systemDirLen + fileLen <= MAX_PATH )  26
LPCWSTR fullModulePath = systemDirectory ; 31
LoadLibraryW ( fullModulePath ); 32
0
------------------------------
867 /home/SySeVR/data/CVE_2009_2484_VULN_Win32AddConnection.c LoadLibrary 12
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
HINSTANCE hdll = LoadLibrary ( _T ( "MPR.DLL" ) ) ; 12
if ( ! hdll )  13
OurWNetAddConnection2 = ( void * ) GetProcAddress ( hdll , _T ( "WNetAddConnection2A" ) ); 19
if ( ! OurWNetAddConnection2 )  21
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
FreeLibrary ( hdll ); 60
0
------------------------------
868 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c sscanf 15
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
sscanf ( v -> value , "%lx" , & ident ); 15
0
------------------------------
869 /home/SySeVR/data/CVE_2010_1224_PATCHED_ast_append_ha.c sscanf 30
struct ast_ha *CVE_2010_1224_PATCHED_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
int x ; 7
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
0
------------------------------
870 /home/SySeVR/data/CVE_2010_1224_VULN_ast_append_ha.c sscanf 30
struct ast_ha *CVE_2010_1224_VULN_ast_append_ha(const char *sense, const char *stuff, struct ast_ha *path, int *error) 1
struct ast_ha * ha ; 3
char * nm ; 4
int x ; 7
char * tmp = ast_strdupa ( stuff ) ; 8
ha = ast_malloc ( sizeof ( * ha ) ); 16
if ( ! ha )  17
nm = strchr ( tmp , '/' ); 20
if ( ! nm )  21
* nm = '\0'; 26
nm ++; 27
if ( ! strchr ( nm , '.' ) )  29
if ( ( sscanf ( nm , "%30d" , & x ) == 1 ) && ( x >= 0 ) && ( x <= 32 ) )  30
0
------------------------------
871 /home/SySeVR/data/CVE_2010_2068_PATCHED_ap_proxy_http_process_response.c sscanf 122
static
apr_status_t CVE_2010_2068_PATCHED_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
char buffer [ HUGE_STRING_LEN ] ; 8
char keepchar ; 10
int len , backasswards ; 14
int interim_response = 0 ; 15
apr_table_t * save_table ; 18
if ( len <= 0 )  47
if ( apr_date_checkmask ( buffer , "HTTP/#.# ###*" ) )  119
int major , minor ; 120
if ( 2 != sscanf ( buffer , "HTTP/%u.%u" , & major , & minor ) )  122
keepchar = buffer [ 12 ]; 136
buffer [ 12 ] = '\0'; 137
r -> status = atoi ( & buffer [ 9 ] ); 138
if ( keepchar != '\0' )  140
buffer [ 12 ] = keepchar; 141
buffer [ 12 ] = ' '; 146
buffer [ 13 ] = '\0'; 147
r -> status_line = apr_pstrdup ( p , & buffer [ 9 ] ); 149
save_table = apr_table_make ( r -> pool , 2 ); 157
if ( r -> headers_out == NULL )  165
if ( ! apr_is_empty_table ( save_table ) )  187
r -> headers_out = apr_table_overlay ( r -> pool , r -> headers_out , save_table ); 189
r -> headers_out = ap_proxy_clean_warnings ( p , r -> headers_out ); 235
r -> status = 200; 272
r -> status_line = "200 OK"; 273
if ( ap_is_HTTP_INFO ( r -> status ) )  277
interim_response ++; 278
interim_response = 0; 281
while ( interim_response && ( interim_response < AP_MAX_INTERIM_RESPONSES ) )  483
0
------------------------------
872 /home/SySeVR/data/CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4.c sscanf 28
static int
CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * universal_ip_address = NULL ; 4
char * protocol = NULL ; 5
guint b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; 6
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
if ( universal_ip_address && sscanf ( universal_ip_address , "%u.%u.%u.%u.%u.%u" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 ) == 6 )  15
if ( universal_ip_address && sscanf ( universal_ip_address , "%u.%u" , & b1 , & b2 ) == 2 )  22
if ( universal_ip_address && sscanf ( universal_ip_address , "%2x:%2x:%2x:%2x:%2x:%2x:%2x:%2x.%u.%u" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 , & b7 , & b8 , & b9 , & b10 ) == 10 )  28
0
------------------------------
873 /home/SySeVR/data/CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4.c sscanf 22
static int
CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * universal_ip_address = NULL ; 4
char * protocol = NULL ; 5
guint b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; 6
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
if ( universal_ip_address && sscanf ( universal_ip_address , "%u.%u.%u.%u.%u.%u" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 ) == 6 )  15
if ( universal_ip_address && sscanf ( universal_ip_address , "%u.%u" , & b1 , & b2 ) == 2 )  22
0
------------------------------
874 /home/SySeVR/data/CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4.c sscanf 15
static int
CVE_2011_1592_PATCHED_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * universal_ip_address = NULL ; 4
char * protocol = NULL ; 5
guint b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; 6
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
if ( universal_ip_address && sscanf ( universal_ip_address , "%u.%u.%u.%u.%u.%u" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 ) == 6 )  15
0
------------------------------
875 /home/SySeVR/data/CVE_2011_1592_VULN_dissect_nfs_clientaddr4.c sscanf 29
static int
CVE_2011_1592_VULN_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * universal_ip_address = NULL ; 4
char * protocol = NULL ; 5
guint8 b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; 6
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
if ( universal_ip_address && sscanf ( universal_ip_address , "%hhu.%hhu.%hhu.%hhu.%hhu.%hhu" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 ) == 6 )  15
if ( universal_ip_address && sscanf ( universal_ip_address , "%hhu.%hhu" , & b1 , & b2 ) == 2 )  22
if ( universal_ip_address && sscanf ( universal_ip_address , "%2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx.%hhu.%hhu" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 , & b7 , & b8 , & b9 , & b10 ) == 10 )  29
0
------------------------------
876 /home/SySeVR/data/CVE_2011_1592_VULN_dissect_nfs_clientaddr4.c sscanf 22
static int
CVE_2011_1592_VULN_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * universal_ip_address = NULL ; 4
char * protocol = NULL ; 5
guint8 b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; 6
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
if ( universal_ip_address && sscanf ( universal_ip_address , "%hhu.%hhu.%hhu.%hhu.%hhu.%hhu" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 ) == 6 )  15
if ( universal_ip_address && sscanf ( universal_ip_address , "%hhu.%hhu" , & b1 , & b2 ) == 2 )  22
0
------------------------------
877 /home/SySeVR/data/CVE_2011_1592_VULN_dissect_nfs_clientaddr4.c sscanf 15
static int
CVE_2011_1592_VULN_dissect_nfs_clientaddr4(tvbuff_t *tvb, int offset, proto_tree *tree) 2
char * universal_ip_address = NULL ; 4
char * protocol = NULL ; 5
guint8 b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , b10 ; 6
if ( strlen ( protocol ) == 3 && strncmp ( protocol , "tcp" , 3 ) == 0 )  14
if ( universal_ip_address && sscanf ( universal_ip_address , "%hhu.%hhu.%hhu.%hhu.%hhu.%hhu" , & b1 , & b2 , & b3 , & b4 , & b5 , & b6 ) == 6 )  15
0
------------------------------
878 /home/SySeVR/data/CVE_2011_3950_PATCHED_dirac_decode_data_unit.c sscanf 35
static int CVE_2011_3950_PATCHED_dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int size) 1
int i , parse_code = buf [ 4 ] ; 5
if ( size < DATA_UNIT_HEADER_SIZE )  8
if ( parse_code == pc_seq_header )  13
if ( parse_code == pc_eos )  27
if ( parse_code == pc_aux_data )  30
if ( buf [ 13 ] == 1 )  31
int ver [ 3 ] ; 32
if ( sscanf ( buf + 14 , "Schroedinger %d.%d.%d" , ver , ver + 1 , ver + 2 ) == 3 )  35
if ( ver [ 0 ] == 1 && ver [ 1 ] == 0 && ver [ 2 ] <= 7 )  36
0
------------------------------
879 /home/SySeVR/data/CVE_2012_1184_VULN_ast_parse_digest.c sscanf 85
int CVE_2012_1184_VULN_ast_parse_digest(const char *digest, struct ast_http_digest *d, int request, int pedantic) 2
int i ; 3
char * c , key [ 512 ] , val [ 512 ] ; 4
struct ast_str * str = ast_str_create ( 16 ) ; 5
if ( ast_strlen_zero ( digest ) || ! d || ! str )  7
c = ast_skip_blanks ( ast_str_buffer ( str ) ); 14
if ( strncasecmp ( c , "Digest " , strlen ( "Digest " ) ) )  16
c += strlen ( "Digest " ); 21
while ( * c && * ( c = ast_skip_blanks ( c ) ) )  24
i = 0; 26
while ( * c && * c != '=' && * c != ',' && ! isspace ( * c ) )  27
key [ i ++ ] = * c ++; 28
key [ i ] = '\0'; 30
c = ast_skip_blanks ( c ); 31
if ( * c == '=' )  32
c = ast_skip_blanks ( ++ c ); 33
i = 0; 34
if ( * c == '\"' )  35
c ++; 37
while ( * c && * c != '\"' )  38
if ( * c == '\\' && c [ 1 ] != '\0' )  39
c ++; 40
val [ i ++ ] = * c ++; 42
while ( * c && * c != ',' && ! isspace ( * c ) )  46
val [ i ++ ] = * c ++; 47
val [ i ] = '\0'; 50
while ( * c && * c != ',' )  53
c ++; 54
if ( * c )  56
c ++; 57
if ( ! strcasecmp ( key , "username" ) )  60
if ( ! strcasecmp ( key , "realm" ) )  62
if ( ! strcasecmp ( key , "nonce" ) )  64
if ( ! strcasecmp ( key , "uri" ) )  66
if ( ! strcasecmp ( key , "domain" ) )  68
if ( ! strcasecmp ( key , "response" ) )  70
if ( ! strcasecmp ( key , "algorithm" ) )  72
if ( strcasecmp ( val , "MD5" ) )  73
if ( ! strcasecmp ( key , "cnonce" ) )  77
if ( ! strcasecmp ( key , "opaque" ) )  79
if ( ! strcasecmp ( key , "qop" ) && ! strcasecmp ( val , "auth" ) )  81
if ( ! strcasecmp ( key , "nc" ) )  83
if ( sscanf ( val , "%30lx" , & u ) != 1 )  85
0
------------------------------
880 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c sscanf 68
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int respid ; 15
const char * e ; 17
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
e = ast_skip_blanks ( REQ_OFFSET_TO_STR ( req , rlpart2 ) ); 50
if ( req -> method == SIP_RESPONSE )  58
if ( ast_strlen_zero ( e ) )  65
if ( sscanf ( e , "%30d %n" , & respid , & len ) != 1 )  68
if ( respid <= 0 )  72
ast_log ( LOG_WARNING , "Invalid SIP response code: '%d'\n" , respid ); 73
if ( ( respid == 200 ) || ( ( respid >= 300 ) && ( respid <= 399 ) ) )  87
cause_code -> ast_cause = hangup_sip2cause ( respid ); 102
cause_code -> emulate_sip_cause = 1; 104
ast_queue_control_data ( p -> owner , AST_CONTROL_PVT_CAUSE_CODE , cause_code , data_size ); 107
ast_channel_hangupcause_hash_set ( p -> owner , cause_code , data_size ); 108
handle_response ( p , respid , e + len , req , seqno ); 111
0
------------------------------
881 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c sscanf 37
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
0
------------------------------
882 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 308
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
883 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 308
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
884 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 290
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
ast_verbose ( "Found RTP text format %d\n" , codec ); 296
ast_rtp_codecs_payloads_set_m_type ( & newtextrtp , NULL , codec ); 298
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
885 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 263
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
886 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 263
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
887 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 245
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
ast_verbose ( "Found RTP video format %d\n" , codec ); 251
ast_rtp_codecs_payloads_set_m_type ( & newvideortp , NULL , codec ); 253
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
888 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 211
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
889 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 211
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
890 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 192
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
ast_verbose ( "Found RTP audio format %d\n" , codec ); 198
ast_rtp_codecs_payloads_set_m_type ( & newaudiortp , NULL , codec ); 201
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
891 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 159
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
892 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c sscanf 159
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
0
------------------------------
893 /home/SySeVR/data/CVE_2014_2286_VULN_ast_http_manid_from_vars.c sscanf 9
uint32_t CVE_2014_2286_VULN_ast_http_manid_from_vars(struct ast_variable *headers) 1
struct ast_variable * v , * cookies ; 4
cookies = ast_http_get_cookies ( headers ); 6
for (v = cookies; v; v = v->next) 7
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  8
sscanf ( v -> value , "%30x" , & mngid ); 9
0
------------------------------
894 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c sscanf 171
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
int32_t prioVal ; 167
int32_t oomScoreAdj ; 168
int32_t ioprioClass ; 169
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
if ( setpriority ( PRIO_PROCESS , 0 , prioVal ) )  174
LOG ( ( "setpriority(%d) failed, errno = %d" , prioVal , errno ) ); 175
if ( ioprio_set ( IOPRIO_WHO_PROCESS , 0 , IOPRIO_PRIO_VALUE ( ioprioClass , ioprioLevel ) ) )  177
LOG ( ( "ioprio_set(%d,%d) failed: errno = %d" , ioprioClass , ioprioLevel , errno ) ); 179
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
0
------------------------------
895 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c sscanf 109
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
const char * default_format ; 9
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( ( default_format = cupsGetOption ( "document-format" , printer -> num_options , printer -> options ) ) != NULL )  101
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
filetype = mimeType ( MimeDatabase , super , type ); 144
cupsdLogMessage ( CUPSD_LOG_INFO , "[Job ???] Request file type is %s/%s." , filetype -> super , filetype -> type ); 146
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
ippSetString ( con -> request , & format , 0 , mimetype ); 165
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 167
if ( ! filetype )  170
if ( ! _cups_strcasecmp ( filetype -> super , "application" ) && ( ! _cups_strcasecmp ( filetype -> type , "postscript" ) || ! _cups_strcasecmp ( filetype -> type , "pdf" ) ) )  190
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  199
cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ); 211
job -> koctets += kbytes; 213
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  215
attr -> values [ 0 ] . integer += kbytes; 216
if ( add_file ( con , job , filetype , compression ) )  222
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
if ( cupsdTimeoutJob ( job ) )  234
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 241
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "hold_until=%d" , ( int ) job -> hold_until ); 244
cupsdLogJob ( job , CUPSD_LOG_INFO , "Queued on \"%s\" by \"%s\"." , job -> dest , job -> username ); 245
0
------------------------------
896 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c sscanf 92
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
ipp_attribute_t * attr ; 7
ipp_attribute_t * format ; 8
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
cupsd_printer_t * printer ; 17
if ( ( attr = ippFindAttribute ( con -> request , "compression" , IPP_TAG_KEYWORD ) ) != NULL )  33
if ( ! con -> filename )  60
if ( ! cupsdValidateDest ( uri -> values [ 0 ] . string . text , NULL , & printer ) )  70
if ( ( format = ippFindAttribute ( con -> request , "document-format" , IPP_TAG_MIMETYPE ) ) != NULL )  85
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
0
------------------------------
897 /home/SySeVR/data/CVE_2012_5532_VULN_main.c recvfrom 78
int CVE_2012_5532_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 31
addr . nl_family = AF_NETLINK; 36
addr . nl_pad = 0; 37
addr . nl_pid = 0; 38
addr . nl_groups = CN_KVP_IDX; 39
message = ( struct cn_msg * ) kvp_send_buffer; 53
message -> id . idx = CN_KVP_IDX; 54
message -> id . val = CN_KVP_VAL; 55
message -> ack = 0; 59
message -> len = sizeof ( struct hv_kvp_msg ); 60
len = netlink_send ( fd , message ); 62
while ( 1 )  71
struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; 72
len = recvfrom ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ); 78
if ( len < 0 || addr . nl_pid )  81
if ( len < 0 )  276
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 277
0
------------------------------
898 /home/SySeVR/data/CVE_2012_2669_VULN_main.c recv 72
int CVE_2012_2669_VULN_main(void) 1
int fd , len , sock_opt ; 3
struct cn_msg * message ; 5
fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ); 27
message = ( struct cn_msg * ) kvp_send_buffer; 49
message -> id . idx = CN_KVP_IDX; 50
message -> id . val = CN_KVP_VAL; 51
message -> ack = 0; 55
message -> len = sizeof ( struct hv_kvp_msg ); 56
len = netlink_send ( fd , message ); 58
while ( 1 )  67
len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ); 72
if ( len < 0 )  74
syslog ( LOG_ERR , "recv failed; error:%d" , len ); 75
if ( len < 0 )  224
syslog ( LOG_ERR , "net_link send failed; error:%d" , len ); 225
0
------------------------------
899 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c getenv 177
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 452
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 562
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 611
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 691
if ( ! sUsingService )  767
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 786
0
------------------------------
900 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c getenv 93
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
if ( getenv ( "MOZ_OS_UPDATE" ) )  93
0
------------------------------
901 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c getenv 38
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  458
0
------------------------------
902 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c getenv 177
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 452
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 562
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 605
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 685
if ( ! sUsingService )  761
LaunchCallbackApp ( argv [ 4 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 780
0
------------------------------
903 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c getenv 93
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
if ( getenv ( "MOZ_OS_UPDATE" ) )  93
0
------------------------------
904 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c getenv 38
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  458
0
------------------------------
905 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c getenv 877
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( argc > callbackIndex )  851
if ( getenv ( "MOZ_PROCESS_UPDATES" ) == nullptr )  877
0
------------------------------
906 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c getenv 234
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 499
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 606
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 658
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 739
if ( ! sUsingService )  861
LaunchCallbackApp ( argv [ 5 ] , argc - callbackIndex , argv + callbackIndex , sUsingService ); 878
0
------------------------------
907 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c getenv 165
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( ! WriteStatusFile ( "applying" ) )  149
const char * prioEnv = getenv ( "MOZ_UPDATER_PRIO" ) ; 165
if ( prioEnv )  166
if ( sscanf ( prioEnv , "%d/%d/%d/%d" , & prioVal , & oomScoreAdj , & ioprioClass , & ioprioLevel ) == 4 )  171
LOG ( ( "MOZ_UPDATER_PRIO=%s" , prioEnv ) ); 173
if ( setpriority ( PRIO_PROCESS , 0 , prioVal ) )  174
LOG ( ( "setpriority(%d) failed, errno = %d" , prioVal , errno ) ); 175
if ( ioprio_set ( IOPRIO_WHO_PROCESS , 0 , IOPRIO_PRIO_VALUE ( ioprioClass , ioprioLevel ) ) )  177
LOG ( ( "ioprio_set(%d,%d) failed: errno = %d" , ioprioClass , ioprioLevel , errno ) ); 179
fprintf ( fs , "%d" , oomScoreAdj ); 184
fclose ( fs ); 185
0
------------------------------
908 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c getenv 123
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
if ( getenv ( "MOZ_OS_UPDATE" ) )  123
0
------------------------------
909 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c getenv 57
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  505
0
------------------------------
910 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c getenv 4
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( getenv ( "LD_PRELOAD" ) )  4
0
------------------------------
911 /home/SySeVR/data/CVE_2015_0833_VULN_UpdateThreadFunc.c getenv 54
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
rv = ProcessReplaceRequest ( ); 7
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
MARChannelStringTable MARStrings ; 26
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
MARStrings . MARChannelID [ 0 ] = '\0'; 30
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 33
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
rv = CopyInstallDirToDestDir ( ); 40
if ( rv == OK )  43
rv = DoUpdate ( ); 44
if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) )  54
0
------------------------------
912 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c fread 47
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
913 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c fread 27
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
914 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c fread 17
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
915 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c fread 47
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
char buf [ 97 ] = { '\0' } ; 10
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
if ( additionalBlockSize > 96 )  43
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
916 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c fread 27
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
917 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c fread 17
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
int i , hasAdditionalBlocks , offset , offsetAdditionalBlocks , numAdditionalBlocks , additionalBlockSize , additionalBlockID ; 5
for (i = 0; i < numAdditionalBlocks; ++i) 15
if ( fread ( & additionalBlockSize , sizeof ( additionalBlockSize ) , 1 , mar -> fp ) != 1 )  17
additionalBlockSize = ntohl ( additionalBlockSize ) - sizeof ( additionalBlockSize ) - sizeof ( additionalBlockID ); 22
if ( fread ( & additionalBlockID , sizeof ( additionalBlockID ) , 1 , mar -> fp ) != 1 )  27
additionalBlockID = ntohl ( additionalBlockID ); 32
if ( PRODUCT_INFO_BLOCK_ID == additionalBlockID )  34
if ( fseek ( mar -> fp , additionalBlockSize , SEEK_CUR ) )  79
0
------------------------------
