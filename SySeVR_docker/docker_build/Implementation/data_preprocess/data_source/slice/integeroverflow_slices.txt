1 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c s -> block_stride [ i ] = bw * s -> h_count [ i ] 371
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
unsigned pix_fmt_id ; 4
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
height *= 2; 122
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
s -> rgb = 0; 141
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
s -> upscale_v = 6; 299
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
for (i = 0; i < 4; i++) 343
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
2 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c * dst = val << ( precision - cbps ) 164
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
const AVPixFmtDescriptor * pixdesc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ) ; 4
int compno , reslevelno , bandno ; 5
int x , y ; 6
int planar = ! ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_PLANAR ) ; 7
int pixelsize = planar ? 1 : pixdesc -> nb_components ; 8
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
Jpeg2000Component * comp = tile -> comp + compno ; 129
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 130
int32_t * i_datap = comp -> i_data ; 132
uint16_t * linel ; 133
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
int plane = 0 ; 136
if ( planar )  138
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
uint16_t * dst ; 144
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
if ( codsty -> transform == FF_DWT97 )  148
for (; x < w; x ++) 159
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
i_datap ++; 165
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
3 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c * dst = val << ( precision - cbps ) 154
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
const AVPixFmtDescriptor * pixdesc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ) ; 4
int compno , reslevelno , bandno ; 5
int x , y ; 6
int planar = ! ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_PLANAR ) ; 7
int pixelsize = planar ? 1 : pixdesc -> nb_components ; 8
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
Jpeg2000Component * comp = tile -> comp + compno ; 129
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 130
float * datap = comp -> f_data ; 131
uint16_t * linel ; 133
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
int plane = 0 ; 136
if ( planar )  138
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
uint16_t * dst ; 144
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
if ( codsty -> transform == FF_DWT97 )  148
for (; x < w; x ++) 149
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
datap ++; 155
dst += pixelsize; 156
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
4 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c dst = linel + ( x * pixelsize + compno * ! planar ) 147
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
const AVPixFmtDescriptor * pixdesc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ) ; 4
int compno , reslevelno , bandno ; 5
int x , y ; 6
int planar = ! ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_PLANAR ) ; 7
int pixelsize = planar ? 1 : pixdesc -> nb_components ; 8
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 128
uint16_t * linel ; 133
int plane = 0 ; 136
if ( planar )  138
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
uint16_t * dst ; 144
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
5 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ] 146
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 128
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
for (; x < w; x ++) 149
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
for (; x < w; x ++) 159
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
------------------------------
6 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ] 141
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 128
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
dst = linel + ( x * pixelsize + compno * ! planar ); 147
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
7 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c dst = line + x * pixelsize + compno * ! planar 98
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
const AVPixFmtDescriptor * pixdesc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ) ; 4
int compno , reslevelno , bandno ; 5
int x , y ; 6
int planar = ! ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_PLANAR ) ; 7
int pixelsize = planar ? 1 : pixdesc -> nb_components ; 8
uint8_t * line ; 10
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int plane = 0 ; 86
if ( planar )  88
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
uint8_t * dst ; 95
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
------------------------------
8 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ] 97
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
for (; x < w; x ++) 101
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
for (; x < w; x ++) 110
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
------------------------------
9 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c line = picture -> data [ plane ] + y * picture -> linesize [ plane ] 93
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
const AVPixFmtDescriptor * pixdesc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ) ; 4
int compno , reslevelno , bandno ; 5
int x , y ; 6
int planar = ! ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_PLANAR ) ; 7
uint8_t * line ; 10
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int plane = 0 ; 86
if ( planar )  88
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
dst = line + x * pixelsize + compno * ! planar; 98
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
------------------------------
10 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ] 92
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
dst = line + x * pixelsize + compno * ! planar; 98
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
------------------------------
11 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y 35
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
------------------------------
12 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c s -> bytestream = original_bytestream + best_bytestream_size 111
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint32_t best_sequence_number ; 11
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
sequence_number = s -> sequence_number; 84
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_sequence_number = sequence_number; 95
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
s -> sequence_number = best_sequence_number; 110
s -> bytestream = original_bytestream + best_bytestream_size; 111
s -> bytestream_end = original_bytestream_end; 112
------------------------------
13 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c bytestream_size = s -> bytestream - bytestream_start 86
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
s -> bytestream = original_bytestream + best_bytestream_size; 111
s -> bytestream_end = original_bytestream_end; 112
memcpy ( original_bytestream , best_bytestream , best_bytestream_size ); 114
------------------------------
14 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ) 40
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t * original_bytestream , * original_bytestream_end ; 9
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
memcpy ( diffFrame -> data [ 0 ] , s -> last_frame -> data [ 0 ] , s -> last_frame -> linesize [ 0 ] * s -> last_frame -> height ); 61
size_t row_start = s -> last_frame -> linesize [ 0 ] * y + bpp * last_fctl_chunk . x_offset ; 66
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
sequence_number = s -> sequence_number; 84
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_sequence_number = sequence_number; 95
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> sequence_number = best_sequence_number; 110
s -> bytestream = original_bytestream + best_bytestream_size; 111
s -> bytestream_end = original_bytestream_end; 112
if ( best_bytestream != original_bytestream )  113
memcpy ( original_bytestream , best_bytestream , best_bytestream_size ); 114
av_frame_free ( & diffFrame ); 120
return ret ; 121
------------------------------
15 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ) 39
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
AVFrame * diffFrame ; 7
uint8_t * original_bytestream , * original_bytestream_end ; 9
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
memcpy ( diffFrame -> data [ 0 ] , s -> last_frame -> data [ 0 ] , s -> last_frame -> linesize [ 0 ] * s -> last_frame -> height ); 61
size_t row_start = s -> last_frame -> linesize [ 0 ] * y + bpp * last_fctl_chunk . x_offset ; 66
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
sequence_number = s -> sequence_number; 84
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_sequence_number = sequence_number; 95
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> sequence_number = best_sequence_number; 110
s -> bytestream = original_bytestream + best_bytestream_size; 111
s -> bytestream_end = original_bytestream_end; 112
if ( best_bytestream != original_bytestream )  113
memcpy ( original_bytestream , best_bytestream , best_bytestream_size ); 114
av_frame_free ( & diffFrame ); 120
return ret ; 121
------------------------------
16 /home/SySeVR/data/CVE-2016-2522_VULN_dissect_ber_constrained_bitstring.c val = tvb_get_guint8 ( tvb , offset + nb -> bit / 8 ) 98
dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb) 1
gint8 ber_class ; 3
gboolean pc , ind ; 4
gint32 tag ; 5
guint32 len , byteno ; 6
guint8 pad = 0 , b0 , b1 , val , * bitstring ; 7
const asn_namedbit * nb ; 15
if ( ! implicit_tag )  17
offset = dissect_ber_identifier ( actx -> pinfo , parent_tree , tvb , offset , & ber_class , & pc , & tag ); 20
offset = dissect_ber_length ( actx -> pinfo , parent_tree , tvb , offset , & len , & ind ); 21
if ( ! implicit_tag && ( ber_class != BER_CLASS_APP ) )  32
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_BITSTRING ) )  33
pc = 0; 51
len = tvb_reported_length_remaining ( tvb , offset ); 52
if ( pc )  58
pad = tvb_get_guint8 ( tvb , offset ); 63
offset ++; 76
len --; 77
if ( named_bits )  90
nb = named_bits; 93
bitstring = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset , len ); 94
while ( nb -> p_id )  96
if ( ( len > 0 ) && ( pad < 8 * len ) && ( nb -> bit < ( 8 * len - pad ) ) )  97
val = tvb_get_guint8 ( tvb , offset + nb -> bit / 8 ); 98
bitstring [ ( nb -> bit / 8 ) ] &= ~ ( 0x80 >> ( nb -> bit % 8 ) ); 99
val &= 0x80 >> ( nb -> bit % 8 ); 100
if ( val )  110
nb ++; 123
------------------------------
17 /home/SySeVR/data/CVE-2016-2522_VULN_dissect_ber_constrained_bitstring.c end_offset = offset + len 53
dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb) 1
guint32 len , byteno ; 6
int end_offset ; 8
if ( ! implicit_tag )  17
len = tvb_reported_length_remaining ( tvb , offset ); 52
end_offset = offset + len; 53
return end_offset ; 149
------------------------------
18 /home/SySeVR/data/CVE-2016-2522_VULN_dissect_ber_constrained_bitstring.c end_offset = offset + len 22
dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb) 1
guint32 len , byteno ; 6
int end_offset ; 8
if ( ! implicit_tag )  17
offset = dissect_ber_identifier ( actx -> pinfo , parent_tree , tvb , offset , & ber_class , & pc , & tag ); 20
offset = dissect_ber_length ( actx -> pinfo , parent_tree , tvb , offset , & len , & ind ); 21
end_offset = offset + len; 22
return end_offset ; 47
return end_offset ; 149
------------------------------
19 /home/SySeVR/data/CVE-2016-5829_VULN_hiddev_ioctl_usage.c uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] 95
static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg) 1
struct hid_device * hid = hiddev -> hid ; 3
struct hiddev_report_info rinfo ; 4
struct hiddev_usage_ref * uref ; 6
struct hid_report * report ; 7
struct hid_field * field ; 8
int i ; 9
uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ); 11
if ( ! uref_multi )  12
uref = & uref_multi -> uref; 14
if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES )  15
if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) )  16
if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) )  20
switch ( cmd )  24
rinfo . report_type = uref -> report_type; 26
rinfo . report_id = uref -> report_id; 27
if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL )  28
if ( uref -> field_index >= report -> maxfield )  31
field = report -> field [ uref -> field_index ]; 34
if ( uref -> usage_index >= field -> maxusage )  35
uref -> usage_code = field -> usage [ uref -> usage_index ] . hid; 38
if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT )  46
if ( uref -> report_id == HID_REPORT_ID_UNKNOWN )  51
field = hiddev_lookup_usage ( hid , uref ); 52
if ( field == NULL )  53
rinfo . report_type = uref -> report_type; 56
rinfo . report_id = uref -> report_id; 57
if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL )  58
if ( uref -> field_index >= report -> maxfield )  61
field = report -> field [ uref -> field_index ]; 64
if ( cmd == HIDIOCGCOLLECTIONINDEX )  66
if ( uref -> usage_index >= field -> maxusage )  67
if ( uref -> usage_index >= field -> report_count )  69
if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) )  72
switch ( cmd )  78
uref -> value = field -> value [ uref -> usage_index ]; 80
field -> value [ uref -> usage_index ] = uref -> value; 86
i = field -> usage [ uref -> usage_index ] . collection_index; 90
for (i = 0; i < uref_multi->num_values; i++) 94
uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ]; 95
if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) )  97
for (i = 0; i < uref_multi->num_values; i++) 102
field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ]; 103
kfree ( uref_multi ); 109
kfree ( uref_multi ); 112
kfree ( uref_multi ); 115
------------------------------
20 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ) 40
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
const struct brcmf_tlv * ssid_ie ; 7
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ); 47
ssid_le . SSID_len = cpu_to_le32 ( ssid_ie -> len ); 48
brcmf_dbg ( TRACE , "SSID is (%s) in Head\n" , ssid_le . SSID ); 49
------------------------------
21 /home/SySeVR/data/CVE-2016-8658_VULN_brcmf_cfg80211_start_ap.c ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN 39
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
struct cfg80211_ap_settings *settings) 2
s32 ie_offset ; 4
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  38
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; 39
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); 40
if ( ! ssid_ie )  44
memcpy ( ssid_le . SSID , ssid_ie -> data , ssid_ie -> len ); 47
ssid_le . SSID_len = cpu_to_le32 ( ssid_ie -> len ); 48
brcmf_dbg ( TRACE , "SSID is (%s) in Head\n" , ssid_le . SSID ); 49
------------------------------
22 /home/SySeVR/data/CVE_2005_4886_PATCHED_selinux_parse_skb_ipv6.c offset = skb -> nh . raw - skb -> data 7
static int CVE_2005_4886_PATCHED_selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad) 1
offset = skb -> nh . raw - skb -> data; 7
ip6 = skb_header_pointer ( skb , offset , sizeof ( _ipv6h ) , & _ipv6h ); 8
if ( ip6 == NULL )  9
ipv6_addr_copy ( & ad -> u . net . v6info . saddr , & ip6 -> saddr ); 12
ipv6_addr_copy ( & ad -> u . net . v6info . daddr , & ip6 -> daddr ); 13
nexthdr = ip6 -> nexthdr; 16
offset += sizeof ( _ipv6h ); 17
offset = ipv6_skip_exthdr ( skb , offset , & nexthdr ); 18
if ( offset < 0 )  19
switch ( nexthdr )  22
th = skb_header_pointer ( skb , offset , sizeof ( _tcph ) , & _tcph ); 26
if ( th == NULL )  27
ad -> u . net . sport = th -> source; 30
ad -> u . net . dport = th -> dest; 31
uh = skb_header_pointer ( skb , offset , sizeof ( _udph ) , & _udph ); 38
if ( uh == NULL )  39
ad -> u . net . sport = uh -> source; 42
ad -> u . net . dport = uh -> dest; 43
------------------------------
23 /home/SySeVR/data/CVE_2005_4886_VULN_selinux_parse_skb_ipv6.c offset = ipv6_skip_exthdr ( skb , offset , & nexthdr , skb -> tail - skb -> head - offset ) 18
static int CVE_2005_4886_VULN_selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad) 1
u8 nexthdr ; 3
struct ipv6hdr _ipv6h , * ip6 ; 5
offset = skb -> nh . raw - skb -> data; 7
ip6 = skb_header_pointer ( skb , offset , sizeof ( _ipv6h ) , & _ipv6h ); 8
if ( ip6 == NULL )  9
nexthdr = ip6 -> nexthdr; 16
offset += sizeof ( _ipv6h ); 17
offset = ipv6_skip_exthdr ( skb , offset , & nexthdr , skb -> tail - skb -> head - offset ); 18
if ( offset < 0 )  20
th = skb_header_pointer ( skb , offset , sizeof ( _tcph ) , & _tcph ); 27
if ( th == NULL )  28
ad -> u . net . sport = th -> source; 31
ad -> u . net . dport = th -> dest; 32
uh = skb_header_pointer ( skb , offset , sizeof ( _udph ) , & _udph ); 39
if ( uh == NULL )  40
ad -> u . net . sport = uh -> source; 43
ad -> u . net . dport = uh -> dest; 44
------------------------------
24 /home/SySeVR/data/CVE_2005_4886_VULN_selinux_parse_skb_ipv6.c offset = skb -> nh . raw - skb -> data 7
static int CVE_2005_4886_VULN_selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad) 1
offset = skb -> nh . raw - skb -> data; 7
ip6 = skb_header_pointer ( skb , offset , sizeof ( _ipv6h ) , & _ipv6h ); 8
if ( ip6 == NULL )  9
ipv6_addr_copy ( & ad -> u . net . v6info . saddr , & ip6 -> saddr ); 12
ipv6_addr_copy ( & ad -> u . net . v6info . daddr , & ip6 -> daddr ); 13
nexthdr = ip6 -> nexthdr; 16
offset += sizeof ( _ipv6h ); 17
offset = ipv6_skip_exthdr ( skb , offset , & nexthdr , skb -> tail - skb -> head - offset ); 18
if ( offset < 0 )  20
switch ( nexthdr )  23
th = skb_header_pointer ( skb , offset , sizeof ( _tcph ) , & _tcph ); 27
if ( th == NULL )  28
ad -> u . net . sport = th -> source; 31
ad -> u . net . dport = th -> dest; 32
uh = skb_header_pointer ( skb , offset , sizeof ( _udph ) , & _udph ); 39
if ( uh == NULL )  40
ad -> u . net . sport = uh -> source; 43
ad -> u . net . dport = uh -> dest; 44
------------------------------
25 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c block_end = block_start + blocksize 98
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
int err = 0 ; 6
unsigned blocksize , bbits ; 7
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
if ( PageUptodate ( page ) )  62
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )  67
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
if ( ! buffer_uptodate ( * wait_bh ) )  78
err = - EIO; 79
if ( ! err )  81
bh = head; 95
block_start = 0; 96
block_end = block_start + blocksize; 98
if ( block_end <= from )  99
if ( block_start >= to )  101
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
block_start = block_end; 114
bh = bh -> b_this_page; 115
while ( bh != head )  116
------------------------------
26 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c block_end = block_start + blocksize 25
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
unsigned block_start , block_end ; 4
sector_t block ; 5
unsigned blocksize , bbits ; 7
blocksize = 1 << inode -> i_blkbits; 15
head = page_buffers ( page ); 18
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_uptodate ( bh ) )  28
set_buffer_uptodate ( bh ); 29
if ( buffer_new ( bh ) )  33
clear_buffer_new ( bh ); 34
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
unmap_underlying_metadata ( bh -> b_bdev , bh -> b_blocknr ); 40
set_buffer_uptodate ( bh ); 43
if ( block_end > to || block_start < from )  46
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
if ( block_start < from )  53
memset ( kaddr + block_start , 0 , from - block_start ); 54
kunmap_atomic ( kaddr , KM_USER0 ); 57
if ( PageUptodate ( page ) )  62
if ( ! buffer_uptodate ( bh ) )  63
set_buffer_uptodate ( bh ); 64
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )  67
ll_rw_block ( READ , 1 , & bh ); 69
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
wait_on_buffer ( * -- wait_bh ); 77
if ( ! buffer_uptodate ( * wait_bh ) )  78
if ( ! err )  81
if ( buffer_new ( bh ) )  84
clear_buffer_new ( bh ); 85
while ( ( bh = bh -> b_this_page ) != head )  86
block_end = block_start + blocksize; 98
if ( block_end <= from )  99
if ( block_start >= to )  101
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
block_start = block_end; 114
return err ; 117
------------------------------
27 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ) 21
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
sector_t block ; 5
unsigned blocksize , bbits ; 7
bbits = inode -> i_blkbits; 20
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits ); 21
for(bh = head, block_start = 0; bh != head || !block_start;
block++, block_start=block_end, bh = bh->b_this_page) 24
block_end = block_start + blocksize; 25
if ( block_end <= from || block_start >= to )  26
if ( ! buffer_uptodate ( bh ) )  28
set_buffer_uptodate ( bh ); 29
if ( buffer_new ( bh ) )  33
clear_buffer_new ( bh ); 34
if ( ! buffer_mapped ( bh ) )  35
err = get_block ( inode , block , bh , 1 ); 36
if ( err )  37
if ( buffer_new ( bh ) )  39
unmap_underlying_metadata ( bh -> b_bdev , bh -> b_blocknr ); 40
set_buffer_uptodate ( bh ); 43
if ( block_end > to || block_start < from )  46
if ( block_end > to )  50
memset ( kaddr + to , 0 , block_end - to ); 51
if ( block_start < from )  53
memset ( kaddr + block_start , 0 , from - block_start ); 54
kunmap_atomic ( kaddr , KM_USER0 ); 57
if ( ! buffer_uptodate ( bh ) )  63
set_buffer_uptodate ( bh ); 64
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )  67
ll_rw_block ( READ , 1 , & bh ); 69
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
wait_on_buffer ( * -- wait_bh ); 77
if ( ! buffer_uptodate ( * wait_bh ) )  78
if ( ! err )  81
if ( buffer_new ( bh ) )  84
clear_buffer_new ( bh ); 85
while ( ( bh = bh -> b_this_page ) != head )  86
block_end = block_start + blocksize; 98
if ( block_end <= from )  99
if ( block_start >= to )  101
memset ( kaddr + block_start , 0 , bh -> b_size ); 108
kunmap_atomic ( kaddr , KM_USER0 ); 109
block_start = block_end; 114
return err ; 117
------------------------------
28 /home/SySeVR/data/CVE_2006_5751_PATCHED_get_fdb_entries.c size = maxnum * sizeof ( struct __fdb_entry ) 12
static int CVE_2006_5751_PATCHED_get_fdb_entries(struct net_bridge *br, void __user *userbuf,
unsigned long maxnum, unsigned long offset) 2
size_t size ; 6
if ( maxnum > PAGE_SIZE / sizeof ( struct __fdb_entry ) )  9
maxnum = PAGE_SIZE / sizeof ( struct __fdb_entry ); 10
size = maxnum * sizeof ( struct __fdb_entry ); 12
buf = kmalloc ( size , GFP_USER ); 14
if ( ! buf )  15
num = br_fdb_fillbuf ( br , buf , maxnum , offset ); 18
if ( num > 0 )  19
if ( copy_to_user ( userbuf , buf , num * sizeof ( struct __fdb_entry ) ) )  20
kfree ( buf ); 23
return num ; 25
------------------------------
29 /home/SySeVR/data/CVE_2006_5751_PATCHED_get_fdb_entries.c maxnum = PAGE_SIZE / sizeof ( struct __fdb_entry ) 10
static int CVE_2006_5751_PATCHED_get_fdb_entries(struct net_bridge *br, void __user *userbuf,
unsigned long maxnum, unsigned long offset) 2
if ( maxnum > PAGE_SIZE / sizeof ( struct __fdb_entry ) )  9
maxnum = PAGE_SIZE / sizeof ( struct __fdb_entry ); 10
size = maxnum * sizeof ( struct __fdb_entry ); 12
buf = kmalloc ( size , GFP_USER ); 14
if ( ! buf )  15
num = br_fdb_fillbuf ( br , buf , maxnum , offset ); 18
if ( num > 0 )  19
if ( copy_to_user ( userbuf , buf , num * sizeof ( struct __fdb_entry ) ) )  20
kfree ( buf ); 23
return num ; 25
------------------------------
30 /home/SySeVR/data/CVE_2006_5751_VULN_get_fdb_entries.c maxnum = PAGE_SIZE / sizeof ( struct __fdb_entry ) 10
static int CVE_2006_5751_VULN_get_fdb_entries(struct net_bridge *br, void __user *userbuf,
unsigned long maxnum, unsigned long offset) 2
size_t size = maxnum * sizeof ( struct __fdb_entry ) ; 6
if ( size > PAGE_SIZE )  8
maxnum = PAGE_SIZE / sizeof ( struct __fdb_entry ); 10
num = br_fdb_fillbuf ( br , buf , maxnum , offset ); 17
if ( num > 0 )  18
if ( copy_to_user ( userbuf , buf , num * sizeof ( struct __fdb_entry ) ) )  19
return num ; 24
------------------------------
31 /home/SySeVR/data/CVE_2006_6333_PATCHED_tr_rx.c rbuffer_len = ntohs ( readw ( rbuf + BUFFER_LENGTH_OFST ) ) 139
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev) 1
struct tok_info * ti = ( struct tok_info * ) dev -> priv ; 3
__u32 rbuffer ; 4
void __iomem * rbuf , * rbufdata , * llc ; 5
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ; 8
struct sk_buff * skb ; 10
struct arb_rec_req rarb ; 15
rbuffer = ntohs ( rarb . rec_buf_addr ); 19
rbuf = map_address ( ti , rbuffer , & rbuffer_page ); 20
lan_hdr_len = rarb . lan_hdr_len; 30
length = ntohs ( rarb . frame_len ); 60
skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc ); 87
if ( ! ( skb = dev_alloc_skb ( skb_size ) ) )  89
if ( ibmtr_debug_trace & TRC_INITV && length < rbuffer_len )  123
DPRINTK ( "CURIOUS, length=%d < rbuffer_len=%d\n" , length , rbuffer_len ); 124
chksum = csum_partial_copy_nocheck ( ( void * ) rbufdata , data , length < rbuffer_len ? length : rbuffer_len , chksum ); 127
memcpy_fromio ( data , rbufdata , rbuffer_len ); 130
rbuffer = ntohs ( readw ( rbuf + BUFFER_POINTER_OFST ) ); 131
if ( ! rbuffer )  132
rbuffer -= 2; 134
length -= rbuffer_len; 135
data += rbuffer_len; 136
rbuf = map_address ( ti , rbuffer , & rbuffer_page ); 137
rbuffer_len = ntohs ( readw ( rbuf + BUFFER_LENGTH_OFST ) ); 139
rbufdata = rbuf + offsetof ( struct rec_buf , data ) 140
skb -> csum = chksum; 153
skb -> ip_summed = CHECKSUM_COMPLETE; 154
netif_rx ( skb ); 156
------------------------------
32 /home/SySeVR/data/CVE_2006_6333_PATCHED_tr_rx.c rbuffer = ntohs ( readw ( rbuf + BUFFER_POINTER_OFST ) ) 131
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev) 1
struct tok_info * ti = ( struct tok_info * ) dev -> priv ; 3
__u32 rbuffer ; 4
void __iomem * rbuf , * rbufdata , * llc ; 5
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ; 8
struct sk_buff * skb ; 10
struct arb_rec_req rarb ; 15
rbuffer = ntohs ( rarb . rec_buf_addr ); 19
rbuf = map_address ( ti , rbuffer , & rbuffer_page ); 20
lan_hdr_len = rarb . lan_hdr_len; 30
length = ntohs ( rarb . frame_len ); 60
skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc ); 87
if ( ! ( skb = dev_alloc_skb ( skb_size ) ) )  89
if ( ibmtr_debug_trace & TRC_INITV && length < rbuffer_len )  123
DPRINTK ( "CURIOUS, length=%d < rbuffer_len=%d\n" , length , rbuffer_len ); 124
chksum = csum_partial_copy_nocheck ( ( void * ) rbufdata , data , length < rbuffer_len ? length : rbuffer_len , chksum ); 127
memcpy_fromio ( data , rbufdata , rbuffer_len ); 130
rbuffer = ntohs ( readw ( rbuf + BUFFER_POINTER_OFST ) ); 131
if ( ! rbuffer )  132
rbuffer -= 2; 134
length -= rbuffer_len; 135
data += rbuffer_len; 136
rbuf = map_address ( ti , rbuffer , & rbuffer_page ); 137
rbuffer_len = ntohs ( readw ( rbuf + BUFFER_LENGTH_OFST ) ); 139
rbufdata = rbuf + offsetof ( struct rec_buf , data ) 140
skb -> csum = chksum; 153
skb -> ip_summed = CHECKSUM_COMPLETE; 154
netif_rx ( skb ); 156
------------------------------
33 /home/SySeVR/data/CVE_2006_6333_PATCHED_tr_rx.c iph = ( struct iphdr * ) ( data + lan_hdr_len + sizeof ( struct trllc ) ) 110
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev) 1
struct tok_info * ti = ( struct tok_info * ) dev -> priv ; 3
__u32 rbuffer ; 4
void __iomem * rbuf , * rbufdata , * llc ; 5
unsigned char * data ; 7
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ; 8
struct sk_buff * skb ; 10
struct iphdr * iph ; 14
struct arb_rec_req rarb ; 15
rbuffer = ntohs ( rarb . rec_buf_addr ); 19
rbuf = map_address ( ti , rbuffer , & rbuffer_page ); 20
lan_hdr_len = rarb . lan_hdr_len; 30
if ( lan_hdr_len > sizeof ( struct trh_hdr ) )  31
hdr_len = lan_hdr_len + sizeof ( struct trllc ) + sizeof ( struct iphdr ); 36
llc = rbuf + offsetof ( struct rec_buf , data ) + lan_hdr_len 39
length = ntohs ( rarb . frame_len ); 60
if ( readb ( llc + DSAP_OFST ) == EXTENDED_SAP && readb ( llc + SSAP_OFST ) == EXTENDED_SAP && length >= hdr_len )  61
IPv4_p = 1; 63
skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc ); 87
if ( ! ( skb = dev_alloc_skb ( skb_size ) ) )  89
skb -> dev = dev; 100
data = skb -> data; 101
if ( IPv4_p )  105
iph = ( struct iphdr * ) ( data + lan_hdr_len + sizeof ( struct trllc ) ); 110
ip_len = ntohs ( iph -> tot_len ) - sizeof ( struct iphdr ); 111
if ( ( ip_len <= length ) && ( ip_len > 7 ) )  113
length = ip_len; 114
if ( ibmtr_debug_trace & TRC_INITV && length < rbuffer_len )  123
DPRINTK ( "CURIOUS, length=%d < rbuffer_len=%d\n" , length , rbuffer_len ); 124
chksum = csum_partial_copy_nocheck ( ( void * ) rbufdata , data , length < rbuffer_len ? length : rbuffer_len , chksum ); 127
length -= rbuffer_len; 135
skb -> csum = chksum; 153
skb -> ip_summed = CHECKSUM_COMPLETE; 154
netif_rx ( skb ); 156
------------------------------
34 /home/SySeVR/data/CVE_2006_6333_PATCHED_tr_rx.c skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc ) 87
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev) 1
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ; 8
struct arb_rec_req rarb ; 15
lan_hdr_len = rarb . lan_hdr_len; 30
length = ntohs ( rarb . frame_len ); 60
skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc ); 87
if ( ! ( skb = dev_alloc_skb ( skb_size ) ) )  89
skb_reserve ( skb , sizeof ( struct trh_hdr ) - lan_hdr_len ); 98
skb_put ( skb , length ); 99
skb -> dev = dev; 100
data = skb -> data; 101
memcpy_fromio ( data , rbufdata , hdr_len ); 107
iph = ( struct iphdr * ) ( data + lan_hdr_len + sizeof ( struct trllc ) ); 110
ip_len = ntohs ( iph -> tot_len ) - sizeof ( struct iphdr ); 111
if ( ( ip_len <= length ) && ( ip_len > 7 ) )  113
length = ip_len; 114
data += hdr_len; 115
if ( ibmtr_debug_trace & TRC_INITV && length < rbuffer_len )  123
DPRINTK ( "CURIOUS, length=%d < rbuffer_len=%d\n" , length , rbuffer_len ); 124
chksum = csum_partial_copy_nocheck ( ( void * ) rbufdata , data , length < rbuffer_len ? length : rbuffer_len , chksum ); 127
memcpy_fromio ( data , rbufdata , rbuffer_len ); 130
length -= rbuffer_len; 135
data += rbuffer_len; 136
rbufdata = rbuf + offsetof ( struct rec_buf , data ) 140
ti -> tr_stats . rx_bytes += skb -> len; 148
ti -> tr_stats . rx_packets ++; 149
skb -> protocol = tr_type_trans ( skb , dev ); 151
skb -> csum = chksum; 153
skb -> ip_summed = CHECKSUM_COMPLETE; 154
netif_rx ( skb ); 156
------------------------------
35 /home/SySeVR/data/CVE_2006_6333_PATCHED_tr_rx.c hdr_len = lan_hdr_len + sizeof ( struct trllc ) + sizeof ( struct iphdr ) 36
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev) 1
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ; 8
struct arb_rec_req rarb ; 15
lan_hdr_len = rarb . lan_hdr_len; 30
if ( lan_hdr_len > sizeof ( struct trh_hdr ) )  31
hdr_len = lan_hdr_len + sizeof ( struct trllc ) + sizeof ( struct iphdr ); 36
if ( readb ( llc + DSAP_OFST ) == EXTENDED_SAP && readb ( llc + SSAP_OFST ) == EXTENDED_SAP && length >= hdr_len )  61
memcpy_fromio ( data , rbufdata , hdr_len ); 107
length -= hdr_len; 112
if ( ( ip_len <= length ) && ( ip_len > 7 ) )  113
data += hdr_len; 115
rbuffer_len -= hdr_len; 116
rbufdata += hdr_len; 117
if ( ibmtr_debug_trace & TRC_INITV && length < rbuffer_len )  123
DPRINTK ( "CURIOUS, length=%d < rbuffer_len=%d\n" , length , rbuffer_len ); 124
chksum = csum_partial_copy_nocheck ( ( void * ) rbufdata , data , length < rbuffer_len ? length : rbuffer_len , chksum ); 127
memcpy_fromio ( data , rbufdata , rbuffer_len ); 130
length -= rbuffer_len; 135
data += rbuffer_len; 136
rbufdata = rbuf + offsetof ( struct rec_buf , data ) 140
skb -> csum = chksum; 153
skb -> ip_summed = CHECKSUM_COMPLETE; 154
netif_rx ( skb ); 156
------------------------------
36 /home/SySeVR/data/CVE_2006_6333_PATCHED_tr_rx.c dlc_hdr_len = readb ( ti -> arb + DLC_HDR_LENGTH_OFST ) 35
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev) 1
struct tok_info * ti = ( struct tok_info * ) dev -> priv ; 3
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ; 8
unsigned char dlc_hdr_len ; 9
struct arb_rec_req rarb ; 15
lan_hdr_len = rarb . lan_hdr_len; 30
if ( lan_hdr_len > sizeof ( struct trh_hdr ) )  31
dlc_hdr_len = readb ( ti -> arb + DLC_HDR_LENGTH_OFST ); 35
------------------------------
37 /home/SySeVR/data/CVE_2007_1217_PATCHED_bufprint.c r = cdb -> size - cdb -> pos 31
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
size_t ns = 2 * cdb -> size ; 14
u_char * nb ; 15
while ( ( ns - cdb -> pos ) <= n )  17
ns *= 2; 18
nb = kmalloc ( ns , GFP_ATOMIC ); 19
if ( ! nb )  20
memcpy ( nb , cdb -> buf , cdb -> pos ); 24
nb [ cdb -> pos ] = 0; 26
cdb -> buf = nb; 27
cdb -> p = cdb -> buf + cdb -> pos; 28
cdb -> size = ns; 29
r = cdb -> size - cdb -> pos; 31
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
------------------------------
38 /home/SySeVR/data/CVE_2007_1217_PATCHED_bufprint.c cdb -> p = cdb -> buf + cdb -> pos 28
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
va_list f ; 3
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
size_t ns = 2 * cdb -> size ; 14
u_char * nb ; 15
while ( ( ns - cdb -> pos ) <= n )  17
ns *= 2; 18
nb = kmalloc ( ns , GFP_ATOMIC ); 19
if ( ! nb )  20
memcpy ( nb , cdb -> buf , cdb -> pos ); 24
nb [ cdb -> pos ] = 0; 26
cdb -> buf = nb; 27
cdb -> p = cdb -> buf + cdb -> pos; 28
cdb -> size = ns; 29
r = cdb -> size - cdb -> pos; 31
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
------------------------------
39 /home/SySeVR/data/CVE_2007_1217_PATCHED_bufprint.c r = cdb -> size - cdb -> pos 9
static _cdebbuf *CVE_2007_1217_PATCHED_bufprint(_cdebbuf *cdb, char *fmt,...) 1
size_t n , r ; 4
if ( ! cdb )  6
r = cdb -> size - cdb -> pos; 9
n = vsnprintf ( cdb -> p , r , fmt , f ); 10
if ( n >= r )  12
while ( ( ns - cdb -> pos ) <= n )  17
n = vsnprintf ( cdb -> p , r , fmt , f ); 32
cdb -> p += n; 35
cdb -> pos += n; 36
return cdb ; 37
------------------------------
40 /home/SySeVR/data/CVE_2007_3642_VULN_decode_seq.c bs -> cur = beg + len 110
int CVE_2007_3642_VULN_decode_seq(bitstr_t * bs, field_t * f, char *base, int level) 1
int err ; 4
field_t * son ; 5
base = ( base && ( f -> attr & DECODE ) ) ? base + f -> offset : NULL; 11
ext = ( f -> attr & EXT ) ? get_bit ( bs ) : 0; 14
bmp = get_bitmap ( bs , f -> sz ); 17
if ( base )  18
* ( unsigned * ) base = bmp; 19
for (i = opt = 0, son = f->fields; i < f->lb; i++, son++) 22
if ( son -> attr & STOP )  23
if ( son -> attr & OPT )  29
if ( ! ( ( 0x80000000U >> ( opt ++ ) ) & bmp ) )  30
if ( son -> attr & OPEN )  35
len = get_len ( bs ); 37
if ( ! base )  39
bs -> cur += len; 42
beg = bs -> cur; 45
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  48
bs -> cur = beg + len; 53
bs -> bit = 0; 54
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  55
if ( ! ext )  62
bmp2_len = get_bits ( bs , 7 ) + 1; 66
bmp2 = get_bitmap ( bs , bmp2_len ); 68
bmp |= bmp2 >> f -> sz; 69
if ( base )  70
* ( unsigned * ) base = bmp; 71
for (opt = 0; opt < bmp2_len; opt++, i++, son++) 75
if ( i < f -> ub && son -> attr & STOP )  76
if ( ! ( ( 0x80000000 >> opt ) & bmp2 ) )  82
if ( i >= f -> ub )  86
len = get_len ( bs ); 88
bs -> cur += len; 90
len = get_len ( bs ); 95
if ( ! base || ! ( son -> attr & DECODE ) )  97
bs -> cur += len; 100
beg = bs -> cur; 103
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  105
bs -> cur = beg + len; 110
bs -> bit = 0; 111
------------------------------
41 /home/SySeVR/data/CVE_2007_3642_VULN_decode_seq.c bs -> cur = beg + len 53
int CVE_2007_3642_VULN_decode_seq(bitstr_t * bs, field_t * f, char *base, int level) 1
int err ; 4
field_t * son ; 5
base = ( base && ( f -> attr & DECODE ) ) ? base + f -> offset : NULL; 11
bmp = get_bitmap ( bs , f -> sz ); 17
if ( base )  18
* ( unsigned * ) base = bmp; 19
for (i = opt = 0, son = f->fields; i < f->lb; i++, son++) 22
if ( son -> attr & STOP )  23
if ( son -> attr & OPT )  29
if ( ! ( ( 0x80000000U >> ( opt ++ ) ) & bmp ) )  30
if ( son -> attr & OPEN )  35
len = get_len ( bs ); 37
if ( ! base )  39
bs -> cur += len; 42
beg = bs -> cur; 45
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  48
bs -> cur = beg + len; 53
bs -> bit = 0; 54
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  55
bmp2_len = get_bits ( bs , 7 ) + 1; 66
CHECK_BOUND ( bs , ( bmp2_len + 7 ) >> 3 ); 67
bmp2 = get_bitmap ( bs , bmp2_len ); 68
bmp |= bmp2 >> f -> sz; 69
* ( unsigned * ) base = bmp; 71
BYTE_ALIGN ( bs ); 72
for (opt = 0; opt < bmp2_len; opt++, i++, son++) 75
if ( ! ( ( 0x80000000 >> opt ) & bmp2 ) )  82
CHECK_BOUND ( bs , 2 ); 87
len = get_len ( bs ); 88
CHECK_BOUND ( bs , len ); 89
bs -> cur += len; 90
if ( ! base || ! ( son -> attr & DECODE ) )  97
bs -> cur += len; 100
beg = bs -> cur; 103
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  105
return err ; 108
bs -> cur = beg + len; 110
bs -> bit = 0; 111
------------------------------
42 /home/SySeVR/data/CVE_2007_3642_VULN_decode_seq.c base = ( base && ( f -> attr & DECODE ) ) ? base + f -> offset : NULL 11
int CVE_2007_3642_VULN_decode_seq(bitstr_t * bs, field_t * f, char *base, int level) 1
base = ( base && ( f -> attr & DECODE ) ) ? base + f -> offset : NULL; 11
if ( base )  18
* ( unsigned * ) base = bmp; 19
if ( ! base )  39
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  48
return err ; 51
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  55
return err ; 58
if ( base )  70
* ( unsigned * ) base = bmp; 71
if ( ! base || ! ( son -> attr & DECODE ) )  97
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )  105
return err ; 108
------------------------------
43 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c mAlphaPtr = mAlpha + mBIH . width 355
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
while ( aCount > 0 )  258
PRUint8 byte ; 259
switch ( mState )  261
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
mState = eRLEStateNeedSecondEscapeByte; 266
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
if ( mBIH . compression == BI_RLE8 )  283
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mState = eRLEStateInitial; 294
switch ( byte )  298
mAlphaPtr = mAlpha; 304
mState = eRLEStateInitial; 307
mState = eRLEStateNeedXDelta; 316
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
mState = eRLEStateAbsoluteMode; 342
mState = eRLEStateAbsoluteModePadded; 344
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
mState = eRLEStateNeedYDelta; 358
byte = * aBuffer ++; 363
aCount --; 364
mState = eRLEStateInitial; 365
if ( byte == 0 )  366
if ( mBIH . compression == BI_RLE8 )  379
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( mState == eRLEStateAbsoluteMode )  398
mState = eRLEStateInitial; 399
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
mState = eRLEStateInitial; 405
if ( mCurLine == 0 )  417
------------------------------
44 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ) 280
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aBuffer ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )  233
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )  234
if ( ! mAlpha )  240
PRUint32 alpha ; 241
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 ); 245
if ( ! mAlpha )  246
mAlphaPtr = mAlpha; 248
if ( ! mDecoded )  251
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 ); 252
if ( ! mDecoded )  253
while ( aCount > 0 )  258
PRUint8 byte ; 259
switch ( mState )  261
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
mState = eRLEStateNeedSecondEscapeByte; 266
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
if ( mBIH . compression == BI_RLE8 )  283
while ( mStateData > 0 )  284
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
mState = eRLEStateInitial; 294
switch ( byte )  298
mAlphaPtr = mAlpha; 304
mState = eRLEStateInitial; 307
mState = eRLEStateNeedXDelta; 316
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
mState = eRLEStateAbsoluteMode; 342
mState = eRLEStateAbsoluteModePadded; 344
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mAlphaPtr = mAlpha + mBIH . width; 355
mState = eRLEStateNeedYDelta; 358
byte = * aBuffer ++; 363
aCount --; 364
mState = eRLEStateInitial; 365
if ( byte == 0 )  366
if ( mBIH . compression == BI_RLE8 )  379
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( mState == eRLEStateAbsoluteMode )  398
mState = eRLEStateInitial; 399
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
mState = eRLEStateInitial; 405
if ( mCurLine == 0 )  417
------------------------------
45 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c toCopy = rowSize - mRowBytes 151
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ; 68
mCurLine = real_height; 73
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
if ( rowSize % 4 )  147
rowSize += ( 4 - ( rowSize % 4 ) ); 148
PRUint32 toCopy ; 149
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
if ( ! mDecoded )  161
mDecoded = ( PRUint8 * ) malloc ( mBpr ); 162
if ( ! mDecoded )  163
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
if ( mCurLine == 0 )  225
mRowBytes = 0; 228
while ( aCount > 0 )  231
------------------------------
46 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ] 75
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
------------------------------
47 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c c = retval + strlen ( retval ) 107
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
char workspace [ 512 ] ; 5
struct ast_variable * v ; 11
for (v = params; v; v = v->next) 13
if ( ! strcasecmp ( v -> name , "mansession_id" ) )  14
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += 5; 48
s -> sessiontimeout += httptimeout; 50
if ( s )  53
struct message m = { 0 } ; 54
char tmp [ 80 ] ; 55
unsigned int x ; 56
size_t hdrlen ; 57
for (x = 0, v = params; v && (x < AST_MAX_MANHEADERS); x++, v = v->next) 59
hdrlen = strlen ( v -> name ) + strlen ( v -> value ) + 3; 60
m . headers [ m . hdrcount ] = alloca ( hdrlen ); 61
snprintf ( ( char * ) m . headers [ m . hdrcount ] , hdrlen , "%s: %s" , v -> name , v -> value ); 62
m . hdrcount = x + 1; 63
if ( process_message ( s , & m ) )  66
s -> needdestroy = 1; 80
sprintf ( tmp , "%08lx" , s -> managerid ); 83
if ( s -> outputstr )  94
char * tmp ; 95
if ( format == FORMAT_XML )  96
tmp = xml_translate ( s -> outputstr -> str , params ); 97
if ( format == FORMAT_HTML )  98
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
------------------------------
48 /home/SySeVR/data/CVE_2008_3527_VULN_arch_setup_additional_pages.c vma -> vm_end = addr + PAGE_SIZE 22
int CVE_2008_3527_VULN_arch_setup_additional_pages(struct linux_binprm *bprm, int exstack) 1
struct vm_area_struct * vma ; 3
unsigned long addr ; 5
addr = get_unmapped_area ( NULL , 0 , PAGE_SIZE , 0 , 0 ); 9
if ( IS_ERR_VALUE ( addr ) )  10
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 15
if ( ! vma )  16
vma -> vm_start = addr; 21
vma -> vm_end = addr + PAGE_SIZE; 22
vma -> vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC | VM_MAYWRITE; 24
vma -> vm_flags |= VM_ALWAYSDUMP; 31
vma -> vm_flags |= mm -> def_flags; 32
vma -> vm_page_prot = protection_map [ vma -> vm_flags & 7 ]; 33
vma -> vm_ops = & syscall_vm_ops; 34
vma -> vm_mm = mm; 35
ret = insert_vm_struct ( mm , vma ); 37
if ( unlikely ( ret ) )  38
kmem_cache_free ( vm_area_cachep , vma ); 39
return ret ; 49
------------------------------
49 /home/SySeVR/data/CVE_2008_3686_VULN_rt6_fill_node.c expires = rt -> rt6i_expires - jiffies 102
static int CVE_2008_3686_VULN_rt6_fill_node(struct sk_buff *skb, struct rt6_info *rt,
struct in6_addr *dst, struct in6_addr *src,
int iif, int type, u32 pid, u32 seq,
int prefix, int nowait, unsigned int flags) 4
struct rtmsg * rtm ; 6
struct nlmsghdr * nlh ; 7
long expires ; 8
if ( prefix )  11
if ( ! ( rt -> rt6i_flags & RTF_PREFIX_RT ) )  12
nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * rtm ) , flags ); 18
if ( nlh == NULL )  19
rtm = nlmsg_data ( nlh ); 22
if ( rt -> rt6i_flags & RTF_REJECT )  33
if ( rt -> rt6i_dev && ( rt -> rt6i_dev -> flags & IFF_LOOPBACK ) )  35
rtm -> rtm_type = RTN_UNICAST; 38
rtm -> rtm_flags = 0; 39
rtm -> rtm_scope = RT_SCOPE_UNIVERSE; 40
rtm -> rtm_protocol = rt -> rt6i_protocol; 41
if ( rt -> rt6i_flags & RTF_DYNAMIC )  42
rtm -> rtm_protocol = RTPROT_REDIRECT; 43
if ( rt -> rt6i_flags & RTF_ADDRCONF )  44
rtm -> rtm_protocol = RTPROT_KERNEL; 45
if ( rt -> rt6i_flags & RTF_DEFAULT )  46
rtm -> rtm_protocol = RTPROT_RA; 47
if ( rt -> rt6i_flags & RTF_CACHE )  49
rtm -> rtm_flags |= RTM_F_CLONED; 50
if ( dst )  52
rtm -> rtm_dst_len = 128; 54
if ( src )  58
rtm -> rtm_src_len = 128; 60
if ( iif )  64
if ( ipv6_addr_is_multicast ( & rt -> rt6i_dst . addr ) )  66
int err = ip6mr_get_route ( skb , rtm , nowait ) ; 67
if ( err <= 0 )  68
if ( ! nowait )  69
if ( err == - EMSGSIZE )  74
if ( rtnetlink_put_metrics ( skb , rt -> u . dst . metrics ) < 0 )  88
if ( ! ( rt -> rt6i_flags & RTF_EXPIRES ) )  99
if ( rt -> rt6i_expires - jiffies < INT_MAX )  101
expires = rt -> rt6i_expires - jiffies; 102
if ( rtnl_put_cacheinfo ( skb , & rt -> u . dst , 0 , 0 , 0 , expires , rt -> u . dst . error ) < 0 )  106
------------------------------
50 /home/SySeVR/data/CVE_2008_3915_PATCHED_init_state.c alloc = sizeof ( struct posix_ace_state_array ) + cnt * sizeof ( struct posix_user_ace_state ) 13
static int
CVE_2008_3915_PATCHED_init_state(struct posix_acl_state *state, int cnt) 2
int alloc ; 4
alloc = sizeof ( struct posix_ace_state_array ) + cnt * sizeof ( struct posix_user_ace_state ); 13
state -> users = kzalloc ( alloc , GFP_KERNEL ); 15
if ( ! state -> users )  16
state -> groups = kzalloc ( alloc , GFP_KERNEL ); 18
if ( ! state -> groups )  19
kfree ( state -> users ); 20
------------------------------
51 /home/SySeVR/data/CVE_2008_3915_VULN_init_state.c alloc = sizeof ( struct posix_ace_state_array ) + cnt * sizeof ( struct posix_ace_state ) 13
static int
CVE_2008_3915_VULN_init_state(struct posix_acl_state *state, int cnt) 2
int alloc ; 4
alloc = sizeof ( struct posix_ace_state_array ) + cnt * sizeof ( struct posix_ace_state ); 13
state -> users = kzalloc ( alloc , GFP_KERNEL ); 15
if ( ! state -> users )  16
state -> groups = kzalloc ( alloc , GFP_KERNEL ); 18
if ( ! state -> groups )  19
kfree ( state -> users ); 20
------------------------------
52 /home/SySeVR/data/CVE_2008_4302_PATCHED_pipe_to_file.c ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ) 75
static int CVE_2008_4302_PATCHED_pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
struct splice_desc *sd) 2
struct file * file = sd -> file ; 4
struct address_space * mapping = file -> f_mapping ; 5
unsigned int offset , this_len ; 6
struct page * page ; 7
pgoff_t index ; 8
int ret ; 9
ret = buf -> ops -> pin ( pipe , buf ); 14
if ( unlikely ( ret ) )  15
index = sd -> pos >> PAGE_CACHE_SHIFT; 18
offset = sd -> pos & ~PAGE_CACHE_MASK; 19
this_len = sd -> len; 21
if ( this_len + offset > PAGE_CACHE_SIZE )  22
this_len = PAGE_CACHE_SIZE - offset; 23
page = find_lock_page ( mapping , index ); 26
if ( ! page )  27
page = page_cache_alloc_cold ( mapping ); 29
if ( unlikely ( ! page ) )  30
ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ); 36
if ( unlikely ( ret ) )  38
ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ); 42
if ( unlikely ( ret ) )  43
if ( ret == AOP_TRUNCATED_PAGE )  49
ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ); 75
if ( ret )  76
if ( ret == AOP_TRUNCATED_PAGE )  77
if ( ret < 0 )  81
return ret ; 99
------------------------------
53 /home/SySeVR/data/CVE_2008_4302_PATCHED_pipe_to_file.c ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ) 42
static int CVE_2008_4302_PATCHED_pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
struct splice_desc *sd) 2
struct file * file = sd -> file ; 4
struct address_space * mapping = file -> f_mapping ; 5
unsigned int offset , this_len ; 6
struct page * page ; 7
pgoff_t index ; 8
int ret ; 9
ret = buf -> ops -> pin ( pipe , buf ); 14
if ( unlikely ( ret ) )  15
index = sd -> pos >> PAGE_CACHE_SHIFT; 18
offset = sd -> pos & ~PAGE_CACHE_MASK; 19
this_len = sd -> len; 21
if ( this_len + offset > PAGE_CACHE_SIZE )  22
this_len = PAGE_CACHE_SIZE - offset; 23
page = find_lock_page ( mapping , index ); 26
if ( ! page )  27
page = page_cache_alloc_cold ( mapping ); 29
if ( unlikely ( ! page ) )  30
ret = add_to_page_cache_lru ( page , mapping , index , GFP_KERNEL ); 36
if ( unlikely ( ret ) )  38
ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ); 42
if ( unlikely ( ret ) )  43
if ( ret != AOP_TRUNCATED_PAGE )  46
if ( ret == AOP_TRUNCATED_PAGE )  49
ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ); 75
if ( ret )  76
if ( ret == AOP_TRUNCATED_PAGE )  77
return ret ; 99
------------------------------
54 /home/SySeVR/data/CVE_2008_4302_PATCHED_pipe_to_file.c this_len = PAGE_CACHE_SIZE - offset 23
static int CVE_2008_4302_PATCHED_pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
struct splice_desc *sd) 2
unsigned int offset , this_len ; 6
int ret ; 9
ret = buf -> ops -> pin ( pipe , buf ); 14
if ( unlikely ( ret ) )  15
offset = sd -> pos & ~PAGE_CACHE_MASK; 19
this_len = sd -> len; 21
if ( this_len + offset > PAGE_CACHE_SIZE )  22
this_len = PAGE_CACHE_SIZE - offset; 23
ret = mapping -> a_ops -> prepare_write ( file , page , offset , offset + this_len ); 42
if ( unlikely ( ret ) )  43
if ( ret != AOP_TRUNCATED_PAGE )  46
if ( ret == AOP_TRUNCATED_PAGE )  49
if ( sd -> pos + this_len > isize )  56
memcpy ( dst + offset , src + buf -> offset , this_len ); 69
kunmap_atomic ( dst , KM_USER1 ); 71
ret = mapping -> a_ops -> commit_write ( file , page , offset , offset + this_len ); 75
if ( ret )  76
if ( ret == AOP_TRUNCATED_PAGE )  77
if ( ret < 0 )  81
ret = this_len; 88
return ret ; 99
------------------------------
55 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c p = bss -> rates + n_basic_rates 170
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = min_t ( int , 32 , elem -> len ); 94
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
got_basic_rates = 1; 104
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
memcpy ( & bss -> countryinfo , pcountryinfo , pcountryinfo -> len + 2 ); 149
if ( ! got_basic_rates )  161
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
56 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c n_ex_rates = MAX_RATES - n_basic_rates 168
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
got_basic_rates = 1; 104
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( ! got_basic_rates )  161
n_ex_rates = elem -> len; 166
if ( n_basic_rates + n_ex_rates > MAX_RATES )  167
n_ex_rates = MAX_RATES - n_basic_rates; 168
memcpy ( p , elem -> data , n_ex_rates ); 171
pos += elem -> len + 2; 209
------------------------------
57 /home/SySeVR/data/CVE_2008_5134_PATCHED_lbs_process_bss.c end = pos + beaconsize 33
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
if ( ( end - pos ) < 12 )  43
lbs_deb_scan ( "process_bss: IE len %zd\n" , end - pos ); 79
lbs_deb_hex ( LBS_DEB_SCAN , "process_bss: IE info" , pos , end - pos ); 80
while ( pos <= end - 2 )  83
if ( pos + elem -> len > end )  86
------------------------------
58 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c p = bss -> rates + n_basic_rates 170
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_dsparamset * pDS ; 5
struct ieeetypes_ibssparamset * pibss ; 7
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
memcpy ( bss -> bssid , pos , ETH_ALEN ); 39
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
bss -> rssi = * pos; 55
pos ++; 57
pos += 8; 60
bss -> beaconperiod = get_unaligned_le16 ( pos ); 63
pos += 2; 64
bss -> capability = get_unaligned_le16 ( pos ); 67
pos += 2; 69
if ( bss -> capability & WLAN_CAPABILITY_IBSS )  73
bss -> mode = IW_MODE_ADHOC; 74
bss -> mode = IW_MODE_INFRA; 76
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
bss -> ssid_len = elem -> len; 94
memcpy ( bss -> ssid , elem -> data , elem -> len ); 95
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
memcpy ( bss -> rates , elem -> data , n_basic_rates ); 103
got_basic_rates = 1; 104
pDS = ( struct ieeetypes_dsparamset * ) pos; 116
bss -> channel = pDS -> currentchan; 117
pibss = ( struct ieeetypes_ibssparamset * ) pos; 131
bss -> atimwindow = le16_to_cpu ( pibss -> atimwindow ); 132
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( ! got_basic_rates )  161
p = bss -> rates + n_basic_rates; 170
memcpy ( p , elem -> data , n_ex_rates ); 171
if ( elem -> len >= 4 && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0xf2 && elem -> data [ 3 ] == 0x01 )  175
bss -> wpa_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 178
if ( elem -> len >= MARVELL_MESH_IE_LENGTH && elem -> data [ 0 ] == 0x00 && elem -> data [ 1 ] == 0x50 && elem -> data [ 2 ] == 0x43 && elem -> data [ 3 ] == 0x04 )  182
bss -> mesh = 1; 186
bss -> rsn_ie_len = min ( elem -> len + 2 , MAX_WPA_IE_LEN ); 197
pos += elem -> len + 2; 209
------------------------------
59 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c n_ex_rates = MAX_RATES - n_basic_rates 168
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
struct ieeetypes_countryinfoset * pcountryinfo ; 9
uint8_t * pos , * end , * p ; 10
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ; 11
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
pos += ETH_ALEN; 41
if ( ( end - pos ) < 12 )  43
pos ++; 57
pos += 8; 60
pos += 2; 64
pos += 2; 69
while ( pos <= end - 2 )  83
struct ieee80211_info_element * elem = ( void * ) pos ; 84
if ( pos + elem -> len > end )  86
switch ( elem -> id )  92
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len ); 102
got_basic_rates = 1; 104
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos; 139
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )  141
if ( ! got_basic_rates )  161
n_ex_rates = elem -> len; 166
if ( n_basic_rates + n_ex_rates > MAX_RATES )  167
n_ex_rates = MAX_RATES - n_basic_rates; 168
memcpy ( p , elem -> data , n_ex_rates ); 171
pos += elem -> len + 2; 209
------------------------------
60 /home/SySeVR/data/CVE_2008_5134_VULN_lbs_process_bss.c end = pos + beaconsize 33
static int CVE_2008_5134_VULN_lbs_process_bss(struct bss_descriptor *bss,
uint8_t **pbeaconinfo, int *bytesleft) 2
uint8_t * pos , * end , * p ; 10
uint16_t beaconsize = 0 ; 12
if ( * bytesleft >= sizeof ( beaconsize ) )  17
beaconsize = get_unaligned_le16 ( * pbeaconinfo ); 19
* bytesleft -= sizeof ( beaconsize ); 20
* pbeaconinfo += sizeof ( beaconsize ); 21
if ( beaconsize == 0 || beaconsize > * bytesleft )  24
pos = * pbeaconinfo; 32
end = pos + beaconsize; 33
if ( ( end - pos ) < 12 )  43
lbs_deb_scan ( "process_bss: IE len %zd\n" , end - pos ); 79
lbs_deb_hex ( LBS_DEB_SCAN , "process_bss: IE info" , pos , end - pos ); 80
while ( pos <= end - 2 )  83
if ( pos + elem -> len > end )  86
------------------------------
61 /home/SySeVR/data/CVE_2009_0946_PATCHED_tt_cmap8_validate.c count = ( FT_UInt32 ) ( end - start + 1 ) 49
CVE_2009_0946_PATCHED_tt_cmap8_validate( FT_Byte*      table,
FT_Validator  valid ) 2
FT_Byte * is32 ; 5
FT_UInt32 num_groups ; 7
is32 = table + 12; 17
p = is32 + 8192; 18
num_groups = TT_NEXT_ULONG ( p ); 19
for ( n = 0; n < num_groups; n++ ) 29
start = TT_NEXT_ULONG ( p ); 34
end = TT_NEXT_ULONG ( p ); 35
if ( valid -> level >= FT_VALIDATE_TIGHT )  44
count = ( FT_UInt32 ) ( end - start + 1 ); 49
for ( ; count > 0; count--, start++ ) 55
hi = ( FT_UInt ) ( start >> 16 ); 57
lo = ( FT_UInt ) ( start & 0xFFFFU ); 58
if ( ( is32 [ hi >> 3 ] & ( 0x80 >> ( hi & 7 ) ) ) == 0 )  60
if ( ( is32 [ lo >> 3 ] & ( 0x80 >> ( lo & 7 ) ) ) == 0 )  63
for ( ; count > 0; count--, start++ ) 76
lo = ( FT_UInt ) ( start & 0xFFFFU ); 78
if ( ( is32 [ lo >> 3 ] & ( 0x80 >> ( lo & 7 ) ) ) != 0 )  80
------------------------------
62 /home/SySeVR/data/CVE_2009_0946_VULN_cff_charset_load.c charset -> offset = base_offset + offset 21
static FT_Error
CVE_2009_0946_VULN_cff_charset_load( CFF_Charset  charset,
FT_UInt      num_glyphs,
FT_Stream    stream,
FT_ULong     base_offset,
FT_ULong     offset,
FT_Bool      invert ) 7
if ( offset > 2 )  16
charset -> offset = base_offset + offset; 21
if ( FT_STREAM_SEEK ( charset -> offset ) || FT_READ_BYTE ( charset -> format ) )  24
if ( FT_NEW_ARRAY ( charset -> sids , num_glyphs ) )  29
charset -> sids [ 0 ] = 0; 33
switch ( charset -> format )  35
charset -> sids [ j ] = FT_GET_USHORT ( ); 44
while ( j < num_glyphs )  59
if ( FT_READ_USHORT ( glyph_sid ) )  62
if ( charset -> format == 2 )  66
for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ ) 78
charset -> sids [ j ] = glyph_sid; 79
FT_FREE ( charset -> sids ); 172
FT_FREE ( charset -> cids ); 173
------------------------------
63 /home/SySeVR/data/CVE_2009_0946_VULN_ft_smooth_render_generic.c height = ( FT_UInt ) ( ( cbox . yMax - cbox . yMin ) >> 6 ) 47
static FT_Error
CVE_2009_0946_VULN_ft_smooth_render_generic( FT_Renderer       render,
FT_GlyphSlot      slot,
FT_Render_Mode    mode,
const FT_Vector*  origin,
FT_Render_Mode    required_mode ) 6
FT_BBox cbox ; 10
FT_UInt width , height , height_org , width_org , pitch ; 11
if ( slot -> format != render -> glyph_format )  22
if ( mode != required_mode )  29
cbox . xMin = FT_PIX_FLOOR ( cbox . xMin ); 41
cbox . yMin = FT_PIX_FLOOR ( cbox . yMin ); 42
cbox . xMax = FT_PIX_CEIL ( cbox . xMax ); 43
cbox . yMax = FT_PIX_CEIL ( cbox . yMax ); 44
height = ( FT_UInt ) ( ( cbox . yMax - cbox . yMin ) >> 6 ); 47
height_org = height; 52
height *= 3; 70
height += 3 * extra; 95
bitmap -> rows = height; 105
bitmap -> pitch = pitch; 106
if ( FT_ALLOC ( bitmap -> buffer , ( FT_ULong ) pitch * height ) )  111
------------------------------
64 /home/SySeVR/data/CVE_2009_0946_VULN_ft_smooth_render_generic.c width = ( FT_UInt ) ( ( cbox . xMax - cbox . xMin ) >> 6 ) 46
static FT_Error
CVE_2009_0946_VULN_ft_smooth_render_generic( FT_Renderer       render,
FT_GlyphSlot      slot,
FT_Render_Mode    mode,
const FT_Vector*  origin,
FT_Render_Mode    required_mode ) 6
FT_BBox cbox ; 10
FT_UInt width , height , height_org , width_org , pitch ; 11
if ( slot -> format != render -> glyph_format )  22
if ( mode != required_mode )  29
cbox . xMin = FT_PIX_FLOOR ( cbox . xMin ); 41
cbox . yMin = FT_PIX_FLOOR ( cbox . yMin ); 42
cbox . xMax = FT_PIX_CEIL ( cbox . xMax ); 43
cbox . yMax = FT_PIX_CEIL ( cbox . yMax ); 44
width = ( FT_UInt ) ( ( cbox . xMax - cbox . xMin ) >> 6 ); 46
width_org = width; 51
pitch = width; 62
width = width * 3; 65
pitch = FT_PAD_CEIL ( width , 4 ); 66
width += 3 * extra; 87
pitch = FT_PAD_CEIL ( width , 4 ); 88
bitmap -> width = width; 104
bitmap -> rows = height; 105
bitmap -> pitch = pitch; 106
if ( FT_ALLOC ( bitmap -> buffer , ( FT_ULong ) pitch * height ) )  111
------------------------------
65 /home/SySeVR/data/CVE_2009_1298_PATCHED_ip_frag_reasm.c clone -> len = clone -> data_len = head -> data_len - plen 60
static int CVE_2009_1298_PATCHED_ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
struct net_device *dev) 2
struct sk_buff * fp , * head = qp -> q . fragments ; 6
int len ; 7
int ihlen ; 8
if ( prev )  14
head = prev -> next; 15
fp = skb_clone ( head , GFP_ATOMIC ); 16
if ( ! fp )  17
head -> next = qp -> q . fragments -> next; 24
qp -> q . fragments = head; 27
ihlen = ip_hdrlen ( head ); 34
len = ihlen + qp -> q . len; 35
if ( len > 65535 )  38
if ( skb_cloned ( head ) && pskb_expand_head ( head , 0 , 0 , GFP_ATOMIC ) )  42
if ( skb_shinfo ( head ) -> frag_list )  48
struct sk_buff * clone ; 49
int i , plen = 0 ; 50
if ( ( clone = alloc_skb ( 0 , GFP_ATOMIC ) ) == NULL )  52
clone -> next = head -> next; 54
head -> next = clone; 55
skb_shinfo ( clone ) -> frag_list = skb_shinfo ( head ) -> frag_list; 56
skb_shinfo ( head ) -> frag_list = NULL; 57
for (i=0; i<skb_shinfo(head)->nr_frags; i++) 58
plen += skb_shinfo ( head ) -> frags [ i ] . size; 59
clone -> len = clone -> data_len = head -> data_len - plen; 60
head -> data_len -= clone -> len; 61
head -> len -= clone -> len; 62
clone -> csum = 0; 63
clone -> ip_summed = head -> ip_summed; 64
atomic_add ( clone -> truesize , & qp -> q . net -> mem ); 65
skb_shinfo ( head ) -> frag_list = head -> next; 68
skb_push ( head , head -> data - skb_network_header ( head ) ); 69
atomic_sub ( head -> truesize , & qp -> q . net -> mem ); 70
for (fp=head->next; fp; fp = fp->next) 72
head -> data_len += fp -> len; 73
head -> len += fp -> len; 74
if ( head -> ip_summed != fp -> ip_summed )  75
head -> ip_summed = CHECKSUM_NONE; 76
if ( head -> ip_summed == CHECKSUM_COMPLETE )  77
head -> csum = csum_add ( head -> csum , fp -> csum ); 78
head -> truesize += fp -> truesize; 79
atomic_sub ( fp -> truesize , & qp -> q . net -> mem ); 80
head -> next = NULL; 83
head -> dev = dev; 84
head -> tstamp = qp -> q . stamp; 85
iph = ip_hdr ( head ); 87
iph -> frag_off = 0; 88
iph -> tot_len = htons ( len ); 89
------------------------------
66 /home/SySeVR/data/CVE_2009_1298_PATCHED_ip_frag_reasm.c len = ihlen + qp -> q . len 35
static int CVE_2009_1298_PATCHED_ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
struct net_device *dev) 2
struct sk_buff * fp , * head = qp -> q . fragments ; 6
int len ; 7
int ihlen ; 8
if ( prev )  14
head = prev -> next; 15
fp = skb_clone ( head , GFP_ATOMIC ); 16
if ( ! fp )  17
head -> next = qp -> q . fragments -> next; 24
qp -> q . fragments = head; 27
ihlen = ip_hdrlen ( head ); 34
len = ihlen + qp -> q . len; 35
if ( len > 65535 )  38
iph -> tot_len = htons ( len ); 89
------------------------------
67 /home/SySeVR/data/CVE_2009_1298_VULN_ip_frag_reasm.c clone -> len = clone -> data_len = head -> data_len - plen 60
static int CVE_2009_1298_VULN_ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
struct net_device *dev) 2
struct sk_buff * fp , * head = qp -> q . fragments ; 6
int len ; 7
int ihlen ; 8
if ( prev )  14
head = prev -> next; 15
fp = skb_clone ( head , GFP_ATOMIC ); 16
if ( ! fp )  17
head -> next = qp -> q . fragments -> next; 24
qp -> q . fragments = head; 27
ihlen = ip_hdrlen ( head ); 34
len = ihlen + qp -> q . len; 35
if ( len > 65535 )  38
if ( skb_cloned ( head ) && pskb_expand_head ( head , 0 , 0 , GFP_ATOMIC ) )  42
if ( skb_shinfo ( head ) -> frag_list )  48
struct sk_buff * clone ; 49
int i , plen = 0 ; 50
if ( ( clone = alloc_skb ( 0 , GFP_ATOMIC ) ) == NULL )  52
clone -> next = head -> next; 54
head -> next = clone; 55
skb_shinfo ( clone ) -> frag_list = skb_shinfo ( head ) -> frag_list; 56
skb_shinfo ( head ) -> frag_list = NULL; 57
for (i=0; i<skb_shinfo(head)->nr_frags; i++) 58
plen += skb_shinfo ( head ) -> frags [ i ] . size; 59
clone -> len = clone -> data_len = head -> data_len - plen; 60
head -> data_len -= clone -> len; 61
head -> len -= clone -> len; 62
clone -> csum = 0; 63
clone -> ip_summed = head -> ip_summed; 64
atomic_add ( clone -> truesize , & qp -> q . net -> mem ); 65
skb_shinfo ( head ) -> frag_list = head -> next; 68
skb_push ( head , head -> data - skb_network_header ( head ) ); 69
atomic_sub ( head -> truesize , & qp -> q . net -> mem ); 70
for (fp=head->next; fp; fp = fp->next) 72
head -> data_len += fp -> len; 73
head -> len += fp -> len; 74
if ( head -> ip_summed != fp -> ip_summed )  75
head -> ip_summed = CHECKSUM_NONE; 76
if ( head -> ip_summed == CHECKSUM_COMPLETE )  77
head -> csum = csum_add ( head -> csum , fp -> csum ); 78
head -> truesize += fp -> truesize; 79
atomic_sub ( fp -> truesize , & qp -> q . net -> mem ); 80
head -> next = NULL; 83
head -> dev = dev; 84
head -> tstamp = qp -> q . stamp; 85
iph = ip_hdr ( head ); 87
iph -> frag_off = 0; 88
iph -> tot_len = htons ( len ); 89
------------------------------
68 /home/SySeVR/data/CVE_2009_1298_VULN_ip_frag_reasm.c len = ihlen + qp -> q . len 35
static int CVE_2009_1298_VULN_ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
struct net_device *dev) 2
struct sk_buff * fp , * head = qp -> q . fragments ; 6
int len ; 7
int ihlen ; 8
if ( prev )  14
head = prev -> next; 15
fp = skb_clone ( head , GFP_ATOMIC ); 16
if ( ! fp )  17
head -> next = qp -> q . fragments -> next; 24
qp -> q . fragments = head; 27
ihlen = ip_hdrlen ( head ); 34
len = ihlen + qp -> q . len; 35
if ( len > 65535 )  38
iph -> tot_len = htons ( len ); 89
------------------------------
69 /home/SySeVR/data/CVE_2009_1336_PATCHED_nfs_init_server.c server -> acdirmax = data -> acdirmax * HZ 37
static int CVE_2009_1336_PATCHED_nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data) 1
struct nfs_client * clp ; 3
int error , nfsvers = 2 ; 4
if ( data -> flags & NFS_MOUNT_VER3 )  9
nfsvers = 3; 10
clp = nfs_get_client ( data -> hostname , & data -> addr , nfsvers ); 14
if ( IS_ERR ( clp ) )  15
error = nfs_init_client ( clp , data ); 20
if ( error < 0 )  21
server -> nfs_client = clp; 24
server -> flags = data -> flags & NFS_MOUNT_FLAGMASK; 27
if ( data -> rsize )  29
server -> rsize = nfs_block_size ( data -> rsize , NULL ); 30
if ( data -> wsize )  31
server -> wsize = nfs_block_size ( data -> wsize , NULL ); 32
server -> acregmin = data -> acregmin * HZ; 34
server -> acregmax = data -> acregmax * HZ; 35
server -> acdirmin = data -> acdirmin * HZ; 36
server -> acdirmax = data -> acdirmax * HZ; 37
error = nfs_start_lockd ( server ); 40
if ( error < 0 )  41
error = nfs_init_server_rpcclient ( server , data -> pseudoflavor ); 44
if ( error < 0 )  45
server -> namelen = data -> namlen; 48
nfs_init_server_aclclient ( server ); 50
dprintk ( "<-- CVE_2009_1336_PATCHED_nfs_init_server() = xerror %d\n" , error ); 57
return error ; 58
------------------------------
70 /home/SySeVR/data/CVE_2009_1336_PATCHED_nfs_init_server.c server -> acdirmin = data -> acdirmin * HZ 36
static int CVE_2009_1336_PATCHED_nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data) 1
struct nfs_client * clp ; 3
int error , nfsvers = 2 ; 4
if ( data -> flags & NFS_MOUNT_VER3 )  9
nfsvers = 3; 10
clp = nfs_get_client ( data -> hostname , & data -> addr , nfsvers ); 14
if ( IS_ERR ( clp ) )  15
error = nfs_init_client ( clp , data ); 20
if ( error < 0 )  21
server -> nfs_client = clp; 24
server -> flags = data -> flags & NFS_MOUNT_FLAGMASK; 27
if ( data -> rsize )  29
server -> rsize = nfs_block_size ( data -> rsize , NULL ); 30
if ( data -> wsize )  31
server -> wsize = nfs_block_size ( data -> wsize , NULL ); 32
server -> acregmin = data -> acregmin * HZ; 34
server -> acregmax = data -> acregmax * HZ; 35
server -> acdirmin = data -> acdirmin * HZ; 36
server -> acdirmax = data -> acdirmax * HZ; 37
error = nfs_start_lockd ( server ); 40
if ( error < 0 )  41
error = nfs_init_server_rpcclient ( server , data -> pseudoflavor ); 44
if ( error < 0 )  45
server -> namelen = data -> namlen; 48
nfs_init_server_aclclient ( server ); 50
dprintk ( "<-- CVE_2009_1336_PATCHED_nfs_init_server() = xerror %d\n" , error ); 57
return error ; 58
------------------------------
71 /home/SySeVR/data/CVE_2009_1336_PATCHED_nfs_init_server.c server -> acregmax = data -> acregmax * HZ 35
static int CVE_2009_1336_PATCHED_nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data) 1
struct nfs_client * clp ; 3
int error , nfsvers = 2 ; 4
if ( data -> flags & NFS_MOUNT_VER3 )  9
nfsvers = 3; 10
clp = nfs_get_client ( data -> hostname , & data -> addr , nfsvers ); 14
if ( IS_ERR ( clp ) )  15
error = nfs_init_client ( clp , data ); 20
if ( error < 0 )  21
server -> nfs_client = clp; 24
server -> flags = data -> flags & NFS_MOUNT_FLAGMASK; 27
if ( data -> rsize )  29
server -> rsize = nfs_block_size ( data -> rsize , NULL ); 30
if ( data -> wsize )  31
server -> wsize = nfs_block_size ( data -> wsize , NULL ); 32
server -> acregmin = data -> acregmin * HZ; 34
server -> acregmax = data -> acregmax * HZ; 35
server -> acdirmin = data -> acdirmin * HZ; 36
server -> acdirmax = data -> acdirmax * HZ; 37
error = nfs_start_lockd ( server ); 40
if ( error < 0 )  41
error = nfs_init_server_rpcclient ( server , data -> pseudoflavor ); 44
if ( error < 0 )  45
server -> namelen = data -> namlen; 48
nfs_init_server_aclclient ( server ); 50
dprintk ( "<-- CVE_2009_1336_PATCHED_nfs_init_server() = xerror %d\n" , error ); 57
return error ; 58
------------------------------
72 /home/SySeVR/data/CVE_2009_1336_PATCHED_nfs_init_server.c server -> acregmin = data -> acregmin * HZ 34
static int CVE_2009_1336_PATCHED_nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data) 1
struct nfs_client * clp ; 3
int error , nfsvers = 2 ; 4
if ( data -> flags & NFS_MOUNT_VER3 )  9
nfsvers = 3; 10
clp = nfs_get_client ( data -> hostname , & data -> addr , nfsvers ); 14
if ( IS_ERR ( clp ) )  15
error = nfs_init_client ( clp , data ); 20
if ( error < 0 )  21
server -> nfs_client = clp; 24
server -> flags = data -> flags & NFS_MOUNT_FLAGMASK; 27
if ( data -> rsize )  29
server -> rsize = nfs_block_size ( data -> rsize , NULL ); 30
if ( data -> wsize )  31
server -> wsize = nfs_block_size ( data -> wsize , NULL ); 32
server -> acregmin = data -> acregmin * HZ; 34
server -> acregmax = data -> acregmax * HZ; 35
server -> acdirmin = data -> acdirmin * HZ; 36
server -> acdirmax = data -> acdirmax * HZ; 37
error = nfs_start_lockd ( server ); 40
if ( error < 0 )  41
error = nfs_init_server_rpcclient ( server , data -> pseudoflavor ); 44
if ( error < 0 )  45
server -> namelen = data -> namlen; 48
nfs_init_server_aclclient ( server ); 50
dprintk ( "<-- CVE_2009_1336_PATCHED_nfs_init_server() = xerror %d\n" , error ); 57
return error ; 58
------------------------------
73 /home/SySeVR/data/CVE_2009_1385_PATCHED_e1000_clean_rx_irq.c last_byte = * ( skb -> data + length - 1 ) 62
static bool CVE_2009_1385_PATCHED_e1000_clean_rx_irq(struct e1000_adapter *adapter,
struct e1000_rx_ring *rx_ring,
int *work_done, int work_to_do) 3
struct e1000_hw * hw = & adapter -> hw ; 5
struct net_device * netdev = adapter -> netdev ; 6
struct e1000_rx_desc * rx_desc , * next_rxd ; 8
struct e1000_buffer * buffer_info , * next_buffer ; 9
u32 length ; 11
u8 last_byte ; 12
unsigned int i ; 13
i = rx_ring -> next_to_clean; 18
rx_desc = E1000_RX_DESC ( * rx_ring , i ); 19
buffer_info = & rx_ring -> buffer_info [ i ]; 20
while ( rx_desc -> status & E1000_RXD_STAT_DD )  22
struct sk_buff * skb ; 23
u8 status ; 24
if ( * work_done >= work_to_do )  26
( * work_done ) ++; 28
status = rx_desc -> status; 30
skb = buffer_info -> skb; 31
buffer_info -> skb = NULL; 32
if ( ++ i == rx_ring -> count )  36
i = 0; 36
next_rxd = E1000_RX_DESC ( * rx_ring , i ); 37
next_buffer = & rx_ring -> buffer_info [ i ]; 40
length = le16_to_cpu ( rx_desc -> length ); 49
if ( unlikely ( ! ( status & E1000_RXD_STAT_EOP ) || ( length <= 4 ) ) )  52
buffer_info -> skb = skb; 57
if ( unlikely ( rx_desc -> errors & E1000_RXD_ERR_FRAME_ERR_MASK ) )  61
last_byte = * ( skb -> data + length - 1 ); 62
if ( TBI_ACCEPT ( hw , status , rx_desc -> errors , length , last_byte ) )  63
length --; 70
buffer_info -> skb = skb; 73
length -= 4; 80
if ( length < copybreak )  89
struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 90
if ( new_skb )  92
buffer_info -> skb = skb; 101
skb = new_skb; 102
skb -> protocol = eth_type_trans ( skb , netdev ); 115
rx_desc -> status = 0; 126
rx_desc = next_rxd; 135
buffer_info = next_buffer; 136
------------------------------
74 /home/SySeVR/data/CVE_2009_1385_VULN_e1000_clean_rx_irq.c last_byte = * ( skb -> data + length - 1 ) 61
static bool CVE_2009_1385_VULN_e1000_clean_rx_irq(struct e1000_adapter *adapter,
struct e1000_rx_ring *rx_ring,
int *work_done, int work_to_do) 3
struct e1000_hw * hw = & adapter -> hw ; 5
struct net_device * netdev = adapter -> netdev ; 6
struct e1000_rx_desc * rx_desc , * next_rxd ; 8
struct e1000_buffer * buffer_info , * next_buffer ; 9
u32 length ; 11
u8 last_byte ; 12
unsigned int i ; 13
i = rx_ring -> next_to_clean; 18
rx_desc = E1000_RX_DESC ( * rx_ring , i ); 19
buffer_info = & rx_ring -> buffer_info [ i ]; 20
while ( rx_desc -> status & E1000_RXD_STAT_DD )  22
struct sk_buff * skb ; 23
u8 status ; 24
if ( * work_done >= work_to_do )  26
( * work_done ) ++; 28
status = rx_desc -> status; 30
skb = buffer_info -> skb; 31
buffer_info -> skb = NULL; 32
if ( ++ i == rx_ring -> count )  36
i = 0; 36
next_rxd = E1000_RX_DESC ( * rx_ring , i ); 37
next_buffer = & rx_ring -> buffer_info [ i ]; 40
length = le16_to_cpu ( rx_desc -> length ); 49
if ( unlikely ( ! ( status & E1000_RXD_STAT_EOP ) ) )  51
buffer_info -> skb = skb; 56
if ( unlikely ( rx_desc -> errors & E1000_RXD_ERR_FRAME_ERR_MASK ) )  60
last_byte = * ( skb -> data + length - 1 ); 61
if ( TBI_ACCEPT ( hw , status , rx_desc -> errors , length , last_byte ) )  62
length --; 69
buffer_info -> skb = skb; 72
length -= 4; 79
if ( length < copybreak )  88
struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 89
if ( new_skb )  91
buffer_info -> skb = skb; 100
skb = new_skb; 101
skb -> protocol = eth_type_trans ( skb , netdev ); 114
rx_desc -> status = 0; 125
rx_desc = next_rxd; 134
buffer_info = next_buffer; 135
------------------------------
75 /home/SySeVR/data/CVE_2009_2846_PATCHED_eisa_eeprom_read.c count = * ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - * ppos 11
static ssize_t CVE_2009_2846_PATCHED_eisa_eeprom_read(struct file * file,
char __user *buf, size_t count, loff_t *ppos ) 2
if ( * ppos < 0 || * ppos >= HPEE_MAX_LENGTH )  8
count = * ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - * ppos; 11
tmp = kmalloc ( count , GFP_KERNEL ); 12
if ( tmp )  13
for (i = 0; i < count; i++) 14
tmp [ i ] = readb ( eisa_eeprom_addr + ( * ppos ) ++ ); 15
if ( copy_to_user ( buf , tmp , count ) )  17
ret = count; 20
kfree ( tmp ); 21
return ret ; 25
------------------------------
76 /home/SySeVR/data/CVE_2009_2909_PATCHED_ax25_setsockopt.c ax25 -> t3 = opt * HZ 68
static int CVE_2009_2909_PATCHED_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < ( int ) sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  64
ax25 -> t3 = opt * HZ; 68
------------------------------
77 /home/SySeVR/data/CVE_2009_2909_PATCHED_ax25_setsockopt.c ax25 -> t2 = opt * HZ 52
static int CVE_2009_2909_PATCHED_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < ( int ) sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  48
ax25 -> t2 = opt * HZ; 52
------------------------------
78 /home/SySeVR/data/CVE_2009_2909_PATCHED_ax25_setsockopt.c ax25 -> t1 = opt * HZ 44
static int CVE_2009_2909_PATCHED_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < ( int ) sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  39
ax25 -> rtt = ( opt * HZ ) >> 1; 43
ax25 -> t1 = opt * HZ; 44
------------------------------
79 /home/SySeVR/data/CVE_2009_2909_PATCHED_ax25_setsockopt.c ax25 -> rtt = ( opt * HZ ) >> 1 43
static int CVE_2009_2909_PATCHED_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < ( int ) sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  39
ax25 -> rtt = ( opt * HZ ) >> 1; 43
ax25 -> t1 = opt * HZ; 44
------------------------------
80 /home/SySeVR/data/CVE_2009_2909_VULN_ax25_setsockopt.c ax25 -> t3 = opt * HZ 68
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  64
ax25 -> t3 = opt * HZ; 68
------------------------------
81 /home/SySeVR/data/CVE_2009_2909_VULN_ax25_setsockopt.c ax25 -> t2 = opt * HZ 52
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  48
ax25 -> t2 = opt * HZ; 52
------------------------------
82 /home/SySeVR/data/CVE_2009_2909_VULN_ax25_setsockopt.c ax25 -> t1 = opt * HZ 44
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  39
ax25 -> rtt = ( opt * HZ ) >> 1; 43
ax25 -> t1 = opt * HZ; 44
------------------------------
83 /home/SySeVR/data/CVE_2009_2909_VULN_ax25_setsockopt.c ax25 -> rtt = ( opt * HZ ) >> 1 43
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
struct sock * sk = sock -> sk ; 4
ax25_cb * ax25 ; 5
int opt , res = 0 ; 8
if ( level != SOL_AX25 )  10
if ( optlen < sizeof ( int ) )  13
if ( get_user ( opt , ( int __user * ) optval ) )  16
ax25 = ax25_sk ( sk ); 20
switch ( optname )  22
if ( opt < 1 )  39
ax25 -> rtt = ( opt * HZ ) >> 1; 43
ax25 -> t1 = opt * HZ; 44
------------------------------
84 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c vma -> vm_end = region -> vm_end = addr + len 159
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
struct rb_node * rb ; 10
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
region -> vm_flags = vm_flags; 42
region -> vm_pgoff = pgoff; 43
if ( file )  49
region -> vm_file = file; 50
if ( vm_flags & VM_MAYSHARE )  70
struct vm_region * pregion ; 71
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb)) 77
pregion = rb_entry ( rb , struct vm_region , vm_rb ) 78
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )  80
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )  84
if ( pregion -> vm_pgoff >= pgend )  88
rpglen = pregion -> vm_end - pregion -> vm_start; 91
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 92
rpgend = pregion -> vm_pgoff + rpglen; 93
if ( pgoff >= rpgend )  94
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )  102
if ( file && file -> f_op -> get_unmapped_area )  141
addr = file -> f_op -> get_unmapped_area ( file , addr , len , pgoff , flags ); 142
if ( IS_ERR ( ( void * ) addr ) )  144
vma -> vm_start = region -> vm_start = addr; 158
vma -> vm_end = region -> vm_end = addr + len; 159
vma -> vm_region = region; 164
add_nommu_region ( region ); 165
if ( file && vma -> vm_flags & VM_SHARED )  168
ret = do_mmap_shared_file ( vma ); 169
ret = do_mmap_private ( vma , region , len ); 171
if ( ret < 0 )  172
result = vma -> vm_start; 176
add_vma_to_mm ( current -> mm , vma ); 181
flush_icache_range ( result , result + len ); 186
kleave ( " = %lx" , result ); 188
return result ; 189
__put_nommu_region ( region ); 192
if ( vma )  193
if ( vma -> vm_file )  194
fput ( vma -> vm_file ); 195
if ( vma -> vm_flags & VM_EXECUTABLE )  196
removed_exe_file_vma ( vma -> vm_mm ); 197
kmem_cache_free ( vm_area_cachep , vma ); 199
kleave ( " = %d [pr]" , ret ); 201
return ret ; 202
------------------------------
85 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c vma -> vm_end = start + len 113
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
struct rb_node * rb ; 10
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
vma -> vm_flags = vm_flags; 46
vma -> vm_pgoff = pgoff; 47
if ( file )  49
vma -> vm_file = file; 52
if ( vm_flags & VM_EXECUTABLE )  54
vma -> vm_mm = current -> mm; 56
if ( vm_flags & VM_MAYSHARE )  70
struct vm_region * pregion ; 71
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb)) 77
pregion = rb_entry ( rb , struct vm_region , vm_rb ) 78
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )  80
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )  84
if ( pregion -> vm_pgoff >= pgend )  88
rpglen = pregion -> vm_end - pregion -> vm_start; 91
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 92
rpgend = pregion -> vm_pgoff + rpglen; 93
if ( pgoff >= rpgend )  94
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )  102
vma -> vm_region = pregion; 109
start = pregion -> vm_start; 110
start += ( pgoff - pregion -> vm_pgoff ) << PAGE_SHIFT; 111
vma -> vm_start = start; 112
vma -> vm_end = start + len; 113
vma -> vm_flags |= VM_MAPPED_COPY; 117
------------------------------
86 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c rpgend = pregion -> vm_pgoff + rpglen 93
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
struct rb_node * rb ; 10
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
if ( vm_flags & VM_MAYSHARE )  70
struct vm_region * pregion ; 71
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb)) 77
pregion = rb_entry ( rb , struct vm_region , vm_rb ) 78
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )  80
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )  84
if ( pregion -> vm_pgoff >= pgend )  88
rpglen = pregion -> vm_end - pregion -> vm_start; 91
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 92
rpgend = pregion -> vm_pgoff + rpglen; 93
if ( pgoff >= rpgend )  94
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )  102
------------------------------
87 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT 92
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
struct rb_node * rb ; 10
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
if ( vm_flags & VM_MAYSHARE )  70
struct vm_region * pregion ; 71
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb)) 77
pregion = rb_entry ( rb , struct vm_region , vm_rb ) 78
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )  80
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )  84
if ( pregion -> vm_pgoff >= pgend )  88
rpglen = pregion -> vm_end - pregion -> vm_start; 91
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 92
rpgend = pregion -> vm_pgoff + rpglen; 93
if ( pgoff >= rpgend )  94
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )  102
------------------------------
88 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c rpglen = pregion -> vm_end - pregion -> vm_start 91
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
struct rb_node * rb ; 10
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
if ( vm_flags & VM_MAYSHARE )  70
struct vm_region * pregion ; 71
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb)) 77
pregion = rb_entry ( rb , struct vm_region , vm_rb ) 78
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )  80
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )  84
if ( pregion -> vm_pgoff >= pgend )  88
rpglen = pregion -> vm_end - pregion -> vm_start; 91
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 92
rpgend = pregion -> vm_pgoff + rpglen; 93
if ( pgoff >= rpgend )  94
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )  102
------------------------------
89 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c pgend = pgoff + pglen 75
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
if ( vm_flags & VM_MAYSHARE )  70
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
if ( pregion -> vm_pgoff >= pgend )  88
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
------------------------------
90 /home/SySeVR/data/CVE_2009_3888_PATCHED_do_mmap_pgoff.c pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT 74
unsigned long CVE_2009_3888_PATCHED_do_mmap_pgoff(struct file *file,
unsigned long addr,
unsigned long len,
unsigned long prot,
unsigned long flags,
unsigned long pgoff) 6
struct vm_area_struct * vma ; 8
struct vm_region * region ; 9
unsigned long capabilities , vm_flags , result ; 11
int ret ; 12
if ( ! ( flags & MAP_FIXED ) )  16
addr = round_hint_to_min ( addr ); 17
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities ); 21
if ( ret < 0 )  23
vm_flags = determine_vm_flags ( file , prot , flags , capabilities ); 30
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL ); 33
if ( ! region )  34
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL ); 37
if ( ! vma )  38
if ( vm_flags & VM_MAYSHARE )  70
unsigned long pglen , rpglen , pgend , rpgend , start ; 72
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 74
pgend = pgoff + pglen; 75
if ( pregion -> vm_pgoff >= pgend )  88
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )  99
------------------------------
91 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c offset = ( offset + length ) & ~PAGE_MASK 62
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d , * pd ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
if ( offset == 0 )  64
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
92 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c pd -> data_address = cpu_to_le32 ( page_bus + offset ) 60
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d , * pd ; 7
struct fw_iso_packet * p = packet ; 8
dma_addr_t d_bus , page_bus ; 9
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
page = payload >> PAGE_SHIFT; 23
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
if ( p -> skip && i == 0 )  37
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
page_bus = page_private ( buffer -> pages [ page ] ); 59
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
if ( offset == 0 )  64
page ++; 65
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
------------------------------
93 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c length = PAGE_SIZE - offset 54
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d , * pd ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
if ( offset == 0 )  64
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
94 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ) 42
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d , * pd ; 7
struct fw_iso_packet * p = packet ; 8
dma_addr_t d_bus , page_bus ; 9
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
if ( p -> skip && i == 0 )  37
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
95 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ) 30
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d , * pd ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
96 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1 29
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d , * pd ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
97 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c payload_per_buffer = p -> payload_length / packet_count 25
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct fw_iso_packet * p = packet ; 8
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
payload_per_buffer = p -> payload_length / packet_count; 25
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
if ( offset == 0 )  64
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
98 /home/SySeVR/data/CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer.c packet_count = p -> header_length / ctx -> base . header_size 18
static int CVE_2009_4138_PATCHED_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct fw_iso_packet * p = packet ; 8
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
pd = d; 45
for (j = 1; j < z; j++) 46
pd ++; 47
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 48
if ( offset + rest < PAGE_SIZE )  51
length = rest; 52
length = PAGE_SIZE - offset; 54
pd -> req_count = cpu_to_le16 ( length ); 55
pd -> res_count = pd -> req_count; 56
pd -> transfer_status = 0; 57
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 60
offset = ( offset + length ) & ~PAGE_MASK; 62
rest -= length; 63
if ( offset == 0 )  64
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 67
if ( p -> interrupt && i == packet_count - 1 )  70
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 71
context_append ( & ctx -> context , d , z , header_z ); 73
------------------------------
99 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c offset = ( offset + length ) & ~PAGE_MASK 61
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
if ( offset == 0 )  63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
100 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c pd -> data_address = cpu_to_le32 ( page_bus + offset ) 59
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
dma_addr_t d_bus , page_bus ; 9
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
page = payload >> PAGE_SHIFT; 23
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
if ( p -> skip && i == 0 )  37
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
page_bus = page_private ( buffer -> pages [ page ] ); 58
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
if ( offset == 0 )  63
page ++; 64
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
------------------------------
101 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c length = PAGE_SIZE - offset 53
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
if ( offset == 0 )  63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
102 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c pd = d + j 46
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
dma_addr_t d_bus , page_bus ; 9
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
if ( p -> skip && i == 0 )  37
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
------------------------------
103 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ) 42
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
dma_addr_t d_bus , page_bus ; 9
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
if ( p -> skip && i == 0 )  37
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
104 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ) 30
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
105 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1 29
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct descriptor * d = NULL , * pd = NULL ; 7
struct fw_iso_packet * p = packet ; 8
u32 z , header_z , rest ; 10
int i , j , length ; 11
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
header_size = max ( ctx -> base . header_size , ( size_t ) 8 ); 19
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) ); 22
offset = payload & ~PAGE_MASK; 24
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
106 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c payload_per_buffer = p -> payload_length / packet_count 25
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct fw_iso_packet * p = packet ; 8
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
payload_per_buffer = p -> payload_length / packet_count; 25
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
if ( offset == 0 )  63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
107 /home/SySeVR/data/CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer.c packet_count = p -> header_length / ctx -> base . header_size 18
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,
struct fw_iso_packet *packet,
struct fw_iso_buffer *buffer,
unsigned long payload) 4
struct iso_context * ctx = container_of ( base , struct iso_context , base ) 6
struct fw_iso_packet * p = packet ; 8
int page , offset , packet_count , header_size , payload_per_buffer ; 12
packet_count = p -> header_length / ctx -> base . header_size; 18
payload_per_buffer = p -> payload_length / packet_count; 25
for (i = 0; i < packet_count; i++) 27
z = DIV_ROUND_UP ( payload_per_buffer + offset , PAGE_SIZE ) + 1; 29
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ); 30
if ( d == NULL )  32
d -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 35
d -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT ); 38
d -> req_count = cpu_to_le16 ( header_size ); 39
d -> res_count = d -> req_count; 40
d -> transfer_status = 0; 41
d -> data_address = cpu_to_le32 ( d_bus + ( z * sizeof ( * d ) ) ); 42
rest = payload_per_buffer; 44
for (j = 1; j < z; j++) 45
pd = d + j; 46
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_MORE ); 47
if ( offset + rest < PAGE_SIZE )  50
length = rest; 51
length = PAGE_SIZE - offset; 53
pd -> req_count = cpu_to_le16 ( length ); 54
pd -> res_count = pd -> req_count; 55
pd -> transfer_status = 0; 56
pd -> data_address = cpu_to_le32 ( page_bus + offset ); 59
offset = ( offset + length ) & ~PAGE_MASK; 61
rest -= length; 62
if ( offset == 0 )  63
pd -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_INPUT_LAST | DESCRIPTOR_BRANCH_ALWAYS ); 66
if ( p -> interrupt && i == packet_count - 1 )  69
pd -> control |= cpu_to_le16 ( DESCRIPTOR_IRQ_ALWAYS ); 70
context_append ( & ctx -> context , d , z , header_z ); 72
------------------------------
108 /home/SySeVR/data/CVE_2009_4307_PATCHED_ext4_fill_flex_info.c size = flex_group_count * sizeof ( struct flex_groups ) 23
static int CVE_2009_4307_PATCHED_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
size_t size ; 8
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_inodes , ext4_free_inodes_count ( sb , gdp ) ); 40
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_blocks , ext4_free_blks_count ( sb , gdp ) ); 42
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . used_dirs , ext4_used_dirs_count ( sb , gdp ) ); 44
------------------------------
109 /home/SySeVR/data/CVE_2009_4307_PATCHED_ext4_fill_flex_info.c flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex 20
static int CVE_2009_4307_PATCHED_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
ext4_msg ( sb , KERN_ERR , "not enough memory for "
"%u flex groups" , flex_group_count ) 32
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_inodes , ext4_free_inodes_count ( sb , gdp ) ); 40
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . free_blocks , ext4_free_blks_count ( sb , gdp ) ); 42
atomic_set ( & sbi -> s_flex_groups [ flex_group ] . used_dirs , ext4_used_dirs_count ( sb , gdp ) ); 44
------------------------------
110 /home/SySeVR/data/CVE_2010_0006_VULN_ipv6_hop_jumbo.c pkt_len = ntohl ( * ( __be32 * ) ( nh + optoff + 2 ) ) 15
static int CVE_2010_0006_VULN_ipv6_hop_jumbo(struct sk_buff *skb, int optoff) 1
const unsigned char * nh = skb_network_header ( skb ) ; 3
u32 pkt_len ; 4
if ( nh [ optoff + 1 ] != 4 || ( optoff & 3 ) != 2 )  7
pkt_len = ntohl ( * ( __be32 * ) ( nh + optoff + 2 ) ); 15
if ( pkt_len <= IPV6_MAXPLEN )  16
if ( pkt_len > skb -> len - sizeof ( struct ipv6hdr ) )  29
if ( pskb_trim_rcsum ( skb , pkt_len + sizeof ( struct ipv6hdr ) ) )  35
------------------------------
111 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz 294
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
if ( nbyte > elf_brk - elf_bss )  210
nbyte = elf_brk - elf_bss; 211
if ( clear_user ( ( void __user * ) elf_bss + load_bias , nbyte ) )  212
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
if ( ! load_addr_set )  256
load_addr_set = 1; 257
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
elf_brk += load_bias; 301
retval = set_brk ( elf_bss , elf_brk ); 312
if ( retval )  313
if ( likely ( elf_bss != elf_brk ) && unlikely ( padzero ( elf_bss ) ) )  317
if ( retval < 0 )  364
if ( retval < 0 )  374
return retval ; 421
------------------------------
112 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz 286
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
nbyte = ELF_PAGEOFFSET ( elf_bss ); 207
if ( nbyte )  208
nbyte = ELF_MIN_ALIGN - nbyte; 209
if ( nbyte > elf_brk - elf_bss )  210
nbyte = elf_brk - elf_bss; 211
if ( clear_user ( ( void __user * ) elf_bss + load_bias , nbyte ) )  212
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
if ( ! load_addr_set )  256
load_addr_set = 1; 257
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
if ( ( elf_ppnt -> p_flags & PF_X ) && end_code < k )  290
end_code = k; 291
if ( end_data < k )  292
end_data = k; 293
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
elf_bss += load_bias; 300
elf_brk += load_bias; 301
end_code += load_bias; 303
end_data += load_bias; 305
retval = set_brk ( elf_bss , elf_brk ); 312
if ( retval )  313
if ( likely ( elf_bss != elf_brk ) && unlikely ( padzero ( elf_bss ) ) )  317
if ( retval < 0 )  364
if ( retval < 0 )  374
current -> mm -> end_code = end_code; 379
current -> mm -> start_code = start_code; 380
current -> mm -> start_data = start_data; 381
current -> mm -> end_data = end_data; 382
current -> mm -> start_stack = bprm -> p; 383
if ( ( current -> flags & PF_RANDOMIZE ) && ( randomize_va_space > 1 ) )  386
current -> mm -> brk = current -> mm -> start_brk = arch_randomize_brk ( current -> mm ); 387
if ( current -> personality & MMAP_PAGE_ZERO )  391
down_write ( & current -> mm -> mmap_sem ); 396
up_write ( & current -> mm -> mmap_sem ); 399
return retval ; 421
------------------------------
113 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c load_addr = ( elf_ppnt -> p_vaddr - elf_ppnt -> p_offset ) 258
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
if ( ! load_addr_set )  256
load_addr_set = 1; 257
load_addr = ( elf_ppnt -> p_vaddr - elf_ppnt -> p_offset ); 258
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
load_addr += load_bias; 262
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
retval = create_elf_tables ( bprm , & loc -> elf_ex , load_addr , interp_load_addr ); 372
if ( retval < 0 )  374
return retval ; 421
------------------------------
114 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ) 247
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
if ( clear_user ( ( void __user * ) elf_bss + load_bias , nbyte ) )  212
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
retval = IS_ERR ( ( void * ) error ) ? PTR_ERR ( ( void * ) error ) : - EINVAL; 251
if ( ! load_addr_set )  256
load_addr_set = 1; 257
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
load_addr += load_bias; 262
reloc_func_desc = load_bias; 263
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
loc -> elf_ex . e_entry += load_bias; 299
elf_bss += load_bias; 300
elf_brk += load_bias; 301
start_code += load_bias; 302
end_code += load_bias; 303
start_data += load_bias; 304
end_data += load_bias; 305
retval = set_brk ( elf_bss , elf_brk ); 312
if ( retval )  313
if ( likely ( elf_bss != elf_brk ) && unlikely ( padzero ( elf_bss ) ) )  317
elf_entry = load_elf_interp ( & loc -> interp_elf_ex , interpreter , & interp_map_addr , load_bias ); 326
if ( ! IS_ERR ( ( void * ) elf_entry ) )  330
interp_load_addr = elf_entry; 335
elf_entry += loc -> interp_elf_ex . e_entry; 336
if ( BAD_ADDR ( elf_entry ) )  338
retval = IS_ERR ( ( void * ) elf_entry ) ? ( int ) elf_entry : - EINVAL; 340
reloc_func_desc = interp_load_addr; 344
elf_entry = loc -> elf_ex . e_entry; 350
if ( BAD_ADDR ( elf_entry ) )  351
if ( retval < 0 )  364
retval = create_elf_tables ( bprm , & loc -> elf_ex , load_addr , interp_load_addr ); 372
if ( retval < 0 )  374
current -> mm -> end_code = end_code; 379
current -> mm -> start_code = start_code; 380
current -> mm -> start_data = start_data; 381
current -> mm -> end_data = end_data; 382
current -> mm -> start_stack = bprm -> p; 383
if ( ( current -> flags & PF_RANDOMIZE ) && ( randomize_va_space > 1 ) )  386
current -> mm -> brk = current -> mm -> start_brk = arch_randomize_brk ( current -> mm ); 387
if ( current -> personality & MMAP_PAGE_ZERO )  391
down_write ( & current -> mm -> mmap_sem ); 396
up_write ( & current -> mm -> mmap_sem ); 399
ELF_PLAT_INIT ( regs , reloc_func_desc ); 413
start_thread ( regs , elf_entry , bprm -> p ); 416
kfree ( loc ); 419
return retval ; 421
------------------------------
115 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c nbyte = elf_brk - elf_bss 211
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
unsigned long nbyte ; 196
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
nbyte = ELF_PAGEOFFSET ( elf_bss ); 207
if ( nbyte )  208
nbyte = ELF_MIN_ALIGN - nbyte; 209
if ( nbyte > elf_brk - elf_bss )  210
nbyte = elf_brk - elf_bss; 211
if ( clear_user ( ( void __user * ) elf_bss + load_bias , nbyte ) )  212
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
if ( ! load_addr_set )  256
load_addr_set = 1; 257
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
------------------------------
116 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c nbyte = ELF_MIN_ALIGN - nbyte 209
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
unsigned long nbyte ; 196
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
nbyte = ELF_PAGEOFFSET ( elf_bss ); 207
if ( nbyte )  208
nbyte = ELF_MIN_ALIGN - nbyte; 209
if ( nbyte > elf_brk - elf_bss )  210
if ( clear_user ( ( void __user * ) elf_bss + load_bias , nbyte ) )  212
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
if ( ! load_addr_set )  256
load_addr_set = 1; 257
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
------------------------------
117 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ) 201
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned long load_addr = 0 , load_bias = 0 ; 4
int load_addr_set = 0 ; 5
char * elf_interpreter = NULL ; 6
unsigned long error ; 7
struct elf_phdr * elf_ppnt , * elf_phdata ; 8
unsigned long elf_bss , elf_brk ; 9
int retval , i ; 10
unsigned int size ; 11
int executable_stack = EXSTACK_DEFAULT ; 16
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
retval = - ENOEXEC; 32
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
retval = - ENOMEM; 51
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
elf_ppnt = elf_phdata; 64
elf_bss = 0; 65
elf_brk = 0; 66
for (i = 0; i < loc->elf_ex.e_phnum; i++) 73
if ( elf_ppnt -> p_type == PT_INTERP )  74
retval = - ENOEXEC; 79
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
retval = - ENOMEM; 84
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
retval = - ENOEXEC; 99
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP; 114
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 125
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
executable_stack = EXSTACK_ENABLE_X; 135
executable_stack = EXSTACK_DISABLE_X; 137
if ( elf_interpreter )  142
retval = - ELIBBAD; 143
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  145
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )  148
retval = flush_old_exec ( bprm ); 153
if ( retval )  154
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack ); 176
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
int elf_prot = 0 , elf_flags ; 189
unsigned long k , vaddr ; 190
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
if ( elf_ppnt -> p_flags & PF_R )  223
elf_prot |= PROT_READ; 224
if ( elf_ppnt -> p_flags & PF_W )  225
elf_prot |= PROT_WRITE; 226
if ( elf_ppnt -> p_flags & PF_X )  227
elf_prot |= PROT_EXEC; 228
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE; 230
vaddr = elf_ppnt -> p_vaddr; 232
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )  233
elf_flags |= MAP_FIXED; 234
if ( loc -> elf_ex . e_type == ET_DYN )  235
load_bias = 0; 241
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
if ( ! load_addr_set )  256
load_addr_set = 1; 257
if ( loc -> elf_ex . e_type == ET_DYN )  259
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
k = elf_ppnt -> p_vaddr; 266
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
if ( retval )  313
if ( retval < 0 )  364
if ( retval < 0 )  374
return retval ; 421
------------------------------
118 /home/SySeVR/data/CVE_2010_0307_PATCHED_load_elf_binary.c size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ) 50
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs) 1
unsigned int size ; 11
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ; 18
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL ); 23
if ( ! loc )  24
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf ); 30
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )  34
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )  37
if ( ! elf_check_arch ( & loc -> elf_ex ) )  39
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )  41
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )  45
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )  47
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ); 50
elf_phdata = kmalloc ( size , GFP_KERNEL ); 52
if ( ! elf_phdata )  53
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size ); 56
if ( retval != size )  58
if ( retval >= 0 )  59
elf_ppnt = elf_phdata; 64
if ( elf_ppnt -> p_type == PT_INTERP )  74
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )  80
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL ); 85
if ( ! elf_interpreter )  87
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz ); 90
if ( retval != elf_ppnt -> p_filesz )  93
if ( retval >= 0 )  94
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )  100
interpreter = open_exec ( elf_interpreter ); 103
retval = PTR_ERR ( interpreter ); 104
if ( IS_ERR ( interpreter ) )  105
if ( file_permission ( interpreter , MAY_READ ) < 0 )  113
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE ); 116
if ( retval != BINPRM_BUF_SIZE )  118
if ( retval >= 0 )  119
elf_ppnt ++; 128
elf_ppnt = elf_phdata; 131
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 132
if ( elf_ppnt -> p_type == PT_GNU_STACK )  133
if ( elf_ppnt -> p_flags & PF_X )  134
if ( elf_interpreter )  142
if ( retval )  154
if ( retval < 0 )  178
for(i = 0, elf_ppnt = elf_phdata;
i < loc->elf_ex.e_phnum; i++, elf_ppnt++) 188
if ( elf_ppnt -> p_type != PT_LOAD )  192
if ( unlikely ( elf_brk > elf_bss ) )  195
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ); 201
if ( retval )  203
nbyte = ELF_PAGEOFFSET ( elf_bss ); 207
if ( nbyte )  208
nbyte = ELF_MIN_ALIGN - nbyte; 209
if ( nbyte > elf_brk - elf_bss )  210
nbyte = elf_brk - elf_bss; 211
if ( clear_user ( ( void __user * ) elf_bss + load_bias , nbyte ) )  212
if ( elf_ppnt -> p_flags & PF_R )  223
if ( elf_ppnt -> p_flags & PF_W )  225
if ( elf_ppnt -> p_flags & PF_X )  227
vaddr = elf_ppnt -> p_vaddr; 232
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 ); 247
if ( BAD_ADDR ( error ) )  249
retval = IS_ERR ( ( void * ) error ) ? PTR_ERR ( ( void * ) error ) : - EINVAL; 251
load_addr = ( elf_ppnt -> p_vaddr - elf_ppnt -> p_offset ); 258
load_bias += error - ELF_PAGESTART ( load_bias + vaddr ); 260
load_addr += load_bias; 262
reloc_func_desc = load_bias; 263
k = elf_ppnt -> p_vaddr; 266
if ( k < start_code )  267
start_code = k; 268
if ( start_data < k )  269
start_data = k; 270
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )  277
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz; 286
if ( k > elf_bss )  288
elf_bss = k; 289
if ( ( elf_ppnt -> p_flags & PF_X ) && end_code < k )  290
end_code = k; 291
if ( end_data < k )  292
end_data = k; 293
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz; 294
if ( k > elf_brk )  295
elf_brk = k; 296
loc -> elf_ex . e_entry += load_bias; 299
elf_bss += load_bias; 300
elf_brk += load_bias; 301
start_code += load_bias; 302
end_code += load_bias; 303
start_data += load_bias; 304
end_data += load_bias; 305
retval = set_brk ( elf_bss , elf_brk ); 312
if ( retval )  313
if ( likely ( elf_bss != elf_brk ) && unlikely ( padzero ( elf_bss ) ) )  317
if ( elf_interpreter )  323
elf_entry = load_elf_interp ( & loc -> interp_elf_ex , interpreter , & interp_map_addr , load_bias ); 326
if ( ! IS_ERR ( ( void * ) elf_entry ) )  330
interp_load_addr = elf_entry; 335
elf_entry += loc -> interp_elf_ex . e_entry; 336
if ( BAD_ADDR ( elf_entry ) )  338
retval = IS_ERR ( ( void * ) elf_entry ) ? ( int ) elf_entry : - EINVAL; 340
reloc_func_desc = interp_load_addr; 344
allow_write_access ( interpreter ); 346
fput ( interpreter ); 347
kfree ( elf_interpreter ); 348
elf_entry = loc -> elf_ex . e_entry; 350
if ( BAD_ADDR ( elf_entry ) )  351
kfree ( elf_phdata ); 358
retval = arch_setup_additional_pages ( bprm , ! ! elf_interpreter ); 363
if ( retval < 0 )  364
retval = create_elf_tables ( bprm , & loc -> elf_ex , load_addr , interp_load_addr ); 372
if ( retval < 0 )  374
current -> mm -> end_code = end_code; 379
current -> mm -> start_code = start_code; 380
current -> mm -> start_data = start_data; 381
current -> mm -> end_data = end_data; 382
current -> mm -> start_stack = bprm -> p; 383
if ( ( current -> flags & PF_RANDOMIZE ) && ( randomize_va_space > 1 ) )  386
current -> mm -> brk = current -> mm -> start_brk = arch_randomize_brk ( current -> mm ); 387
if ( current -> personality & MMAP_PAGE_ZERO )  391
down_write ( & current -> mm -> mmap_sem ); 396
up_write ( & current -> mm -> mmap_sem ); 399
ELF_PLAT_INIT ( regs , reloc_func_desc ); 413
start_thread ( regs , elf_entry , bprm -> p ); 416
kfree ( loc ); 419
return retval ; 421
allow_write_access ( interpreter ); 425
if ( interpreter )  426
fput ( interpreter ); 427
kfree ( elf_interpreter ); 429
kfree ( elf_phdata ); 431
------------------------------
119 /home/SySeVR/data/CVE_2010_2495_VULN_pppol2tp_sendmsg.c udp_len = hdr_len + sizeof ( ppph ) + total_len 53
static int CVE_2010_2495_VULN_pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
size_t total_len) 2
struct sock * sk = sock -> sk ; 5
struct sk_buff * skb ; 8
int hdr_len ; 10
struct pppol2tp_session * session ; 11
struct pppol2tp_tunnel * tunnel ; 12
struct sock * sk_tun ; 15
u16 udp_len ; 16
if ( sock_flag ( sk , SOCK_DEAD ) || ! ( sk -> sk_state & PPPOX_CONNECTED ) )  19
session = pppol2tp_sock_to_session ( sk ); 24
if ( session == NULL )  25
sk_tun = session -> tunnel_sock; 28
tunnel = pppol2tp_sock_to_tunnel ( sk_tun ); 29
if ( tunnel == NULL )  30
hdr_len = pppol2tp_l2tp_header_len ( session ); 34
skb = sock_wmalloc ( sk , NET_SKB_PAD + sizeof ( struct iphdr ) + sizeof ( struct udphdr ) + hdr_len + sizeof ( ppph ) + total_len , 0 , GFP_KERNEL ); 38
if ( ! skb )  42
udp_len = hdr_len + sizeof ( ppph ) + total_len; 53
uh -> len = htons ( udp_len ); 57
uh -> check = 0; 58
csum = skb_checksum ( skb , 0 , udp_len , 0 ); 83
uh -> check = csum_tcpudp_magic ( inet -> inet_saddr , inet -> inet_daddr , udp_len , IPPROTO_UDP , csum ); 84
if ( uh -> check == 0 )  87
uh -> check = CSUM_MANGLED_0; 88
uh -> check = ~csum_tcpudp_magic ( inet -> inet_saddr , inet -> inet_daddr , udp_len , IPPROTO_UDP , 0 ); 93
------------------------------
120 /home/SySeVR/data/CVE_2010_2495_VULN_pppol2tp_sendmsg.c skb = sock_wmalloc ( sk , NET_SKB_PAD + sizeof ( struct iphdr ) + sizeof ( struct udphdr ) + hdr_len + sizeof ( ppph ) + total_len , 0 , GFP_KERNEL ) 38
static int CVE_2010_2495_VULN_pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
size_t total_len) 2
struct sock * sk = sock -> sk ; 5
struct sk_buff * skb ; 8
int hdr_len ; 10
struct pppol2tp_session * session ; 11
struct pppol2tp_tunnel * tunnel ; 12
struct sock * sk_tun ; 15
if ( sock_flag ( sk , SOCK_DEAD ) || ! ( sk -> sk_state & PPPOX_CONNECTED ) )  19
session = pppol2tp_sock_to_session ( sk ); 24
if ( session == NULL )  25
sk_tun = session -> tunnel_sock; 28
tunnel = pppol2tp_sock_to_tunnel ( sk_tun ); 29
if ( tunnel == NULL )  30
hdr_len = pppol2tp_l2tp_header_len ( session ); 34
skb = sock_wmalloc ( sk , NET_SKB_PAD + sizeof ( struct iphdr ) + sizeof ( struct udphdr ) + hdr_len + sizeof ( ppph ) + total_len , 0 , GFP_KERNEL ); 38
if ( ! skb )  42
skb_reserve ( skb , NET_SKB_PAD ); 46
skb_reset_network_header ( skb ); 47
skb_reserve ( skb , sizeof ( struct iphdr ) ); 48
skb_reset_transport_header ( skb ); 49
uh = ( struct udphdr * ) skb -> data; 54
uh -> source = inet -> inet_sport; 55
uh -> dest = inet -> inet_dport; 56
uh -> len = htons ( udp_len ); 57
uh -> check = 0; 58
skb_put ( skb , sizeof ( struct udphdr ) ); 59
pppol2tp_build_l2tp_header ( session , skb -> data ); 62
skb_put ( skb , hdr_len ); 63
skb -> data [ 0 ] = ppph [ 0 ]; 66
skb -> data [ 1 ] = ppph [ 1 ]; 67
skb_put ( skb , 2 ); 68
error = memcpy_fromiovec ( skb -> data , m -> msg_iov , total_len ); 71
if ( error < 0 )  72
kfree_skb ( skb ); 73
skb_put ( skb , total_len ); 76
skb -> ip_summed = CHECKSUM_NONE; 80
if ( ! ( skb_dst ( skb ) -> dev -> features & NETIF_F_V4_CSUM ) )  81
skb -> ip_summed = CHECKSUM_COMPLETE; 82
csum = skb_checksum ( skb , 0 , udp_len , 0 ); 83
uh -> check = csum_tcpudp_magic ( inet -> inet_saddr , inet -> inet_daddr , udp_len , IPPROTO_UDP , csum ); 84
if ( uh -> check == 0 )  87
uh -> check = CSUM_MANGLED_0; 88
skb -> ip_summed = CHECKSUM_PARTIAL; 90
skb -> csum_start = skb_transport_header ( skb ) - skb -> head; 91
uh -> check = ~csum_tcpudp_magic ( inet -> inet_saddr , inet -> inet_daddr , udp_len , IPPROTO_UDP , 0 ); 93
unsigned char * datap = skb -> data ; 109
printk ( " %02X" , * datap ++ ); 113
len = skb -> len; 123
error = ip_queue_xmit ( skb , 1 ); 124
if ( error >= 0 )  127
tunnel -> stats . tx_bytes += len; 129
session -> stats . tx_bytes += len; 131
return error ; 137
return error ; 144
------------------------------
121 /home/SySeVR/data/CVE_2010_2498_PATCHED_psh_glyph_find_strong_points.c count = next - first 41
static void
CVE_2010_2498_PATCHED_psh_glyph_find_strong_points( PSH_Glyph  glyph,
FT_Int     dimension ) 4
PSH_Hint_Table table = & glyph -> hint_tables [ dimension ] ; 9
PS_Mask mask = table -> hint_masks -> masks ; 10
FT_UInt num_masks = table -> hint_masks -> num_masks ; 11
if ( num_masks > 1 && glyph -> num_points > 0 )  25
first = mask -> end_point > glyph -> num_points ? glyph -> num_points : mask -> end_point; 28
mask ++; 31
for ( ; num_masks > 1; num_masks--, mask++ ) 32
FT_UInt next ; 34
FT_Int count ; 35
next = mask -> end_point > glyph -> num_points ? glyph -> num_points : mask -> end_point; 38
count = next - first; 41
if ( count > 0 )  42
psh_hint_table_find_strong_points ( table , point , count , threshold , major_dir ); 49
first = next; 52
psh_hint_table_find_strong_points ( table , point , count , threshold , major_dir ); 65
for ( ; count > 0; count--, point++ ) 76
if ( point -> hint && ! psh_point_is_strong ( point ) )  77
psh_point_set_strong ( point ); 78
------------------------------
122 /home/SySeVR/data/CVE_2010_2500_PATCHED_gray_render_span.c p = ( unsigned char * ) map -> buffer - y * map -> pitch 12
static void
CVE_2010_2500_PATCHED_gray_render_span( int             y,
int             count,
const FT_Span*  spans,
PWorker         worker ) 5
unsigned char * p ; 7
FT_Bitmap * map = & worker -> target ; 8
p = ( unsigned char * ) map -> buffer - y * map -> pitch; 12
p += ( unsigned ) ( ( map -> rows - 1 ) * map -> pitch ); 14
FT_MEM_SET ( p + spans -> x , ( unsigned char ) coverage , spans -> len ); 28
unsigned char * q = p + spans -> x ; 31
* q ++ = ( unsigned char ) coverage; 36
* q ++ = ( unsigned char ) coverage; 37
* q ++ = ( unsigned char ) coverage; 38
* q ++ = ( unsigned char ) coverage; 39
* q ++ = ( unsigned char ) coverage; 40
* q ++ = ( unsigned char ) coverage; 41
* q = ( unsigned char ) coverage; 42
------------------------------
123 /home/SySeVR/data/CVE_2010_2500_VULN_gray_render_span.c p = ( unsigned char * ) map -> buffer - y * map -> pitch 12
static void
CVE_2010_2500_VULN_gray_render_span( int             y,
int             count,
const FT_Span*  spans,
PWorker         worker ) 5
unsigned char * p ; 7
FT_Bitmap * map = & worker -> target ; 8
p = ( unsigned char * ) map -> buffer - y * map -> pitch; 12
p += ( map -> rows - 1 ) * map -> pitch; 14
FT_MEM_SET ( p + spans -> x , ( unsigned char ) coverage , spans -> len ); 28
unsigned char * q = p + spans -> x ; 31
* q ++ = ( unsigned char ) coverage; 36
* q ++ = ( unsigned char ) coverage; 37
* q ++ = ( unsigned char ) coverage; 38
* q ++ = ( unsigned char ) coverage; 39
* q ++ = ( unsigned char ) coverage; 40
* q ++ = ( unsigned char ) coverage; 41
* q = ( unsigned char ) coverage; 42
------------------------------
124 /home/SySeVR/data/CVE_2010_2519_VULN_Mac_Read_POST_Resource.c error = FT_Stream_Read ( stream , ( FT_Byte * ) pfb_data + pfb_pos , rlen ) 86
static FT_Error
CVE_2010_2519_VULN_Mac_Read_POST_Resource( FT_Library  library,
FT_Stream   stream,
FT_Long    *offsets,
FT_Long     resource_cnt,
FT_Long     face_index,
FT_Face    *aface ) 8
FT_Byte * pfb_data ; 12
int i , type , flags ; 13
FT_Long len ; 14
FT_Long pfb_len , pfb_pos , pfb_lenpos ; 15
FT_Long rlen , temp ; 16
if ( face_index == - 1 )  19
face_index = 0; 20
if ( face_index != 0 )  21
pfb_len = 0; 26
for ( i = 0; i < resource_cnt; ++i ) 27
error = FT_Stream_Seek ( stream , offsets [ i ] ); 29
if ( error )  30
if ( FT_READ_LONG ( temp ) )  32
pfb_len += temp + 6; 34
if ( FT_ALLOC ( pfb_data , ( FT_Long ) pfb_len + 2 ) )  37
pfb_pos = 6; 46
pfb_lenpos = 2; 47
len = 0; 49
type = 1; 50
for ( i = 0; i < resource_cnt; ++i ) 51
error = FT_Stream_Seek ( stream , offsets [ i ] ); 53
if ( error )  54
if ( FT_READ_LONG ( rlen ) )  56
if ( FT_READ_USHORT ( flags ) )  58
rlen -= 2; 60
if ( ( flags >> 8 ) == type )  61
len += rlen; 62
pfb_data [ pfb_lenpos ] = ( FT_Byte ) ( len ); 65
pfb_data [ pfb_lenpos + 1 ] = ( FT_Byte ) ( len >> 8 ); 66
pfb_data [ pfb_lenpos + 2 ] = ( FT_Byte ) ( len >> 16 ); 67
pfb_data [ pfb_lenpos + 3 ] = ( FT_Byte ) ( len >> 24 ); 68
if ( ( flags >> 8 ) == 5 )  70
pfb_data [ pfb_pos ++ ] = 0x80; 73
type = flags >> 8; 75
len = rlen; 76
pfb_data [ pfb_pos ++ ] = ( FT_Byte ) type; 78
pfb_lenpos = pfb_pos; 79
pfb_data [ pfb_pos ++ ] = 0; 80
pfb_data [ pfb_pos ++ ] = 0; 81
pfb_data [ pfb_pos ++ ] = 0; 82
pfb_data [ pfb_pos ++ ] = 0; 83
error = FT_Stream_Read ( stream , ( FT_Byte * ) pfb_data + pfb_pos , rlen ); 86
pfb_pos += rlen; 87
return error ; 109
------------------------------
125 /home/SySeVR/data/CVE_2010_2521_PATCHED_nfsd4_decode_compound.c argp -> ops = kmalloc ( argp -> opcnt * sizeof ( * argp -> ops ) , GFP_KERNEL ) 28
static __be32
CVE_2010_2521_PATCHED_nfsd4_decode_compound(struct nfsd4_compoundargs *argp) 2
if ( argp -> opcnt > ARRAY_SIZE ( argp -> iops ) )  27
argp -> ops = kmalloc ( argp -> opcnt * sizeof ( * argp -> ops ) , GFP_KERNEL ); 28
if ( ! argp -> ops )  29
argp -> ops = argp -> iops; 30
if ( argp -> minorversion >= ARRAY_SIZE ( nfsd4_minorversion ) )  36
argp -> opcnt = 0; 37
ops = & nfsd4_minorversion [ argp -> minorversion ]; 39
for (i = 0; i < argp->opcnt; i++) 40
op = & argp -> ops [ i ]; 41
op -> replay = NULL; 42
if ( argp -> p == argp -> end )  51
if ( argp -> pagelen < 4 )  52
op -> opnum = OP_WRITE + 1; 54
op -> status = nfserr_bad_xdr; 55
argp -> opcnt = i + 1; 56
argp -> p = page_address ( argp -> pagelist [ 0 ] ); 65
argp -> pagelist ++; 66
if ( argp -> pagelen < PAGE_SIZE )  67
argp -> end = argp -> p + ( argp -> pagelen >> 2 ); 68
argp -> pagelen = 0; 69
argp -> end = argp -> p + ( PAGE_SIZE >> 2 ); 71
argp -> pagelen -= PAGE_SIZE; 72
op -> opnum = ntohl ( * argp -> p ++ ); 75
if ( op -> opnum >= OP_ACCESS && op -> opnum < ops -> nops )  77
op -> status = ops -> decoders [ op -> opnum ] ( argp , & op -> u ); 78
op -> opnum = OP_ILLEGAL; 80
op -> status = nfserr_op_illegal; 81
if ( op -> status )  84
------------------------------
126 /home/SySeVR/data/CVE_2010_2803_VULN_drm_ioctl.c ioctl = & dev -> driver -> ioctls [ nr - DRM_COMMAND_BASE ] 28
long CVE_2010_2803_VULN_drm_ioctl(struct file *filp,
unsigned int cmd, unsigned long arg) 2
struct drm_file * file_priv = filp -> private_data ; 4
struct drm_device * dev ; 5
struct drm_ioctl_desc * ioctl ; 6
unsigned int nr = DRM_IOCTL_NR ( cmd ) ; 8
dev = file_priv -> minor -> dev; 13
if ( ( nr >= DRM_CORE_IOCTL_COUNT ) && ( ( nr < DRM_COMMAND_BASE ) || ( nr >= DRM_COMMAND_END ) ) )  23
if ( ( nr >= DRM_COMMAND_BASE ) && ( nr < DRM_COMMAND_END ) && ( nr < DRM_COMMAND_BASE + dev -> driver -> num_ioctls ) )  26
ioctl = & dev -> driver -> ioctls [ nr - DRM_COMMAND_BASE ]; 28
func = ioctl -> func; 36
if ( ! func )  41
if ( ( ( ioctl -> flags & DRM_ROOT_ONLY ) && ! capable ( CAP_SYS_ADMIN ) ) || ( ( ioctl -> flags & DRM_AUTH ) && ! file_priv -> authenticated ) || ( ( ioctl -> flags & DRM_MASTER ) && ! file_priv -> is_master ) || ( ! ( ioctl -> flags & DRM_CONTROL_ALLOW ) && ( file_priv -> minor -> type == DRM_MINOR_CONTROL ) ) )  44
if ( ioctl -> flags & DRM_UNLOCKED )  69
retcode = func ( dev , kdata , file_priv ); 70
retcode = func ( dev , kdata , file_priv ); 73
if ( retcode )  88
DRM_DEBUG ( "ret = %x\n" , retcode ); 89
return retcode ; 90
------------------------------
127 /home/SySeVR/data/CVE_2010_2805_PATCHED_FT_Stream_EnterFrame.c stream -> limit = stream -> cursor + count 69
CVE_2010_2805_PATCHED_FT_Stream_EnterFrame( FT_Stream  stream,
FT_ULong   count ) 2
if ( stream -> read )  11
if ( stream -> pos >= stream -> size || stream -> size - stream -> pos < count )  56
stream -> cursor = stream -> base + stream -> pos; 68
stream -> limit = stream -> cursor + count; 69
stream -> pos += count; 70
------------------------------
128 /home/SySeVR/data/CVE_2010_2805_PATCHED_FT_Stream_EnterFrame.c stream -> cursor = stream -> base + stream -> pos 68
CVE_2010_2805_PATCHED_FT_Stream_EnterFrame( FT_Stream  stream,
FT_ULong   count ) 2
if ( stream -> read )  11
if ( stream -> pos >= stream -> size || stream -> size - stream -> pos < count )  56
stream -> cursor = stream -> base + stream -> pos; 68
stream -> limit = stream -> cursor + count; 69
stream -> pos += count; 70
------------------------------
129 /home/SySeVR/data/CVE_2010_2805_PATCHED_FT_Stream_EnterFrame.c stream -> limit = stream -> cursor + count 50
CVE_2010_2805_PATCHED_FT_Stream_EnterFrame( FT_Stream  stream,
FT_ULong   count ) 2
FT_Error error = FT_Err_Ok ; 4
if ( stream -> read )  11
FT_Memory memory = stream -> memory ; 14
if ( count > stream -> size )  18
stream -> base = ( unsigned char * ) ft_mem_qalloc ( memory , count , & error ); 30
if ( error )  31
stream -> cursor = stream -> base; 49
stream -> limit = stream -> cursor + count; 50
stream -> pos += read_bytes; 51
------------------------------
130 /home/SySeVR/data/CVE_2010_2962_PATCHED_i915_gem_gtt_pwrite_fast.c page_length = PAGE_SIZE - page_offset 42
static int
CVE_2010_2962_PATCHED_i915_gem_gtt_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,
struct drm_i915_gem_pwrite *args,
struct drm_file *file_priv) 4
drm_i915_private_t * dev_priv = dev -> dev_private ; 7
ssize_t remain ; 8
loff_t offset , page_base ; 9
char __user * user_data ; 10
int page_offset , page_length ; 11
int ret ; 12
user_data = ( char __user * ) ( uintptr_t ) args -> data_ptr; 14
remain = args -> size; 15
ret = i915_gem_object_pin ( obj , 0 ); 19
if ( ret )  20
ret = i915_gem_object_set_to_gtt_domain ( obj , 1 ); 24
if ( ret )  25
obj_priv = to_intel_bo ( obj ); 28
offset = obj_priv -> gtt_offset + args -> offset; 29
while ( remain > 0 )  31
page_base = ( offset & ~ ( PAGE_SIZE - 1 ) ); 38
page_offset = offset & ( PAGE_SIZE - 1 ); 39
page_length = remain; 40
if ( ( page_offset + remain ) > PAGE_SIZE )  41
page_length = PAGE_SIZE - page_offset; 42
ret = fast_user_write ( dev_priv -> mm . gtt_mapping , page_base , page_offset , user_data , page_length ); 44
if ( ret )  51
remain -= page_length; 54
user_data += page_length; 55
offset += page_length; 56
return ret ; 63
------------------------------
131 /home/SySeVR/data/CVE_2010_2962_PATCHED_i915_gem_gtt_pwrite_fast.c offset = obj_priv -> gtt_offset + args -> offset 29
static int
CVE_2010_2962_PATCHED_i915_gem_gtt_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,
struct drm_i915_gem_pwrite *args,
struct drm_file *file_priv) 4
loff_t offset , page_base ; 9
int ret ; 12
ret = i915_gem_object_pin ( obj , 0 ); 19
if ( ret )  20
ret = i915_gem_object_set_to_gtt_domain ( obj , 1 ); 24
if ( ret )  25
obj_priv = to_intel_bo ( obj ); 28
offset = obj_priv -> gtt_offset + args -> offset; 29
while ( remain > 0 )  31
page_base = ( offset & ~ ( PAGE_SIZE - 1 ) ); 38
page_offset = offset & ( PAGE_SIZE - 1 ); 39
page_length = remain; 40
if ( ( page_offset + remain ) > PAGE_SIZE )  41
page_length = PAGE_SIZE - page_offset; 42
ret = fast_user_write ( dev_priv -> mm . gtt_mapping , page_base , page_offset , user_data , page_length ); 44
if ( ret )  51
remain -= page_length; 54
user_data += page_length; 55
offset += page_length; 56
return ret ; 63
------------------------------
132 /home/SySeVR/data/CVE_2010_2962_VULN_i915_gem_gtt_pwrite_fast.c page_length = PAGE_SIZE - page_offset 44
static int
CVE_2010_2962_VULN_i915_gem_gtt_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,
struct drm_i915_gem_pwrite *args,
struct drm_file *file_priv) 4
drm_i915_private_t * dev_priv = dev -> dev_private ; 7
ssize_t remain ; 8
loff_t offset , page_base ; 9
char __user * user_data ; 10
int page_offset , page_length ; 11
int ret ; 12
user_data = ( char __user * ) ( uintptr_t ) args -> data_ptr; 14
remain = args -> size; 15
if ( ! access_ok ( VERIFY_READ , user_data , remain ) )  16
ret = i915_gem_object_pin ( obj , 0 ); 21
if ( ret )  22
ret = i915_gem_object_set_to_gtt_domain ( obj , 1 ); 26
if ( ret )  27
obj_priv = to_intel_bo ( obj ); 30
offset = obj_priv -> gtt_offset + args -> offset; 31
while ( remain > 0 )  33
page_base = ( offset & ~ ( PAGE_SIZE - 1 ) ); 40
page_offset = offset & ( PAGE_SIZE - 1 ); 41
page_length = remain; 42
if ( ( page_offset + remain ) > PAGE_SIZE )  43
page_length = PAGE_SIZE - page_offset; 44
ret = fast_user_write ( dev_priv -> mm . gtt_mapping , page_base , page_offset , user_data , page_length ); 46
if ( ret )  53
remain -= page_length; 56
user_data += page_length; 57
offset += page_length; 58
return ret ; 65
------------------------------
133 /home/SySeVR/data/CVE_2010_2962_VULN_i915_gem_gtt_pwrite_fast.c offset = obj_priv -> gtt_offset + args -> offset 31
static int
CVE_2010_2962_VULN_i915_gem_gtt_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,
struct drm_i915_gem_pwrite *args,
struct drm_file *file_priv) 4
ssize_t remain ; 8
loff_t offset , page_base ; 9
char __user * user_data ; 10
int ret ; 12
user_data = ( char __user * ) ( uintptr_t ) args -> data_ptr; 14
remain = args -> size; 15
if ( ! access_ok ( VERIFY_READ , user_data , remain ) )  16
ret = i915_gem_object_pin ( obj , 0 ); 21
if ( ret )  22
ret = i915_gem_object_set_to_gtt_domain ( obj , 1 ); 26
if ( ret )  27
obj_priv = to_intel_bo ( obj ); 30
offset = obj_priv -> gtt_offset + args -> offset; 31
while ( remain > 0 )  33
page_base = ( offset & ~ ( PAGE_SIZE - 1 ) ); 40
page_offset = offset & ( PAGE_SIZE - 1 ); 41
page_length = remain; 42
if ( ( page_offset + remain ) > PAGE_SIZE )  43
page_length = PAGE_SIZE - page_offset; 44
ret = fast_user_write ( dev_priv -> mm . gtt_mapping , page_base , page_offset , user_data , page_length ); 46
if ( ret )  53
remain -= page_length; 56
user_data += page_length; 57
offset += page_length; 58
return ret ; 65
------------------------------
134 /home/SySeVR/data/CVE_2010_3015_PATCHED_ext4_ext_get_blocks.c allocated = ee_len - ( iblock - ee_block ) 84
int CVE_2010_3015_PATCHED_ext4_ext_get_blocks(handle_t *handle, struct inode *inode,
ext4_lblk_t iblock,
unsigned int max_blocks, struct buffer_head *bh_result,
int flags) 4
struct ext4_extent newex , * ex ; 8
cache_type = ext4_ext_in_cache ( inode , iblock , & newex ); 20
if ( cache_type )  21
if ( cache_type == EXT4_EXT_CACHE_GAP )  22
if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 )  23
if ( cache_type == EXT4_EXT_CACHE_EXTENT )  31
path = ext4_ext_find_extent ( inode , iblock , NULL ); 46
if ( IS_ERR ( path ) )  47
depth = ext_depth ( inode ); 53
if ( path [ depth ] . p_ext == NULL && depth != 0 )  60
ex = path [ depth ] . p_ext; 69
if ( ex )  70
ext4_lblk_t ee_block = le32_to_cpu ( ex -> ee_block ) ; 71
unsigned short ee_len ; 73
ee_len = ext4_ext_get_actual_len ( ex ); 79
if ( in_range ( iblock , ee_block , ee_len ) )  81
allocated = ee_len - ( iblock - ee_block ); 84
ret = ext4_ext_handle_uninitialized_extents ( handle , inode , iblock , max_blocks , path , flags , allocated , bh_result , newblock ); 95
return ret ; 98
if ( allocated > max_blocks )  225
return err ? err : allocated ; 236
------------------------------
135 /home/SySeVR/data/CVE_2010_3015_PATCHED_ext4_ext_get_blocks.c newblock = iblock - ee_block + ee_start 82
int CVE_2010_3015_PATCHED_ext4_ext_get_blocks(handle_t *handle, struct inode *inode,
ext4_lblk_t iblock,
unsigned int max_blocks, struct buffer_head *bh_result,
int flags) 4
struct ext4_extent newex , * ex ; 8
ext4_fsblk_t newblock ; 9
cache_type = ext4_ext_in_cache ( inode , iblock , & newex ); 20
if ( cache_type )  21
if ( cache_type == EXT4_EXT_CACHE_GAP )  22
if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 )  23
if ( cache_type == EXT4_EXT_CACHE_EXTENT )  31
path = ext4_ext_find_extent ( inode , iblock , NULL ); 46
if ( IS_ERR ( path ) )  47
depth = ext_depth ( inode ); 53
if ( path [ depth ] . p_ext == NULL && depth != 0 )  60
ex = path [ depth ] . p_ext; 69
if ( ex )  70
ext4_lblk_t ee_block = le32_to_cpu ( ex -> ee_block ) ; 71
ext4_fsblk_t ee_start = ext_pblock ( ex ) ; 72
unsigned short ee_len ; 73
ee_len = ext4_ext_get_actual_len ( ex ); 79
if ( in_range ( iblock , ee_block , ee_len ) )  81
newblock = iblock - ee_block + ee_start; 82
ext_debug ( "%u fit into %u:%d -> %llu\n" , iblock , ee_block , ee_len , newblock ); 85
ret = ext4_ext_handle_uninitialized_extents ( handle , inode , iblock , max_blocks , path , flags , allocated , bh_result , newblock ); 95
return ret ; 98
bh_result -> b_blocknr = newblock; 230
------------------------------
136 /home/SySeVR/data/CVE_2010_3015_PATCHED_ext4_ext_get_blocks.c allocated = ext4_ext_get_actual_len ( & newex ) - ( iblock - le32_to_cpu ( newex . ee_block ) ) 37
int CVE_2010_3015_PATCHED_ext4_ext_get_blocks(handle_t *handle, struct inode *inode,
ext4_lblk_t iblock,
unsigned int max_blocks, struct buffer_head *bh_result,
int flags) 4
struct ext4_extent newex , * ex ; 8
cache_type = ext4_ext_in_cache ( inode , iblock , & newex ); 20
if ( cache_type )  21
if ( cache_type == EXT4_EXT_CACHE_GAP )  22
if ( cache_type == EXT4_EXT_CACHE_EXTENT )  31
allocated = ext4_ext_get_actual_len ( & newex ) - ( iblock - le32_to_cpu ( newex . ee_block ) ); 37
if ( allocated > max_blocks )  225
return err ? err : allocated ; 236
------------------------------
137 /home/SySeVR/data/CVE_2010_3015_PATCHED_ext4_ext_get_blocks.c newblock = iblock - le32_to_cpu ( newex . ee_block ) + ext_pblock ( & newex ) 33
int CVE_2010_3015_PATCHED_ext4_ext_get_blocks(handle_t *handle, struct inode *inode,
ext4_lblk_t iblock,
unsigned int max_blocks, struct buffer_head *bh_result,
int flags) 4
struct ext4_extent newex , * ex ; 8
ext4_fsblk_t newblock ; 9
cache_type = ext4_ext_in_cache ( inode , iblock , & newex ); 20
if ( cache_type )  21
if ( cache_type == EXT4_EXT_CACHE_GAP )  22
if ( cache_type == EXT4_EXT_CACHE_EXTENT )  31
newblock = iblock - le32_to_cpu ( newex . ee_block ) + ext_pblock ( & newex ); 33
bh_result -> b_blocknr = newblock; 230
------------------------------
138 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP.c * ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ) 232
static int CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
int pixel_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
unsigned char * pixels ; 28
int pixel ; 29
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixels = s -> frame . data [ 0 ]; 39
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 81
for (i = 0; i < line_packets; i++) 82
pixel_skip = buf [ stream_ptr ++ ]; 84
pixel_ptr += ( pixel_skip * 2 ); 85
pixel_countdown -= pixel_skip; 86
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 87
if ( byte_run < 0 )  88
byte_run = - byte_run; 89
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 90
stream_ptr += 2; 91
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 93
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 94
pixel_ptr += 2; 95
for (j = 0; j < byte_run; j++, pixel_countdown--) 99
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 100
stream_ptr += 2; 101
pixel_ptr += 2; 102
y_ptr += s -> frame . linesize [ 0 ]; 107
stream_ptr = stream_ptr + chunk_size - 6; 114
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 119
y_ptr = 0; 124
for (lines = 0; lines < s->avctx->height; lines++) 125
pixel_ptr = y_ptr; 126
stream_ptr ++; 129
pixel_countdown = ( s -> avctx -> width * 2 ); 130
while ( pixel_countdown > 0 )  132
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 133
if ( byte_run > 0 )  134
palette_idx1 = buf [ stream_ptr ++ ]; 135
for (j = 0; j < byte_run; j++) 137
pixels [ pixel_ptr ++ ] = palette_idx1; 138
pixel_countdown --; 139
byte_run = - byte_run; 145
for (j = 0; j < byte_run; j++) 147
palette_idx1 = buf [ stream_ptr ++ ]; 148
pixels [ pixel_ptr ++ ] = palette_idx1; 149
pixel_countdown --; 150
pixel_ptr = y_ptr; 164
pixel_countdown = s -> avctx -> width; 165
while ( pixel_countdown > 0 )  166
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 167
pixel_ptr += 2; 168
y_ptr += s -> frame . linesize [ 0 ]; 171
y_ptr = 0; 176
for (lines = 0; lines < s->avctx->height; lines++) 177
pixel_ptr = y_ptr; 178
stream_ptr ++; 181
pixel_countdown = s -> avctx -> width; 182
while ( pixel_countdown > 0 )  184
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 185
if ( byte_run > 0 )  186
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 187
stream_ptr += 2; 188
for (j = 0; j < byte_run; j++) 190
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 191
pixel_ptr += 2; 192
pixel_countdown --; 193
byte_run = - byte_run; 199
for (j = 0; j < byte_run; j++) 201
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 202
stream_ptr += 2; 203
pixel_ptr += 2; 204
pixel_countdown --; 205
y_ptr += s -> frame . linesize [ 0 ]; 213
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  220
stream_ptr += chunk_size - 6; 223
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 227
pixel_countdown = s -> avctx -> width; 229
pixel_ptr = 0; 230
while ( pixel_countdown > 0 )  231
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 232
pixel_ptr += 2; 233
pixel_countdown --; 234
stream_ptr += s -> avctx -> width * 2; 236
stream_ptr += chunk_size - 6; 243
frame_size -= chunk_size; 251
num_chunks --; 252
------------------------------
139 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP.c stream_ptr = stream_ptr + chunk_size - 6 114
static int CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 81
for (i = 0; i < line_packets; i++) 82
pixel_skip = buf [ stream_ptr ++ ]; 84
pixel_ptr += ( pixel_skip * 2 ); 85
pixel_countdown -= pixel_skip; 86
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 87
if ( byte_run < 0 )  88
byte_run = - byte_run; 89
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 90
stream_ptr += 2; 91
CHECK_PIXEL_PTR ( 2 * byte_run ); 92
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 93
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 94
pixel_ptr += 2; 95
CHECK_PIXEL_PTR ( 2 * byte_run ); 98
for (j = 0; j < byte_run; j++, pixel_countdown--) 99
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 100
stream_ptr += 2; 101
pixel_ptr += 2; 102
y_ptr += s -> frame . linesize [ 0 ]; 107
stream_ptr = stream_ptr + chunk_size - 6; 114
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 119
y_ptr = 0; 124
for (lines = 0; lines < s->avctx->height; lines++) 125
pixel_ptr = y_ptr; 126
stream_ptr ++; 129
pixel_countdown = ( s -> avctx -> width * 2 ); 130
while ( pixel_countdown > 0 )  132
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 133
if ( byte_run > 0 )  134
palette_idx1 = buf [ stream_ptr ++ ]; 135
CHECK_PIXEL_PTR ( byte_run ); 136
for (j = 0; j < byte_run; j++) 137
pixels [ pixel_ptr ++ ] = palette_idx1; 138
pixel_countdown --; 139
if ( pixel_countdown < 0 )  140
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) (linea%d)\n" , pixel_countdown , lines ); 141
byte_run = - byte_run; 145
CHECK_PIXEL_PTR ( byte_run ); 146
for (j = 0; j < byte_run; j++) 147
palette_idx1 = buf [ stream_ptr ++ ]; 148
pixels [ pixel_ptr ++ ] = palette_idx1; 149
pixel_countdown --; 150
if ( pixel_countdown < 0 )  151
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 152
pixel_ptr = y_ptr; 164
pixel_countdown = s -> avctx -> width; 165
while ( pixel_countdown > 0 )  166
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 167
pixel_ptr += 2; 168
y_ptr += s -> frame . linesize [ 0 ]; 171
y_ptr = 0; 176
for (lines = 0; lines < s->avctx->height; lines++) 177
pixel_ptr = y_ptr; 178
stream_ptr ++; 181
pixel_countdown = s -> avctx -> width; 182
while ( pixel_countdown > 0 )  184
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 185
if ( byte_run > 0 )  186
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 187
stream_ptr += 2; 188
CHECK_PIXEL_PTR ( 2 * byte_run ); 189
for (j = 0; j < byte_run; j++) 190
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 191
pixel_ptr += 2; 192
pixel_countdown --; 193
if ( pixel_countdown < 0 )  194
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 195
byte_run = - byte_run; 199
CHECK_PIXEL_PTR ( 2 * byte_run ); 200
for (j = 0; j < byte_run; j++) 201
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 202
stream_ptr += 2; 203
pixel_ptr += 2; 204
pixel_countdown --; 205
if ( pixel_countdown < 0 )  206
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 207
y_ptr += s -> frame . linesize [ 0 ]; 213
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  220
av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) "
"bigger than image, skipping chunk\n" , chunk_size - 6 ) 222
stream_ptr += chunk_size - 6; 223
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 227
while ( pixel_countdown > 0 )  231
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 232
pixel_ptr += 2; 233
pixel_countdown --; 234
stream_ptr += s -> avctx -> width * 2; 236
stream_ptr += chunk_size - 6; 243
av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ); 247
frame_size -= chunk_size; 251
num_chunks --; 252
if ( ( stream_ptr != buf_size ) && ( stream_ptr != buf_size - 1 ) )  257
------------------------------
140 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP.c stream_ptr = stream_ptr + chunk_size - 6 63
static int CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 81
for (i = 0; i < line_packets; i++) 82
pixel_skip = buf [ stream_ptr ++ ]; 84
pixel_ptr += ( pixel_skip * 2 ); 85
pixel_countdown -= pixel_skip; 86
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 87
if ( byte_run < 0 )  88
byte_run = - byte_run; 89
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 90
stream_ptr += 2; 91
CHECK_PIXEL_PTR ( 2 * byte_run ); 92
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 93
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 94
pixel_ptr += 2; 95
CHECK_PIXEL_PTR ( 2 * byte_run ); 98
for (j = 0; j < byte_run; j++, pixel_countdown--) 99
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 100
stream_ptr += 2; 101
pixel_ptr += 2; 102
y_ptr += s -> frame . linesize [ 0 ]; 107
stream_ptr = stream_ptr + chunk_size - 6; 114
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 119
y_ptr = 0; 124
for (lines = 0; lines < s->avctx->height; lines++) 125
pixel_ptr = y_ptr; 126
stream_ptr ++; 129
pixel_countdown = ( s -> avctx -> width * 2 ); 130
while ( pixel_countdown > 0 )  132
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 133
if ( byte_run > 0 )  134
palette_idx1 = buf [ stream_ptr ++ ]; 135
CHECK_PIXEL_PTR ( byte_run ); 136
for (j = 0; j < byte_run; j++) 137
pixels [ pixel_ptr ++ ] = palette_idx1; 138
pixel_countdown --; 139
if ( pixel_countdown < 0 )  140
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) (linea%d)\n" , pixel_countdown , lines ); 141
byte_run = - byte_run; 145
CHECK_PIXEL_PTR ( byte_run ); 146
for (j = 0; j < byte_run; j++) 147
palette_idx1 = buf [ stream_ptr ++ ]; 148
pixels [ pixel_ptr ++ ] = palette_idx1; 149
pixel_countdown --; 150
if ( pixel_countdown < 0 )  151
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 152
pixel_ptr = y_ptr; 164
pixel_countdown = s -> avctx -> width; 165
while ( pixel_countdown > 0 )  166
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 167
pixel_ptr += 2; 168
y_ptr += s -> frame . linesize [ 0 ]; 171
y_ptr = 0; 176
for (lines = 0; lines < s->avctx->height; lines++) 177
pixel_ptr = y_ptr; 178
stream_ptr ++; 181
pixel_countdown = s -> avctx -> width; 182
while ( pixel_countdown > 0 )  184
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 185
if ( byte_run > 0 )  186
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 187
stream_ptr += 2; 188
CHECK_PIXEL_PTR ( 2 * byte_run ); 189
for (j = 0; j < byte_run; j++) 190
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 191
pixel_ptr += 2; 192
pixel_countdown --; 193
if ( pixel_countdown < 0 )  194
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 195
byte_run = - byte_run; 199
CHECK_PIXEL_PTR ( 2 * byte_run ); 200
for (j = 0; j < byte_run; j++) 201
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 202
stream_ptr += 2; 203
pixel_ptr += 2; 204
pixel_countdown --; 205
if ( pixel_countdown < 0 )  206
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 207
y_ptr += s -> frame . linesize [ 0 ]; 213
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  220
av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) "
"bigger than image, skipping chunk\n" , chunk_size - 6 ) 222
stream_ptr += chunk_size - 6; 223
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 227
while ( pixel_countdown > 0 )  231
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 232
pixel_ptr += 2; 233
pixel_countdown --; 234
stream_ptr += s -> avctx -> width * 2; 236
stream_ptr += chunk_size - 6; 243
av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ); 247
frame_size -= chunk_size; 251
num_chunks --; 252
if ( ( stream_ptr != buf_size ) && ( stream_ptr != buf_size - 1 ) )  257
------------------------------
141 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP.c pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] 40
static int CVE_2010_3429_PATCHED_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
unsigned int pixel_limit ; 30
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ]; 40
------------------------------
142 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1 130
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int pixel_ptr ; 9
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1; 130
pixels [ pixel_ptr ] = line_packets & 0xff; 132
compressed_lines --; 134
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
for (j = 0; j < byte_run; j++) 231
pixel_countdown --; 233
byte_run = - byte_run; 239
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixel_countdown --; 244
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
frame_size -= chunk_size; 282
num_chunks --; 283
------------------------------
143 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6 65
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
av_log ( avctx , AV_LOG_ERROR , "Undefined opcode (%x) in DELTA_FLI\n" , line_packets ); 127
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1; 130
pixels [ pixel_ptr ] = line_packets & 0xff; 132
compressed_lines --; 134
pixel_ptr = y_ptr; 135
pixel_countdown = s -> avctx -> width; 137
for (i = 0; i < line_packets; i++) 138
pixel_skip = buf [ stream_ptr ++ ]; 140
pixel_ptr += pixel_skip; 141
pixel_countdown -= pixel_skip; 142
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 143
if ( byte_run < 0 )  144
byte_run = - byte_run; 145
palette_idx1 = buf [ stream_ptr ++ ]; 146
palette_idx2 = buf [ stream_ptr ++ ]; 147
CHECK_PIXEL_PTR ( byte_run * 2 ); 148
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 149
pixels [ pixel_ptr ++ ] = palette_idx1; 150
pixels [ pixel_ptr ++ ] = palette_idx2; 151
CHECK_PIXEL_PTR ( byte_run * 2 ); 154
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 155
palette_idx1 = buf [ stream_ptr ++ ]; 156
pixels [ pixel_ptr ++ ] = palette_idx1; 157
y_ptr += s -> frame . linesize [ 0 ]; 162
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 169
stream_ptr += 2; 170
y_ptr = 0; 171
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 172
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 174
stream_ptr += 2; 175
while ( compressed_lines > 0 )  176
pixel_ptr = y_ptr; 177
pixel_countdown = s -> avctx -> width; 179
line_packets = buf [ stream_ptr ++ ]; 180
if ( line_packets > 0 )  181
for (i = 0; i < line_packets; i++) 182
pixel_skip = buf [ stream_ptr ++ ]; 184
pixel_ptr += pixel_skip; 185
pixel_countdown -= pixel_skip; 186
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 187
if ( byte_run > 0 )  188
CHECK_PIXEL_PTR ( byte_run ); 189
for (j = 0; j < byte_run; j++, pixel_countdown--) 190
palette_idx1 = buf [ stream_ptr ++ ]; 191
pixels [ pixel_ptr ++ ] = palette_idx1; 192
if ( byte_run < 0 )  194
byte_run = - byte_run; 195
palette_idx1 = buf [ stream_ptr ++ ]; 196
CHECK_PIXEL_PTR ( byte_run ); 197
for (j = 0; j < byte_run; j++, pixel_countdown--) 198
pixels [ pixel_ptr ++ ] = palette_idx1; 199
y_ptr += s -> frame . linesize [ 0 ]; 205
compressed_lines --; 206
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 212
y_ptr = 0; 219
for (lines = 0; lines < s->avctx->height; lines++) 220
pixel_ptr = y_ptr; 221
stream_ptr ++; 224
pixel_countdown = s -> avctx -> width; 225
while ( pixel_countdown > 0 )  226
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 227
if ( byte_run > 0 )  228
palette_idx1 = buf [ stream_ptr ++ ]; 229
CHECK_PIXEL_PTR ( byte_run ); 230
for (j = 0; j < byte_run; j++) 231
pixels [ pixel_ptr ++ ] = palette_idx1; 232
pixel_countdown --; 233
if ( pixel_countdown < 0 )  234
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 235
byte_run = - byte_run; 239
CHECK_PIXEL_PTR ( byte_run ); 240
for (j = 0; j < byte_run; j++) 241
palette_idx1 = buf [ stream_ptr ++ ]; 242
pixels [ pixel_ptr ++ ] = palette_idx1; 243
pixel_countdown --; 244
if ( pixel_countdown < 0 )  245
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 246
y_ptr += s -> frame . linesize [ 0 ]; 252
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  258
av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) "
"bigger than image, skipping chunk\n" , chunk_size - 6 ) 260
stream_ptr += chunk_size - 6; 261
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 264
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 265
stream_ptr += s -> avctx -> width; 267
stream_ptr += chunk_size - 6; 274
av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ); 278
frame_size -= chunk_size; 282
num_chunks --; 283
if ( ( stream_ptr != buf_size ) && ( stream_ptr != buf_size - 1 ) )  288
memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ); 293
if ( s -> new_palette )  294
s -> frame . palette_has_changed = 1; 295
s -> new_palette = 0; 296
* ( AVFrame * ) data = s -> frame; 300
------------------------------
144 /home/SySeVR/data/CVE_2010_3429_PATCHED_flic_decode_frame_8BPP.c pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] 46
static int CVE_2010_3429_PATCHED_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
unsigned int pixel_limit ; 36
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ]; 46
------------------------------
145 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_15_16BPP.c * ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ) 231
static int CVE_2010_3429_VULN_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
int pixel_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
unsigned char * pixels ; 28
int pixel ; 29
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixels = s -> frame . data [ 0 ]; 39
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 80
for (i = 0; i < line_packets; i++) 81
pixel_skip = buf [ stream_ptr ++ ]; 83
pixel_ptr += ( pixel_skip * 2 ); 84
pixel_countdown -= pixel_skip; 85
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 86
if ( byte_run < 0 )  87
byte_run = - byte_run; 88
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 89
stream_ptr += 2; 90
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 92
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 93
pixel_ptr += 2; 94
for (j = 0; j < byte_run; j++, pixel_countdown--) 98
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 99
stream_ptr += 2; 100
pixel_ptr += 2; 101
y_ptr += s -> frame . linesize [ 0 ]; 106
stream_ptr = stream_ptr + chunk_size - 6; 113
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 118
y_ptr = 0; 123
for (lines = 0; lines < s->avctx->height; lines++) 124
pixel_ptr = y_ptr; 125
stream_ptr ++; 128
pixel_countdown = ( s -> avctx -> width * 2 ); 129
while ( pixel_countdown > 0 )  131
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 132
if ( byte_run > 0 )  133
palette_idx1 = buf [ stream_ptr ++ ]; 134
for (j = 0; j < byte_run; j++) 136
pixels [ pixel_ptr ++ ] = palette_idx1; 137
pixel_countdown --; 138
byte_run = - byte_run; 144
for (j = 0; j < byte_run; j++) 146
palette_idx1 = buf [ stream_ptr ++ ]; 147
pixels [ pixel_ptr ++ ] = palette_idx1; 148
pixel_countdown --; 149
pixel_ptr = y_ptr; 163
pixel_countdown = s -> avctx -> width; 164
while ( pixel_countdown > 0 )  165
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 166
pixel_ptr += 2; 167
y_ptr += s -> frame . linesize [ 0 ]; 170
y_ptr = 0; 175
for (lines = 0; lines < s->avctx->height; lines++) 176
pixel_ptr = y_ptr; 177
stream_ptr ++; 180
pixel_countdown = s -> avctx -> width; 181
while ( pixel_countdown > 0 )  183
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 184
if ( byte_run > 0 )  185
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 186
stream_ptr += 2; 187
for (j = 0; j < byte_run; j++) 189
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 190
pixel_ptr += 2; 191
pixel_countdown --; 192
byte_run = - byte_run; 198
for (j = 0; j < byte_run; j++) 200
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 201
stream_ptr += 2; 202
pixel_ptr += 2; 203
pixel_countdown --; 204
y_ptr += s -> frame . linesize [ 0 ]; 212
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  219
stream_ptr += chunk_size - 6; 222
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 226
pixel_countdown = s -> avctx -> width; 228
pixel_ptr = 0; 229
while ( pixel_countdown > 0 )  230
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 231
pixel_ptr += 2; 232
pixel_countdown --; 233
stream_ptr += s -> avctx -> width * 2; 235
stream_ptr += chunk_size - 6; 242
frame_size -= chunk_size; 250
num_chunks --; 251
------------------------------
146 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_15_16BPP.c stream_ptr = stream_ptr + chunk_size - 6 113
static int CVE_2010_3429_VULN_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 80
for (i = 0; i < line_packets; i++) 81
pixel_skip = buf [ stream_ptr ++ ]; 83
pixel_ptr += ( pixel_skip * 2 ); 84
pixel_countdown -= pixel_skip; 85
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 86
if ( byte_run < 0 )  87
byte_run = - byte_run; 88
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 89
stream_ptr += 2; 90
CHECK_PIXEL_PTR ( byte_run ); 91
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 92
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 93
pixel_ptr += 2; 94
CHECK_PIXEL_PTR ( byte_run ); 97
for (j = 0; j < byte_run; j++, pixel_countdown--) 98
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 99
stream_ptr += 2; 100
pixel_ptr += 2; 101
y_ptr += s -> frame . linesize [ 0 ]; 106
stream_ptr = stream_ptr + chunk_size - 6; 113
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 118
y_ptr = 0; 123
for (lines = 0; lines < s->avctx->height; lines++) 124
pixel_ptr = y_ptr; 125
stream_ptr ++; 128
pixel_countdown = ( s -> avctx -> width * 2 ); 129
while ( pixel_countdown > 0 )  131
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 132
if ( byte_run > 0 )  133
palette_idx1 = buf [ stream_ptr ++ ]; 134
CHECK_PIXEL_PTR ( byte_run ); 135
for (j = 0; j < byte_run; j++) 136
pixels [ pixel_ptr ++ ] = palette_idx1; 137
pixel_countdown --; 138
if ( pixel_countdown < 0 )  139
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) (linea%d)\n" , pixel_countdown , lines ); 140
byte_run = - byte_run; 144
CHECK_PIXEL_PTR ( byte_run ); 145
for (j = 0; j < byte_run; j++) 146
palette_idx1 = buf [ stream_ptr ++ ]; 147
pixels [ pixel_ptr ++ ] = palette_idx1; 148
pixel_countdown --; 149
if ( pixel_countdown < 0 )  150
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 151
pixel_ptr = y_ptr; 163
pixel_countdown = s -> avctx -> width; 164
while ( pixel_countdown > 0 )  165
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 166
pixel_ptr += 2; 167
y_ptr += s -> frame . linesize [ 0 ]; 170
y_ptr = 0; 175
for (lines = 0; lines < s->avctx->height; lines++) 176
pixel_ptr = y_ptr; 177
stream_ptr ++; 180
pixel_countdown = s -> avctx -> width; 181
while ( pixel_countdown > 0 )  183
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 184
if ( byte_run > 0 )  185
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 186
stream_ptr += 2; 187
CHECK_PIXEL_PTR ( byte_run ); 188
for (j = 0; j < byte_run; j++) 189
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 190
pixel_ptr += 2; 191
pixel_countdown --; 192
if ( pixel_countdown < 0 )  193
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 194
byte_run = - byte_run; 198
CHECK_PIXEL_PTR ( byte_run ); 199
for (j = 0; j < byte_run; j++) 200
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 201
stream_ptr += 2; 202
pixel_ptr += 2; 203
pixel_countdown --; 204
if ( pixel_countdown < 0 )  205
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 206
y_ptr += s -> frame . linesize [ 0 ]; 212
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  219
av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) "
"bigger than image, skipping chunk\n" , chunk_size - 6 ) 221
stream_ptr += chunk_size - 6; 222
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 226
while ( pixel_countdown > 0 )  230
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 231
pixel_ptr += 2; 232
pixel_countdown --; 233
stream_ptr += s -> avctx -> width * 2; 235
stream_ptr += chunk_size - 6; 242
av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ); 246
frame_size -= chunk_size; 250
num_chunks --; 251
if ( ( stream_ptr != buf_size ) && ( stream_ptr != buf_size - 1 ) )  256
------------------------------
147 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_15_16BPP.c stream_ptr = stream_ptr + chunk_size - 6 63
static int CVE_2010_3429_VULN_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int stream_ptr = 0 ; 9
unsigned char palette_idx1 ; 11
unsigned int frame_size ; 13
int num_chunks ; 14
unsigned int chunk_size ; 16
int chunk_type ; 17
int i , j ; 19
int lines ; 21
int compressed_lines ; 22
signed short line_packets ; 23
int y_ptr ; 24
int byte_run ; 25
int pixel_skip ; 26
int pixel_countdown ; 27
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 42
stream_ptr += 6; 43
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 44
stream_ptr += 10; 45
frame_size -= 16; 47
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  50
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 51
stream_ptr += 4; 52
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 53
stream_ptr += 2; 54
switch ( chunk_type )  56
stream_ptr = stream_ptr + chunk_size - 6; 63
y_ptr = 0; 68
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 69
stream_ptr += 2; 70
while ( compressed_lines > 0 )  71
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 72
stream_ptr += 2; 73
if ( line_packets < 0 )  74
line_packets = - line_packets; 75
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 76
compressed_lines --; 78
pixel_ptr = y_ptr; 79
pixel_countdown = s -> avctx -> width; 80
for (i = 0; i < line_packets; i++) 81
pixel_skip = buf [ stream_ptr ++ ]; 83
pixel_ptr += ( pixel_skip * 2 ); 84
pixel_countdown -= pixel_skip; 85
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 86
if ( byte_run < 0 )  87
byte_run = - byte_run; 88
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 89
stream_ptr += 2; 90
CHECK_PIXEL_PTR ( byte_run ); 91
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 92
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 93
pixel_ptr += 2; 94
CHECK_PIXEL_PTR ( byte_run ); 97
for (j = 0; j < byte_run; j++, pixel_countdown--) 98
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 99
stream_ptr += 2; 100
pixel_ptr += 2; 101
y_ptr += s -> frame . linesize [ 0 ]; 106
stream_ptr = stream_ptr + chunk_size - 6; 113
memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 118
y_ptr = 0; 123
for (lines = 0; lines < s->avctx->height; lines++) 124
pixel_ptr = y_ptr; 125
stream_ptr ++; 128
pixel_countdown = ( s -> avctx -> width * 2 ); 129
while ( pixel_countdown > 0 )  131
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 132
if ( byte_run > 0 )  133
palette_idx1 = buf [ stream_ptr ++ ]; 134
CHECK_PIXEL_PTR ( byte_run ); 135
for (j = 0; j < byte_run; j++) 136
pixels [ pixel_ptr ++ ] = palette_idx1; 137
pixel_countdown --; 138
if ( pixel_countdown < 0 )  139
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) (linea%d)\n" , pixel_countdown , lines ); 140
byte_run = - byte_run; 144
CHECK_PIXEL_PTR ( byte_run ); 145
for (j = 0; j < byte_run; j++) 146
palette_idx1 = buf [ stream_ptr ++ ]; 147
pixels [ pixel_ptr ++ ] = palette_idx1; 148
pixel_countdown --; 149
if ( pixel_countdown < 0 )  150
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 151
pixel_ptr = y_ptr; 163
pixel_countdown = s -> avctx -> width; 164
while ( pixel_countdown > 0 )  165
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ); 166
pixel_ptr += 2; 167
y_ptr += s -> frame . linesize [ 0 ]; 170
y_ptr = 0; 175
for (lines = 0; lines < s->avctx->height; lines++) 176
pixel_ptr = y_ptr; 177
stream_ptr ++; 180
pixel_countdown = s -> avctx -> width; 181
while ( pixel_countdown > 0 )  183
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 184
if ( byte_run > 0 )  185
pixel = AV_RL16 ( & buf [ stream_ptr ] ); 186
stream_ptr += 2; 187
CHECK_PIXEL_PTR ( byte_run ); 188
for (j = 0; j < byte_run; j++) 189
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel; 190
pixel_ptr += 2; 191
pixel_countdown --; 192
if ( pixel_countdown < 0 )  193
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 194
byte_run = - byte_run; 198
CHECK_PIXEL_PTR ( byte_run ); 199
for (j = 0; j < byte_run; j++) 200
* ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr ] ); 201
stream_ptr += 2; 202
pixel_ptr += 2; 203
pixel_countdown --; 204
if ( pixel_countdown < 0 )  205
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d)\n" , pixel_countdown ); 206
y_ptr += s -> frame . linesize [ 0 ]; 212
if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 )  219
av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) "
"bigger than image, skipping chunk\n" , chunk_size - 6 ) 221
stream_ptr += chunk_size - 6; 222
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 226
while ( pixel_countdown > 0 )  230
* ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = AV_RL16 ( & buf [ stream_ptr + pixel_ptr ] ); 231
pixel_ptr += 2; 232
pixel_countdown --; 233
stream_ptr += s -> avctx -> width * 2; 235
stream_ptr += chunk_size - 6; 242
av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ); 246
frame_size -= chunk_size; 250
num_chunks --; 251
if ( ( stream_ptr != buf_size ) && ( stream_ptr != buf_size - 1 ) )  256
------------------------------
148 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_15_16BPP.c pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] 40
static int CVE_2010_3429_VULN_flic_decode_frame_15_16BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 7
int pixel_limit ; 30
s -> frame . reference = 1; 32
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 33
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  34
pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ]; 40
------------------------------
149 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6 65
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int stream_ptr = 0 ; 7
int stream_ptr_after_color_chunk ; 8
int palette_ptr ; 10
unsigned char palette_idx1 ; 11
unsigned char palette_idx2 ; 12
unsigned int frame_size ; 14
int num_chunks ; 15
unsigned int chunk_size ; 17
int chunk_type ; 18
int i , j ; 20
int color_packets ; 22
int color_changes ; 23
int color_shift ; 24
unsigned char r , g , b ; 25
int lines ; 27
int compressed_lines ; 28
int starting_line ; 29
signed short line_packets ; 30
int y_ptr ; 31
int byte_run ; 32
int pixel_skip ; 33
int pixel_countdown ; 34
unsigned char * pixels ; 35
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixels = s -> frame . data [ 0 ]; 45
frame_size = AV_RL32 ( & buf [ stream_ptr ] ); 48
stream_ptr += 6; 49
num_chunks = AV_RL16 ( & buf [ stream_ptr ] ); 50
stream_ptr += 10; 51
frame_size -= 16; 53
while ( ( frame_size > 0 ) && ( num_chunks > 0 ) )  56
chunk_size = AV_RL32 ( & buf [ stream_ptr ] ); 57
stream_ptr += 4; 58
chunk_type = AV_RL16 ( & buf [ stream_ptr ] ); 59
stream_ptr += 2; 60
switch ( chunk_type )  62
stream_ptr_after_color_chunk = stream_ptr + chunk_size - 6; 65
if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) )  71
color_shift = 0; 72
color_shift = 2; 74
color_packets = AV_RL16 ( & buf [ stream_ptr ] ); 76
stream_ptr += 2; 77
palette_ptr = 0; 78
for (i = 0; i < color_packets; i++) 79
palette_ptr += buf [ stream_ptr ++ ]; 81
color_changes = buf [ stream_ptr ++ ]; 84
if ( color_changes == 0 )  87
color_changes = 256; 88
for (j = 0; j < color_changes; j++) 90
unsigned int entry ; 91
if ( ( unsigned ) palette_ptr >= 256 )  94
palette_ptr = 0; 95
r = buf [ stream_ptr ++ ] << color_shift; 97
g = buf [ stream_ptr ++ ] << color_shift; 98
b = buf [ stream_ptr ++ ] << color_shift; 99
entry = ( r << 16 ) | ( g << 8 ) | b; 100
if ( s -> palette [ palette_ptr ] != entry )  101
s -> new_palette = 1; 102
s -> palette [ palette_ptr ++ ] = entry; 103
stream_ptr = stream_ptr_after_color_chunk; 111
y_ptr = 0; 116
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 117
stream_ptr += 2; 118
while ( compressed_lines > 0 )  119
line_packets = AV_RL16 ( & buf [ stream_ptr ] ); 120
stream_ptr += 2; 121
if ( ( line_packets & 0xC000 ) == 0xC000 )  122
line_packets = - line_packets; 124
y_ptr += line_packets * s -> frame . linesize [ 0 ]; 125
if ( ( line_packets & 0xC000 ) == 0x4000 )  126
av_log ( avctx , AV_LOG_ERROR , "Undefined opcode (%x) in DELTA_FLI\n" , line_packets ); 127
if ( ( line_packets & 0xC000 ) == 0x8000 )  128
pixels [ y_ptr + s -> frame . linesize [ 0 ] - 1 ] = line_packets & 0xff; 130
compressed_lines --; 132
pixel_ptr = y_ptr; 133
pixel_countdown = s -> avctx -> width; 134
for (i = 0; i < line_packets; i++) 135
pixel_skip = buf [ stream_ptr ++ ]; 137
pixel_ptr += pixel_skip; 138
pixel_countdown -= pixel_skip; 139
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 140
if ( byte_run < 0 )  141
byte_run = - byte_run; 142
palette_idx1 = buf [ stream_ptr ++ ]; 143
palette_idx2 = buf [ stream_ptr ++ ]; 144
CHECK_PIXEL_PTR ( byte_run ); 145
for (j = 0; j < byte_run; j++, pixel_countdown -= 2) 146
pixels [ pixel_ptr ++ ] = palette_idx1; 147
pixels [ pixel_ptr ++ ] = palette_idx2; 148
CHECK_PIXEL_PTR ( byte_run * 2 ); 151
for (j = 0; j < byte_run * 2; j++, pixel_countdown--) 152
palette_idx1 = buf [ stream_ptr ++ ]; 153
pixels [ pixel_ptr ++ ] = palette_idx1; 154
y_ptr += s -> frame . linesize [ 0 ]; 159
starting_line = AV_RL16 ( & buf [ stream_ptr ] ); 166
stream_ptr += 2; 167
y_ptr = 0; 168
y_ptr += starting_line * s -> frame . linesize [ 0 ]; 169
compressed_lines = AV_RL16 ( & buf [ stream_ptr ] ); 171
stream_ptr += 2; 172
while ( compressed_lines > 0 )  173
pixel_ptr = y_ptr; 174
pixel_countdown = s -> avctx -> width; 175
line_packets = buf [ stream_ptr ++ ]; 176
if ( line_packets > 0 )  177
for (i = 0; i < line_packets; i++) 178
pixel_skip = buf [ stream_ptr ++ ]; 180
pixel_ptr += pixel_skip; 181
pixel_countdown -= pixel_skip; 182
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 183
if ( byte_run > 0 )  184
CHECK_PIXEL_PTR ( byte_run ); 185
for (j = 0; j < byte_run; j++, pixel_countdown--) 186
palette_idx1 = buf [ stream_ptr ++ ]; 187
pixels [ pixel_ptr ++ ] = palette_idx1; 188
if ( byte_run < 0 )  190
byte_run = - byte_run; 191
palette_idx1 = buf [ stream_ptr ++ ]; 192
CHECK_PIXEL_PTR ( byte_run ); 193
for (j = 0; j < byte_run; j++, pixel_countdown--) 194
pixels [ pixel_ptr ++ ] = palette_idx1; 195
y_ptr += s -> frame . linesize [ 0 ]; 201
compressed_lines --; 202
memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ); 208
y_ptr = 0; 215
for (lines = 0; lines < s->avctx->height; lines++) 216
pixel_ptr = y_ptr; 217
stream_ptr ++; 220
pixel_countdown = s -> avctx -> width; 221
while ( pixel_countdown > 0 )  222
byte_run = ( signed char ) ( buf [ stream_ptr ++ ] ); 223
if ( byte_run > 0 )  224
palette_idx1 = buf [ stream_ptr ++ ]; 225
CHECK_PIXEL_PTR ( byte_run ); 226
for (j = 0; j < byte_run; j++) 227
pixels [ pixel_ptr ++ ] = palette_idx1; 228
pixel_countdown --; 229
if ( pixel_countdown < 0 )  230
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 231
byte_run = - byte_run; 235
CHECK_PIXEL_PTR ( byte_run ); 236
for (j = 0; j < byte_run; j++) 237
palette_idx1 = buf [ stream_ptr ++ ]; 238
pixels [ pixel_ptr ++ ] = palette_idx1; 239
pixel_countdown --; 240
if ( pixel_countdown < 0 )  241
av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ); 242
y_ptr += s -> frame . linesize [ 0 ]; 248
if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height )  254
av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) "
"bigger than image, skipping chunk\n" , chunk_size - 6 ) 256
stream_ptr += chunk_size - 6; 257
for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;
y_ptr += s->frame.linesize[0]) 260
memcpy ( & pixels [ y_ptr ] , & buf [ stream_ptr ] , s -> avctx -> width ); 261
stream_ptr += s -> avctx -> width; 263
stream_ptr += chunk_size - 6; 270
av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ); 274
frame_size -= chunk_size; 278
num_chunks --; 279
if ( ( stream_ptr != buf_size ) && ( stream_ptr != buf_size - 1 ) )  284
memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ); 289
if ( s -> new_palette )  290
s -> frame . palette_has_changed = 1; 291
s -> new_palette = 0; 292
* ( AVFrame * ) data = s -> frame; 296
------------------------------
150 /home/SySeVR/data/CVE_2010_3429_VULN_flic_decode_frame_8BPP.c pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] 46
static int CVE_2010_3429_VULN_flic_decode_frame_8BPP(AVCodecContext *avctx,
void *data, int *data_size,
const uint8_t *buf, int buf_size) 3
FlicDecodeContext * s = avctx -> priv_data ; 5
int pixel_limit ; 36
s -> frame . reference = 1; 38
s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; 39
if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 )  40
pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ]; 46
------------------------------
151 /home/SySeVR/data/CVE_2010_3848_PATCHED_econet_sendmsg.c skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ) 81
static int CVE_2010_3848_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sk_buff * skb ; 11
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( dev -> type == ARPHRD_ECONET )  68
if ( len + 15 > dev -> mtu )  74
skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ); 81
if ( skb == NULL )  83
skb_reserve ( skb , LL_RESERVED_SPACE ( dev ) ); 86
skb_reset_network_header ( skb ); 87
eb = ( struct ec_cb * ) & skb -> cb; 89
eb -> cookie = saddr -> cookie; 92
eb -> sec = * saddr; 93
eb -> sent = ec_tx_done; 94
res = dev_hard_header ( skb , dev , ntohs ( proto ) , & addr , NULL , len ); 97
if ( res < 0 )  98
if ( res > 0 )  100
fh = ( struct ec_framehdr * ) ( skb -> data ); 104
fh -> cb = cb; 105
fh -> port = port; 106
skb_reset_tail_pointer ( skb ); 108
skb -> len = 0; 109
err = memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ); 114
skb -> protocol = proto; 115
skb -> dev = dev; 116
skb -> priority = sk -> sk_priority; 117
if ( err )  118
dev_queue_xmit ( skb ); 129
kfree_skb ( skb ); 135
return err ; 144
------------------------------
152 /home/SySeVR/data/CVE_2010_3848_VULN_econet_sendmsg.c skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ) 81
static int CVE_2010_3848_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sk_buff * skb ; 11
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( len + 15 > dev -> mtu )  68
if ( dev -> type == ARPHRD_ECONET )  73
skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ); 81
if ( skb == NULL )  83
skb_reserve ( skb , LL_RESERVED_SPACE ( dev ) ); 86
skb_reset_network_header ( skb ); 87
eb = ( struct ec_cb * ) & skb -> cb; 89
eb -> cookie = saddr -> cookie; 92
eb -> sec = * saddr; 93
eb -> sent = ec_tx_done; 94
res = dev_hard_header ( skb , dev , ntohs ( proto ) , & addr , NULL , len ); 97
if ( res < 0 )  98
if ( res > 0 )  100
fh = ( struct ec_framehdr * ) ( skb -> data ); 104
fh -> cb = cb; 105
fh -> port = port; 106
skb_reset_tail_pointer ( skb ); 108
skb -> len = 0; 109
err = memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ); 114
skb -> protocol = proto; 115
skb -> dev = dev; 116
skb -> priority = sk -> sk_priority; 117
if ( err )  118
dev_queue_xmit ( skb ); 129
kfree_skb ( skb ); 135
return err ; 144
if ( ( skb = sock_alloc_send_skb ( sk , 0 , msg -> msg_flags & MSG_DONTWAIT , & err ) ) == NULL )  210
return err ; 214
eb = ( struct ec_cb * ) & skb -> cb; 217
eb -> cookie = saddr -> cookie; 219
eb -> timeout = ( 5 * HZ ); 220
eb -> start = jiffies; 221
eb -> seq = ( aun_seq ++ ); 223
eb -> sec = * saddr; 224
skb_queue_tail ( & aun_queue , skb ); 226
return err ; 244
------------------------------
153 /home/SySeVR/data/CVE_2010_3849_PATCHED_econet_sendmsg.c skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ) 72
static int CVE_2010_3849_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sk_buff * skb ; 11
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL || msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  37
addr . station = saddr -> addr . station; 41
addr . net = saddr -> addr . net; 42
dev = net2dev_map [ addr . net ]; 47
if ( dev == NULL )  50
dev = net2dev_map [ 0 ]; 51
if ( dev == NULL )  53
if ( len + 15 > dev -> mtu )  59
if ( dev -> type == ARPHRD_ECONET )  64
skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ); 72
if ( skb == NULL )  74
skb_reserve ( skb , LL_RESERVED_SPACE ( dev ) ); 77
skb_reset_network_header ( skb ); 78
eb = ( struct ec_cb * ) & skb -> cb; 80
eb -> cookie = saddr -> cookie; 82
eb -> sec = * saddr; 83
eb -> sent = ec_tx_done; 84
res = dev_hard_header ( skb , dev , ntohs ( proto ) , & addr , NULL , len ); 87
if ( res < 0 )  88
if ( res > 0 )  90
fh = ( struct ec_framehdr * ) ( skb -> data ); 94
fh -> cb = cb; 95
fh -> port = port; 96
skb_reset_tail_pointer ( skb ); 98
skb -> len = 0; 99
err = memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ); 104
skb -> protocol = proto; 105
skb -> dev = dev; 106
skb -> priority = sk -> sk_priority; 107
if ( err )  108
dev_queue_xmit ( skb ); 119
kfree_skb ( skb ); 125
return err ; 134
if ( ( skb = sock_alloc_send_skb ( sk , 0 , msg -> msg_flags & MSG_DONTWAIT , & err ) ) == NULL )  200
return err ; 204
eb = ( struct ec_cb * ) & skb -> cb; 207
eb -> cookie = saddr -> cookie; 209
eb -> timeout = ( 5 * HZ ); 210
eb -> start = jiffies; 211
eb -> seq = ( aun_seq ++ ); 213
eb -> sec = * saddr; 214
skb_queue_tail ( & aun_queue , skb ); 216
return err ; 234
------------------------------
154 /home/SySeVR/data/CVE_2010_3849_VULN_econet_sendmsg.c skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ) 81
static int CVE_2010_3849_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct sock * sk = sock -> sk ; 4
struct sockaddr_ec * saddr = ( struct sockaddr_ec * ) msg -> msg_name ; 5
struct net_device * dev ; 6
struct ec_addr addr ; 7
struct sk_buff * skb ; 11
if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) )  28
if ( saddr == NULL )  37
struct econet_sock * eo = ec_sk ( sk ) ; 38
addr . station = eo -> station; 40
addr . net = eo -> net; 41
if ( msg -> msg_namelen < sizeof ( struct sockaddr_ec ) )  45
addr . station = saddr -> addr . station; 49
addr . net = saddr -> addr . net; 50
dev = net2dev_map [ addr . net ]; 56
if ( dev == NULL )  59
dev = net2dev_map [ 0 ]; 60
if ( dev == NULL )  62
if ( len + 15 > dev -> mtu )  68
if ( dev -> type == ARPHRD_ECONET )  73
skb = sock_alloc_send_skb ( sk , len + LL_ALLOCATED_SPACE ( dev ) , msg -> msg_flags & MSG_DONTWAIT , & err ); 81
if ( skb == NULL )  83
skb_reserve ( skb , LL_RESERVED_SPACE ( dev ) ); 86
skb_reset_network_header ( skb ); 87
eb = ( struct ec_cb * ) & skb -> cb; 89
eb -> cookie = saddr -> cookie; 92
eb -> sec = * saddr; 93
eb -> sent = ec_tx_done; 94
res = dev_hard_header ( skb , dev , ntohs ( proto ) , & addr , NULL , len ); 97
if ( res < 0 )  98
if ( res > 0 )  100
fh = ( struct ec_framehdr * ) ( skb -> data ); 104
fh -> cb = cb; 105
fh -> port = port; 106
skb_reset_tail_pointer ( skb ); 108
skb -> len = 0; 109
err = memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ); 114
skb -> protocol = proto; 115
skb -> dev = dev; 116
skb -> priority = sk -> sk_priority; 117
if ( err )  118
dev_queue_xmit ( skb ); 129
kfree_skb ( skb ); 135
return err ; 144
------------------------------
155 /home/SySeVR/data/CVE_2010_3859_PATCHED_verify_iovec.c len = INT_MAX - err 28
int CVE_2010_3859_PATCHED_verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode) 1
int size , ct , err ; 3
if ( m -> msg_namelen )  5
if ( mode == VERIFY_READ )  6
err = move_addr_to_kernel ( m -> msg_name , m -> msg_namelen , address ); 7
if ( err < 0 )  9
m -> msg_name = address; 12
m -> msg_name = NULL; 14
size = m -> msg_iovlen * sizeof ( struct iovec ); 17
if ( copy_from_user ( iov , m -> msg_iov , size ) )  18
m -> msg_iov = iov; 21
err = 0; 22
for (ct = 0; ct < m->msg_iovlen; ct++) 24
size_t len = iov [ ct ] . iov_len ; 25
if ( len > INT_MAX - err )  27
len = INT_MAX - err; 28
iov [ ct ] . iov_len = len; 29
err += len; 31
return err ; 34
------------------------------
156 /home/SySeVR/data/CVE_2010_3859_PATCHED_verify_iovec.c size = m -> msg_iovlen * sizeof ( struct iovec ) 17
int CVE_2010_3859_PATCHED_verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode) 1
int size , ct , err ; 3
if ( m -> msg_namelen )  5
if ( mode == VERIFY_READ )  6
err = move_addr_to_kernel ( m -> msg_name , m -> msg_namelen , address ); 7
if ( err < 0 )  9
m -> msg_name = address; 12
m -> msg_name = NULL; 14
size = m -> msg_iovlen * sizeof ( struct iovec ); 17
if ( copy_from_user ( iov , m -> msg_iov , size ) )  18
------------------------------
157 /home/SySeVR/data/CVE_2010_3859_VULN_tipc_msg_build.c res = ! copy_from_user ( ( * buf ) -> data + pos , msg_sect [ cnt ] . iov_base , msg_sect [ cnt ] . iov_len ) 27
int CVE_2010_3859_VULN_tipc_msg_build(struct tipc_msg *hdr,
struct iovec const *msg_sect, u32 num_sect,
int max_size, int usrmem, struct sk_buff** buf) 3
int dsz , sz , hsz , pos , res , cnt ; 5
dsz = tipc_msg_calc_data_size ( msg_sect , num_sect ); 7
if ( unlikely ( dsz > TIPC_MAX_USER_MSG_SIZE ) )  8
pos = hsz = msg_hdr_sz ( hdr ); 13
sz = hsz + dsz; 14
if ( unlikely ( sz > max_size ) )  16
* buf = buf_acquire ( sz ); 21
if ( ! ( * buf ) )  22
for (res = 1, cnt = 0; res && (cnt < num_sect); cnt++) 25
if ( likely ( usrmem ) )  26
res = ! copy_from_user ( ( * buf ) -> data + pos , msg_sect [ cnt ] . iov_base , msg_sect [ cnt ] . iov_len ); 27
pos += msg_sect [ cnt ] . iov_len; 34
if ( likely ( res ) )  36
------------------------------
158 /home/SySeVR/data/CVE_2010_3859_VULN_tipc_msg_build.c sz = hsz + dsz 14
int CVE_2010_3859_VULN_tipc_msg_build(struct tipc_msg *hdr,
struct iovec const *msg_sect, u32 num_sect,
int max_size, int usrmem, struct sk_buff** buf) 3
int dsz , sz , hsz , pos , res , cnt ; 5
dsz = tipc_msg_calc_data_size ( msg_sect , num_sect ); 7
if ( unlikely ( dsz > TIPC_MAX_USER_MSG_SIZE ) )  8
pos = hsz = msg_hdr_sz ( hdr ); 13
sz = hsz + dsz; 14
msg_set_size ( hdr , sz ); 15
if ( unlikely ( sz > max_size ) )  16
* buf = buf_acquire ( sz ); 21
if ( ! ( * buf ) )  22
skb_copy_to_linear_data ( * buf , hdr , hsz ); 24
for (res = 1, cnt = 0; res && (cnt < num_sect); cnt++) 25
res = ! copy_from_user ( ( * buf ) -> data + pos , msg_sect [ cnt ] . iov_base , msg_sect [ cnt ] . iov_len ); 27
skb_copy_to_linear_data_offset ( * buf , pos , msg_sect [ cnt ] . iov_base , msg_sect [ cnt ] . iov_len ); 31
if ( likely ( res ) )  36
buf_discard ( * buf ); 39
* buf = NULL; 40
------------------------------
159 /home/SySeVR/data/CVE_2010_3859_VULN_verify_iovec.c size = m -> msg_iovlen * sizeof ( struct iovec ) 18
long CVE_2010_3859_VULN_verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode) 1
int size , ct ; 3
long err ; 4
if ( m -> msg_namelen )  6
if ( mode == VERIFY_READ )  7
err = move_addr_to_kernel ( m -> msg_name , m -> msg_namelen , address ); 8
if ( err < 0 )  10
m -> msg_name = address; 13
m -> msg_name = NULL; 15
size = m -> msg_iovlen * sizeof ( struct iovec ); 18
if ( copy_from_user ( iov , m -> msg_iov , size ) )  19
------------------------------
160 /home/SySeVR/data/CVE_2010_3904_PATCHED_rds_page_copy_user.c ret = copy_from_user ( addr + offset , ptr , bytes ) 14
int CVE_2010_3904_PATCHED_rds_page_copy_user(struct page *page, unsigned long offset,
void __user *ptr, unsigned long bytes,
int to_user) 3
unsigned long ret ; 5
void * addr ; 6
addr = kmap ( page ); 8
if ( to_user )  9
ret = copy_from_user ( addr + offset , ptr , bytes ); 14
return ret ? - EFAULT : 0 ; 18
------------------------------
161 /home/SySeVR/data/CVE_2010_3904_PATCHED_rds_page_copy_user.c ret = copy_to_user ( ptr , addr + offset , bytes ) 11
int CVE_2010_3904_PATCHED_rds_page_copy_user(struct page *page, unsigned long offset,
void __user *ptr, unsigned long bytes,
int to_user) 3
unsigned long ret ; 5
void * addr ; 6
addr = kmap ( page ); 8
if ( to_user )  9
ret = copy_to_user ( ptr , addr + offset , bytes ); 11
return ret ? - EFAULT : 0 ; 18
------------------------------
162 /home/SySeVR/data/CVE_2010_3904_VULN_rds_page_copy_user.c ret = copy_from_user ( addr + offset , ptr , bytes ) 25
int CVE_2010_3904_VULN_rds_page_copy_user(struct page *page, unsigned long offset,
void __user *ptr, unsigned long bytes,
int to_user) 3
unsigned long ret ; 5
void * addr ; 6
addr = kmap_atomic ( page , KM_USER0 ); 13
if ( to_user )  14
ret = __copy_to_user_inatomic ( ptr , addr + offset , bytes ); 15
ret = __copy_from_user_inatomic ( addr + offset , ptr , bytes ); 17
if ( ret )  20
addr = kmap ( page ); 21
if ( to_user )  22
ret = copy_from_user ( addr + offset , ptr , bytes ); 25
if ( ret )  27
------------------------------
163 /home/SySeVR/data/CVE_2010_3904_VULN_rds_page_copy_user.c ret = copy_to_user ( ptr , addr + offset , bytes ) 23
int CVE_2010_3904_VULN_rds_page_copy_user(struct page *page, unsigned long offset,
void __user *ptr, unsigned long bytes,
int to_user) 3
unsigned long ret ; 5
void * addr ; 6
addr = kmap_atomic ( page , KM_USER0 ); 13
if ( to_user )  14
ret = __copy_to_user_inatomic ( ptr , addr + offset , bytes ); 15
ret = __copy_from_user_inatomic ( addr + offset , ptr , bytes ); 17
if ( ret )  20
addr = kmap ( page ); 21
if ( to_user )  22
ret = copy_to_user ( ptr , addr + offset , bytes ); 23
if ( ret )  27
------------------------------
164 /home/SySeVR/data/CVE_2010_3904_VULN_rds_page_copy_user.c ret = __copy_from_user_inatomic ( addr + offset , ptr , bytes ) 17
int CVE_2010_3904_VULN_rds_page_copy_user(struct page *page, unsigned long offset,
void __user *ptr, unsigned long bytes,
int to_user) 3
unsigned long ret ; 5
void * addr ; 6
addr = kmap_atomic ( page , KM_USER0 ); 13
if ( to_user )  14
ret = __copy_from_user_inatomic ( addr + offset , ptr , bytes ); 17
if ( ret )  20
if ( ret )  27
------------------------------
165 /home/SySeVR/data/CVE_2010_3904_VULN_rds_page_copy_user.c ret = __copy_to_user_inatomic ( ptr , addr + offset , bytes ) 15
int CVE_2010_3904_VULN_rds_page_copy_user(struct page *page, unsigned long offset,
void __user *ptr, unsigned long bytes,
int to_user) 3
unsigned long ret ; 5
void * addr ; 6
addr = kmap_atomic ( page , KM_USER0 ); 13
if ( to_user )  14
ret = __copy_to_user_inatomic ( ptr , addr + offset , bytes ); 15
if ( ret )  20
if ( ret )  27
------------------------------
166 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c icsk -> icsk_accept_queue . rskq_defer_accept = secs_to_retrans ( val , TCP_TIMEOUT_INIT / HZ , TCP_RTO_MAX / HZ ) 236
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
struct inet_connection_sock * icsk = inet_csk ( sk ) ; 5
int val ; 6
switch ( optname )  10
char name [ TCP_CA_NAME_MAX ] ; 12
if ( optlen < 1 )  14
val = strncpy_from_user ( name , optval ,
min_t ( long , TCP_CA_NAME_MAX - 1 , optlen ) ) 18
if ( val < 0 )  19
name [ val ] = 0; 21
if ( optlen < sizeof ( int ) )  116
if ( get_user ( val , ( int __user * ) optval ) )  119
switch ( optname )  124
if ( val < 1 || val > MAX_TCP_SYNCNT )  219
icsk -> icsk_syn_retries = val; 222
icsk -> icsk_accept_queue . rskq_defer_accept = secs_to_retrans ( val , TCP_TIMEOUT_INIT / HZ , TCP_RTO_MAX / HZ ); 236
icsk -> icsk_ack . pingpong = 1; 255
------------------------------
167 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c tp -> linger2 = val * HZ 231
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
struct tcp_sock * tp = tcp_sk ( sk ) ; 4
int val ; 6
switch ( optname )  10
char name [ TCP_CA_NAME_MAX ] ; 12
if ( optlen < 1 )  14
val = strncpy_from_user ( name , optval ,
min_t ( long , TCP_CA_NAME_MAX - 1 , optlen ) ) 18
if ( val < 0 )  19
name [ val ] = 0; 21
if ( optlen < sizeof ( int ) )  116
if ( get_user ( val , ( int __user * ) optval ) )  119
switch ( optname )  124
if ( val < 0 )  226
if ( val > sysctl_tcp_fin_timeout / HZ )  228
tp -> linger2 = val * HZ; 231
tp -> window_clamp = 0; 247
------------------------------
168 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c tp -> keepalive_intvl = val * HZ 210
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
struct tcp_sock * tp = tcp_sk ( sk ) ; 4
int val ; 6
switch ( optname )  10
char name [ TCP_CA_NAME_MAX ] ; 12
if ( optlen < 1 )  14
val = strncpy_from_user ( name , optval ,
min_t ( long , TCP_CA_NAME_MAX - 1 , optlen ) ) 18
if ( val < 0 )  19
name [ val ] = 0; 21
if ( optlen < sizeof ( int ) )  116
if ( get_user ( val , ( int __user * ) optval ) )  119
switch ( optname )  124
if ( val )  179
tp -> nonagle &= ~TCP_NAGLE_CORK; 182
if ( tp -> nonagle & TCP_NAGLE_OFF )  183
tp -> nonagle |= TCP_NAGLE_PUSH; 184
if ( val < 1 || val > MAX_TCP_KEEPIDLE )  190
tp -> keepalive_time = val * HZ; 193
if ( val < 1 || val > MAX_TCP_KEEPINTVL )  207
tp -> keepalive_intvl = val * HZ; 210
tp -> keepalive_probes = val; 216
tp -> linger2 = - 1; 227
------------------------------
169 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c elapsed = tp -> keepalive_time - elapsed 199
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
struct tcp_sock * tp = tcp_sk ( sk ) ; 4
int val ; 6
switch ( optname )  10
char name [ TCP_CA_NAME_MAX ] ; 12
if ( optlen < 1 )  14
val = strncpy_from_user ( name , optval ,
min_t ( long , TCP_CA_NAME_MAX - 1 , optlen ) ) 18
if ( val < 0 )  19
name [ val ] = 0; 21
if ( optlen < sizeof ( int ) )  116
if ( get_user ( val , ( int __user * ) optval ) )  119
switch ( optname )  124
if ( val )  179
tp -> nonagle &= ~TCP_NAGLE_CORK; 182
if ( tp -> nonagle & TCP_NAGLE_OFF )  183
tp -> nonagle |= TCP_NAGLE_PUSH; 184
if ( val < 1 || val > MAX_TCP_KEEPIDLE )  190
tp -> keepalive_time = val * HZ; 193
if ( sock_flag ( sk , SOCK_KEEPOPEN ) && ! ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) )  194
u32 elapsed = keepalive_time_elapsed ( tp ) ; 197
if ( tp -> keepalive_time > elapsed )  198
elapsed = tp -> keepalive_time - elapsed; 199
inet_csk_reset_keepalive_timer ( sk , elapsed ); 202
------------------------------
170 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c tp -> keepalive_time = val * HZ 193
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
struct tcp_sock * tp = tcp_sk ( sk ) ; 4
int val ; 6
switch ( optname )  10
char name [ TCP_CA_NAME_MAX ] ; 12
if ( optlen < 1 )  14
val = strncpy_from_user ( name , optval ,
min_t ( long , TCP_CA_NAME_MAX - 1 , optlen ) ) 18
if ( val < 0 )  19
name [ val ] = 0; 21
if ( optlen < sizeof ( int ) )  116
if ( get_user ( val , ( int __user * ) optval ) )  119
switch ( optname )  124
if ( val )  179
tp -> nonagle &= ~TCP_NAGLE_CORK; 182
if ( tp -> nonagle & TCP_NAGLE_OFF )  183
tp -> nonagle |= TCP_NAGLE_PUSH; 184
if ( val < 1 || val > MAX_TCP_KEEPIDLE )  190
tp -> keepalive_time = val * HZ; 193
u32 elapsed = keepalive_time_elapsed ( tp ) ; 197
if ( tp -> keepalive_time > elapsed )  198
elapsed = tp -> keepalive_time - elapsed; 199
inet_csk_reset_keepalive_timer ( sk , elapsed ); 202
tp -> keepalive_intvl = val * HZ; 210
tp -> keepalive_probes = val; 216
tp -> linger2 = - 1; 227
------------------------------
171 /home/SySeVR/data/CVE_2010_4256_VULN_pipe_fcntl.c ret = pipe -> buffers * PAGE_SIZE 31
long CVE_2010_4256_VULN_pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg) 1
struct pipe_inode_info * pipe ; 3
long ret ; 4
pipe = file -> f_path . dentry -> d_inode -> i_pipe; 6
if ( ! pipe )  7
switch ( cmd )  12
ret = pipe -> buffers * PAGE_SIZE; 31
return ret ; 40
------------------------------
172 /home/SySeVR/data/CVE_2010_4342_PATCHED_aun_incoming.c newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ) 19
static void CVE_2010_4342_PATCHED_aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len) 1
struct iphdr * ip = ip_hdr ( skb ) ; 3
unsigned char stn = ntohl ( ip -> saddr ) & 0xff ; 4
struct dst_entry * dst = skb_dst ( skb ) ; 5
struct ec_device * edev = NULL ; 6
struct sk_buff * newskb ; 8
if ( dst )  10
edev = dst -> dev -> ec_ptr; 11
if ( ! edev )  13
if ( ( sk = ec_listening_socket ( ah -> port , stn , edev -> net ) ) == NULL )  16
newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ); 19
if ( newskb == NULL )  21
memcpy ( skb_put ( newskb , len - sizeof ( struct aunhdr ) ) , ( void * ) ( ah + 1 ) , len - sizeof ( struct aunhdr ) ); 28
if ( ec_queue_packet ( sk , newskb , stn , edev -> net , ah -> cb , ah -> port ) )  31
kfree_skb ( newskb ); 34
------------------------------
173 /home/SySeVR/data/CVE_2010_4342_VULN_aun_incoming.c newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ) 15
static void CVE_2010_4342_VULN_aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len) 1
struct iphdr * ip = ip_hdr ( skb ) ; 3
unsigned char stn = ntohl ( ip -> saddr ) & 0xff ; 4
struct sk_buff * newskb ; 6
struct ec_device * edev = skb -> dev -> ec_ptr ; 7
if ( ! edev )  9
if ( ( sk = ec_listening_socket ( ah -> port , stn , edev -> net ) ) == NULL )  12
newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ); 15
if ( newskb == NULL )  17
memcpy ( skb_put ( newskb , len - sizeof ( struct aunhdr ) ) , ( void * ) ( ah + 1 ) , len - sizeof ( struct aunhdr ) ); 24
if ( ec_queue_packet ( sk , newskb , stn , edev -> net , ah -> cb , ah -> port ) )  27
kfree_skb ( newskb ); 30
------------------------------
174 /home/SySeVR/data/CVE_2010_4649_PATCHED_ib_uverbs_poll_cq.c data_ptr = header_ptr + sizeof resp 22
ssize_t CVE_2010_4649_PATCHED_ib_uverbs_poll_cq(struct ib_uverbs_file *file,
const char __user *buf, int in_len,
int out_len) 3
struct CVE_2010_4649_PATCHED_ib_uverbs_poll_cq cmd ; 5
struct ib_uverbs_poll_cq_resp resp ; 6
u8 __user * header_ptr ; 7
u8 __user * data_ptr ; 8
struct ib_cq * cq ; 9
if ( copy_from_user ( & cmd , buf , sizeof cmd ) )  13
cq = idr_read_cq ( cmd . cq_handle , file -> ucontext , 0 ); 16
if ( ! cq )  17
header_ptr = ( void __user * ) ( unsigned long ) cmd . response; 21
data_ptr = header_ptr + sizeof resp; 22
ret = copy_wc_to_user ( data_ptr , & wc ); 32
if ( ret )  33
data_ptr += sizeof ( struct ib_uverbs_wc ); 36
return ret ; 49
------------------------------
175 /home/SySeVR/data/CVE_2010_4649_VULN_ib_uverbs_poll_cq.c rsize = sizeof * resp + cmd . ne * sizeof ( struct ib_uverbs_wc ) 20
ssize_t CVE_2010_4649_VULN_ib_uverbs_poll_cq(struct ib_uverbs_file *file,
const char __user *buf, int in_len,
int out_len) 3
struct CVE_2010_4649_VULN_ib_uverbs_poll_cq cmd ; 5
struct ib_uverbs_poll_cq_resp * resp ; 6
struct ib_wc * wc ; 8
int rsize ; 11
if ( copy_from_user ( & cmd , buf , sizeof cmd ) )  13
wc = kmalloc ( cmd . ne * sizeof * wc , GFP_KERNEL ); 16
if ( ! wc )  17
rsize = sizeof * resp + cmd . ne * sizeof ( struct ib_uverbs_wc ); 20
resp = kmalloc ( rsize , GFP_KERNEL ); 21
if ( ! resp )  22
resp -> count = ib_poll_cq ( cq , cmd . ne , wc ); 33
for (i = 0; i < resp->count; i++) 37
resp -> wc [ i ] . wr_id = wc [ i ] . wr_id; 38
resp -> wc [ i ] . status = wc [ i ] . status; 39
resp -> wc [ i ] . opcode = wc [ i ] . opcode; 40
resp -> wc [ i ] . vendor_err = wc [ i ] . vendor_err; 41
resp -> wc [ i ] . byte_len = wc [ i ] . byte_len; 42
resp -> wc [ i ] . ex . imm_data = ( __u32 __force ) wc [ i ] . ex . imm_data; 43
resp -> wc [ i ] . qp_num = wc [ i ] . qp -> qp_num; 44
resp -> wc [ i ] . src_qp = wc [ i ] . src_qp; 45
resp -> wc [ i ] . wc_flags = wc [ i ] . wc_flags; 46
resp -> wc [ i ] . pkey_index = wc [ i ] . pkey_index; 47
resp -> wc [ i ] . slid = wc [ i ] . slid; 48
resp -> wc [ i ] . sl = wc [ i ] . sl; 49
resp -> wc [ i ] . dlid_path_bits = wc [ i ] . dlid_path_bits; 50
resp -> wc [ i ] . port_num = wc [ i ] . port_num; 51
if ( copy_to_user ( ( void __user * ) ( unsigned long ) cmd . response , resp , rsize ) )  54
kfree ( resp ); 58
------------------------------
176 /home/SySeVR/data/CVE_2010_4649_VULN_ib_uverbs_poll_cq.c wc = kmalloc ( cmd . ne * sizeof * wc , GFP_KERNEL ) 16
ssize_t CVE_2010_4649_VULN_ib_uverbs_poll_cq(struct ib_uverbs_file *file,
const char __user *buf, int in_len,
int out_len) 3
struct CVE_2010_4649_VULN_ib_uverbs_poll_cq cmd ; 5
struct ib_wc * wc ; 8
if ( copy_from_user ( & cmd , buf , sizeof cmd ) )  13
wc = kmalloc ( cmd . ne * sizeof * wc , GFP_KERNEL ); 16
if ( ! wc )  17
resp -> count = ib_poll_cq ( cq , cmd . ne , wc ); 33
for (i = 0; i < resp->count; i++) 37
resp -> wc [ i ] . wr_id = wc [ i ] . wr_id; 38
resp -> wc [ i ] . status = wc [ i ] . status; 39
resp -> wc [ i ] . opcode = wc [ i ] . opcode; 40
resp -> wc [ i ] . vendor_err = wc [ i ] . vendor_err; 41
resp -> wc [ i ] . byte_len = wc [ i ] . byte_len; 42
resp -> wc [ i ] . ex . imm_data = ( __u32 __force ) wc [ i ] . ex . imm_data; 43
resp -> wc [ i ] . qp_num = wc [ i ] . qp -> qp_num; 44
resp -> wc [ i ] . src_qp = wc [ i ] . src_qp; 45
resp -> wc [ i ] . wc_flags = wc [ i ] . wc_flags; 46
resp -> wc [ i ] . pkey_index = wc [ i ] . pkey_index; 47
resp -> wc [ i ] . slid = wc [ i ] . slid; 48
resp -> wc [ i ] . sl = wc [ i ] . sl; 49
resp -> wc [ i ] . dlid_path_bits = wc [ i ] . dlid_path_bits; 50
resp -> wc [ i ] . port_num = wc [ i ] . port_num; 51
if ( copy_to_user ( ( void __user * ) ( unsigned long ) cmd . response , resp , rsize ) )  54
kfree ( resp ); 58
kfree ( wc ); 61
------------------------------
177 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeScroll.c p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ] 65
static int CVE_2011_0021_PATCHED_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ; 3
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
p_cdg -> i_offseth = p_data [ 1 ] & 0x7; 11
if ( p_cdg -> i_offseth >= CDG_SCREEN_BORDER_WIDTH )  12
p_cdg -> i_offseth = CDG_SCREEN_BORDER_WIDTH - 1; 13
p_cdg -> i_offsetv = p_data [ 2 ] & 0xf; 15
if ( p_cdg -> i_offsetv >= CDG_SCREEN_BORDER_HEIGHT )  16
p_cdg -> i_offsetv = CDG_SCREEN_BORDER_HEIGHT - 1; 17
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) ); 41
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
for( x = 0; x < CDG_SCREEN_WIDTH; x++ ) 50
int dx = i_shifth + x ; 52
if ( b_copy )  54
dy %= CDG_SCREEN_HEIGHT; 56
dx %= CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
178 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ] 65
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ; 3
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
p_cdg -> i_offseth = p_data [ 1 ] & 0x7; 11
if ( p_cdg -> i_offseth >= CDG_SCREEN_BORDER_WIDTH )  12
p_cdg -> i_offseth = CDG_SCREEN_BORDER_WIDTH - 1; 13
p_cdg -> i_offsetv = p_data [ 2 ] & 0xf; 15
if ( p_cdg -> i_offsetv >= CDG_SCREEN_BORDER_HEIGHT )  16
p_cdg -> i_offsetv = CDG_SCREEN_BORDER_HEIGHT - 1; 17
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) ); 41
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
for( x = 0; x < CDG_SCREEN_WIDTH; x++ ) 50
int dx = i_shifth + x ; 52
if ( b_copy )  54
dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT; 56
dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
179 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH 57
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
for( x = 0; x < CDG_SCREEN_WIDTH; x++ ) 50
int dx = i_shifth + x ; 52
if ( b_copy )  54
dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT; 56
dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
180 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT 56
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
for( x = 0; x < CDG_SCREEN_WIDTH; x++ ) 50
int dx = i_shifth + x ; 52
if ( b_copy )  54
dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT; 56
dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
181 /home/SySeVR/data/CVE_2011_0726_PATCHED_do_task_stat.c start_time = ( unsigned long long ) task -> real_start_time . tv_sec * NSEC_PER_SEC + task -> real_start_time . tv_nsec 100
static int CVE_2011_0726_PATCHED_do_task_stat(struct seq_file *m, struct pid_namespace *ns,
struct pid *pid, struct task_struct *task, int whole) 2
unsigned long long start_time ; 13
start_time = ( unsigned long long ) task -> real_start_time . tv_sec * NSEC_PER_SEC + task -> real_start_time . tv_nsec; 100
start_time = nsec_to_clock_t ( start_time ); 104
seq_printf ( m , "%d (%s) %c %d %d %d %d %d %u %lu \\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\n" , pid_nr_ns ( pid , ns ) , tcomm , state , ppid , pgid , sid , tty_nr , tty_pgrp , task -> flags , min_flt , cmin_flt , maj_flt , cmaj_flt , cputime_to_clock_t ( utime ) , cputime_to_clock_t ( stime ) , cputime_to_clock_t ( cutime ) , cputime_to_clock_t ( cstime ) , priority , nice , num_threads , start_time , vsize , mm ? get_mm_rss ( mm ) : 0 , rsslim , mm ? ( permitted ? mm -> start_code : 1 ) : 0 , mm ? ( permitted ? mm -> end_code : 1 ) : 0 , ( permitted && mm ) ? mm -> start_stack : 0 , esp , eip , task -> pending . signal . sig [ 0 ] & 0x7fffffffUL , task -> blocked . sig [ 0 ] & 0x7fffffffUL , sigign . sig [ 0 ] & 0x7fffffffUL , sigcatch . sig [ 0 ] & 0x7fffffffUL , wchan , 0UL , 0UL , task -> exit_signal , task_cpu ( task ) , task -> rt_priority , task -> policy , ( unsigned long long ) delayacct_blkio_ticks ( task ) , cputime_to_clock_t ( gtime ) , cputime_to_clock_t ( cgtime ) ); 106
------------------------------
182 /home/SySeVR/data/CVE_2011_0726_VULN_do_task_stat.c start_time = ( unsigned long long ) task -> real_start_time . tv_sec * NSEC_PER_SEC + task -> real_start_time . tv_nsec 100
static int CVE_2011_0726_VULN_do_task_stat(struct seq_file *m, struct pid_namespace *ns,
struct pid *pid, struct task_struct *task, int whole) 2
unsigned long long start_time ; 13
start_time = ( unsigned long long ) task -> real_start_time . tv_sec * NSEC_PER_SEC + task -> real_start_time . tv_nsec; 100
start_time = nsec_to_clock_t ( start_time ); 104
seq_printf ( m , "%d (%s) %c %d %d %d %d %d %u %lu \\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\n" , pid_nr_ns ( pid , ns ) , tcomm , state , ppid , pgid , sid , tty_nr , tty_pgrp , task -> flags , min_flt , cmin_flt , maj_flt , cmaj_flt , cputime_to_clock_t ( utime ) , cputime_to_clock_t ( stime ) , cputime_to_clock_t ( cutime ) , cputime_to_clock_t ( cstime ) , priority , nice , num_threads , start_time , vsize , mm ? get_mm_rss ( mm ) : 0 , rsslim , mm ? mm -> start_code : 0 , mm ? mm -> end_code : 0 , ( permitted && mm ) ? mm -> start_stack : 0 , esp , eip , task -> pending . signal . sig [ 0 ] & 0x7fffffffUL , task -> blocked . sig [ 0 ] & 0x7fffffffUL , sigign . sig [ 0 ] & 0x7fffffffUL , sigcatch . sig [ 0 ] & 0x7fffffffUL , wchan , 0UL , 0UL , task -> exit_signal , task_cpu ( task ) , task -> rt_priority , task -> policy , ( unsigned long long ) delayacct_blkio_ticks ( task ) , cputime_to_clock_t ( gtime ) , cputime_to_clock_t ( cgtime ) ); 106
------------------------------
183 /home/SySeVR/data/CVE_2011_1010_VULN_mac_partition.c part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + pos % 512 ) 41
int CVE_2011_1010_VULN_mac_partition(struct parsed_partitions *state) 1
unsigned char * data ; 5
int blk , blocks_in_map ; 6
unsigned secsize ; 7
struct CVE_2011_1010_VULN_mac_partition * part ; 12
struct mac_driver_desc * md ; 13
md = read_part_sector ( state , 0 , & sect ); 16
if ( ! md )  17
if ( be16_to_cpu ( md -> signature ) != MAC_DRIVER_MAGIC )  19
secsize = be16_to_cpu ( md -> block_size ); 23
data = read_part_sector ( state , secsize / 512 , & sect ); 25
if ( ! data )  26
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + secsize % 512 ); 28
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  29
blocks_in_map = be32_to_cpu ( part -> map_count ); 34
for (blk = 1; blk <= blocks_in_map; ++blk) 35
int pos = blk * secsize ; 36
data = read_part_sector ( state , pos / 512 , & sect ); 38
if ( ! data )  39
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + pos % 512 ); 41
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  42
put_partition ( state , slot , be32_to_cpu ( part -> start_block ) * ( secsize / 512 ) , be32_to_cpu ( part -> block_count ) * ( secsize / 512 ) ); 44
if ( ! strnicmp ( part -> type , "Linux_RAID" , 10 ) )  48
mac_fix_string ( part -> processor , 16 ); 58
mac_fix_string ( part -> name , 32 ); 59
mac_fix_string ( part -> type , 32 ); 60
if ( ( be32_to_cpu ( part -> status ) & MAC_STATUS_BOOTABLE ) && strcasecmp ( part -> processor , "powerpc" ) == 0 )  62
if ( strcasecmp ( part -> type , "Apple_UNIX_SVR2" ) == 0 || ( strnicmp ( part -> type , "Linux" , 5 ) == 0 && strcasecmp ( part -> type , "Linux_swap" ) != 0 ) )  66
l = strlen ( part -> name ); 72
if ( strcmp ( part -> name , "/" ) == 0 )  73
for (i = 0; i <= l - 4; ++i) 75
if ( strnicmp ( part -> name + i , "root" , 4 ) == 0 )  76
if ( strnicmp ( part -> name , "swap" , 4 ) == 0 )  82
------------------------------
184 /home/SySeVR/data/CVE_2011_1010_VULN_mac_partition.c part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + secsize % 512 ) 28
int CVE_2011_1010_VULN_mac_partition(struct parsed_partitions *state) 1
unsigned char * data ; 5
unsigned secsize ; 7
struct CVE_2011_1010_VULN_mac_partition * part ; 12
struct mac_driver_desc * md ; 13
md = read_part_sector ( state , 0 , & sect ); 16
if ( ! md )  17
if ( be16_to_cpu ( md -> signature ) != MAC_DRIVER_MAGIC )  19
secsize = be16_to_cpu ( md -> block_size ); 23
data = read_part_sector ( state , secsize / 512 , & sect ); 25
if ( ! data )  26
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + secsize % 512 ); 28
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  29
blocks_in_map = be32_to_cpu ( part -> map_count ); 34
for (blk = 1; blk <= blocks_in_map; ++blk) 35
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  42
put_partition ( state , slot , be32_to_cpu ( part -> start_block ) * ( secsize / 512 ) , be32_to_cpu ( part -> block_count ) * ( secsize / 512 ) ); 44
if ( ! strnicmp ( part -> type , "Linux_RAID" , 10 ) )  48
mac_fix_string ( part -> processor , 16 ); 58
mac_fix_string ( part -> name , 32 ); 59
mac_fix_string ( part -> type , 32 ); 60
if ( ( be32_to_cpu ( part -> status ) & MAC_STATUS_BOOTABLE ) && strcasecmp ( part -> processor , "powerpc" ) == 0 )  62
if ( strcasecmp ( part -> type , "Apple_UNIX_SVR2" ) == 0 || ( strnicmp ( part -> type , "Linux" , 5 ) == 0 && strcasecmp ( part -> type , "Linux_swap" ) != 0 ) )  66
l = strlen ( part -> name ); 72
if ( strcmp ( part -> name , "/" ) == 0 )  73
for (i = 0; i <= l - 4; ++i) 75
if ( strnicmp ( part -> name + i , "root" , 4 ) == 0 )  76
if ( strnicmp ( part -> name , "swap" , 4 ) == 0 )  82
------------------------------
185 /home/SySeVR/data/CVE_2011_1023_PATCHED_rds_loop_xmit.c ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) 12
static int CVE_2011_1023_PATCHED_rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,
unsigned int hdr_off, unsigned int sg,
unsigned int off) 3
struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; 5
int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; 6
if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP )  10
ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ); 12
return ret ; 30
------------------------------
186 /home/SySeVR/data/CVE_2011_1044_VULN_ib_uverbs_poll_cq.c rsize = sizeof * resp + cmd . ne * sizeof ( struct ib_uverbs_wc ) 20
ssize_t CVE_2011_1044_VULN_ib_uverbs_poll_cq(struct ib_uverbs_file *file,
const char __user *buf, int in_len,
int out_len) 3
struct CVE_2011_1044_VULN_ib_uverbs_poll_cq cmd ; 5
struct ib_uverbs_poll_cq_resp * resp ; 6
struct ib_wc * wc ; 8
int rsize ; 11
if ( copy_from_user ( & cmd , buf , sizeof cmd ) )  13
wc = kmalloc ( cmd . ne * sizeof * wc , GFP_KERNEL ); 16
if ( ! wc )  17
rsize = sizeof * resp + cmd . ne * sizeof ( struct ib_uverbs_wc ); 20
resp = kmalloc ( rsize , GFP_KERNEL ); 21
if ( ! resp )  22
resp -> count = ib_poll_cq ( cq , cmd . ne , wc ); 33
for (i = 0; i < resp->count; i++) 37
resp -> wc [ i ] . wr_id = wc [ i ] . wr_id; 38
resp -> wc [ i ] . status = wc [ i ] . status; 39
resp -> wc [ i ] . opcode = wc [ i ] . opcode; 40
resp -> wc [ i ] . vendor_err = wc [ i ] . vendor_err; 41
resp -> wc [ i ] . byte_len = wc [ i ] . byte_len; 42
resp -> wc [ i ] . ex . imm_data = ( __u32 __force ) wc [ i ] . ex . imm_data; 43
resp -> wc [ i ] . qp_num = wc [ i ] . qp -> qp_num; 44
resp -> wc [ i ] . src_qp = wc [ i ] . src_qp; 45
resp -> wc [ i ] . wc_flags = wc [ i ] . wc_flags; 46
resp -> wc [ i ] . pkey_index = wc [ i ] . pkey_index; 47
resp -> wc [ i ] . slid = wc [ i ] . slid; 48
resp -> wc [ i ] . sl = wc [ i ] . sl; 49
resp -> wc [ i ] . dlid_path_bits = wc [ i ] . dlid_path_bits; 50
resp -> wc [ i ] . port_num = wc [ i ] . port_num; 51
if ( copy_to_user ( ( void __user * ) ( unsigned long ) cmd . response , resp , rsize ) )  54
kfree ( resp ); 58
------------------------------
187 /home/SySeVR/data/CVE_2011_1044_VULN_ib_uverbs_poll_cq.c wc = kmalloc ( cmd . ne * sizeof * wc , GFP_KERNEL ) 16
ssize_t CVE_2011_1044_VULN_ib_uverbs_poll_cq(struct ib_uverbs_file *file,
const char __user *buf, int in_len,
int out_len) 3
struct CVE_2011_1044_VULN_ib_uverbs_poll_cq cmd ; 5
struct ib_wc * wc ; 8
if ( copy_from_user ( & cmd , buf , sizeof cmd ) )  13
wc = kmalloc ( cmd . ne * sizeof * wc , GFP_KERNEL ); 16
if ( ! wc )  17
resp -> count = ib_poll_cq ( cq , cmd . ne , wc ); 33
for (i = 0; i < resp->count; i++) 37
resp -> wc [ i ] . wr_id = wc [ i ] . wr_id; 38
resp -> wc [ i ] . status = wc [ i ] . status; 39
resp -> wc [ i ] . opcode = wc [ i ] . opcode; 40
resp -> wc [ i ] . vendor_err = wc [ i ] . vendor_err; 41
resp -> wc [ i ] . byte_len = wc [ i ] . byte_len; 42
resp -> wc [ i ] . ex . imm_data = ( __u32 __force ) wc [ i ] . ex . imm_data; 43
resp -> wc [ i ] . qp_num = wc [ i ] . qp -> qp_num; 44
resp -> wc [ i ] . src_qp = wc [ i ] . src_qp; 45
resp -> wc [ i ] . wc_flags = wc [ i ] . wc_flags; 46
resp -> wc [ i ] . pkey_index = wc [ i ] . pkey_index; 47
resp -> wc [ i ] . slid = wc [ i ] . slid; 48
resp -> wc [ i ] . sl = wc [ i ] . sl; 49
resp -> wc [ i ] . dlid_path_bits = wc [ i ] . dlid_path_bits; 50
resp -> wc [ i ] . port_num = wc [ i ] . port_num; 51
if ( copy_to_user ( ( void __user * ) ( unsigned long ) cmd . response , resp , rsize ) )  54
kfree ( resp ); 58
kfree ( wc ); 61
------------------------------
188 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c opt_vlen = next_opt - eq 47
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
unsigned long derrno ; 5
int ret ; 6
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
end = data + datalen; 19
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
const char * next_opt ; 26
opt ++; 29
const char * eq ; 32
int opt_len , opt_nlen , opt_vlen , tmp ; 33
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
tmp = opt_vlen >= 0 ? opt_vlen : 0; 49
kdebug ( "option '%*.*s' val '%*.*s'" , opt_nlen , opt_nlen , opt , tmp , tmp , eq ); 50
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
if ( derrno < 1 || derrno > 511 )  65
while ( opt = next_opt + 1 , opt < end )  79
------------------------------
189 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c opt_nlen = eq - opt 45
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
unsigned long derrno ; 5
int ret ; 6
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
end = data + datalen; 19
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
const char * next_opt ; 26
opt ++; 29
const char * eq ; 32
int opt_len , opt_nlen , opt_vlen , tmp ; 33
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
kdebug ( "option '%*.*s' val '%*.*s'" , opt_nlen , opt_nlen , opt , tmp , tmp , eq ); 50
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
if ( derrno < 1 || derrno > 511 )  65
printk ( KERN_WARNING
"Option '%*.*s' to dns_resolver key %d:"
" bad/missing value\n" ,
opt_nlen , opt_nlen , opt , key -> serial ) 77
while ( opt = next_opt + 1 , opt < end )  79
------------------------------
190 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c opt_len = next_opt - opt 36
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
unsigned long derrno ; 5
int ret ; 6
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
end = data + datalen; 19
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
const char * next_opt ; 26
opt ++; 29
const char * eq ; 32
int opt_len , opt_nlen , opt_vlen , tmp ; 33
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
tmp = opt_vlen >= 0 ? opt_vlen : 0; 49
kdebug ( "option '%*.*s' val '%*.*s'" , opt_nlen , opt_nlen , opt , tmp , tmp , eq ); 50
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
if ( derrno < 1 || derrno > 511 )  65
printk ( KERN_WARNING
"Option '%*.*s' to dns_resolver key %d:"
" bad/missing value\n" ,
opt_nlen , opt_nlen , opt , key -> serial ) 77
while ( opt = next_opt + 1 , opt < end )  79
if ( ret < 0 )  91
------------------------------
191 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c result_len = opt - data 28
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
opt = memchr ( data , '#' , datalen ); 20
if ( ! opt )  21
result_len = opt - data; 28
ret = key_payload_reserve ( key , result_len ); 90
if ( ret < 0 )  91
upayload = kmalloc ( sizeof ( * upayload ) + result_len + 1 , GFP_KERNEL ); 94
if ( ! upayload )  95
upayload -> datalen = result_len; 100
memcpy ( upayload -> data , data , result_len ); 101
upayload -> data [ result_len ] = '\0'; 102
rcu_assign_pointer ( key -> payload . data , upayload ); 103
------------------------------
192 /home/SySeVR/data/CVE_2011_1076_PATCHED_dns_resolver_instantiate.c end = data + datalen 19
static int
CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) 2
const char * data = _data , * end , * opt ; 8
if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  14
datalen --; 16
end = data + datalen; 19
next_opt = memchr ( opt , '#' , end - opt ) ? : end 35
opt_len = next_opt - opt; 36
if ( ! opt_len )  37
eq = memchr ( opt , '=' , opt_len ) ? : end 44
opt_nlen = eq - opt; 45
eq ++; 46
opt_vlen = next_opt - eq; 47
tmp = opt_vlen >= 0 ? opt_vlen : 0; 49
kdebug ( "option '%*.*s' val '%*.*s'" , opt_nlen , opt_nlen , opt , tmp , tmp , eq ); 50
if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  55
if ( opt_vlen <= 0 )  58
ret = strict_strtoul ( eq , 10 , & derrno ); 61
if ( ret < 0 )  62
printk ( KERN_WARNING
"Option '%*.*s' to dns_resolver key %d:"
" bad/missing value\n" ,
opt_nlen , opt_nlen , opt , key -> serial ) 77
while ( opt = next_opt + 1 , opt < end )  79
if ( ret < 0 )  91
------------------------------
193 /home/SySeVR/data/CVE_2011_1138_PATCHED_dissect_6lowpan_iphc.c nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ) 368
static tvbuff_t *
CVE_2011_1138_PATCHED_dissect_6lowpan_iphc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size) 2
gint offset = 0 ; 4
gint length ; 5
guint16 iphc_flags ; 12
guint8 iphc_traffic ; 13
guint8 iphc_hop_limit ; 14
guint8 iphc_src_mode ; 15
guint8 iphc_dst_mode ; 16
guint8 ipv6_class = 0 ; 19
struct ip6_hdr ipv6 ; 20
struct lowpan_nhdr * nhdr_list ; 23
iphc_flags = tvb_get_ntohs ( tvb , offset ); 38
iphc_traffic = ( iphc_flags & LOWPAN_IPHC_FLAG_FLOW ) >> LOWPAN_IPHC_FLAG_OFFSET_FLOW; 39
iphc_hop_limit = ( iphc_flags & LOWPAN_IPHC_FLAG_HLIM ) >> LOWPAN_IPHC_FLAG_OFFSET_HLIM; 40
iphc_src_mode = ( iphc_flags & LOWPAN_IPHC_FLAG_SRC_MODE ) >> LOWPAN_IPHC_FLAG_OFFSET_SRC_MODE; 41
iphc_dst_mode = ( iphc_flags & LOWPAN_IPHC_FLAG_DST_MODE ) >> LOWPAN_IPHC_FLAG_OFFSET_DST_MODE; 42
offset += sizeof ( guint16 ); 58
if ( iphc_flags & LOWPAN_IPHC_FLAG_CONTEXT_ID )  61
offset += sizeof ( guint8 ); 67
offset <<= 3; 74
if ( iphc_traffic != LOWPAN_IPHC_FLOW_COMPRESSED )  76
ipv6_class |= tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_ECN_BITS ); 77
offset += LOWPAN_IPHC_ECN_BITS; 78
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS ) )  81
ipv6_class |= ( tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_DSCP_BITS ) << LOWPAN_IPHC_ECN_BITS ); 82
offset += LOWPAN_IPHC_DSCP_BITS; 83
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_ECN_LABEL ) )  98
offset += ( ( 4 - offset ) & 0x7 ); 100
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , offset , LOWPAN_IPHC_LABEL_BITS , FALSE ); 101
offset += LOWPAN_IPHC_LABEL_BITS; 105
ipv6 . ip6_flow = 0; 107
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow ) | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ); 110
ipv6 . ip6_vfc = ( 0x6 << 4 ) | ( ipv6_class >> 4 ); 111
offset >>= 3; 114
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_NHDR ) )  121
ipv6 . ip6_nxt = tvb_get_guint8 ( tvb , offset ); 122
offset += sizeof ( guint8 ); 127
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_1 )  131
ipv6 . ip6_hlim = 1; 132
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_64 )  134
ipv6 . ip6_hlim = 64; 135
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_255 )  137
ipv6 . ip6_hlim = 255; 138
ipv6 . ip6_hlim = tvb_get_guint8 ( tvb , offset ); 141
offset += sizeof ( guint8 ); 145
length = 0; 153
memset ( & ipv6 . ip6_src , 0 , sizeof ( ipv6 . ip6_src ) ); 154
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_SRC_COMP ) )  159
ipv6 . ip6_src . bytes [ 0 ] = 0xfe; 161
ipv6 . ip6_src . bytes [ 1 ] = 0x80; 162
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_FULL_INLINE )  164
length = sizeof ( ipv6 . ip6_src ); 165
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  169
length = sizeof ( guint64 ); 170
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  173
length = sizeof ( guint16 ); 174
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_SRC_UNSPEC )  193
length = 0; 194
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  197
length = sizeof ( guint64 ); 197
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  198
length = sizeof ( guint16 ); 198
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_COMPRESSED )  199
length = 0; 199
offset += length; 214
length = 0; 226
memset ( & ipv6 . ip6_dst , 0 , sizeof ( ipv6 . ip6_dst ) ); 227
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_DST_COMP ) && ! ( iphc_flags & LOWPAN_IPHC_FLAG_MCAST_COMP ) )  232
ipv6 . ip6_dst . bytes [ 0 ] = 0xfe; 234
ipv6 . ip6_dst . bytes [ 1 ] = 0x80; 235
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_FULL_INLINE )  237
length = sizeof ( ipv6 . ip6_dst ); 238
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  242
length = sizeof ( guint64 ); 243
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  246
length = sizeof ( guint16 ); 247
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_DST_COMP ) && ( iphc_flags & LOWPAN_IPHC_FLAG_MCAST_COMP ) )  259
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_FULL_INLINE )  260
length = sizeof ( ipv6 . ip6_dst ); 261
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_48BIT )  264
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 265
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 266
ipv6 . ip6_dst . bytes [ 11 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 267
ipv6 . ip6_dst . bytes [ 12 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 268
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 269
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 270
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 271
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_32BIT )  273
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 274
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 275
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 276
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 277
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 278
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_8BIT )  280
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 281
ipv6 . ip6_dst . bytes [ 1 ] = 0x02; 282
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 283
if ( ( iphc_flags & LOWPAN_IPHC_FLAG_DST_COMP ) && ! ( iphc_flags & LOWPAN_IPHC_FLAG_MCAST_COMP ) )  295
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  298
length = sizeof ( guint64 ); 298
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  299
length = sizeof ( guint16 ); 299
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_COMPRESSED )  300
length = 0; 300
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_STATEFUL_48BIT )  312
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 313
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 314
ipv6 . ip6_dst . bytes [ 2 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 315
ipv6 . ip6_dst . bytes [ 12 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 318
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 319
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 320
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 321
offset += length; 338
if ( iphc_flags & LOWPAN_IPHC_FLAG_NHDR )  350
length = ( gint ) tvb_ensure_length_remaining ( tvb , offset ); 359
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + length ); 360
if ( dgram_size < 0 )  364
nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); 368
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 370
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 378
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 379
return ipv6_tvb ; 380
------------------------------
194 /home/SySeVR/data/CVE_2011_1138_PATCHED_dissect_6lowpan_iphc.c nhdr_list = dissect_6lowpan_iphc_nhc ( tvb , pinfo , tree , offset , dgram_size - sizeof ( struct ip6_hdr ) ) 355
static tvbuff_t *
CVE_2011_1138_PATCHED_dissect_6lowpan_iphc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size) 2
gint offset = 0 ; 4
gint length ; 5
guint16 iphc_flags ; 12
guint8 iphc_traffic ; 13
guint8 iphc_hop_limit ; 14
guint8 iphc_src_mode ; 15
guint8 iphc_dst_mode ; 16
guint8 ipv6_class = 0 ; 19
struct ip6_hdr ipv6 ; 20
struct lowpan_nhdr * nhdr_list ; 23
iphc_flags = tvb_get_ntohs ( tvb , offset ); 38
iphc_traffic = ( iphc_flags & LOWPAN_IPHC_FLAG_FLOW ) >> LOWPAN_IPHC_FLAG_OFFSET_FLOW; 39
iphc_hop_limit = ( iphc_flags & LOWPAN_IPHC_FLAG_HLIM ) >> LOWPAN_IPHC_FLAG_OFFSET_HLIM; 40
iphc_src_mode = ( iphc_flags & LOWPAN_IPHC_FLAG_SRC_MODE ) >> LOWPAN_IPHC_FLAG_OFFSET_SRC_MODE; 41
iphc_dst_mode = ( iphc_flags & LOWPAN_IPHC_FLAG_DST_MODE ) >> LOWPAN_IPHC_FLAG_OFFSET_DST_MODE; 42
offset += sizeof ( guint16 ); 58
if ( iphc_flags & LOWPAN_IPHC_FLAG_CONTEXT_ID )  61
offset += sizeof ( guint8 ); 67
offset <<= 3; 74
if ( iphc_traffic != LOWPAN_IPHC_FLOW_COMPRESSED )  76
ipv6_class |= tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_ECN_BITS ); 77
offset += LOWPAN_IPHC_ECN_BITS; 78
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS ) )  81
ipv6_class |= ( tvb_get_bits8 ( tvb , offset , LOWPAN_IPHC_DSCP_BITS ) << LOWPAN_IPHC_ECN_BITS ); 82
offset += LOWPAN_IPHC_DSCP_BITS; 83
if ( ( iphc_traffic == LOWPAN_IPHC_FLOW_CLASS_LABEL ) || ( iphc_traffic == LOWPAN_IPHC_FLOW_ECN_LABEL ) )  98
offset += ( ( 4 - offset ) & 0x7 ); 100
ipv6 . ip6_flow = tvb_get_bits32 ( tvb , offset , LOWPAN_IPHC_LABEL_BITS , FALSE ); 101
offset += LOWPAN_IPHC_LABEL_BITS; 105
ipv6 . ip6_flow = 0; 107
ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow ) | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ); 110
ipv6 . ip6_vfc = ( 0x6 << 4 ) | ( ipv6_class >> 4 ); 111
offset >>= 3; 114
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_NHDR ) )  121
ipv6 . ip6_nxt = tvb_get_guint8 ( tvb , offset ); 122
offset += sizeof ( guint8 ); 127
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_1 )  131
ipv6 . ip6_hlim = 1; 132
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_64 )  134
ipv6 . ip6_hlim = 64; 135
if ( iphc_hop_limit == LOWPAN_IPHC_HLIM_255 )  137
ipv6 . ip6_hlim = 255; 138
ipv6 . ip6_hlim = tvb_get_guint8 ( tvb , offset ); 141
offset += sizeof ( guint8 ); 145
length = 0; 153
memset ( & ipv6 . ip6_src , 0 , sizeof ( ipv6 . ip6_src ) ); 154
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_SRC_COMP ) )  159
ipv6 . ip6_src . bytes [ 0 ] = 0xfe; 161
ipv6 . ip6_src . bytes [ 1 ] = 0x80; 162
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_FULL_INLINE )  164
length = sizeof ( ipv6 . ip6_src ); 165
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  169
length = sizeof ( guint64 ); 170
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  173
length = sizeof ( guint16 ); 174
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_SRC_UNSPEC )  193
length = 0; 194
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  197
length = sizeof ( guint64 ); 197
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  198
length = sizeof ( guint16 ); 198
if ( iphc_src_mode == LOWPAN_IPHC_ADDR_COMPRESSED )  199
length = 0; 199
offset += length; 214
length = 0; 226
memset ( & ipv6 . ip6_dst , 0 , sizeof ( ipv6 . ip6_dst ) ); 227
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_DST_COMP ) && ! ( iphc_flags & LOWPAN_IPHC_FLAG_MCAST_COMP ) )  232
ipv6 . ip6_dst . bytes [ 0 ] = 0xfe; 234
ipv6 . ip6_dst . bytes [ 1 ] = 0x80; 235
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_FULL_INLINE )  237
length = sizeof ( ipv6 . ip6_dst ); 238
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  242
length = sizeof ( guint64 ); 243
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  246
length = sizeof ( guint16 ); 247
if ( ! ( iphc_flags & LOWPAN_IPHC_FLAG_DST_COMP ) && ( iphc_flags & LOWPAN_IPHC_FLAG_MCAST_COMP ) )  259
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_FULL_INLINE )  260
length = sizeof ( ipv6 . ip6_dst ); 261
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_48BIT )  264
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 265
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 266
ipv6 . ip6_dst . bytes [ 11 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 267
ipv6 . ip6_dst . bytes [ 12 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 268
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 269
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 270
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 271
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_32BIT )  273
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 274
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 275
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 276
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 277
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 278
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_8BIT )  280
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 281
ipv6 . ip6_dst . bytes [ 1 ] = 0x02; 282
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 283
if ( ( iphc_flags & LOWPAN_IPHC_FLAG_DST_COMP ) && ! ( iphc_flags & LOWPAN_IPHC_FLAG_MCAST_COMP ) )  295
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_64BIT_INLINE )  298
length = sizeof ( guint64 ); 298
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_16BIT_INLINE )  299
length = sizeof ( guint16 ); 299
if ( iphc_dst_mode == LOWPAN_IPHC_ADDR_COMPRESSED )  300
length = 0; 300
if ( iphc_dst_mode == LOWPAN_IPHC_MCAST_STATEFUL_48BIT )  312
ipv6 . ip6_dst . bytes [ 0 ] = 0xff; 313
ipv6 . ip6_dst . bytes [ 1 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 314
ipv6 . ip6_dst . bytes [ 2 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 315
ipv6 . ip6_dst . bytes [ 12 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 318
ipv6 . ip6_dst . bytes [ 13 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 319
ipv6 . ip6_dst . bytes [ 14 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 320
ipv6 . ip6_dst . bytes [ 15 ] = tvb_get_guint8 ( tvb , offset + ( length ++ ) ); 321
offset += length; 338
if ( iphc_flags & LOWPAN_IPHC_FLAG_NHDR )  350
nhdr_list = dissect_6lowpan_iphc_nhc ( tvb , pinfo , tree , offset , dgram_size - sizeof ( struct ip6_hdr ) ); 355
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 378
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 379
return ipv6_tvb ; 380
------------------------------
195 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ) 312
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
int i ; 6
guint8 hc1_encoding ; 7
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
struct lowpan_nhdr * nhdr_list ; 16
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
bit_offset += LOWPAN_IPV6_HOP_LIMIT_BITS; 87
offset = bit_offset; 93
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_PREFIX ) )  94
for (i=0; i<8; i++, bit_offset += 8) 95
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 96
memcpy ( ipv6 . ip6_src . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); 100
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_IFC ) )  102
for (i=8; i<16; i++, bit_offset += 8) 103
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 104
if ( pinfo -> src . type == AT_EUI64 )  108
memcpy ( & ipv6 . ip6_src . bytes [ 8 ] , pinfo -> src . data , 8 ); 109
offset = bit_offset; 130
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_PREFIX ) )  131
for (i=0; i<8; i++, bit_offset += 8) 132
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 133
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_IFC ) )  139
for (i=8; i<16; i++, bit_offset += 8) 140
if ( ! ( hc1_encoding & LOWPAN_HC1_TRAFFIC_CLASS ) )  166
bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; 173
bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; 181
if ( next_header == LOWPAN_HC1_NEXT_UDP )  187
if ( next_header == LOWPAN_HC1_NEXT_ICMP )  190
if ( next_header == LOWPAN_HC1_NEXT_TCP )  193
bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; 204
if ( ( hc1_encoding & LOWPAN_HC1_MORE ) && ( next_header == LOWPAN_HC1_NEXT_UDP ) )  211
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 303
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + tvb_length_remaining ( tvb , offset ) ); 304
if ( dgram_size < 0 )  308
nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); 312
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); 314
ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); 318
add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); 319
return ipv6_tvb ; 320
------------------------------
196 /home/SySeVR/data/CVE_2011_1138_VULN_dissect_6lowpan_hc1.c nhdr_list -> length = length + sizeof ( struct udp_hdr ) 291
static tvbuff_t *
CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) 2
gint offset = 0 ; 4
gint bit_offset ; 5
int i ; 6
guint8 hc1_encoding ; 7
guint8 hc_udp_encoding = 0 ; 8
guint8 next_header ; 9
struct ip6_hdr ipv6 ; 15
struct lowpan_nhdr * nhdr_list ; 16
offset += sizeof ( guint8 ); 30
hc1_encoding = tvb_get_guint8 ( tvb , offset ); 33
next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); 34
offset += sizeof ( guint8 ); 44
if ( hc1_encoding & LOWPAN_HC1_MORE )  47
if ( next_header == LOWPAN_HC1_NEXT_UDP )  48
hc_udp_encoding = tvb_get_guint8 ( tvb , offset ); 49
offset += sizeof ( guint8 ); 57
bit_offset = offset << 3; 79
ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); 82
bit_offset += LOWPAN_IPV6_HOP_LIMIT_BITS; 87
offset = bit_offset; 93
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_PREFIX ) )  94
for (i=0; i<8; i++, bit_offset += 8) 95
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 96
memcpy ( ipv6 . ip6_src . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); 100
if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_IFC ) )  102
for (i=8; i<16; i++, bit_offset += 8) 103
ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 104
if ( pinfo -> src . type == AT_EUI64 )  108
memcpy ( & ipv6 . ip6_src . bytes [ 8 ] , pinfo -> src . data , 8 ); 109
offset = bit_offset; 130
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_PREFIX ) )  131
for (i=0; i<8; i++, bit_offset += 8) 132
ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); 133
if ( ! ( hc1_encoding & LOWPAN_HC1_DEST_IFC ) )  139
for (i=8; i<16; i++, bit_offset += 8) 140
if ( ! ( hc1_encoding & LOWPAN_HC1_TRAFFIC_CLASS ) )  166
bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; 173
bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; 181
if ( next_header == LOWPAN_HC1_NEXT_UDP )  187
if ( next_header == LOWPAN_HC1_NEXT_ICMP )  190
if ( next_header == LOWPAN_HC1_NEXT_TCP )  193
bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; 204
if ( ( hc1_encoding & LOWPAN_HC1_MORE ) && ( next_header == LOWPAN_HC1_NEXT_UDP ) )  211
gint length ; 213
offset = bit_offset; 216
if ( hc_udp_encoding & LOWPAN_HC2_UDP_SRCPORT )  217
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 219
bit_offset += LOWPAN_UDP_PORT_BITS; 223
offset = bit_offset; 232
if ( hc_udp_encoding & LOWPAN_HC2_UDP_DSTPORT )  233
bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; 235
bit_offset += LOWPAN_UDP_PORT_BITS; 239
if ( ! ( hc_udp_encoding & LOWPAN_HC2_UDP_LENGTH ) )  248
bit_offset += LOWPAN_UDP_LENGTH_BITS; 255
if ( dgram_size >= 0 )  258
if ( dgram_size < ( gint ) sizeof ( struct ip6_hdr ) )  259
bit_offset += LOWPAN_UDP_CHECKSUM_BITS; 282
offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); 286
length = tvb_length_remaining ( tvb , offset ); 287
nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ); 288
nhdr_list -> next = NULL; 289
nhdr_list -> proto = IP_PROTO_UDP; 290
nhdr_list -> length = length + sizeof ( struct udp_hdr ); 291
nhdr_list -> reported = g_ntohs ( udp . length ); 292
memcpy ( LOWPAN_NHDR_DATA ( nhdr_list ) , & udp , sizeof ( struct udp_hdr ) ); 295
tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) + sizeof ( struct udp_hdr ) , offset , length ); 296
------------------------------
197 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c limit = ( l + m ) & UDPTL_BUF_MASK 146
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int i ; 5
int j ; 6
int k ; 7
int l ; 8
int m ; 9
int x ; 10
int limit ; 11
int which ; 12
int ptr ; 13
int seq_no ; 16
int ifp_len ; 19
int repaired [ 16 ] ; 20
int span ; 23
int entries ; 24
ptr = 0; 27
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( ifp_len > LOCAL_FAX_MAX_DATAGRAM )  86
for ( ; seq_no > s->rx_seq_no; s->rx_seq_no++) 89
x = s -> rx_seq_no & UDPTL_BUF_MASK; 90
s -> rx [ x ] . buf_len = - 1; 91
s -> rx [ x ] . fec_len [ 0 ] = 0; 92
s -> rx [ x ] . fec_span = 0; 93
s -> rx [ x ] . fec_entries = 0; 94
x = seq_no & UDPTL_BUF_MASK; 97
memset ( repaired , 0 , sizeof ( repaired ) ); 99
s -> rx [ x ] . buf_len = ifp_len; 103
repaired [ x ] = TRUE; 104
if ( ptr + 2 > len )  109
if ( buf [ ptr ++ ] != 1 )  111
span = buf [ ptr ++ ]; 113
s -> rx [ x ] . fec_span = span; 114
if ( ptr + 1 > len )  118
entries = buf [ ptr ++ ]; 120
s -> rx [ x ] . fec_entries = entries; 121
for (i = 0; i < entries; i++) 124
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
for (j = 0; j < s->rx[x].fec_len[i]; j++) 134
for (l = x; l != ((x - (16 - span*entries)) & UDPTL_BUF_MASK); l = (l - 1) & UDPTL_BUF_MASK) 142
if ( s -> rx [ l ] . fec_len [ 0 ] <= 0 )  143
for (m = 0; m < s->rx[l].fec_entries; m++) 145
limit = ( l + m ) & UDPTL_BUF_MASK; 146
for (which = -1, k = (limit - s->rx[l].fec_span * s->rx[l].fec_entries) & UDPTL_BUF_MASK; k != limit; k = (k + s->rx[l].fec_entries) & UDPTL_BUF_MASK) 147
if ( s -> rx [ k ] . buf_len <= 0 )  148
which = ( which == - 1 ) ? k : - 2; 149
if ( which >= 0 )  151
for (j = 0; j < s->rx[l].fec_len[m]; j++) 153
s -> rx [ which ] . buf [ j ] = s -> rx [ l ] . fec [ m ] [ j ]; 154
for (k = (limit - s->rx[l].fec_span * s->rx[l].fec_entries) & UDPTL_BUF_MASK; k != limit; k = (k + s->rx[l].fec_entries) & UDPTL_BUF_MASK) 155
s -> rx [ which ] . buf [ j ] ^= ( s -> rx [ k ] . buf_len > j ) ? s -> rx [ k ] . buf [ j ] : 0; 156
s -> rx [ which ] . buf_len = s -> rx [ l ] . fec_len [ m ]; 158
repaired [ which ] = TRUE; 159
for (l = (x + 1) & UDPTL_BUF_MASK, j = seq_no - UDPTL_BUF_MASK; l != x; l = (l + 1) & UDPTL_BUF_MASK, j++) 164
if ( repaired [ l ] )  165
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 167
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 168
s -> f [ ifp_no ] . mallocd = 0; 170
s -> f [ ifp_no ] . seqno = j; 171
s -> f [ ifp_no ] . datalen = s -> rx [ l ] . buf_len; 172
s -> f [ ifp_no ] . data = s -> rx [ l ] . buf; 173
s -> f [ ifp_no ] . offset = 0; 174
s -> f [ ifp_no ] . src = "UDPTL"; 175
if ( ifp_no > 0 )  176
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 177
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 178
ifp_no ++; 179
if ( seq_no >= s -> rx_seq_no )  186
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
------------------------------
198 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c s -> f [ ifp_no ] . seqno = seq_no - i 69
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int stat ; 3
int stat2 ; 4
int i ; 5
int ptr ; 13
int count ; 14
int total_count ; 15
int seq_no ; 16
const uint8_t * bufs [ 16 ] ; 21
int lengths [ 16 ] ; 22
int ifp_no ; 25
ptr = 0; 27
ifp_no = 0; 28
memset ( & s -> f [ 0 ] , 0 , sizeof ( s -> f [ 0 ] ) ); 29
if ( ptr + 2 > len )  32
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ]; 34
ptr += 2; 35
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )  38
if ( ptr + 1 > len )  41
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )  43
if ( seq_no > s -> rx_seq_no )  45
total_count = 0; 48
if ( ( stat2 = decode_length ( buf , len , & ptr , & count ) ) < 0 )  50
for (i = 0; i < count; i++) 52
if ( ( stat = decode_open_type ( buf , len , & ptr , & bufs [ total_count + i ] , & lengths [ total_count + i ] ) ) != 0 )  53
total_count += count; 56
while ( stat2 > 0 )  58
for (i = total_count; i > 0; i--) 60
if ( seq_no - i >= s -> rx_seq_no )  61
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 65
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 66
s -> f [ ifp_no ] . mallocd = 0; 68
s -> f [ ifp_no ] . seqno = seq_no - i; 69
s -> f [ ifp_no ] . datalen = lengths [ i - 1 ]; 70
s -> f [ ifp_no ] . data = ( uint8_t * ) bufs [ i - 1 ]; 71
s -> f [ ifp_no ] . offset = 0; 72
s -> f [ ifp_no ] . src = "UDPTL"; 73
if ( ifp_no > 0 )  74
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 75
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 76
ifp_no ++; 77
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
------------------------------
199 /home/SySeVR/data/CVE_2011_1495_PATCHED__ctl_do_mpt_command.c timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , timeout * HZ ) 283
static long
CVE_2011_1495_PATCHED__ctl_do_mpt_command(struct MPT2SAS_ADAPTER *ioc,
struct mpt2_ioctl_command karg, void __user *mf, enum block_state state) 3
u32 ioc_state ; 7
u16 smid ; 9
unsigned long timeout , timeleft ; 10
void * data_out = NULL ; 14
u16 wait_state_count ; 22
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )  26
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )  28
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )  31
wait_state_count = 0; 38
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 39
while ( ioc_state != MPI2_IOC_STATE_OPERATIONAL )  40
if ( wait_state_count ++ == 10 )  41
ioc_state = mpt2sas_base_get_iocstate ( ioc , 1 ); 49
mpi_request = kzalloc ( ioc -> request_sz , GFP_KERNEL ); 58
if ( ! mpi_request )  59
if ( karg . data_sge_offset * 4 > ioc -> request_sz || karg . data_sge_offset > ( UINT_MAX / 4 ) )  67
if ( copy_from_user ( mpi_request , mf , karg . data_sge_offset * 4 ) )  74
if ( mpi_request -> Function == MPI2_FUNCTION_SCSI_TASK_MGMT )  81
smid = mpt2sas_base_get_smid_hpr ( ioc , ioc -> ctl_cb_idx ); 82
if ( ! smid )  83
smid = mpt2sas_base_get_smid_scsiio ( ioc , ioc -> ctl_cb_idx , NULL ); 91
if ( ! smid )  92
ioc -> ctl_cmds . status = MPT2_CMD_PENDING; 101
memset ( ioc -> ctl_cmds . reply , 0 , ioc -> reply_sz ); 102
request = mpt2sas_base_get_msg_frame ( ioc , smid ); 103
ioc -> ctl_cmds . smid = smid; 105
data_out_sz = karg . data_out_size; 106
data_in_sz = karg . data_in_size; 107
if ( mpi_request -> Function == MPI2_FUNCTION_SCSI_IO_REQUEST || mpi_request -> Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH )  109
if ( ! le16_to_cpu ( mpi_request -> FunctionDependent1 ) || le16_to_cpu ( mpi_request -> FunctionDependent1 ) > ioc -> facts . MaxDevHandle )  111
if ( data_out_sz )  121
data_out = pci_alloc_consistent ( ioc -> pdev , data_out_sz , & data_out_dma ); 122
if ( ! data_out )  124
if ( copy_from_user ( data_out , karg . data_out_buf_ptr , data_out_sz ) )  131
if ( data_in_sz )  141
data_in = pci_alloc_consistent ( ioc -> pdev , data_in_sz , & data_in_dma ); 142
if ( ! data_in )  144
switch ( mpi_request -> Function )  197
memset ( ioc -> ctl_cmds . sense , 0 , SCSI_SENSE_BUFFERSIZE ); 206
Mpi2SCSITaskManagementRequest_t * tm_request = ( Mpi2SCSITaskManagementRequest_t * ) request ; 216
if ( tm_request -> TaskType == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK || tm_request -> TaskType == MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK )  223
if ( _ctl_set_task_mid ( ioc , & karg , tm_request ) )  227
Mpi2SmpPassthroughRequest_t * smp_request = ( Mpi2SmpPassthroughRequest_t * ) mpi_request ; 240
u8 * data ; 242
smp_request -> PhysicalPort = 0xFF; 245
if ( smp_request -> PassthroughFlags & MPI2_SMP_PT_REQ_PT_FLAGS_IMMEDIATE )  246
data = ( u8 * ) & smp_request -> SGL; 248
data = data_out; 250
if ( data [ 1 ] == 0x91 && ( data [ 10 ] == 1 || data [ 10 ] == 2 ) )  252
ioc -> ioc_link_reset_in_progress = 1; 253
ioc -> ignore_loginfos = 1; 254
Mpi2SasIoUnitControlRequest_t * sasiounit_request = ( Mpi2SasIoUnitControlRequest_t * ) mpi_request ; 261
if ( sasiounit_request -> Operation == MPI2_SAS_OP_PHY_HARD_RESET || sasiounit_request -> Operation == MPI2_SAS_OP_PHY_LINK_RESET )  264
ioc -> ioc_link_reset_in_progress = 1; 267
ioc -> ignore_loginfos = 1; 268
if ( karg . timeout < MPT2_IOCTL_DEFAULT_TIMEOUT )  278
timeout = MPT2_IOCTL_DEFAULT_TIMEOUT; 279
timeout = karg . timeout; 281
timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , timeout * HZ ); 283
------------------------------
200 /home/SySeVR/data/CVE_2011_1495_VULN__ctl_diag_read_buffer.c timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , MPT2_IOCTL_DEFAULT_TIMEOUT * HZ ) 122
static long
CVE_2011_1495_VULN__ctl_diag_read_buffer(void __user *arg, enum block_state state) 2
struct mpt2_diag_read_buffer karg ; 4
struct mpt2_diag_read_buffer __user * uarg = arg ; 5
struct MPT2SAS_ADAPTER * ioc ; 6
void * request_data , * diag_data ; 7
u8 buffer_type ; 11
unsigned long timeleft ; 12
u16 smid ; 13
if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) )  17
if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )  22
buffer_type = karg . unique_id & 0x000000ff; 28
if ( ! _ctl_diag_capability ( ioc , buffer_type ) )  29
if ( karg . unique_id != ioc -> unique_id [ buffer_type ] )  35
request_data = ioc -> diag_buffer [ buffer_type ]; 41
if ( ! request_data )  42
if ( ( karg . starting_offset % 4 ) || ( karg . bytes_to_read % 4 ) )  48
diag_data = ( void * ) ( request_data + karg . starting_offset ); 55
if ( copy_to_user ( ( void __user * ) uarg -> diagnostic_data , diag_data , karg . bytes_to_read ) )  60
if ( ( karg . flags & MPT2_FLAGS_REREGISTER ) == 0 )  68
if ( ( ioc -> diag_buffer_status [ buffer_type ] & MPT2_DIAG_BUFFER_IS_RELEASED ) == 0 )  73
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )  82
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )  84
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )  87
smid = mpt2sas_base_get_smid ( ioc , ioc -> ctl_cb_idx ); 94
if ( ! smid )  95
ioc -> ctl_cmds . status = MPT2_CMD_PENDING; 103
memset ( ioc -> ctl_cmds . reply , 0 , ioc -> reply_sz ); 104
ioc -> ctl_cmds . smid = smid; 106
timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , MPT2_IOCTL_DEFAULT_TIMEOUT * HZ ); 122
------------------------------
201 /home/SySeVR/data/CVE_2011_1495_VULN__ctl_diag_read_buffer.c diag_data = ( void * ) ( request_data + karg . starting_offset ) 55
static long
CVE_2011_1495_VULN__ctl_diag_read_buffer(void __user *arg, enum block_state state) 2
struct mpt2_diag_read_buffer karg ; 4
struct MPT2SAS_ADAPTER * ioc ; 6
void * request_data , * diag_data ; 7
u8 buffer_type ; 11
if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) )  17
if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )  22
buffer_type = karg . unique_id & 0x000000ff; 28
if ( ! _ctl_diag_capability ( ioc , buffer_type ) )  29
if ( karg . unique_id != ioc -> unique_id [ buffer_type ] )  35
request_data = ioc -> diag_buffer [ buffer_type ]; 41
if ( ! request_data )  42
if ( ( karg . starting_offset % 4 ) || ( karg . bytes_to_read % 4 ) )  48
diag_data = ( void * ) ( request_data + karg . starting_offset ); 55
dctlprintk ( ioc , printk ( MPT2SAS_INFO_FMT "%s: diag_buffer(%p), "
"offset(%d), sz(%d)\n" , ioc -> name , __func__ ,
diag_data , karg . starting_offset , karg . bytes_to_read ) ) 58
if ( copy_to_user ( ( void __user * ) uarg -> diagnostic_data , diag_data , karg . bytes_to_read ) )  60
printk ( MPT2SAS_ERR_FMT "%s: Unable to write "
"mpt_diag_read_buffer_t data @ %p\n" , ioc -> name ,
__func__ , diag_data ) 64
------------------------------
202 /home/SySeVR/data/CVE_2011_1573_VULN_sctp_make_init_ack.c chunksize = sizeof ( initack ) + addrs_len + cookie_len + unkparam_len 44
struct sctp_chunk *CVE_2011_1573_VULN_sctp_make_init_ack(const struct sctp_association *asoc,
const struct sctp_chunk *chunk,
gfp_t gfp, int unkparam_len) 3
union sctp_params addrs ; 7
int addrs_len ; 9
sctp_cookie_param_t * cookie ; 10
int cookie_len ; 11
size_t chunksize ; 12
addrs = sctp_bind_addrs_to_raw ( & asoc -> base . bind_addr , & addrs_len , gfp ); 24
cookie = sctp_pack_cookie ( asoc -> ep , asoc , chunk , & cookie_len , addrs . v , addrs_len ); 35
if ( ! cookie )  37
chunksize = sizeof ( initack ) + addrs_len + cookie_len + unkparam_len; 44
chunksize += sizeof ( ecap_param ); 48
chunksize += sizeof ( prsctp_param ); 51
chunksize += sizeof ( aiparam ); 60
chunksize += ntohs ( auth_random -> length ); 64
chunksize += ntohs ( auth_hmacs -> length ); 68
chunksize += ntohs ( auth_chunks -> length ); 74
chunksize += sizeof ( sctp_supported_ext_param_t ) + num_ext; 83
retval = sctp_make_chunk ( asoc , SCTP_CID_INIT_ACK , 0 , chunksize ); 86
if ( ! retval )  87
retval -> transport = chunk -> transport; 93
retval -> subh . init_hdr = sctp_addto_chunk ( retval , sizeof ( initack ) , & initack ); 94
retval -> param_hdr . v = sctp_addto_chunk ( retval , addrs_len , addrs . v ); 96
sctp_addto_chunk ( retval , cookie_len , cookie ); 97
sctp_addto_chunk ( retval , sizeof ( ecap_param ) , & ecap_param ); 99
sctp_addto_chunk ( retval , sizeof ( sctp_supported_ext_param_t ) , & ext_param ); 104
sctp_addto_param ( retval , num_ext , extensions ); 106
sctp_addto_chunk ( retval , sizeof ( prsctp_param ) , & prsctp_param ); 109
sctp_addto_chunk ( retval , sizeof ( aiparam ) , & aiparam ); 115
sctp_addto_chunk ( retval , ntohs ( auth_random -> length ) , auth_random ); 119
sctp_addto_chunk ( retval , ntohs ( auth_hmacs -> length ) , auth_hmacs ); 122
sctp_addto_chunk ( retval , ntohs ( auth_chunks -> length ) , auth_chunks ); 125
retval -> asoc = ( struct sctp_association * ) asoc; 130
retval -> transport = chunk -> transport; 142
return retval ; 148
------------------------------
203 /home/SySeVR/data/CVE_2011_1747_VULN_agp_allocate_memory.c scratch_pages = ( page_count + ENTRIES_PER_PAGE - 1 ) / ENTRIES_PER_PAGE 28
struct agp_memory *CVE_2011_1747_VULN_agp_allocate_memory(struct agp_bridge_data *bridge,
size_t page_count, u32 type) 2
int scratch_pages ; 4
if ( ! bridge )  8
if ( ( atomic_read ( & bridge -> current_memory_agp ) + page_count ) > bridge -> max_memory_agp )  11
scratch_pages = ( page_count + ENTRIES_PER_PAGE - 1 ) / ENTRIES_PER_PAGE; 28
new = agp_create_memory ( scratch_pages ) 30
if ( new == NULL ) 32
if ( bridge -> driver -> agp_alloc_pages ( bridge , new , page_count ) )
agp_free_memory ( new ) 37
agp_free_memory ( new ) 48
new -> pages [ i ] = page
new -> page_count ++ 52
return new 56
------------------------------
204 /home/SySeVR/data/CVE_2011_2587_VULN_DemuxAudioSipr.c p_block = block_New ( p_demux , tk -> i_frame_size * tk -> i_subpacket_h ) 11
static void CVE_2011_2587_VULN_DemuxAudioSipr( demux_t *p_demux, real_track_t *tk, mtime_t i_pts ) 1
demux_sys_t * p_sys = p_demux -> p_sys ; 3
block_t * p_block = tk -> p_sipr_packet ; 4
if ( p_sys -> i_buffer < tk -> i_frame_size )  6
if ( ! p_block )  9
p_block = block_New ( p_demux , tk -> i_frame_size * tk -> i_subpacket_h ); 11
if ( ! p_block )  12
tk -> p_sipr_packet = p_block; 14
memcpy ( p_block -> p_buffer + tk -> i_sipr_subpacket_count * tk -> i_frame_size , p_sys -> buffer , tk -> i_frame_size ); 17
if ( ! tk -> i_sipr_subpacket_count )  19
p_block -> i_dts = p_block -> i_pts = i_pts; 21
if ( ++ tk -> i_sipr_subpacket_count < tk -> i_subpacket_h )  25
SiprPacketReorder ( p_block -> p_buffer , tk -> i_subpacket_h , tk -> i_frame_size ); 28
CheckPcr ( p_demux , tk , p_block -> i_pts ); 29
es_out_Send ( p_demux -> out , tk -> p_es , p_block ); 30
tk -> i_sipr_subpacket_count = 0; 31
tk -> p_sipr_packet = NULL; 32
------------------------------
205 /home/SySeVR/data/CVE_2011_2588_PATCHED_AVI_ChunkRead_strf.c p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) 36
static int CVE_2011_2588_PATCHED_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
if ( p_chk -> strf . auds . p_wf -> wFormatTag == WAVE_FORMAT_EXTENSIBLE )  39
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
msg_Dbg ( ( vlc_object_t * ) s , "strf: audio:0x%4.4x channels:%d %dHz %dbits/sample %dkb/s" , p_chk -> strf . auds . p_wf -> wFormatTag , p_chk -> strf . auds . p_wf -> nChannels , p_chk -> strf . auds . p_wf -> nSamplesPerSec , p_chk -> strf . auds . p_wf -> wBitsPerSample , p_chk -> strf . auds . p_wf -> nAvgBytesPerSec * 8 / 1024 ); 57
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( * p_chk -> strf . vids . p_bih ) ) ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 72
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 74
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 75
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 80
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 81
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  82
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 84
if ( p_chk -> common . i_chunk_size > sizeof ( BITMAPINFOHEADER ) )  86
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 88
p_chk -> strf . common . i_cat = UNKNOWN_ES; 104
------------------------------
206 /home/SySeVR/data/CVE_2011_2588_VULN_AVI_ChunkRead_strf.c p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) 36
static int CVE_2011_2588_VULN_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk ) 1
p_chk -> strf . auds . i_cat = AUDIO_ES; 20
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) ); 21
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )  28
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )  33
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ); 36
if ( p_chk -> strf . auds . p_wf -> wFormatTag == WAVE_FORMAT_EXTENSIBLE )  39
p_chk -> strf . auds . p_wf -> cbSize = 0; 48
if ( p_chk -> strf . auds . p_wf -> cbSize > 0 )  50
memcpy ( & p_chk -> strf . auds . p_wf [ 1 ] , p_buff + 8 + sizeof ( WAVEFORMATEX ) , p_chk -> strf . auds . p_wf -> cbSize ); 52
msg_Dbg ( ( vlc_object_t * ) s , "strf: audio:0x%4.4x channels:%d %dHz %dbits/sample %dkb/s" , p_chk -> strf . auds . p_wf -> wFormatTag , p_chk -> strf . auds . p_wf -> nChannels , p_chk -> strf . auds . p_wf -> nSamplesPerSec , p_chk -> strf . auds . p_wf -> wBitsPerSample , p_chk -> strf . auds . p_wf -> nAvgBytesPerSec * 8 / 1024 ); 57
p_chk -> strf . vids . i_cat = VIDEO_ES; 68
p_chk -> strf . vids . p_bih = malloc ( p_chk -> common . i_chunk_size ); 69
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSize ); 70
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biWidth ); 71
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biHeight ); 72
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biPlanes ); 73
AVI_READ2BYTES ( p_chk -> strf . vids . p_bih -> biBitCount ); 74
AVI_READFOURCC ( p_chk -> strf . vids . p_bih -> biCompression ); 75
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biSizeImage ); 76
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biXPelsPerMeter ); 77
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biYPelsPerMeter ); 78
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrUsed ); 79
AVI_READ4BYTES ( p_chk -> strf . vids . p_bih -> biClrImportant ); 80
if ( p_chk -> strf . vids . p_bih -> biSize > p_chk -> common . i_chunk_size )  81
p_chk -> strf . vids . p_bih -> biSize = p_chk -> common . i_chunk_size; 83
if ( p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) > 0 )  85
memcpy ( & p_chk -> strf . vids . p_bih [ 1 ] , p_buff + 8 + sizeof ( BITMAPINFOHEADER ) , p_chk -> common . i_chunk_size - sizeof ( BITMAPINFOHEADER ) ); 87
p_chk -> strf . common . i_cat = UNKNOWN_ES; 103
------------------------------
207 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) 74
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; 11
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 13
if ( mode & ~FALLOC_FL_KEEP_SIZE )  16
offset &= bsize_mask; 19
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
bytes &= bsize_mask; 25
if ( bytes == 0 )  26
bytes = sdp -> sd_sb . sb_bsize; 27
error = gfs2_glock_nq ( & ip -> i_gh ); 30
if ( unlikely ( error ) )  31
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  34
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
al = gfs2_alloc_get ( ip ); 40
if ( ! al )  41
error = gfs2_quota_lock_check ( ip ); 46
if ( error )  47
al -> al_requested = data_blocks + ind_blocks; 53
error = gfs2_inplace_reserve ( ip ); 54
if ( error )  55
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
bytes = sdp -> sd_sb . sb_bsize; 60
max_bytes = bytes; 65
al -> al_requested = data_blocks + ind_blocks; 67
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 69
if ( gfs2_is_jdata ( ip ) )  71
rblocks += data_blocks ? data_blocks : 1; 72
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 74
if ( error )  76
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
208 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ) 69
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; 11
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 13
if ( mode & ~FALLOC_FL_KEEP_SIZE )  16
offset &= bsize_mask; 19
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
bytes &= bsize_mask; 25
if ( bytes == 0 )  26
bytes = sdp -> sd_sb . sb_bsize; 27
error = gfs2_glock_nq ( & ip -> i_gh ); 30
if ( unlikely ( error ) )  31
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  34
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
al = gfs2_alloc_get ( ip ); 40
if ( ! al )  41
error = gfs2_quota_lock_check ( ip ); 46
if ( error )  47
al -> al_requested = data_blocks + ind_blocks; 53
error = gfs2_inplace_reserve ( ip ); 54
if ( error )  55
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
bytes = sdp -> sd_sb . sb_bsize; 60
max_bytes = bytes; 65
al -> al_requested = data_blocks + ind_blocks; 67
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 69
if ( gfs2_is_jdata ( ip ) )  71
rblocks += data_blocks ? data_blocks : 1; 72
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 74
if ( error )  76
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
209 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c al -> al_requested = data_blocks + ind_blocks 67
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; 11
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 13
if ( mode & ~FALLOC_FL_KEEP_SIZE )  16
offset &= bsize_mask; 19
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
bytes &= bsize_mask; 25
if ( bytes == 0 )  26
bytes = sdp -> sd_sb . sb_bsize; 27
error = gfs2_glock_nq ( & ip -> i_gh ); 30
if ( unlikely ( error ) )  31
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  34
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
al = gfs2_alloc_get ( ip ); 40
if ( ! al )  41
error = gfs2_quota_lock_check ( ip ); 46
if ( error )  47
al -> al_requested = data_blocks + ind_blocks; 53
error = gfs2_inplace_reserve ( ip ); 54
if ( error )  55
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
bytes = sdp -> sd_sb . sb_bsize; 60
max_bytes = bytes; 65
al -> al_requested = data_blocks + ind_blocks; 67
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 69
if ( gfs2_is_jdata ( ip ) )  71
rblocks += data_blocks ? data_blocks : 1; 72
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 74
if ( error )  76
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
210 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c al -> al_requested = data_blocks + ind_blocks 53
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; 11
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 13
if ( mode & ~FALLOC_FL_KEEP_SIZE )  16
offset &= bsize_mask; 19
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
bytes &= bsize_mask; 25
if ( bytes == 0 )  26
bytes = sdp -> sd_sb . sb_bsize; 27
error = gfs2_glock_nq ( & ip -> i_gh ); 30
if ( unlikely ( error ) )  31
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  34
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
al = gfs2_alloc_get ( ip ); 40
if ( ! al )  41
error = gfs2_quota_lock_check ( ip ); 46
if ( error )  47
al -> al_requested = data_blocks + ind_blocks; 53
error = gfs2_inplace_reserve ( ip ); 54
if ( error )  55
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
bytes = sdp -> sd_sb . sb_bsize; 60
max_bytes = bytes; 65
al -> al_requested = data_blocks + ind_blocks; 67
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 69
if ( gfs2_is_jdata ( ip ) )  71
rblocks += data_blocks ? data_blocks : 1; 72
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 74
if ( error )  76
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
211 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 22
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
loff_t bytes , max_bytes ; 8
if ( mode & ~FALLOC_FL_KEEP_SIZE )  16
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes &= bsize_mask; 25
if ( bytes == 0 )  26
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ); 51
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
max_bytes = bytes; 65
calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ); 66
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
212 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c len = next - offset 21
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; 11
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 13
if ( mode & ~FALLOC_FL_KEEP_SIZE )  16
offset &= bsize_mask; 19
len = next - offset; 21
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  34
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ); 51
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
max_bytes = bytes; 65
calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ); 66
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
213 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) 68
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 12
if ( mode & ~FALLOC_FL_KEEP_SIZE )  15
offset = ( offset >> sdp -> sd_sb . sb_bsize_shift ) << sdp -> sd_sb . sb_bsize_shift; 18
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
error = gfs2_glock_nq ( & ip -> i_gh ); 27
if ( unlikely ( error ) )  28
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  31
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
al = gfs2_alloc_get ( ip ); 37
if ( ! al )  38
error = gfs2_quota_lock_check ( ip ); 43
if ( error )  44
al -> al_requested = data_blocks + ind_blocks; 50
error = gfs2_inplace_reserve ( ip ); 51
if ( error )  52
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
al -> al_requested = data_blocks + ind_blocks; 61
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 63
if ( gfs2_is_jdata ( ip ) )  65
rblocks += data_blocks ? data_blocks : 1; 66
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 68
if ( error )  70
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
214 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ) 63
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 12
if ( mode & ~FALLOC_FL_KEEP_SIZE )  15
offset = ( offset >> sdp -> sd_sb . sb_bsize_shift ) << sdp -> sd_sb . sb_bsize_shift; 18
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
error = gfs2_glock_nq ( & ip -> i_gh ); 27
if ( unlikely ( error ) )  28
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  31
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
al = gfs2_alloc_get ( ip ); 37
if ( ! al )  38
error = gfs2_quota_lock_check ( ip ); 43
if ( error )  44
al -> al_requested = data_blocks + ind_blocks; 50
error = gfs2_inplace_reserve ( ip ); 51
if ( error )  52
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
al -> al_requested = data_blocks + ind_blocks; 61
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 63
if ( gfs2_is_jdata ( ip ) )  65
rblocks += data_blocks ? data_blocks : 1; 66
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 68
if ( error )  70
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
215 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c al -> al_requested = data_blocks + ind_blocks 61
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 12
if ( mode & ~FALLOC_FL_KEEP_SIZE )  15
offset = ( offset >> sdp -> sd_sb . sb_bsize_shift ) << sdp -> sd_sb . sb_bsize_shift; 18
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
error = gfs2_glock_nq ( & ip -> i_gh ); 27
if ( unlikely ( error ) )  28
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  31
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
al = gfs2_alloc_get ( ip ); 37
if ( ! al )  38
error = gfs2_quota_lock_check ( ip ); 43
if ( error )  44
al -> al_requested = data_blocks + ind_blocks; 50
error = gfs2_inplace_reserve ( ip ); 51
if ( error )  52
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
al -> al_requested = data_blocks + ind_blocks; 61
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 63
if ( gfs2_is_jdata ( ip ) )  65
rblocks += data_blocks ? data_blocks : 1; 66
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 68
if ( error )  70
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
216 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c al -> al_requested = data_blocks + ind_blocks 50
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
struct gfs2_inode * ip = GFS2_I ( inode ) ; 6
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; 7
loff_t bytes , max_bytes ; 8
struct gfs2_alloc * al ; 9
int error ; 10
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 12
if ( mode & ~FALLOC_FL_KEEP_SIZE )  15
offset = ( offset >> sdp -> sd_sb . sb_bsize_shift ) << sdp -> sd_sb . sb_bsize_shift; 18
len = next - offset; 21
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
bytes = UINT_MAX; 24
error = gfs2_glock_nq ( & ip -> i_gh ); 27
if ( unlikely ( error ) )  28
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  31
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
al = gfs2_alloc_get ( ip ); 37
if ( ! al )  38
error = gfs2_quota_lock_check ( ip ); 43
if ( error )  44
al -> al_requested = data_blocks + ind_blocks; 50
error = gfs2_inplace_reserve ( ip ); 51
if ( error )  52
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
al -> al_requested = data_blocks + ind_blocks; 61
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ); 63
if ( gfs2_is_jdata ( ip ) )  65
rblocks += data_blocks ? data_blocks : 1; 66
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ); 68
if ( error )  70
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
217 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 22
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
loff_t bytes , max_bytes ; 8
if ( mode & ~FALLOC_FL_KEEP_SIZE )  15
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2; 22
if ( ! bytes )  23
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ); 48
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ); 60
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
218 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c len = next - offset 21
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 12
if ( mode & ~FALLOC_FL_KEEP_SIZE )  15
offset = ( offset >> sdp -> sd_sb . sb_bsize_shift ) << sdp -> sd_sb . sb_bsize_shift; 18
len = next - offset; 21
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  31
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ); 48
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ); 60
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
219 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount 515
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
220 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ) 497
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
221 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c pc = pc + GET_OFFSET ( pc ) 462
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
222 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = x -> cp - gData -> cpbegin 452
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
223 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = x -> cp - gData -> cpbegin 414
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
224 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c pc = pc + GET_OFFSET ( pc ) 401
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
225 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = x -> cp - gData -> cpbegin 386
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
226 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = startcp - gData -> cpbegin 344
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
227 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + ARG_LEN 331
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
228 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = startcp - gData -> cpbegin 288
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
229 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c pc = pc + GET_OFFSET ( pc ) 282
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
230 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + ARG_LEN 273
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
231 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c pc = pc + GET_OFFSET ( pc ) 267
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
232 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ) 239
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
233 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c x -> cp = gData -> cpbegin + curState -> index 238
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
234 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ) 227
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
235 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c x -> cp = gData -> cpbegin + curState -> index 226
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
236 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = x -> cp - gData -> cpbegin 214
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
237 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + GET_OFFSET ( pc ) 200
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
238 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c curState -> index = x -> cp - gData -> cpbegin 190
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
239 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + GET_OFFSET ( pc ) 178
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
240 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c delta = x -> cp - ( gData -> cpbegin + cap -> index ) 169
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
RECapture * cap ; 8
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
ptrdiff_t delta ; 164
pc = ReadCompactIndex ( pc , & parenIndex ); 166
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
x = result; 527
op = ( REOp ) * pc ++; 532
------------------------------
241 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin 157
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
242 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + GET_OFFSET ( pc ) 100
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
243 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + GET_OFFSET ( pc ) 85
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
244 /home/SySeVR/data/CVE_2011_2998_VULN_ExecuteREBytecode.c nextpc = pc + GET_OFFSET ( pc ) 59
static JS_ALWAYS_INLINE REMatchState *
CVE_2011_2998_VULN_ExecuteREBytecode(REGlobalData *gData, REMatchState *x) 2
REMatchState * result = NULL ; 4
REBackTrackData * backTrackData ; 5
jsbytecode * nextpc , * testpc ; 6
REOp nextop ; 7
REProgState * curState ; 9
const jschar * startcp ; 10
size_t parenIndex , k ; 11
size_t parenSoFar = 0 ; 12
jschar matchCh1 , matchCh2 ; 14
RECharSet * charSet ; 15
JSBool anchor ; 17
jsbytecode * pc = gData -> regexp -> program ; 18
REOp op = ( REOp ) * pc ++ ; 19
if ( REOP_IS_SIMPLE ( op ) && ! ( gData -> regexp -> flags & JSREG_STICKY ) )  25
anchor = JS_FALSE; 26
while ( x -> cp <= gData -> cpend )  27
nextpc = pc; 28
result = SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ); 29
if ( result )  30
anchor = JS_TRUE; 31
x = result; 32
pc = nextpc; 33
op = ( REOp ) * pc ++; 34
gData -> skipped ++; 38
x -> cp ++; 39
if ( ! anchor )  41
const char * opname = reop_names [ op ] ; 47
re_debug ( "\n%06d: %*s%s" , pc - gData -> regexp -> program , gData -> stateStackTop * 2 , "" , opname ); 48
if ( REOP_IS_SIMPLE ( op ) )  51
result = SimpleMatch ( gData , x , op , & pc , JS_TRUE ); 52
curState = & gData -> stateStack [ gData -> stateStackTop ]; 54
switch ( op )  55
nextpc = pc + GET_OFFSET ( pc ); 59
pc += ARG_LEN; 60
matchCh2 = GET_ARG ( pc ); 61
pc += ARG_LEN; 62
k = GET_ARG ( pc ); 63
pc += ARG_LEN; 64
if ( x -> cp != gData -> cpend )  66
if ( * x -> cp == matchCh2 )  67
charSet = & gData -> regexp -> classList [ k ]; 70
if ( ! charSet -> converted && ! MatcherProcessCharSet ( gData , charSet ) )  71
matchCh1 = * x -> cp; 73
k = matchCh1 >> 3; 74
if ( ( matchCh1 > charSet -> length || ! ( charSet -> u . bits [ k ] & ( 1 << ( matchCh1 & 0x7 ) ) ) ) ^ charSet -> sense )  75
result = NULL; 81
nextpc = pc + GET_OFFSET ( pc ); 85
pc += ARG_LEN; 86
matchCh1 = GET_ARG ( pc ); 87
pc += ARG_LEN; 88
matchCh2 = GET_ARG ( pc ); 89
pc += ARG_LEN; 90
if ( x -> cp == gData -> cpend || ( * x -> cp != matchCh1 && * x -> cp != matchCh2 ) )  91
result = NULL; 93
nextpc = pc + GET_OFFSET ( pc ); 100
pc += ARG_LEN; 101
curState -> parenSoFar = parenSoFar; 102
op = ( REOp ) * pc ++; 104
startcp = x -> cp; 105
if ( REOP_IS_SIMPLE ( op ) )  106
if ( ! SimpleMatch ( gData , x , op , & pc , JS_TRUE ) )  107
op = ( REOp ) * nextpc ++; 108
pc = nextpc; 109
result = x; 112
op = ( REOp ) * pc ++; 113
nextop = ( REOp ) * nextpc ++; 115
if ( ! PushBackTrackState ( gData , nextop , nextpc , x , startcp , 0 , 0 ) )  116
if ( ! result )  128
result = x; 129
pc += GET_OFFSET ( pc ); 132
op = ( REOp ) * pc ++; 133
if ( ! result )  144
result = x; 145
op = ( REOp ) * pc ++; 148
pc = ReadCompactIndex ( pc , & parenIndex ); 152
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 154
if ( parenIndex + 1 > parenSoFar )  155
parenSoFar = parenIndex + 1; 156
x -> parens [ parenIndex ] . index = x -> cp - gData -> cpbegin; 157
x -> parens [ parenIndex ] . length = 0; 158
op = ( REOp ) * pc ++; 159
pc = ReadCompactIndex ( pc , & parenIndex ); 166
JS_ASSERT ( parenIndex < gData -> regexp -> parenCount ); 167
cap = & x -> parens [ parenIndex ]; 168
delta = x -> cp - ( gData -> cpbegin + cap -> index ); 169
cap -> length = ( delta < 0 ) ? 0 : ( size_t ) delta; 170
op = ( REOp ) * pc ++; 171
if ( ! result )  173
result = x; 174
nextpc = pc + GET_OFFSET ( pc ); 178
pc += ARG_LEN; 179
op = ( REOp ) * pc ++; 180
testpc = pc; 181
if ( REOP_IS_SIMPLE ( op ) && ! SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) )  182
result = NULL; 184
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 187
curState -> u . assertion . sz = gData -> cursz; 189
curState -> index = x -> cp - gData -> cpbegin; 190
curState -> parenSoFar = parenSoFar; 191
if ( ! PushBackTrackState ( gData , REOP_ASSERTTEST , nextpc , x , x -> cp , 0 , 0 ) )  193
nextpc = pc + GET_OFFSET ( pc ); 200
pc += ARG_LEN; 201
op = ( REOp ) * pc ++; 202
testpc = pc; 203
if ( REOP_IS_SIMPLE ( op ) && SimpleMatch ( gData , x , op , & testpc , JS_FALSE ) && * testpc == REOP_ASSERTNOTTEST )  204
result = NULL; 207
curState -> u . assertion . top = ( char * ) gData -> backTrackSP - ( char * ) gData -> backTrackStack; 210
curState -> u . assertion . sz = gData -> cursz; 213
curState -> index = x -> cp - gData -> cpbegin; 214
curState -> parenSoFar = parenSoFar; 215
if ( ! PushBackTrackState ( gData , REOP_ASSERTNOTTEST , nextpc , x , x -> cp , 0 , 0 ) )  217
x -> cp = gData -> cpbegin + curState -> index; 226
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 227
gData -> cursz = curState -> u . assertion . sz; 230
if ( result )  231
result = x; 232
-- gData -> stateStackTop; 236
x -> cp = gData -> cpbegin + curState -> index; 238
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) gData -> backTrackStack + curState -> u . assertion . top ); 239
gData -> cursz = curState -> u . assertion . sz; 242
result = ( ! result ) ? x : NULL; 243
curState -> u . quantifier . min = 0; 246
curState -> u . quantifier . max = ( uintN ) - 1; 247
curState -> u . quantifier . min = 1; 250
curState -> u . quantifier . max = ( uintN ) - 1; 251
curState -> u . quantifier . min = 0; 254
curState -> u . quantifier . max = 1; 255
pc = ReadCompactIndex ( pc , & k ); 258
curState -> u . quantifier . min = k; 259
pc = ReadCompactIndex ( pc , & k ); 260
curState -> u . quantifier . max = k - 1; 262
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 263
if ( curState -> u . quantifier . max == 0 )  266
pc = pc + GET_OFFSET ( pc ); 267
op = ( REOp ) * pc ++; 268
result = x; 269
nextpc = pc + ARG_LEN; 273
op = ( REOp ) * nextpc ++; 274
startcp = x -> cp; 275
if ( REOP_IS_SIMPLE ( op ) )  276
if ( ! SimpleMatch ( gData , x , op , & nextpc , JS_TRUE ) )  277
if ( curState -> u . quantifier . min == 0 )  278
result = x; 279
result = NULL; 281
pc = pc + GET_OFFSET ( pc ); 282
op = ( REOp ) * nextpc ++; 285
result = x; 286
curState -> index = startcp - gData -> cpbegin; 288
curState -> continue_op = REOP_REPEAT; 289
curState -> continue_pc = pc; 290
curState -> parenSoFar = parenSoFar; 291
PUSH_STATE_STACK ( gData ); 292
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , 0 , 0 ) )  293
pc = nextpc; 298
pc = curState [ - 1 ] . continue_pc; 302
op = ( REOp ) curState [ - 1 ] . continue_op; 303
if ( ! result )  305
result = x; 306
-- gData -> stateStackTop; 312
if ( ! result )  313
if ( curState -> u . quantifier . min == 0 )  315
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  319
result = NULL; 322
if ( curState -> u . quantifier . min != 0 )  325
curState -> u . quantifier . min --; 326
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  327
curState -> u . quantifier . max --; 328
if ( curState -> u . quantifier . max == 0 )  329
nextpc = pc + ARG_LEN; 331
nextop = ( REOp ) * nextpc; 332
startcp = x -> cp; 333
if ( REOP_IS_SIMPLE ( nextop ) )  334
nextpc ++; 335
if ( ! SimpleMatch ( gData , x , nextop , & nextpc , JS_TRUE ) )  336
if ( curState -> u . quantifier . min == 0 )  337
result = NULL; 339
result = x; 342
curState -> index = startcp - gData -> cpbegin; 344
PUSH_STATE_STACK ( gData ); 345
if ( curState -> u . quantifier . min == 0 && ! PushBackTrackState ( gData , REOP_REPEAT , pc , x , startcp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  346
while ( * nextpc == REOP_ENDCHILD )  354
pc = nextpc; 355
op = ( REOp ) * pc ++; 356
parenSoFar = curState -> parenSoFar; 357
result = x; 361
pc += GET_OFFSET ( pc ); 362
curState -> u . quantifier . min = 0; 366
curState -> u . quantifier . max = ( uintN ) - 1; 367
curState -> u . quantifier . min = 1; 370
curState -> u . quantifier . max = ( uintN ) - 1; 371
curState -> u . quantifier . min = 0; 374
curState -> u . quantifier . max = 1; 375
pc = ReadCompactIndex ( pc , & k ); 378
curState -> u . quantifier . min = k; 379
pc = ReadCompactIndex ( pc , & k ); 380
curState -> u . quantifier . max = k - 1; 382
JS_ASSERT ( curState -> u . quantifier . min <= curState -> u . quantifier . max ); 383
curState -> index = x -> cp - gData -> cpbegin; 386
curState -> parenSoFar = parenSoFar; 387
if ( curState -> u . quantifier . min != 0 )  389
curState -> continue_op = REOP_MINIMALREPEAT; 390
curState -> continue_pc = pc; 391
pc += OFFSET_LEN; 393
op = ( REOp ) * pc ++; 394
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , 0 , 0 ) )  396
pc = pc + GET_OFFSET ( pc ); 401
op = ( REOp ) * pc ++; 402
re_debug ( "{%d,%d}" , curState -> u . quantifier . min , curState -> u . quantifier . max ); 410
curState -> index = x -> cp - gData -> cpbegin; 414
curState -> continue_op = REOP_MINIMALREPEAT; 415
curState -> continue_pc = pc; 416
pc += ARG_LEN; 417
for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
x->parens[k].index = -1;                                          \
PUSH_STATE_STACK(gData);                                              \
op = (REOp) *pc++;                                                    \
JS_ASSERT(op < REOP_LIMIT);                                           \
JS_END_MACRO 424
if ( ! result )  425
if ( curState -> u . quantifier . max == ( uintN ) - 1 || curState -> u . quantifier . max > 0 )  430
if ( curState -> u . quantifier . min == 0 && x -> cp == gData -> cpbegin + curState -> index )  438
result = NULL; 441
if ( curState -> u . quantifier . min != 0 )  444
curState -> u . quantifier . min --; 445
if ( curState -> u . quantifier . max != ( uintN ) - 1 )  446
curState -> u . quantifier . max --; 447
if ( curState -> u . quantifier . min != 0 )  448
curState -> index = x -> cp - gData -> cpbegin; 452
curState -> parenSoFar = parenSoFar; 453
if ( ! PushBackTrackState ( gData , REOP_MINIMALREPEAT , pc , x , x -> cp , curState -> parenSoFar , parenSoFar - curState -> parenSoFar ) )  455
pc = pc + GET_OFFSET ( pc ); 462
op = ( REOp ) * pc ++; 463
JS_ASSERT ( op < REOP_LIMIT ); 464
result = NULL; 468
if ( ! result )  477
if ( gData -> cursz == 0 )  478
if ( ! JS_CHECK_OPERATION_LIMIT ( gData -> cx ) )  480
gData -> ok = JS_FALSE; 481
gData -> backTrackCount ++; 486
if ( gData -> backTrackLimit && gData -> backTrackCount >= gData -> backTrackLimit )  487
JS_ReportErrorNumber ( gData -> cx , js_GetErrorMessage , NULL , JSMSG_REGEXP_TOO_COMPLEX ); 489
gData -> ok = JS_FALSE; 491
backTrackData = gData -> backTrackSP; 495
gData -> cursz = backTrackData -> sz; 496
gData -> backTrackSP = ( REBackTrackData * ) ( ( char * ) backTrackData - backTrackData -> sz ); 497
x -> cp = backTrackData -> cp; 499
pc = backTrackData -> backtrack_pc; 500
op = ( REOp ) backTrackData -> backtrack_op; 501
JS_ASSERT ( op < REOP_LIMIT ); 502
gData -> stateStackTop = backTrackData -> saveStateStackTop; 503
JS_ASSERT ( gData -> stateStackTop ); 504
memcpy ( gData -> stateStack , backTrackData + 1 , sizeof ( REProgState ) * backTrackData -> saveStateStackTop ); 506
curState = & gData -> stateStack [ gData -> stateStackTop - 1 ]; 508
if ( backTrackData -> parenCount )  510
memcpy ( & x -> parens [ backTrackData -> parenIndex ] , ( char * ) ( backTrackData + 1 ) + sizeof ( REProgState ) * backTrackData -> saveStateStackTop , sizeof ( RECapture ) * backTrackData -> parenCount ); 511
parenSoFar = backTrackData -> parenIndex + backTrackData -> parenCount; 515
for (k = curState->parenSoFar; k < parenSoFar; k++) 517
x -> parens [ k ] . index = - 1; 518
parenSoFar = curState -> parenSoFar; 519
re_debug ( "\tBT_Pop: %ld,%ld" , ( unsigned long ) backTrackData -> parenIndex , ( unsigned long ) backTrackData -> parenCount ); 522
x = result; 527
op = ( REOp ) * pc ++; 532
JS_ASSERT ( op < REOP_LIMIT ); 533
return x ; 542
------------------------------
245 /home/SySeVR/data/CVE_2011_3362_PATCHED_decode_residual_block.c run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 13
static int CVE_2011_3362_PATCHED_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
int i , esc_code , level , mask ; 4
unsigned int level_code , run ; 5
for(i=0;i<65;i++) 10
level_code = get_ue_code ( gb , r -> golomb_order ); 11
if ( level_code >= ESCAPE_CODE )  12
run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1; 13
esc_code = get_ue_code ( gb , esc_golomb_order ); 14
level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ); 15
while ( level > r -> inc_limit )  16
r ++; 17
level = ( level ^ mask ) - mask; 19
level = r -> rltab [ level_code ] [ 0 ]; 21
if ( ! level )  22
r += r -> rltab [ level_code ] [ 2 ]; 25
level_buf [ i ] = level; 27
run_buf [ i ] = run; 28
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  30
------------------------------
246 /home/SySeVR/data/CVE_2011_3362_VULN_decode_residual_block.c run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 12
static int CVE_2011_3362_VULN_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
int i , level_code , esc_code , level , run , mask ; 4
for(i=0;i<65;i++) 9
level_code = get_ue_code ( gb , r -> golomb_order ); 10
if ( level_code >= ESCAPE_CODE )  11
run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1; 12
esc_code = get_ue_code ( gb , esc_golomb_order ); 13
level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ); 14
while ( level > r -> inc_limit )  15
r ++; 16
level = ( level ^ mask ) - mask; 18
level = r -> rltab [ level_code ] [ 0 ]; 20
if ( ! level )  21
r += r -> rltab [ level_code ] [ 2 ]; 24
level_buf [ i ] = level; 26
run_buf [ i ] = run; 27
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  29
------------------------------
247 /home/SySeVR/data/CVE_2011_3363_PATCHED_cifs_mount.c tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ) 213
int
CVE_2011_3363_PATCHED_cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
char *mount_data_global, const char *devname) 3
int rc ; 5
int xid ; 6
struct smb_vol * volume_info ; 7
struct cifsSesInfo * pSesInfo ; 8
struct cifsTconInfo * tcon ; 9
struct TCP_Server_Info * srvTcp ; 10
char * full_path ; 11
char * mount_data = mount_data_global ; 12
struct tcon_link * tlink ; 13
struct dfs_info3_param * referrals = NULL ; 15
unsigned int num_referrals = 0 ; 16
int referral_walks_count = 0 ; 17
rc = 0; 20
tlink = NULL; 25
xid = GetXid ( ); 27
volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ); 29
if ( ! volume_info )  30
if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) )  35
if ( volume_info -> nullauth )  40
volume_info -> username = ""; 42
if ( volume_info -> username )  43
if ( volume_info -> iocharset == NULL )  55
volume_info -> local_nls = load_nls_default ( ); 57
volume_info -> local_nls = load_nls ( volume_info -> iocharset ); 59
if ( volume_info -> local_nls == NULL )  60
cifs_sb -> local_nls = volume_info -> local_nls; 67
srvTcp = cifs_get_tcp_session ( volume_info ); 70
if ( IS_ERR ( srvTcp ) )  71
pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ); 77
if ( IS_ERR ( pSesInfo ) )  78
tcon = cifs_get_tcon ( pSesInfo , volume_info ); 94
if ( IS_ERR ( tcon ) )  95
rc = PTR_ERR ( tcon ); 96
tcon = NULL; 97
if ( tcon -> ses -> capabilities & CAP_UNIX )  108
tcon -> unix_ext = 0; 113
if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) )  119
cifs_sb -> rsize = 1024 * 127; 120
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) )  123
cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 124
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) )  126
cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 127
if ( ! rc && tcon )  132
full_path = cifs_build_path_to_root ( cifs_sb , tcon ); 134
if ( full_path == NULL )  135
rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ); 139
if ( rc != 0 && rc != - EREMOTE )  140
if ( rc == - EREMOTE )  148
if ( referral_walks_count > MAX_NESTED_LINKS )  150
full_path = build_unc_path_to_root ( volume_info , cifs_sb ); 164
if ( IS_ERR ( full_path ) )  165
rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ); 171
if ( ! rc && num_referrals > 0 )  174
mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ); 180
if ( IS_ERR ( mount_data ) )  188
referral_walks_count ++; 200
if ( rc )  209
tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ); 213
if ( tlink == NULL )  214
tlink -> tl_uid = pSesInfo -> linux_uid; 219
tlink -> tl_tcon = tcon; 220
tlink -> tl_time = jiffies; 221
set_bit ( TCON_LINK_MASTER , & tlink -> tl_flags ); 222
set_bit ( TCON_LINK_IN_TREE , & tlink -> tl_flags ); 223
cifs_sb -> master_tlink = tlink; 225
spin_lock ( & cifs_sb -> tlink_tree_lock ); 226
tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ); 227
spin_unlock ( & cifs_sb -> tlink_tree_lock ); 228
queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ); 230
------------------------------
248 /home/SySeVR/data/CVE_2011_3363_PATCHED_cifs_mount.c cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) 127
int
CVE_2011_3363_PATCHED_cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
char *mount_data_global, const char *devname) 3
int rc ; 5
int xid ; 6
struct smb_vol * volume_info ; 7
struct cifsSesInfo * pSesInfo ; 8
struct cifsTconInfo * tcon ; 9
struct TCP_Server_Info * srvTcp ; 10
char * full_path ; 11
char * mount_data = mount_data_global ; 12
struct dfs_info3_param * referrals = NULL ; 15
unsigned int num_referrals = 0 ; 16
int referral_walks_count = 0 ; 17
rc = 0; 20
xid = GetXid ( ); 27
volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ); 29
if ( ! volume_info )  30
if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) )  35
if ( volume_info -> nullauth )  40
volume_info -> username = ""; 42
if ( volume_info -> username )  43
if ( volume_info -> iocharset == NULL )  55
volume_info -> local_nls = load_nls_default ( ); 57
volume_info -> local_nls = load_nls ( volume_info -> iocharset ); 59
if ( volume_info -> local_nls == NULL )  60
cifs_sb -> local_nls = volume_info -> local_nls; 67
srvTcp = cifs_get_tcp_session ( volume_info ); 70
if ( IS_ERR ( srvTcp ) )  71
pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ); 77
if ( IS_ERR ( pSesInfo ) )  78
tcon = cifs_get_tcon ( pSesInfo , volume_info ); 94
if ( IS_ERR ( tcon ) )  95
rc = PTR_ERR ( tcon ); 96
tcon = NULL; 97
if ( tcon -> ses -> capabilities & CAP_UNIX )  108
tcon -> unix_ext = 0; 113
if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) )  119
cifs_sb -> rsize = 1024 * 127; 120
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) )  123
cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 124
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) )  126
cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 127
if ( ! rc && tcon )  132
full_path = cifs_build_path_to_root ( cifs_sb , tcon ); 134
if ( full_path == NULL )  135
rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ); 139
if ( rc != 0 && rc != - EREMOTE )  140
kfree ( full_path ); 141
kfree ( full_path ); 144
if ( rc == - EREMOTE )  148
if ( referral_walks_count > MAX_NESTED_LINKS )  150
if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 )  161
convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ); 162
full_path = build_unc_path_to_root ( volume_info , cifs_sb ); 164
if ( IS_ERR ( full_path ) )  165
rc = PTR_ERR ( full_path ); 166
cFYI ( 1 , "Getting referral for: %s" , full_path ); 170
rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ); 171
if ( ! rc && num_referrals > 0 )  174
if ( mount_data != mount_data_global )  177
kfree ( mount_data ); 178
mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ); 180
kfree ( full_path ); 186
if ( IS_ERR ( mount_data ) )  188
rc = PTR_ERR ( mount_data ); 189
referral_walks_count ++; 200
if ( rc )  209
cifs_sb -> master_tlink = tlink; 225
spin_lock ( & cifs_sb -> tlink_tree_lock ); 226
tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ); 227
spin_unlock ( & cifs_sb -> tlink_tree_lock ); 228
queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ); 230
if ( rc )  235
if ( mount_data != mount_data_global )  236
kfree ( mount_data ); 237
return rc ; 257
------------------------------
249 /home/SySeVR/data/CVE_2011_3363_PATCHED_cifs_mount.c cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) 124
int
CVE_2011_3363_PATCHED_cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
char *mount_data_global, const char *devname) 3
int rc ; 5
int xid ; 6
struct smb_vol * volume_info ; 7
struct cifsSesInfo * pSesInfo ; 8
struct cifsTconInfo * tcon ; 9
struct TCP_Server_Info * srvTcp ; 10
char * full_path ; 11
char * mount_data = mount_data_global ; 12
struct dfs_info3_param * referrals = NULL ; 15
unsigned int num_referrals = 0 ; 16
int referral_walks_count = 0 ; 17
rc = 0; 20
xid = GetXid ( ); 27
volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ); 29
if ( ! volume_info )  30
if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) )  35
if ( volume_info -> nullauth )  40
volume_info -> username = ""; 42
if ( volume_info -> username )  43
if ( volume_info -> iocharset == NULL )  55
volume_info -> local_nls = load_nls_default ( ); 57
volume_info -> local_nls = load_nls ( volume_info -> iocharset ); 59
if ( volume_info -> local_nls == NULL )  60
cifs_sb -> local_nls = volume_info -> local_nls; 67
srvTcp = cifs_get_tcp_session ( volume_info ); 70
if ( IS_ERR ( srvTcp ) )  71
pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ); 77
if ( IS_ERR ( pSesInfo ) )  78
tcon = cifs_get_tcon ( pSesInfo , volume_info ); 94
if ( IS_ERR ( tcon ) )  95
rc = PTR_ERR ( tcon ); 96
tcon = NULL; 97
if ( tcon -> ses -> capabilities & CAP_UNIX )  108
tcon -> unix_ext = 0; 113
if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) )  119
cifs_sb -> rsize = 1024 * 127; 120
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) )  123
cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 124
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) )  126
cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 127
if ( ! rc && tcon )  132
full_path = cifs_build_path_to_root ( cifs_sb , tcon ); 134
if ( full_path == NULL )  135
rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ); 139
if ( rc != 0 && rc != - EREMOTE )  140
kfree ( full_path ); 141
kfree ( full_path ); 144
if ( rc == - EREMOTE )  148
if ( referral_walks_count > MAX_NESTED_LINKS )  150
if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 )  161
convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ); 162
full_path = build_unc_path_to_root ( volume_info , cifs_sb ); 164
if ( IS_ERR ( full_path ) )  165
rc = PTR_ERR ( full_path ); 166
cFYI ( 1 , "Getting referral for: %s" , full_path ); 170
rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ); 171
if ( ! rc && num_referrals > 0 )  174
if ( mount_data != mount_data_global )  177
kfree ( mount_data ); 178
mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ); 180
kfree ( full_path ); 186
if ( IS_ERR ( mount_data ) )  188
rc = PTR_ERR ( mount_data ); 189
referral_walks_count ++; 200
if ( rc )  209
cifs_sb -> master_tlink = tlink; 225
spin_lock ( & cifs_sb -> tlink_tree_lock ); 226
tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ); 227
spin_unlock ( & cifs_sb -> tlink_tree_lock ); 228
queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ); 230
if ( rc )  235
if ( mount_data != mount_data_global )  236
kfree ( mount_data ); 237
return rc ; 257
------------------------------
250 /home/SySeVR/data/CVE_2011_3363_VULN_cifs_mount.c tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ) 213
int
CVE_2011_3363_VULN_cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
char *mount_data_global, const char *devname) 3
int rc ; 5
int xid ; 6
struct smb_vol * volume_info ; 7
struct cifsSesInfo * pSesInfo ; 8
struct cifsTconInfo * tcon ; 9
struct TCP_Server_Info * srvTcp ; 10
char * full_path ; 11
char * mount_data = mount_data_global ; 12
struct tcon_link * tlink ; 13
struct dfs_info3_param * referrals = NULL ; 15
unsigned int num_referrals = 0 ; 16
int referral_walks_count = 0 ; 17
rc = 0; 20
tcon = NULL; 21
pSesInfo = NULL; 22
srvTcp = NULL; 23
full_path = NULL; 24
tlink = NULL; 25
xid = GetXid ( ); 27
volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ); 29
if ( ! volume_info )  30
if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) )  35
if ( volume_info -> nullauth )  40
volume_info -> username = ""; 42
if ( volume_info -> username )  43
if ( volume_info -> iocharset == NULL )  55
volume_info -> local_nls = load_nls_default ( ); 57
volume_info -> local_nls = load_nls ( volume_info -> iocharset ); 59
if ( volume_info -> local_nls == NULL )  60
cifs_sb -> local_nls = volume_info -> local_nls; 67
srvTcp = cifs_get_tcp_session ( volume_info ); 70
if ( IS_ERR ( srvTcp ) )  71
pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ); 77
if ( IS_ERR ( pSesInfo ) )  78
tcon = cifs_get_tcon ( pSesInfo , volume_info ); 94
if ( IS_ERR ( tcon ) )  95
rc = PTR_ERR ( tcon ); 96
tcon = NULL; 97
if ( tcon -> ses -> capabilities & CAP_UNIX )  108
tcon -> unix_ext = 0; 113
if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) )  119
cifs_sb -> rsize = 1024 * 127; 120
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) )  123
cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 124
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) )  126
cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 127
if ( ! rc && cifs_sb -> prepathlen && tcon )  132
full_path = cifs_build_path_to_root ( cifs_sb , tcon ); 134
if ( full_path == NULL )  135
rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ); 139
if ( rc != 0 && rc != - EREMOTE )  140
if ( rc == - EREMOTE )  148
if ( referral_walks_count > MAX_NESTED_LINKS )  150
full_path = build_unc_path_to_root ( volume_info , cifs_sb ); 164
if ( IS_ERR ( full_path ) )  165
rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ); 171
if ( ! rc && num_referrals > 0 )  174
mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ); 180
if ( IS_ERR ( mount_data ) )  188
referral_walks_count ++; 200
if ( rc )  209
tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ); 213
if ( tlink == NULL )  214
tlink -> tl_uid = pSesInfo -> linux_uid; 219
tlink -> tl_tcon = tcon; 220
tlink -> tl_time = jiffies; 221
set_bit ( TCON_LINK_MASTER , & tlink -> tl_flags ); 222
set_bit ( TCON_LINK_IN_TREE , & tlink -> tl_flags ); 223
cifs_sb -> master_tlink = tlink; 225
spin_lock ( & cifs_sb -> tlink_tree_lock ); 226
tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ); 227
spin_unlock ( & cifs_sb -> tlink_tree_lock ); 228
queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ); 230
------------------------------
251 /home/SySeVR/data/CVE_2011_3363_VULN_cifs_mount.c cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) 127
int
CVE_2011_3363_VULN_cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
char *mount_data_global, const char *devname) 3
int rc ; 5
int xid ; 6
struct smb_vol * volume_info ; 7
struct cifsSesInfo * pSesInfo ; 8
struct cifsTconInfo * tcon ; 9
struct TCP_Server_Info * srvTcp ; 10
char * full_path ; 11
char * mount_data = mount_data_global ; 12
struct dfs_info3_param * referrals = NULL ; 15
unsigned int num_referrals = 0 ; 16
int referral_walks_count = 0 ; 17
rc = 0; 20
tcon = NULL; 21
pSesInfo = NULL; 22
srvTcp = NULL; 23
full_path = NULL; 24
xid = GetXid ( ); 27
volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ); 29
if ( ! volume_info )  30
if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) )  35
if ( volume_info -> nullauth )  40
volume_info -> username = ""; 42
if ( volume_info -> username )  43
if ( volume_info -> iocharset == NULL )  55
volume_info -> local_nls = load_nls_default ( ); 57
volume_info -> local_nls = load_nls ( volume_info -> iocharset ); 59
if ( volume_info -> local_nls == NULL )  60
cifs_sb -> local_nls = volume_info -> local_nls; 67
srvTcp = cifs_get_tcp_session ( volume_info ); 70
if ( IS_ERR ( srvTcp ) )  71
pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ); 77
if ( IS_ERR ( pSesInfo ) )  78
tcon = cifs_get_tcon ( pSesInfo , volume_info ); 94
if ( IS_ERR ( tcon ) )  95
rc = PTR_ERR ( tcon ); 96
tcon = NULL; 97
if ( tcon -> ses -> capabilities & CAP_UNIX )  108
tcon -> unix_ext = 0; 113
if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) )  119
cifs_sb -> rsize = 1024 * 127; 120
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) )  123
cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 124
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) )  126
cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 127
if ( ! rc && cifs_sb -> prepathlen && tcon )  132
full_path = cifs_build_path_to_root ( cifs_sb , tcon ); 134
if ( full_path == NULL )  135
rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ); 139
if ( rc != 0 && rc != - EREMOTE )  140
kfree ( full_path ); 141
kfree ( full_path ); 144
if ( rc == - EREMOTE )  148
if ( referral_walks_count > MAX_NESTED_LINKS )  150
if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 )  161
convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ); 162
full_path = build_unc_path_to_root ( volume_info , cifs_sb ); 164
if ( IS_ERR ( full_path ) )  165
rc = PTR_ERR ( full_path ); 166
cFYI ( 1 , "Getting referral for: %s" , full_path ); 170
rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ); 171
if ( ! rc && num_referrals > 0 )  174
if ( mount_data != mount_data_global )  177
kfree ( mount_data ); 178
mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ); 180
kfree ( full_path ); 186
if ( IS_ERR ( mount_data ) )  188
rc = PTR_ERR ( mount_data ); 189
referral_walks_count ++; 200
if ( rc )  209
cifs_sb -> master_tlink = tlink; 225
spin_lock ( & cifs_sb -> tlink_tree_lock ); 226
tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ); 227
spin_unlock ( & cifs_sb -> tlink_tree_lock ); 228
queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ); 230
if ( rc )  235
if ( mount_data != mount_data_global )  236
kfree ( mount_data ); 237
return rc ; 257
------------------------------
252 /home/SySeVR/data/CVE_2011_3363_VULN_cifs_mount.c cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) 124
int
CVE_2011_3363_VULN_cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
char *mount_data_global, const char *devname) 3
int rc ; 5
int xid ; 6
struct smb_vol * volume_info ; 7
struct cifsSesInfo * pSesInfo ; 8
struct cifsTconInfo * tcon ; 9
struct TCP_Server_Info * srvTcp ; 10
char * full_path ; 11
char * mount_data = mount_data_global ; 12
struct dfs_info3_param * referrals = NULL ; 15
unsigned int num_referrals = 0 ; 16
int referral_walks_count = 0 ; 17
rc = 0; 20
tcon = NULL; 21
pSesInfo = NULL; 22
srvTcp = NULL; 23
full_path = NULL; 24
xid = GetXid ( ); 27
volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ); 29
if ( ! volume_info )  30
if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) )  35
if ( volume_info -> nullauth )  40
volume_info -> username = ""; 42
if ( volume_info -> username )  43
if ( volume_info -> iocharset == NULL )  55
volume_info -> local_nls = load_nls_default ( ); 57
volume_info -> local_nls = load_nls ( volume_info -> iocharset ); 59
if ( volume_info -> local_nls == NULL )  60
cifs_sb -> local_nls = volume_info -> local_nls; 67
srvTcp = cifs_get_tcp_session ( volume_info ); 70
if ( IS_ERR ( srvTcp ) )  71
pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ); 77
if ( IS_ERR ( pSesInfo ) )  78
tcon = cifs_get_tcon ( pSesInfo , volume_info ); 94
if ( IS_ERR ( tcon ) )  95
rc = PTR_ERR ( tcon ); 96
tcon = NULL; 97
if ( tcon -> ses -> capabilities & CAP_UNIX )  108
tcon -> unix_ext = 0; 113
if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) )  119
cifs_sb -> rsize = 1024 * 127; 120
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) )  123
cifs_sb -> wsize = min ( cifs_sb -> wsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 124
if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) )  126
cifs_sb -> rsize = min ( cifs_sb -> rsize , ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ); 127
if ( ! rc && cifs_sb -> prepathlen && tcon )  132
full_path = cifs_build_path_to_root ( cifs_sb , tcon ); 134
if ( full_path == NULL )  135
rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ); 139
if ( rc != 0 && rc != - EREMOTE )  140
kfree ( full_path ); 141
kfree ( full_path ); 144
if ( rc == - EREMOTE )  148
if ( referral_walks_count > MAX_NESTED_LINKS )  150
if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 )  161
convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ); 162
full_path = build_unc_path_to_root ( volume_info , cifs_sb ); 164
if ( IS_ERR ( full_path ) )  165
rc = PTR_ERR ( full_path ); 166
cFYI ( 1 , "Getting referral for: %s" , full_path ); 170
rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , cifs_sb -> local_nls , & num_referrals , & referrals , cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ); 171
if ( ! rc && num_referrals > 0 )  174
if ( mount_data != mount_data_global )  177
kfree ( mount_data ); 178
mount_data = cifs_compose_mount_options ( cifs_sb -> mountdata , full_path + 1 , referrals , & fake_devname ); 180
kfree ( full_path ); 186
if ( IS_ERR ( mount_data ) )  188
rc = PTR_ERR ( mount_data ); 189
referral_walks_count ++; 200
if ( rc )  209
cifs_sb -> master_tlink = tlink; 225
spin_lock ( & cifs_sb -> tlink_tree_lock ); 226
tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ); 227
spin_unlock ( & cifs_sb -> tlink_tree_lock ); 228
queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , TLINK_IDLE_EXPIRE ); 230
if ( rc )  235
if ( mount_data != mount_data_global )  236
kfree ( mount_data ); 237
return rc ; 257
------------------------------
253 /home/SySeVR/data/CVE_2011_3648_VULN_nsShiftJISToUnicode__Convert.c * aDestLen = dest - aDest 156
NS_IMETHODIMP CVE_2011_3648_VULN_nsShiftJISToUnicode::Convert(
const char * aSrc, PRInt32 * aSrcLen,
PRUnichar * aDest, PRInt32 * aDestLen) 3
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 41
const unsigned char * src = ( unsigned char * ) aSrc ; 42
PRUnichar * destEnd = aDest + * aDestLen ; 43
PRUnichar * dest = aDest ; 44
while ( src < srcEnd )  45
switch ( mState )  47
if ( * src & 0x80 )  51
mData = SJIS_INDEX [ * src & 0x7F ]; 53
if ( mData < 0xE000 )  54
mState = 1; 56
if ( mData > 0xFF00 )  58
if ( 0xFFFD == mData )  60
switch ( * src )  67
* dest ++ = ( PRUnichar ) * src; 69
* dest ++ = ( PRUnichar ) 0xf8f0; 73
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) ); 79
if ( mErrBehavior == kOnError_Signal )  84
* dest ++ = SJIS_UNMAPPED; 86
if ( dest >= destEnd )  88
* dest ++ = mData; 91
if ( dest >= destEnd )  92
mState = 2; 96
* dest ++ = ( PRUnichar ) * src; 101
if ( dest >= destEnd )  102
PRUint8 off = sbIdx [ * src ] ; 109
if ( 0xFF == off )  110
if ( mErrBehavior == kOnError_Signal )  111
* dest ++ = SJIS_UNMAPPED; 113
PRUnichar ch = gJapaneseMap [ mData + off ] ; 115
if ( ch == 0xfffd )  116
if ( mErrBehavior == kOnError_Signal )  117
ch = SJIS_UNMAPPED; 119
* dest ++ = ch; 121
mState = 0; 123
if ( dest >= destEnd )  124
PRUint8 off = sbIdx [ * src ] ; 131
if ( 0xFF == off )  132
if ( mErrBehavior == kOnError_Signal )  133
* dest ++ = SJIS_UNMAPPED; 136
* dest ++ = mData + off; 138
mState = 0; 140
if ( dest >= destEnd )  141
src ++; 147
* aDestLen = dest - aDest; 149
* aDestLen = dest - aDest; 152
* aDestLen = dest - aDest; 156
------------------------------
254 /home/SySeVR/data/CVE_2011_3648_VULN_nsShiftJISToUnicode__Convert.c * aDestLen = dest - aDest 152
NS_IMETHODIMP CVE_2011_3648_VULN_nsShiftJISToUnicode::Convert(
const char * aSrc, PRInt32 * aSrcLen,
PRUnichar * aDest, PRInt32 * aDestLen) 3
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 41
const unsigned char * src = ( unsigned char * ) aSrc ; 42
PRUnichar * destEnd = aDest + * aDestLen ; 43
PRUnichar * dest = aDest ; 44
while ( src < srcEnd )  45
switch ( mState )  47
if ( * src & 0x80 )  51
mData = SJIS_INDEX [ * src & 0x7F ]; 53
if ( mData < 0xE000 )  54
mState = 1; 56
if ( mData > 0xFF00 )  58
if ( 0xFFFD == mData )  60
switch ( * src )  67
* dest ++ = ( PRUnichar ) * src; 69
* dest ++ = ( PRUnichar ) 0xf8f0; 73
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) ); 79
if ( mErrBehavior == kOnError_Signal )  84
* dest ++ = SJIS_UNMAPPED; 86
if ( dest >= destEnd )  88
* dest ++ = mData; 91
if ( dest >= destEnd )  92
mState = 2; 96
* dest ++ = ( PRUnichar ) * src; 101
if ( dest >= destEnd )  102
PRUint8 off = sbIdx [ * src ] ; 109
if ( 0xFF == off )  110
if ( mErrBehavior == kOnError_Signal )  111
* dest ++ = SJIS_UNMAPPED; 113
PRUnichar ch = gJapaneseMap [ mData + off ] ; 115
if ( ch == 0xfffd )  116
if ( mErrBehavior == kOnError_Signal )  117
ch = SJIS_UNMAPPED; 119
* dest ++ = ch; 121
mState = 0; 123
if ( dest >= destEnd )  124
PRUint8 off = sbIdx [ * src ] ; 131
if ( 0xFF == off )  132
if ( mErrBehavior == kOnError_Signal )  133
* dest ++ = SJIS_UNMAPPED; 136
* dest ++ = mData + off; 138
mState = 0; 140
if ( dest >= destEnd )  141
src ++; 147
* aDestLen = dest - aDest; 149
* aDestLen = dest - aDest; 152
* aDestLen = dest - aDest; 156
------------------------------
255 /home/SySeVR/data/CVE_2011_3648_VULN_nsShiftJISToUnicode__Convert.c * aDestLen = dest - aDest 149
NS_IMETHODIMP CVE_2011_3648_VULN_nsShiftJISToUnicode::Convert(
const char * aSrc, PRInt32 * aSrcLen,
PRUnichar * aDest, PRInt32 * aDestLen) 3
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 41
const unsigned char * src = ( unsigned char * ) aSrc ; 42
PRUnichar * destEnd = aDest + * aDestLen ; 43
PRUnichar * dest = aDest ; 44
while ( src < srcEnd )  45
switch ( mState )  47
if ( * src & 0x80 )  51
mData = SJIS_INDEX [ * src & 0x7F ]; 53
if ( mData < 0xE000 )  54
mState = 1; 56
if ( mData > 0xFF00 )  58
if ( 0xFFFD == mData )  60
switch ( * src )  67
* dest ++ = ( PRUnichar ) * src; 69
* dest ++ = ( PRUnichar ) 0xf8f0; 73
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) ); 79
if ( mErrBehavior == kOnError_Signal )  84
* dest ++ = SJIS_UNMAPPED; 86
if ( dest >= destEnd )  88
* dest ++ = mData; 91
if ( dest >= destEnd )  92
mState = 2; 96
* dest ++ = ( PRUnichar ) * src; 101
if ( dest >= destEnd )  102
PRUint8 off = sbIdx [ * src ] ; 109
if ( 0xFF == off )  110
if ( mErrBehavior == kOnError_Signal )  111
* dest ++ = SJIS_UNMAPPED; 113
PRUnichar ch = gJapaneseMap [ mData + off ] ; 115
if ( ch == 0xfffd )  116
if ( mErrBehavior == kOnError_Signal )  117
ch = SJIS_UNMAPPED; 119
* dest ++ = ch; 121
mState = 0; 123
if ( dest >= destEnd )  124
PRUint8 off = sbIdx [ * src ] ; 131
if ( 0xFF == off )  132
if ( mErrBehavior == kOnError_Signal )  133
* dest ++ = SJIS_UNMAPPED; 136
* dest ++ = mData + off; 138
mState = 0; 140
if ( dest >= destEnd )  141
src ++; 147
* aDestLen = dest - aDest; 149
* aDestLen = dest - aDest; 152
* aDestLen = dest - aDest; 156
------------------------------
256 /home/SySeVR/data/CVE_2011_3648_VULN_nsShiftJISToUnicode__Convert.c * dest ++ = mData + off 138
NS_IMETHODIMP CVE_2011_3648_VULN_nsShiftJISToUnicode::Convert(
const char * aSrc, PRInt32 * aSrcLen,
PRUnichar * aDest, PRInt32 * aDestLen) 3
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 41
const unsigned char * src = ( unsigned char * ) aSrc ; 42
PRUnichar * destEnd = aDest + * aDestLen ; 43
PRUnichar * dest = aDest ; 44
while ( src < srcEnd )  45
switch ( mState )  47
if ( * src & 0x80 )  51
mData = SJIS_INDEX [ * src & 0x7F ]; 53
if ( mData < 0xE000 )  54
mState = 1; 56
if ( mData > 0xFF00 )  58
if ( 0xFFFD == mData )  60
switch ( * src )  67
* dest ++ = ( PRUnichar ) * src; 69
* dest ++ = ( PRUnichar ) 0xf8f0; 73
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) ); 79
if ( mErrBehavior == kOnError_Signal )  84
* dest ++ = SJIS_UNMAPPED; 86
if ( dest >= destEnd )  88
* dest ++ = mData; 91
if ( dest >= destEnd )  92
mState = 2; 96
* dest ++ = ( PRUnichar ) * src; 101
if ( dest >= destEnd )  102
PRUint8 off = sbIdx [ * src ] ; 109
if ( 0xFF == off )  110
if ( mErrBehavior == kOnError_Signal )  111
* dest ++ = SJIS_UNMAPPED; 113
PRUnichar ch = gJapaneseMap [ mData + off ] ; 115
if ( ch == 0xfffd )  116
if ( mErrBehavior == kOnError_Signal )  117
ch = SJIS_UNMAPPED; 119
* dest ++ = ch; 121
mState = 0; 123
if ( dest >= destEnd )  124
PRUint8 off = sbIdx [ * src ] ; 131
if ( 0xFF == off )  132
if ( mErrBehavior == kOnError_Signal )  133
* dest ++ = SJIS_UNMAPPED; 136
* dest ++ = mData + off; 138
mState = 0; 140
if ( dest >= destEnd )  141
src ++; 147
* aDestLen = dest - aDest; 149
* aDestLen = dest - aDest; 152
* aDestLen = dest - aDest; 156
------------------------------
257 /home/SySeVR/data/CVE_2011_3936_PATCHED_dv_extract_audio.c of = sys -> audio_shuffle [ i % half_ch + half_ch ] [ j ] + ( d - 8 ) / 3 * sys -> audio_stride 70
static int CVE_2011_3936_PATCHED_dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],
const DVprofile *sys) 2
int size , chan , i , j , d , of , smpls , freq , quant , half_ch ; 4
const uint8_t * as_pack ; 6
uint8_t * pcm , ipcm ; 7
as_pack = dv_extract_pack ( frame , dv_audio_source ); 9
if ( ! as_pack )  10
smpls = as_pack [ 1 ] & 0x3f; 13
freq = ( as_pack [ 4 ] >> 3 ) & 0x07; 14
quant = as_pack [ 4 ] & 0x07; 15
if ( quant > 1 )  17
size = ( sys -> audio_min_samples [ freq ] + smpls ) * 4; 20
half_ch = sys -> difseg_size / 2; 21
ipcm = ( sys -> height == 720 && ! ( frame [ 1 ] & 0x0C ) ) ? 2 : 0; 25
for (chan = 0; chan < sys->n_difchan; chan++) 28
pcm = ppcm [ ipcm ++ ]; 30
if ( ! pcm )  31
for (i = 0; i < sys->difseg_size; i++) 35
if ( quant == 1 && i == half_ch )  37
pcm = ppcm [ ipcm ++ ]; 39
if ( ! pcm )  40
for (j = 0; j < 9; j++) 45
for (d = 8; d < 80; d += 2) 46
if ( quant == 0 )  47
of = sys -> audio_shuffle [ i ] [ j ] + ( d - 8 ) / 2 * sys -> audio_stride; 48
if ( of * 2 >= size )  49
of = sys -> audio_shuffle [ i % half_ch ] [ j ] + ( d - 8 ) / 3 * sys -> audio_stride; 64
if ( of * 2 >= size )  65
of = sys -> audio_shuffle [ i % half_ch + half_ch ] [ j ] + ( d - 8 ) / 3 * sys -> audio_stride; 70
pcm [ of * 2 ] = rc & 0xff; 72
pcm [ of * 2 + 1 ] = rc >> 8; 73
------------------------------
258 /home/SySeVR/data/CVE_2011_3936_VULN_dv_extract_audio.c of = sys -> audio_shuffle [ i % half_ch + half_ch ] [ j ] + ( d - 8 ) / 3 * sys -> audio_stride 66
static int CVE_2011_3936_VULN_dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],
const DVprofile *sys) 2
int size , chan , i , j , d , of , smpls , freq , quant , half_ch ; 4
uint16_t lc , rc ; 5
const uint8_t * as_pack ; 6
uint8_t * pcm , ipcm ; 7
as_pack = dv_extract_pack ( frame , dv_audio_source ); 9
if ( ! as_pack )  10
smpls = as_pack [ 1 ] & 0x3f; 13
freq = ( as_pack [ 4 ] >> 3 ) & 0x07; 14
quant = as_pack [ 4 ] & 0x07; 15
if ( quant > 1 )  17
size = ( sys -> audio_min_samples [ freq ] + smpls ) * 4; 20
half_ch = sys -> difseg_size / 2; 21
ipcm = ( sys -> height == 720 && ! ( frame [ 1 ] & 0x0C ) ) ? 2 : 0; 25
pcm = ppcm [ ipcm ++ ]; 26
for (chan = 0; chan < sys->n_difchan; chan++) 29
for (i = 0; i < sys->difseg_size; i++) 31
frame += 6 * 80; 32
if ( quant == 1 && i == half_ch )  33
pcm = ppcm [ ipcm ++ ]; 35
if ( ! pcm )  36
for (j = 0; j < 9; j++) 41
for (d = 8; d < 80; d += 2) 42
if ( quant == 0 )  43
of = sys -> audio_shuffle [ i ] [ j ] + ( d - 8 ) / 2 * sys -> audio_stride; 44
if ( of * 2 >= size )  45
lc = ( ( uint16_t ) frame [ d ] << 4 ) | ( ( uint16_t ) frame [ d + 2 ] >> 4 ); 53
rc = ( ( uint16_t ) frame [ d + 1 ] << 4 ) | ( ( uint16_t ) frame [ d + 2 ] & 0x0f ); 55
lc = ( lc == 0x800 ? 0 : dv_audio_12to16 ( lc ) ); 57
rc = ( rc == 0x800 ? 0 : dv_audio_12to16 ( rc ) ); 58
of = sys -> audio_shuffle [ i % half_ch ] [ j ] + ( d - 8 ) / 3 * sys -> audio_stride; 60
if ( of * 2 >= size )  61
pcm [ of * 2 ] = lc & 0xff; 64
pcm [ of * 2 + 1 ] = lc >> 8; 65
of = sys -> audio_shuffle [ i % half_ch + half_ch ] [ j ] + ( d - 8 ) / 3 * sys -> audio_stride; 66
pcm [ of * 2 ] = rc & 0xff; 68
pcm [ of * 2 + 1 ] = rc >> 8; 69
frame += 16 * 80; 74
pcm = ppcm [ ipcm ++ ]; 79
if ( ! pcm )  80
------------------------------
259 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c inp = out + outcnt - offset 86
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
KgvContext * const c = avctx -> priv_data 5
int offsets [ 8 ] ; 6
uint16_t * out , * prev ; 7
int outcnt = 0 , maxcnt ; 8
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
buf += 2; 16
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
for (i = 0; i < 8; i++) 36
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
int code = AV_RL16 ( buf ) ; 40
buf += 2; 41
if ( ! ( code & 0x8000 ) )  43
out [ outcnt ++ ] = code; 44
int count ; 46
uint16_t * inp ; 47
if ( ( code & 0x6000 ) == 0x6000 )  49
int oidx = ( code >> 10 ) & 7 ; 51
int start ; 52
count = ( code & 0x3FF ) + 3; 54
if ( offsets [ oidx ] < 0 )  56
if ( buf_end - 3 < buf )  57
offsets [ oidx ] = AV_RL24 ( buf ); 59
buf += 3; 60
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
int offset = ( code & 0x1FFF ) + 1 ; 71
if ( ! ( code & 0x6000 ) )  73
count = 2; 74
if ( ( code & 0x6000 ) == 0x2000 )  75
count = 3; 76
if ( buf_end - 1 < buf )  78
count = 4 + * buf ++; 80
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
260 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c inp = prev + start 68
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
KgvContext * const c = avctx -> priv_data 5
int offsets [ 8 ] ; 6
uint16_t * out , * prev ; 7
int outcnt = 0 , maxcnt ; 8
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
buf += 2; 16
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
for (i = 0; i < 8; i++) 36
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
int code = AV_RL16 ( buf ) ; 40
buf += 2; 41
if ( ! ( code & 0x8000 ) )  43
out [ outcnt ++ ] = code; 44
int count ; 46
uint16_t * inp ; 47
if ( ( code & 0x6000 ) == 0x6000 )  49
int oidx = ( code >> 10 ) & 7 ; 51
int start ; 52
count = ( code & 0x3FF ) + 3; 54
if ( offsets [ oidx ] < 0 )  56
if ( buf_end - 3 < buf )  57
offsets [ oidx ] = AV_RL24 ( buf ); 59
buf += 3; 60
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
int offset = ( code & 0x1FFF ) + 1 ; 71
if ( ! ( code & 0x6000 ) )  73
count = 2; 74
if ( ( code & 0x6000 ) == 0x2000 )  75
count = 3; 76
if ( buf_end - 1 < buf )  78
count = 4 + * buf ++; 80
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
261 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c start = ( outcnt + offsets [ oidx ] ) % maxcnt 63
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
KgvContext * const c = avctx -> priv_data 5
int offsets [ 8 ] ; 6
uint16_t * out , * prev ; 7
int outcnt = 0 , maxcnt ; 8
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
buf += 2; 16
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
for (i = 0; i < 8; i++) 36
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
int code = AV_RL16 ( buf ) ; 40
buf += 2; 41
if ( ! ( code & 0x8000 ) )  43
out [ outcnt ++ ] = code; 44
int count ; 46
uint16_t * inp ; 47
if ( ( code & 0x6000 ) == 0x6000 )  49
int oidx = ( code >> 10 ) & 7 ; 51
int start ; 52
count = ( code & 0x3FF ) + 3; 54
if ( offsets [ oidx ] < 0 )  56
if ( buf_end - 3 < buf )  57
offsets [ oidx ] = AV_RL24 ( buf ); 59
buf += 3; 60
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
int offset = ( code & 0x1FFF ) + 1 ; 71
if ( ! ( code & 0x6000 ) )  73
count = 2; 74
if ( ( code & 0x6000 ) == 0x2000 )  75
count = 3; 76
if ( buf_end - 1 < buf )  78
count = 4 + * buf ++; 80
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
262 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c prev = av_realloc ( c -> prev , w * h * 2 ) 31
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
KgvContext * const c = avctx -> priv_data 5
uint16_t * out , * prev ; 7
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
c -> prev = prev; 34
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
c -> pic . data [ 0 ] = ( uint8_t * ) c -> cur; 100
c -> pic . linesize [ 0 ] = w * 2; 101
* ( AVFrame * ) data = c -> pic; 104
FFSWAP ( uint16_t * , c -> cur , c -> prev ) 106
------------------------------
263 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c out = av_realloc ( c -> cur , w * h * 2 ) 26
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
KgvContext * const c = avctx -> priv_data 5
uint16_t * out , * prev ; 7
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
c -> prev = prev; 34
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
c -> pic . data [ 0 ] = ( uint8_t * ) c -> cur; 100
c -> pic . linesize [ 0 ] = w * 2; 101
* ( AVFrame * ) data = c -> pic; 104
FFSWAP ( uint16_t * , c -> cur , c -> prev ) 106
------------------------------
264 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c maxcnt = w * h 24
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
265 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c inp = out + outcnt - offset 86
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
KgvContext * const c = avctx -> priv_data 5
int offsets [ 7 ] ; 6
uint16_t * out , * prev ; 7
int outcnt = 0 , maxcnt ; 8
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
buf += 2; 16
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
for (i = 0; i < 7; i++) 36
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
int code = AV_RL16 ( buf ) ; 40
buf += 2; 41
if ( ! ( code & 0x8000 ) )  43
out [ outcnt ++ ] = code; 44
int count ; 46
uint16_t * inp ; 47
if ( ( code & 0x6000 ) == 0x6000 )  49
int oidx = ( code >> 10 ) & 7 ; 51
int start ; 52
count = ( code & 0x3FF ) + 3; 54
if ( offsets [ oidx ] < 0 )  56
if ( buf_end - 3 < buf )  57
offsets [ oidx ] = AV_RL24 ( buf ); 59
buf += 3; 60
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
int offset = ( code & 0x1FFF ) + 1 ; 71
if ( ! ( code & 0x6000 ) )  73
count = 2; 74
if ( ( code & 0x6000 ) == 0x2000 )  75
count = 3; 76
if ( buf_end - 1 < buf )  78
count = 4 + * buf ++; 80
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
266 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c inp = prev + start 68
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
KgvContext * const c = avctx -> priv_data 5
int offsets [ 7 ] ; 6
uint16_t * out , * prev ; 7
int outcnt = 0 , maxcnt ; 8
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
buf += 2; 16
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
for (i = 0; i < 7; i++) 36
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
int code = AV_RL16 ( buf ) ; 40
buf += 2; 41
if ( ! ( code & 0x8000 ) )  43
out [ outcnt ++ ] = code; 44
int count ; 46
uint16_t * inp ; 47
if ( ( code & 0x6000 ) == 0x6000 )  49
int oidx = ( code >> 10 ) & 7 ; 51
int start ; 52
count = ( code & 0x3FF ) + 3; 54
if ( offsets [ oidx ] < 0 )  56
if ( buf_end - 3 < buf )  57
offsets [ oidx ] = AV_RL24 ( buf ); 59
buf += 3; 60
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
int offset = ( code & 0x1FFF ) + 1 ; 71
if ( ! ( code & 0x6000 ) )  73
count = 2; 74
if ( ( code & 0x6000 ) == 0x2000 )  75
count = 3; 76
if ( buf_end - 1 < buf )  78
count = 4 + * buf ++; 80
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
267 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c start = ( outcnt + offsets [ oidx ] ) % maxcnt 63
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
KgvContext * const c = avctx -> priv_data 5
int offsets [ 7 ] ; 6
uint16_t * out , * prev ; 7
int outcnt = 0 , maxcnt ; 8
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
buf += 2; 16
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
for (i = 0; i < 7; i++) 36
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
int code = AV_RL16 ( buf ) ; 40
buf += 2; 41
if ( ! ( code & 0x8000 ) )  43
out [ outcnt ++ ] = code; 44
int count ; 46
uint16_t * inp ; 47
if ( ( code & 0x6000 ) == 0x6000 )  49
int oidx = ( code >> 10 ) & 7 ; 51
int start ; 52
count = ( code & 0x3FF ) + 3; 54
if ( offsets [ oidx ] < 0 )  56
if ( buf_end - 3 < buf )  57
offsets [ oidx ] = AV_RL24 ( buf ); 59
buf += 3; 60
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
int offset = ( code & 0x1FFF ) + 1 ; 71
if ( ! ( code & 0x6000 ) )  73
count = 2; 74
if ( ( code & 0x6000 ) == 0x2000 )  75
count = 3; 76
if ( buf_end - 1 < buf )  78
count = 4 + * buf ++; 80
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
268 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c prev = av_realloc ( c -> prev , w * h * 2 ) 31
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
KgvContext * const c = avctx -> priv_data 5
uint16_t * out , * prev ; 7
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
c -> prev = prev; 34
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
c -> pic . data [ 0 ] = ( uint8_t * ) c -> cur; 100
c -> pic . linesize [ 0 ] = w * 2; 101
* ( AVFrame * ) data = c -> pic; 104
FFSWAP ( uint16_t * , c -> cur , c -> prev ) 106
------------------------------
269 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c out = av_realloc ( c -> cur , w * h * 2 ) 26
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
KgvContext * const c = avctx -> priv_data 5
uint16_t * out , * prev ; 7
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
out = av_realloc ( c -> cur , w * h * 2 ); 26
if ( ! out )  27
c -> cur = out; 29
prev = av_realloc ( c -> prev , w * h * 2 ); 31
if ( ! prev )  32
c -> prev = prev; 34
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
c -> pic . data [ 0 ] = ( uint8_t * ) c -> cur; 100
c -> pic . linesize [ 0 ] = w * 2; 101
* ( AVFrame * ) data = c -> pic; 104
FFSWAP ( uint16_t * , c -> cur , c -> prev ) 106
------------------------------
270 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c maxcnt = w * h 24
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
int w , h , i ; 9
if ( avpkt -> size < 2 )  11
w = ( buf [ 0 ] + 1 ) * 8; 14
h = ( buf [ 1 ] + 1 ) * 8; 15
if ( av_image_check_size ( w , h , 0 , avctx ) )  18
maxcnt = w * h; 24
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
271 /home/SySeVR/data/CVE_2011_3973_PATCHED_cavs_decode_frame.c input_size = ( buf_end - buf_ptr ) * 8 29
static int CVE_2011_3973_PATCHED_cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 3
int buf_size = avpkt -> size ; 4
int input_size ; 7
const uint8_t * buf_end ; 8
const uint8_t * buf_ptr ; 9
uint32_t stc = - 1 ; 11
if ( buf_size == 0 )  15
buf_ptr = buf; 23
buf_end = buf + buf_size; 24
buf_ptr = ff_find_start_code ( buf_ptr , buf_end , & stc ); 26
if ( ( stc & 0xFFFFFE00 ) || buf_ptr == buf_end )  27
input_size = ( buf_end - buf_ptr ) * 8; 29
init_get_bits ( & s -> gb , buf_ptr , input_size ); 32
init_get_bits ( & s -> gb , buf_ptr , input_size ); 47
init_get_bits ( & s -> gb , buf_ptr , input_size ); 69
------------------------------
272 /home/SySeVR/data/CVE_2011_3973_PATCHED_cavs_decode_frame.c buf_end = buf + buf_size 24
static int CVE_2011_3973_PATCHED_cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 3
int buf_size = avpkt -> size ; 4
const uint8_t * buf_end ; 8
if ( buf_size == 0 )  15
buf_end = buf + buf_size; 24
buf_ptr = ff_find_start_code ( buf_ptr , buf_end , & stc ); 26
if ( ( stc & 0xFFFFFE00 ) || buf_ptr == buf_end )  27
return FFMAX ( 0 , buf_ptr - buf - s -> parse_context . last_index ) ; 28
input_size = ( buf_end - buf_ptr ) * 8; 29
init_get_bits ( & s -> gb , buf_ptr , input_size ); 32
init_get_bits ( & s -> gb , buf_ptr , input_size ); 47
init_get_bits ( & s -> gb , buf_ptr , input_size ); 69
------------------------------
273 /home/SySeVR/data/CVE_2011_3973_PATCHED_decode_residual_block.c run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 13
static int CVE_2011_3973_PATCHED_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
int i , esc_code , level , mask ; 4
unsigned int level_code , run ; 5
for(i=0;i<65;i++) 10
level_code = get_ue_code ( gb , r -> golomb_order ); 11
if ( level_code >= ESCAPE_CODE )  12
run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1; 13
esc_code = get_ue_code ( gb , esc_golomb_order ); 14
level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] ); 15
while ( level > r -> inc_limit )  16
r ++; 17
level = ( level ^ mask ) - mask; 19
if ( level_code >= 0 )  20
level = r -> rltab [ level_code ] [ 0 ]; 21
if ( ! level )  22
r += r -> rltab [ level_code ] [ 2 ]; 25
level_buf [ i ] = level; 29
run_buf [ i ] = run; 30
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  32
------------------------------
274 /home/SySeVR/data/CVE_2011_3973_VULN_cavs_decode_frame.c input_size = ( buf_end - buf_ptr ) * 8 29
static int CVE_2011_3973_VULN_cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 3
int buf_size = avpkt -> size ; 4
int input_size ; 7
const uint8_t * buf_end ; 8
const uint8_t * buf_ptr ; 9
uint32_t stc = - 1 ; 11
if ( buf_size == 0 )  15
buf_ptr = buf; 23
buf_end = buf + buf_size; 24
buf_ptr = ff_find_start_code ( buf_ptr , buf_end , & stc ); 26
if ( stc & 0xFFFFFE00 )  27
input_size = ( buf_end - buf_ptr ) * 8; 29
init_get_bits ( & s -> gb , buf_ptr , input_size ); 32
init_get_bits ( & s -> gb , buf_ptr , input_size ); 47
init_get_bits ( & s -> gb , buf_ptr , input_size ); 69
------------------------------
275 /home/SySeVR/data/CVE_2011_3973_VULN_cavs_decode_frame.c buf_end = buf + buf_size 24
static int CVE_2011_3973_VULN_cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 3
int buf_size = avpkt -> size ; 4
const uint8_t * buf_end ; 8
if ( buf_size == 0 )  15
buf_end = buf + buf_size; 24
buf_ptr = ff_find_start_code ( buf_ptr , buf_end , & stc ); 26
return FFMAX ( 0 , buf_ptr - buf - s -> parse_context . last_index ) ; 28
input_size = ( buf_end - buf_ptr ) * 8; 29
init_get_bits ( & s -> gb , buf_ptr , input_size ); 32
init_get_bits ( & s -> gb , buf_ptr , input_size ); 47
init_get_bits ( & s -> gb , buf_ptr , input_size ); 69
------------------------------
276 /home/SySeVR/data/CVE_2011_4594_PATCHED___sys_sendmsg.c iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) 29
static int CVE_2011_4594_PATCHED___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
struct msghdr *msg_sys, unsigned flags,
struct used_address *used_address) 3
struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; 5
int err , ctl_len , iov_size , total_len ; 13
if ( MSG_CMSG_COMPAT & flags )  16
if ( get_compat_msghdr ( msg_sys , msg_compat ) )  17
if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) )  19
if ( msg_sys -> msg_iovlen > UIO_MAXIOV )  24
iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ); 29
iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ); 31
if ( ! iov )  32
err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 38
err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 42
if ( err < 0 )  45
total_len = err; 47
if ( err )  58
err = sock_sendmsg_nosec ( sock , msg_sys , total_len ); 94
err = sock_sendmsg ( sock , msg_sys , total_len ); 97
if ( used_address && err >= 0 )  102
if ( iov != iovstack )  113
sock_kfree_s ( sock -> sk , iov , iov_size ); 114
return err ; 116
------------------------------
277 /home/SySeVR/data/CVE_2012_0067_PATCHED_iptrace_read_1_0.c * err_info = g_strdup_printf ( "iptrace: file has a %u-byte record, too small to have even a packet meta-data header" , packet_size + IPTRACE_1_0_PDATA_SIZE ) 58
static gboolean CVE_2012_0067_PATCHED_iptrace_read_1_0(wtap *wth, int *err, gchar **err_info,
gint64 *data_offset) 2
int ret ; 4
guint32 packet_size ; 5
guint8 header [ IPTRACE_1_0_PHDR_SIZE ] ; 6
iptrace_1_0_phdr pkt_hdr ; 8
ret = iptrace_read_rec_header ( wth -> fh , header , IPTRACE_1_0_PHDR_SIZE , err , err_info ); 13
if ( ret <= 0 )  15
wth -> data_offset += IPTRACE_1_0_PHDR_SIZE; 19
pkt_hdr . if_type = header [ 28 ]; 26
wth -> phdr . pkt_encap = wtap_encap_ift ( pkt_hdr . if_type ); 27
packet_size = pntohl ( & header [ 0 ] ); 30
if ( packet_size < IPTRACE_1_0_PDATA_SIZE )  31
packet_size -= IPTRACE_1_0_PDATA_SIZE; 41
if ( wth -> phdr . pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED )  47
if ( packet_size < 3 )  52
* err_info = g_strdup_printf ( "iptrace: file has a %u-byte record, too small to have even a packet meta-data header" , packet_size + IPTRACE_1_0_PDATA_SIZE ); 58
------------------------------
278 /home/SySeVR/data/CVE_2012_0475_PATCHED_nsContentUtils__GetUTFOrigin.c aOrigin = NS_ConvertUTF8toUTF16 ( scheme + NS_LITERAL_CSTRING ( "://" ) + hostPort ) 28
nsresult
CVE_2012_0475_PATCHED_nsContentUtils::GetUTFOrigin(nsIURI* aURI, nsString& aOrigin) 2
nsCOMPtr < nsIURI > uri = NS_GetInnermostURI ( aURI ) ; 8
nsCString host ; 11
nsresult rv = uri -> GetHost ( host ) ; 12
if ( NS_SUCCEEDED ( rv ) && ! host . IsEmpty ( ) )  14
nsCString scheme ; 15
nsCString hostPort ; 24
aOrigin = NS_ConvertUTF8toUTF16 ( scheme + NS_LITERAL_CSTRING ( "://" ) + hostPort ); 28
------------------------------
279 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c * aDestLen = dest - aDest 518
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 518
------------------------------
280 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c * aDestLen = dest - aDest 512
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 508
* aDestLen = dest - aDest; 512
------------------------------
281 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c * aDestLen = dest - aDest 508
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 508
* aDestLen = dest - aDest; 512
------------------------------
282 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c aLen = destEnd - dest 454
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 508
* aDestLen = dest - aDest; 512
* aDestLen = dest - aDest; 518
------------------------------
283 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ) 450
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
------------------------------
284 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c aLen = destEnd - dest 322
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 508
* aDestLen = dest - aDest; 512
* aDestLen = dest - aDest; 518
------------------------------
285 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c aLen = destEnd - dest 204
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 508
* aDestLen = dest - aDest; 512
* aDestLen = dest - aDest; 518
------------------------------
286 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c aLen = destEnd - dest 122
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
* aDestLen = dest - aDest; 508
* aDestLen = dest - aDest; 512
* aDestLen = dest - aDest; 518
------------------------------
287 /home/SySeVR/data/CVE_2012_0477_VULN_nsISO2022KRToUnicode__Convert.c * aDestLen = dest - aDest 174
NS_IMETHODIMP CVE_2012_0477_VULN_nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
while ( src < srcEnd )  7
if ( * src == 0x0a || * src == 0x0d )  10
mState = mState_Init; 11
switch ( mState )  13
if ( 0x1b == * src )  16
mLastLegalState = mState_ASCII; 17
mState = mState_ESC; 18
mState = mState_ASCII; 21
if ( 0x0e == * src )  25
mState = mState_KSX1001_1992; 26
mRunLength = 0; 27
if ( * src & 0x80 )  29
* dest ++ = 0xFFFD; 30
if ( dest >= destEnd )  31
* dest ++ = ( PRUnichar ) * src; 35
if ( dest >= destEnd )  36
if ( '$' == * src )  42
mState = mState_ESC_24; 43
if ( ( dest + 2 ) >= destEnd )  46
* dest ++ = ( PRUnichar ) 0x1b; 48
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 49
mState = mLastLegalState; 50
if ( ')' == * src )  55
mState = mState_ESC_24_29; 56
if ( ( dest + 3 ) >= destEnd )  59
* dest ++ = ( PRUnichar ) 0x1b; 61
* dest ++ = ( PRUnichar ) '$'; 62
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 63
mState = mLastLegalState; 64
if ( 'C' == * src )  70
mState = mState_ASCII; 71
mRunLength = 0; 72
if ( ( dest + 4 ) >= destEnd )  75
* dest ++ = ( PRUnichar ) 0x1b; 77
* dest ++ = ( PRUnichar ) '$'; 78
* dest ++ = ( PRUnichar ) ')'; 79
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 80
mState = mLastLegalState; 81
if ( 0x20 < ( PRUint8 ) * src && ( PRUint8 ) * src < 0x7f )  86
mState = mState_KSX1001_1992_2ndbyte; 88
if ( 0x0f == * src )  90
mState = mState_ASCII; 91
if ( mRunLength == 0 )  92
if ( dest + 1 >= destEnd )  93
* dest ++ = 0xFFFD; 95
mRunLength = 0; 97
if ( ( PRUint8 ) * src == 0x20 || ( PRUint8 ) * src == 0x09 )  99
mState = mState_KSX1001_1992; 101
* dest ++ = ( PRUnichar ) * src; 102
if ( dest >= destEnd )  104
* dest ++ = 0xFFFD; 108
if ( dest >= destEnd )  109
if ( 0x20 < ( PRUint8 ) * src && ( PRUint8 ) * src < 0x7f )  115
if ( ! mEUCKRDecoder )  126
* dest ++ = 0xFFFD; 127
PRUnichar uni ; 131
* dest ++ = uni; 140
if ( dest >= destEnd )  143
mState = mState_KSX1001_1992; 145
if ( 0x0f == * src )  148
mState = mState_ASCII; 149
mState = mState_KSX1001_1992; 152
* dest ++ = 0xFFFD; 154
if ( dest >= destEnd )  155
mState = mLastLegalState; 161
* dest ++ = 0xFFFD; 162
if ( dest >= destEnd )  163
src ++; 168
* aDestLen = dest - aDest; 170
* aDestLen = dest - aDest; 174
------------------------------
288 /home/SySeVR/data/CVE_2012_0477_VULN_nsISO2022KRToUnicode__Convert.c * aDestLen = dest - aDest 170
NS_IMETHODIMP CVE_2012_0477_VULN_nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
while ( src < srcEnd )  7
if ( * src == 0x0a || * src == 0x0d )  10
mState = mState_Init; 11
switch ( mState )  13
if ( 0x1b == * src )  16
mLastLegalState = mState_ASCII; 17
mState = mState_ESC; 18
mState = mState_ASCII; 21
if ( 0x0e == * src )  25
mState = mState_KSX1001_1992; 26
mRunLength = 0; 27
if ( * src & 0x80 )  29
* dest ++ = 0xFFFD; 30
if ( dest >= destEnd )  31
* dest ++ = ( PRUnichar ) * src; 35
if ( dest >= destEnd )  36
if ( '$' == * src )  42
mState = mState_ESC_24; 43
if ( ( dest + 2 ) >= destEnd )  46
* dest ++ = ( PRUnichar ) 0x1b; 48
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 49
mState = mLastLegalState; 50
if ( ')' == * src )  55
mState = mState_ESC_24_29; 56
if ( ( dest + 3 ) >= destEnd )  59
* dest ++ = ( PRUnichar ) 0x1b; 61
* dest ++ = ( PRUnichar ) '$'; 62
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 63
mState = mLastLegalState; 64
if ( 'C' == * src )  70
mState = mState_ASCII; 71
mRunLength = 0; 72
if ( ( dest + 4 ) >= destEnd )  75
* dest ++ = ( PRUnichar ) 0x1b; 77
* dest ++ = ( PRUnichar ) '$'; 78
* dest ++ = ( PRUnichar ) ')'; 79
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 80
mState = mLastLegalState; 81
if ( 0x20 < ( PRUint8 ) * src && ( PRUint8 ) * src < 0x7f )  86
mState = mState_KSX1001_1992_2ndbyte; 88
if ( 0x0f == * src )  90
mState = mState_ASCII; 91
if ( mRunLength == 0 )  92
if ( dest + 1 >= destEnd )  93
* dest ++ = 0xFFFD; 95
mRunLength = 0; 97
if ( ( PRUint8 ) * src == 0x20 || ( PRUint8 ) * src == 0x09 )  99
mState = mState_KSX1001_1992; 101
* dest ++ = ( PRUnichar ) * src; 102
if ( dest >= destEnd )  104
* dest ++ = 0xFFFD; 108
if ( dest >= destEnd )  109
if ( 0x20 < ( PRUint8 ) * src && ( PRUint8 ) * src < 0x7f )  115
if ( ! mEUCKRDecoder )  126
* dest ++ = 0xFFFD; 127
PRUnichar uni ; 131
* dest ++ = uni; 140
if ( dest >= destEnd )  143
mState = mState_KSX1001_1992; 145
if ( 0x0f == * src )  148
mState = mState_ASCII; 149
mState = mState_KSX1001_1992; 152
* dest ++ = 0xFFFD; 154
if ( dest >= destEnd )  155
mState = mLastLegalState; 161
* dest ++ = 0xFFFD; 162
if ( dest >= destEnd )  163
src ++; 168
* aDestLen = dest - aDest; 170
* aDestLen = dest - aDest; 174
------------------------------
289 /home/SySeVR/data/CVE_2012_1183_PATCHED_milliwatt_generate.c len = samples * sizeof ( buf [ 0 ] ) 24
static int CVE_2012_1183_PATCHED_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) - ( AST_FRIENDLY_OFFSET / sizeof ( buf [ 0 ] ) ) ; 4
if ( samples > maxsamples )  19
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
for (i = 0; i < len; i++) 29
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
290 /home/SySeVR/data/CVE_2012_1183_PATCHED_milliwatt_generate.c wf . data . ptr = buf + AST_FRIENDLY_OFFSET 12
static int CVE_2012_1183_PATCHED_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
struct ast_frame wf =
. frametype = AST_FRAME_VOICE ,
. offset = AST_FRIENDLY_OFFSET ,
. src = __FUNCTION__ , 9
wf . data . ptr = buf + AST_FRIENDLY_OFFSET; 12
wf . datalen = len; 25
wf . samples = samples; 26
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
291 /home/SySeVR/data/CVE_2012_1183_VULN_milliwatt_generate.c len = samples * sizeof ( buf [ 0 ] ) 24
static int CVE_2012_1183_VULN_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) ; 4
if ( samples > maxsamples )  19
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
for (i = 0; i < len; i++) 29
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
292 /home/SySeVR/data/CVE_2012_1183_VULN_milliwatt_generate.c wf . data . ptr = buf + AST_FRIENDLY_OFFSET 12
static int CVE_2012_1183_VULN_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
struct ast_frame wf =
. frametype = AST_FRAME_VOICE ,
. offset = AST_FRIENDLY_OFFSET ,
. src = __FUNCTION__ , 9
wf . data . ptr = buf + AST_FRIENDLY_OFFSET; 12
wf . datalen = len; 25
wf . samples = samples; 26
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
293 /home/SySeVR/data/CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric.c gamma_table [ X ] = clamp_float ( c * X / 255. + f ) 58
void CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
size_t X ; 3
float interval ; 4
float a , b , c , e , f ; 5
if ( count == 0 )  7
c = 0; 10
f = 0; 12
interval = - INFINITY; 13
if ( count == 1 )  14
c = 0; 17
f = 0; 19
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 20
if ( count == 2 )  21
c = 0; 24
f = parameter [ 3 ]; 26
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 27
if ( count == 3 )  28
c = parameter [ 3 ]; 31
f = 0; 33
interval = parameter [ 4 ]; 34
if ( count == 4 )  35
c = parameter [ 3 ]; 38
f = parameter [ 6 ]; 40
interval = parameter [ 4 ]; 41
c = 0; 46
f = 0; 48
interval = - INFINITY; 49
for (X = 0; X < 256; X++) 51
if ( X >= interval )  52
gamma_table [ X ] = clamp_float ( c * X / 255. + f ); 58
------------------------------
294 /home/SySeVR/data/CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric.c gamma_table [ X ] = clamp_float ( pow ( a * X / 255. + b , y ) + c + e ) 56
void CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
size_t X ; 3
float interval ; 4
float a , b , c , e , f ; 5
float y = parameter [ 0 ] ; 6
if ( count == 0 )  7
a = 1; 8
b = 0; 9
c = 0; 10
e = 0; 11
interval = - INFINITY; 13
if ( count == 1 )  14
a = parameter [ 1 ]; 15
b = parameter [ 2 ]; 16
c = 0; 17
e = 0; 18
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 20
if ( count == 2 )  21
a = parameter [ 1 ]; 22
b = parameter [ 2 ]; 23
c = 0; 24
e = parameter [ 3 ]; 25
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 27
if ( count == 3 )  28
a = parameter [ 1 ]; 29
b = parameter [ 2 ]; 30
c = parameter [ 3 ]; 31
e = - c; 32
interval = parameter [ 4 ]; 34
if ( count == 4 )  35
a = parameter [ 1 ]; 36
b = parameter [ 2 ]; 37
c = parameter [ 3 ]; 38
e = parameter [ 5 ] - c; 39
interval = parameter [ 4 ]; 41
a = 1; 44
b = 0; 45
c = 0; 46
e = 0; 47
interval = - INFINITY; 49
for (X = 0; X < 256; X++) 51
if ( X >= interval )  52
gamma_table [ X ] = clamp_float ( pow ( a * X / 255. + b , y ) + c + e ); 56
------------------------------
295 /home/SySeVR/data/CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric.c gamma_table [ X ] = c * X / 255. + f 58
void CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
size_t X ; 3
float interval ; 4
float a , b , c , e , f ; 5
if ( count == 0 )  7
c = 0; 10
f = 0; 12
interval = - INFINITY; 13
if ( count == 1 )  14
c = 0; 17
f = 0; 19
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 20
if ( count == 2 )  21
c = 0; 24
f = parameter [ 3 ]; 26
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 27
if ( count == 3 )  28
c = parameter [ 3 ]; 31
f = 0; 33
interval = parameter [ 4 ]; 34
if ( count == 4 )  35
c = parameter [ 3 ]; 38
f = parameter [ 6 ]; 40
interval = parameter [ 4 ]; 41
c = 0; 46
f = 0; 48
interval = - INFINITY; 49
for (X = 0; X < 256; X++) 51
if ( X >= interval )  52
gamma_table [ X ] = c * X / 255. + f; 58
------------------------------
296 /home/SySeVR/data/CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric.c gamma_table [ X ] = pow ( a * X / 255. + b , y ) + c + e 56
void CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
size_t X ; 3
float interval ; 4
float a , b , c , e , f ; 5
float y = parameter [ 0 ] ; 6
if ( count == 0 )  7
a = 1; 8
b = 0; 9
c = 0; 10
e = 0; 11
interval = - INFINITY; 13
if ( count == 1 )  14
a = parameter [ 1 ]; 15
b = parameter [ 2 ]; 16
c = 0; 17
e = 0; 18
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 20
if ( count == 2 )  21
a = parameter [ 1 ]; 22
b = parameter [ 2 ]; 23
c = 0; 24
e = parameter [ 3 ]; 25
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 27
if ( count == 3 )  28
a = parameter [ 1 ]; 29
b = parameter [ 2 ]; 30
c = parameter [ 3 ]; 31
e = - c; 32
interval = parameter [ 4 ]; 34
if ( count == 4 )  35
a = parameter [ 1 ]; 36
b = parameter [ 2 ]; 37
c = parameter [ 3 ]; 38
e = parameter [ 5 ] - c; 39
interval = parameter [ 4 ]; 41
a = 1; 44
b = 0; 45
c = 0; 46
e = 0; 47
interval = - INFINITY; 49
for (X = 0; X < 256; X++) 51
if ( X >= interval )  52
gamma_table [ X ] = pow ( a * X / 255. + b , y ) + c + e; 56
------------------------------
297 /home/SySeVR/data/CVE_2012_2100_VULN_ext4_fill_flex_info.c size = flex_group_count * sizeof ( struct flex_groups ) 23
static int CVE_2012_2100_VULN_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
size_t size ; 8
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ); 40
atomic_add ( ext4_free_blks_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_blocks ); 42
atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ); 44
------------------------------
298 /home/SySeVR/data/CVE_2012_2100_VULN_ext4_fill_flex_info.c flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex 20
static int CVE_2012_2100_VULN_ext4_fill_flex_info(struct super_block *sb) 1
struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; 3
ext4_group_t flex_group_count ; 5
sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex; 11
groups_per_flex = 1 << sbi -> s_log_groups_per_flex; 12
if ( groups_per_flex < 2 )  14
flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex; 20
size = flex_group_count * sizeof ( struct flex_groups ); 23
sbi -> s_flex_groups = kzalloc ( size , GFP_KERNEL ); 24
if ( sbi -> s_flex_groups == NULL )  25
sbi -> s_flex_groups = vmalloc ( size ); 26
if ( sbi -> s_flex_groups )  27
memset ( sbi -> s_flex_groups , 0 , size ); 28
if ( sbi -> s_flex_groups == NULL )  30
ext4_msg ( sb , KERN_ERR , "not enough memory for "
"%u flex groups" , flex_group_count ) 32
for (i = 0; i < sbi->s_groups_count; i++) 36
flex_group = ext4_flex_group ( sbi , i ); 39
atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ); 40
atomic_add ( ext4_free_blks_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_blocks ); 42
atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ); 44
------------------------------
299 /home/SySeVR/data/CVE_2012_2375_VULN___nfs4_get_acl_uncached.c acl_len = res . acl_len - res . acl_data_offset 52
static ssize_t CVE_2012_2375_VULN___nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) 1
struct page * pages [ NFS4ACL_MAXPAGES ] = NULL ,
struct nfs_getaclargs args =
. fh = NFS_FH ( inode ) ,
. acl_pages = pages ,
. acl_len = buflen , 7
struct nfs_getaclres res =
. acl_len = buflen , 10
struct rpc_message msg =
. rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] ,
. rpc_argp = & args ,
. rpc_resp = & res , 16
npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 20
if ( npages == 0 )  23
npages = 1; 24
for (i = 0; i < npages; i++) 26
pages [ i ] = alloc_page ( GFP_KERNEL ); 27
if ( ! pages [ i ] )  28
if ( npages > 1 )  31
res . acl_scratch = alloc_page ( GFP_KERNEL ); 33
if ( ! res . acl_scratch )  34
args . acl_len = npages * PAGE_SIZE; 37
args . acl_pgbase = 0; 38
if ( buf == NULL )  41
res . acl_flags |= NFS4_ACL_LEN_REQUEST; 42
ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ); 47
if ( ret )  49
acl_len = res . acl_len - res . acl_data_offset; 52
if ( acl_len > args . acl_len )  53
nfs4_write_cached_acl ( inode , NULL , acl_len ); 54
nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ); 56
if ( acl_len > buflen )  60
ret = acl_len; 65
return ret ; 72
------------------------------
300 /home/SySeVR/data/CVE_2012_2375_VULN___nfs4_get_acl_uncached.c args . acl_len = npages * PAGE_SIZE 37
static ssize_t CVE_2012_2375_VULN___nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) 1
struct page * pages [ NFS4ACL_MAXPAGES ] = NULL ,
struct nfs_getaclargs args =
. fh = NFS_FH ( inode ) ,
. acl_pages = pages ,
. acl_len = buflen , 7
struct nfs_getaclres res =
. acl_len = buflen , 10
npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 20
if ( npages == 0 )  23
npages = 1; 24
for (i = 0; i < npages; i++) 26
pages [ i ] = alloc_page ( GFP_KERNEL ); 27
if ( ! pages [ i ] )  28
if ( npages > 1 )  31
res . acl_scratch = alloc_page ( GFP_KERNEL ); 33
if ( ! res . acl_scratch )  34
args . acl_len = npages * PAGE_SIZE; 37
args . acl_pgbase = 0; 38
dprintk ( "%s  buf %p buflen %zu npages %d args.acl_len %zu\n" , __func__ , buf , buflen , npages , args . acl_len ); 45
ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ); 47
if ( ret )  49
if ( acl_len > args . acl_len )  53
return ret ; 72
------------------------------
301 /home/SySeVR/data/CVE_2012_2375_VULN___nfs4_get_acl_uncached.c npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT 20
static ssize_t CVE_2012_2375_VULN___nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) 1
npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT; 20
if ( npages == 0 )  23
for (i = 0; i < npages; i++) 26
if ( npages > 1 )  31
args . acl_len = npages * PAGE_SIZE; 37
args . acl_pgbase = 0; 38
dprintk ( "%s  buf %p buflen %zu npages %d args.acl_len %zu\n" , __func__ , buf , buflen , npages , args . acl_len ); 45
ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ); 47
if ( ret )  49
if ( acl_len > args . acl_len )  53
for (i = 0; i < npages; i++) 67
return ret ; 72
------------------------------
302 /home/SySeVR/data/CVE_2012_2390_PATCHED_hugetlb_reserve_pages.c chg = to - from 31
int CVE_2012_2390_PATCHED_hugetlb_reserve_pages(struct inode *inode,
long from, long to,
struct vm_area_struct *vma,
vm_flags_t vm_flags) 4
long ret , chg ; 6
if ( vm_flags & VM_NORESERVE )  15
if ( ! vma || vma -> vm_flags & VM_MAYSHARE )  24
struct resv_map * resv_map = resv_map_alloc ( ) ; 27
if ( ! resv_map )  28
chg = to - from; 31
if ( chg < 0 )  37
ret = chg; 38
if ( hugepage_subpool_get_pages ( spool , chg ) )  43
ret = hugetlb_acct_memory ( h , chg ); 52
if ( ret < 0 )  53
hugepage_subpool_put_pages ( spool , chg ); 54
return ret ; 74
------------------------------
303 /home/SySeVR/data/CVE_2012_2390_PATCHED_hugetlb_vm_op_close.c reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) 14
static void CVE_2012_2390_PATCHED_hugetlb_vm_op_close(struct vm_area_struct *vma) 1
struct hstate * h = hstate_vma ( vma ) ; 3
struct resv_map * reservations = vma_resv_map ( vma ) ; 4
unsigned long reserve ; 6
unsigned long start ; 7
unsigned long end ; 8
if ( reservations )  10
start = vma_hugecache_offset ( h , vma , vma -> vm_start ); 11
end = vma_hugecache_offset ( h , vma , vma -> vm_end ); 12
reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ); 14
if ( reserve )  19
hugetlb_acct_memory ( h , - reserve ); 20
hugepage_subpool_put_pages ( spool , reserve ); 21
------------------------------
304 /home/SySeVR/data/CVE_2012_2390_VULN_hugetlb_reserve_pages.c chg = to - from 31
int CVE_2012_2390_VULN_hugetlb_reserve_pages(struct inode *inode,
long from, long to,
struct vm_area_struct *vma,
vm_flags_t vm_flags) 4
long ret , chg ; 6
if ( vm_flags & VM_NORESERVE )  15
if ( ! vma || vma -> vm_flags & VM_MAYSHARE )  24
struct resv_map * resv_map = resv_map_alloc ( ) ; 27
if ( ! resv_map )  28
chg = to - from; 31
if ( chg < 0 )  37
return chg ; 38
if ( hugepage_subpool_get_pages ( spool , chg ) )  41
ret = hugetlb_acct_memory ( h , chg ); 48
if ( ret < 0 )  49
hugepage_subpool_put_pages ( spool , chg ); 50
return ret ; 51
------------------------------
305 /home/SySeVR/data/CVE_2012_2776_PATCHED_decode_cell_data.c num_lines = 257 - code - line 76
static int CVE_2012_2776_PATCHED_decode_cell_data(Cell *cell, uint8_t *block, uint8_t *ref_block,
int pitch, int h_zoom, int v_zoom, int mode,
const vqEntry *delta[2], int swap_quads[2],
const uint8_t **data_ptr, const uint8_t *last_ptr) 4
int x , y , line , num_lines ; 6
int rle_blocks = 0 ; 7
uint8_t code , * dst , * ref ; 8
const vqEntry * delta_tab ; 9
unsigned int dyad1 , dyad2 ; 10
for (y = 0; y + v_zoom < cell->height; is_first_row = 0, y += 1 + v_zoom) 19
for (x = 0; x + h_zoom < cell->width; x += 1 + h_zoom) 20
if ( rle_blocks > 0 )  24
rle_blocks --; 30
for (line = 0; line < 4;) 32
num_lines = 1; 33
is_top_of_cell = is_first_row && ! line; 34
if ( mode <= 4 )  37
delta_tab = delta [ line & 1 ]; 38
delta_tab = delta [ 1 ]; 40
code = bytestream_get_byte ( data_ptr ); 42
if ( code < 248 )  43
if ( code < delta_tab -> num_dyads )  44
dyad1 = bytestream_get_byte ( data_ptr ); 46
if ( dyad1 >= delta_tab -> num_dyads || dyad1 >= 248 )  48
code -= delta_tab -> num_dyads; 52
dyad1 = code / delta_tab -> quad_exp; 53
dyad2 = code % delta_tab -> quad_exp; 54
if ( swap_quads [ line & 1 ] )  55
FFSWAP ( unsigned int , dyad1 , dyad2 ) 56
switch ( code )  67
rle_blocks = 1; 70
code = 253; 71
num_lines = 257 - code - line; 76
if ( num_lines <= 0 )  77
code = bytestream_get_byte ( data_ptr ); 87
rle_blocks = ( code & 0x1F ) - 1; 88
if ( code >= 64 || rle_blocks < 0 )  89
num_lines = 4 - line; 92
rle_blocks = 1; 103
if ( line )  106
num_lines = 4; 108
line += num_lines; 122
ref += row_offset * ( num_lines << v_zoom ); 123
dst += row_offset * ( num_lines << v_zoom ); 124
------------------------------
306 /home/SySeVR/data/CVE_2012_2776_PATCHED_decode_cell_data.c dyad1 = code / delta_tab -> quad_exp 53
static int CVE_2012_2776_PATCHED_decode_cell_data(Cell *cell, uint8_t *block, uint8_t *ref_block,
int pitch, int h_zoom, int v_zoom, int mode,
const vqEntry *delta[2], int swap_quads[2],
const uint8_t **data_ptr, const uint8_t *last_ptr) 4
int x , y , line , num_lines ; 6
int rle_blocks = 0 ; 7
uint8_t code , * dst , * ref ; 8
const vqEntry * delta_tab ; 9
unsigned int dyad1 , dyad2 ; 10
for (y = 0; y + v_zoom < cell->height; is_first_row = 0, y += 1 + v_zoom) 19
for (x = 0; x + h_zoom < cell->width; x += 1 + h_zoom) 20
if ( rle_blocks > 0 )  24
rle_blocks --; 30
for (line = 0; line < 4;) 32
num_lines = 1; 33
if ( mode <= 4 )  37
delta_tab = delta [ line & 1 ]; 38
delta_tab = delta [ 1 ]; 40
code = bytestream_get_byte ( data_ptr ); 42
if ( code < 248 )  43
if ( code < delta_tab -> num_dyads )  44
dyad1 = bytestream_get_byte ( data_ptr ); 46
if ( dyad1 >= delta_tab -> num_dyads || dyad1 >= 248 )  48
code -= delta_tab -> num_dyads; 52
dyad1 = code / delta_tab -> quad_exp; 53
FFSWAP ( unsigned int , dyad1 , dyad2 ) 56
switch ( code )  67
rle_blocks = 1; 70
code = 253; 71
num_lines = 257 - code - line; 76
if ( num_lines <= 0 )  77
code = bytestream_get_byte ( data_ptr ); 87
rle_blocks = ( code & 0x1F ) - 1; 88
if ( code >= 64 || rle_blocks < 0 )  89
num_lines = 4 - line; 92
rle_blocks = 1; 103
if ( line )  106
num_lines = 4; 108
line += num_lines; 122
------------------------------
307 /home/SySeVR/data/CVE_2012_2783_PATCHED_ff_vp56_decode_frame.c mb_row_flip = s -> mb_height - mb_row - 1 93
int CVE_2012_2783_PATCHED_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != p && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
------------------------------
308 /home/SySeVR/data/CVE_2012_2783_VULN_ff_vp56_decode_frame.c mb_row_flip = s -> mb_height - mb_row - 1 93
int CVE_2012_2783_VULN_ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
VP56Context * s = avctx -> priv_data ; 5
AVFrame * const p = s -> framep [ VP56_FRAME_CURRENT ] 6
int remaining_buf_size = avpkt -> size ; 7
int is_alpha , av_uninit ( alpha_offset ) ; 8
if ( s -> has_alpha )  10
if ( remaining_buf_size < 3 )  11
alpha_offset = bytestream_get_be24 ( & buf ); 13
remaining_buf_size -= 3; 14
if ( remaining_buf_size < alpha_offset )  15
for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) 19
int mb_row , mb_col , mb_row_flip , mb_offset = 0 ; 20
int block , y , uv , stride_y , stride_uv ; 21
int golden_frame = 0 ; 22
int res ; 23
s -> modelp = & s -> models [ is_alpha ]; 25
res = s -> parse_header ( s , buf , remaining_buf_size , & golden_frame ); 27
if ( ! res )  28
if ( res == 2 )  31
if ( s -> frames [ i ] . data [ 0 ] )  34
if ( is_alpha )  37
if ( ! is_alpha )  43
p -> reference = 1; 44
if ( avctx -> get_buffer ( avctx , p ) < 0 )  45
if ( res == 2 )  50
if ( vp56_size_changed ( avctx ) )  51
if ( p -> key_frame )  57
p -> pict_type = AV_PICTURE_TYPE_I; 58
for (block=0; block<s->mb_height*s->mb_width; block++) 60
s -> macroblocks [ block ] . type = VP56_MB_INTRA; 61
p -> pict_type = AV_PICTURE_TYPE_P; 63
s -> mb_type = VP56_MB_INTER_NOVEC_PF; 66
if ( s -> parse_coeff_models ( s ) )  69
memset ( s -> prev_dc , 0 , sizeof ( s -> prev_dc ) ); 72
s -> prev_dc [ 1 ] [ VP56_FRAME_CURRENT ] = 128; 73
s -> prev_dc [ 2 ] [ VP56_FRAME_CURRENT ] = 128; 74
for (block=0; block < 4*s->mb_width+6; block++) 76
s -> above_blocks [ block ] . ref_frame = VP56_FRAME_NONE; 77
s -> above_blocks [ block ] . dc_coeff = 0; 78
s -> above_blocks [ block ] . not_null_dc = 0; 79
s -> above_blocks [ 2 * s -> mb_width + 2 ] . ref_frame = VP56_FRAME_CURRENT; 81
s -> above_blocks [ 3 * s -> mb_width + 4 ] . ref_frame = VP56_FRAME_CURRENT; 82
stride_y = p -> linesize [ 0 ]; 84
stride_uv = p -> linesize [ 1 ]; 85
if ( s -> flip < 0 )  87
mb_offset = 7; 88
for (mb_row=0; mb_row<s->mb_height; mb_row++) 91
if ( s -> flip < 0 )  92
mb_row_flip = s -> mb_height - mb_row - 1; 93
mb_row_flip = mb_row; 95
for (block=0; block<4; block++) 97
s -> left_block [ block ] . ref_frame = VP56_FRAME_NONE; 98
s -> left_block [ block ] . dc_coeff = 0; 99
s -> left_block [ block ] . not_null_dc = 0; 100
memset ( s -> coeff_ctx , 0 , sizeof ( s -> coeff_ctx ) ); 102
memset ( s -> coeff_ctx_last , 24 , sizeof ( s -> coeff_ctx_last ) ); 103
s -> above_block_idx [ 0 ] = 1; 105
s -> above_block_idx [ 1 ] = 2; 106
s -> above_block_idx [ 2 ] = 1; 107
s -> above_block_idx [ 3 ] = 2; 108
s -> above_block_idx [ 4 ] = 2 * s -> mb_width + 2 + 1; 109
s -> above_block_idx [ 5 ] = 3 * s -> mb_width + 4 + 1; 110
s -> block_offset [ s -> frbi ] = ( mb_row_flip * 16 + mb_offset ) * stride_y; 112
s -> block_offset [ s -> srbi ] = s -> block_offset [ s -> frbi ] + 8 * stride_y; 113
s -> block_offset [ 1 ] = s -> block_offset [ 0 ] + 8; 114
s -> block_offset [ 3 ] = s -> block_offset [ 2 ] + 8; 115
s -> block_offset [ 4 ] = ( mb_row_flip * 8 + mb_offset ) * stride_uv; 116
s -> block_offset [ 5 ] = s -> block_offset [ 4 ]; 117
for (mb_col=0; mb_col<s->mb_width; mb_col++) 119
vp56_decode_mb ( s , mb_row , mb_col , is_alpha ); 120
for (y=0; y<4; y++) 122
s -> above_block_idx [ y ] += 2; 123
s -> block_offset [ y ] += 16; 124
for (uv=4; uv<6; uv++) 127
s -> above_block_idx [ uv ] += 1; 128
s -> block_offset [ uv ] += 8; 129
if ( p -> key_frame || golden_frame )  135
if ( s -> framep [ VP56_FRAME_GOLDEN ] -> data [ 0 ] && s -> framep [ VP56_FRAME_GOLDEN ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  136
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_GOLDEN ] ); 138
s -> framep [ VP56_FRAME_GOLDEN ] = p; 139
if ( s -> has_alpha )  142
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_GOLDEN ] ,
s -> framep [ VP56_FRAME_GOLDEN2 ] ) 144
buf += alpha_offset; 145
remaining_buf_size -= alpha_offset; 146
if ( s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN ] || s -> framep [ VP56_FRAME_PREVIOUS ] == s -> framep [ VP56_FRAME_GOLDEN2 ] )  150
if ( s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN ] && s -> framep [ VP56_FRAME_UNUSED ] != s -> framep [ VP56_FRAME_GOLDEN2 ] )  152
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED ] ) 155
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_PREVIOUS ] ,
s -> framep [ VP56_FRAME_UNUSED2 ] ) 158
if ( s -> framep [ VP56_FRAME_PREVIOUS ] -> data [ 0 ] )  159
avctx -> release_buffer ( avctx , s -> framep [ VP56_FRAME_PREVIOUS ] ); 160
FFSWAP ( AVFrame * , s -> framep [ VP56_FRAME_CURRENT ] ,
s -> framep [ VP56_FRAME_PREVIOUS ] ) 162
p -> qscale_table = s -> qscale_table; 165
p -> qscale_type = FF_QSCALE_TYPE_VP56; 166
* ( AVFrame * ) data = * p; 167
------------------------------
309 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c current_res = bd -> raw_samples + start 232
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
ALSSpecificConfig * sconf = & ctx -> sconf ; 3
AVCodecContext * avctx = ctx -> avctx ; 4
GetBitContext * gb = & ctx -> gb ; 5
unsigned int k ; 6
unsigned int s [ 8 ] ; 7
unsigned int sx [ 8 ] ; 8
unsigned int sub_blocks , log2_sub_blocks , sb_length ; 9
unsigned int start = 0 ; 10
unsigned int opt_order ; 11
int32_t * current_res ; 14
* bd -> const_block = 0; 18
* bd -> opt_order = 1; 20
bd -> js_blocks = get_bits1 ( gb ); 21
opt_order = * bd -> opt_order; 23
if ( ! sconf -> bgmc && ! sconf -> sb_part )  26
log2_sub_blocks = 0; 27
if ( sconf -> bgmc && sconf -> sb_part )  29
log2_sub_blocks = get_bits ( gb , 2 ); 30
log2_sub_blocks = 2 * get_bits1 ( gb ); 32
sub_blocks = 1 << log2_sub_blocks; 35
if ( bd -> block_length & ( sub_blocks - 1 ) )  39
if ( sconf -> bgmc )  47
s [ 0 ] = get_bits ( gb , 8 + ( sconf -> resolution > 1 ) ); 48
for (k = 1; k < sub_blocks; k++) 49
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 2 ); 50
for (k = 0; k < sub_blocks; k++) 52
sx [ k ] = s [ k ] & 0x0F; 53
s [ k ] >>= 4; 54
s [ 0 ] = get_bits ( gb , 4 + ( sconf -> resolution > 1 ) ); 57
for (k = 1; k < sub_blocks; k++) 58
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 0 ); 59
if ( get_bits1 ( gb ) )  62
* bd -> shift_lsbs = get_bits ( gb , 4 ) + 1; 63
* bd -> store_prev_samples = ( bd -> js_blocks && bd -> raw_other ) || * bd -> shift_lsbs; 65
if ( ! sconf -> rlslms )  68
if ( sconf -> adapt_order )  69
int opt_order_length = av_ceil_log2 ( av_clip ( ( bd -> block_length >> 3 ) - 1 , 2 , sconf -> max_order + 1 ) ) ; 70
* bd -> opt_order = get_bits ( gb , opt_order_length ); 72
* bd -> opt_order = sconf -> max_order; 74
opt_order = * bd -> opt_order; 77
if ( sconf -> long_term_prediction )  128
* bd -> use_ltp = get_bits1 ( gb ); 129
if ( * bd -> use_ltp )  131
int r , c ; 132
bd -> ltp_gain [ 0 ] = decode_rice ( gb , 1 ) << 3; 134
bd -> ltp_gain [ 1 ] = decode_rice ( gb , 2 ) << 3; 135
r = get_unary ( gb , 0 , 4 ); 137
c = get_bits ( gb , 2 ); 138
bd -> ltp_gain [ 2 ] = ltp_gain_values [ r ] [ c ]; 139
bd -> ltp_gain [ 3 ] = decode_rice ( gb , 2 ) << 3; 141
bd -> ltp_gain [ 4 ] = decode_rice ( gb , 1 ) << 3; 142
* bd -> ltp_lag = get_bits ( gb , ctx -> ltp_lag_length ); 144
* bd -> ltp_lag += FFMAX ( 4 , opt_order + 1 ); 145
if ( bd -> ra_block )  150
if ( opt_order )  151
bd -> raw_samples [ 0 ] = decode_rice ( gb , avctx -> bits_per_raw_sample - 4 ); 152
if ( opt_order > 1 )  153
bd -> raw_samples [ 1 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 3 , ctx -> s_max ) ); 154
if ( opt_order > 2 )  155
bd -> raw_samples [ 2 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 1 , ctx -> s_max ) ); 156
start = FFMIN ( opt_order , 3 ); 158
if ( sconf -> bgmc )  162
current_res = bd -> raw_samples + start; 232
* current_res ++ = decode_rice ( gb , s [ sb ] ); 236
------------------------------
310 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c current_res = bd -> raw_samples + start 192
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
ALSSpecificConfig * sconf = & ctx -> sconf ; 3
AVCodecContext * avctx = ctx -> avctx ; 4
GetBitContext * gb = & ctx -> gb ; 5
unsigned int k ; 6
unsigned int s [ 8 ] ; 7
unsigned int sx [ 8 ] ; 8
unsigned int sub_blocks , log2_sub_blocks , sb_length ; 9
unsigned int start = 0 ; 10
unsigned int opt_order ; 11
int32_t * current_res ; 14
* bd -> const_block = 0; 18
* bd -> opt_order = 1; 20
bd -> js_blocks = get_bits1 ( gb ); 21
opt_order = * bd -> opt_order; 23
if ( ! sconf -> bgmc && ! sconf -> sb_part )  26
log2_sub_blocks = 0; 27
if ( sconf -> bgmc && sconf -> sb_part )  29
log2_sub_blocks = get_bits ( gb , 2 ); 30
log2_sub_blocks = 2 * get_bits1 ( gb ); 32
sub_blocks = 1 << log2_sub_blocks; 35
if ( bd -> block_length & ( sub_blocks - 1 ) )  39
if ( sconf -> bgmc )  47
s [ 0 ] = get_bits ( gb , 8 + ( sconf -> resolution > 1 ) ); 48
for (k = 1; k < sub_blocks; k++) 49
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 2 ); 50
for (k = 0; k < sub_blocks; k++) 52
sx [ k ] = s [ k ] & 0x0F; 53
s [ k ] >>= 4; 54
s [ 0 ] = get_bits ( gb , 4 + ( sconf -> resolution > 1 ) ); 57
for (k = 1; k < sub_blocks; k++) 58
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 0 ); 59
if ( get_bits1 ( gb ) )  62
* bd -> shift_lsbs = get_bits ( gb , 4 ) + 1; 63
* bd -> store_prev_samples = ( bd -> js_blocks && bd -> raw_other ) || * bd -> shift_lsbs; 65
if ( ! sconf -> rlslms )  68
if ( sconf -> adapt_order )  69
int opt_order_length = av_ceil_log2 ( av_clip ( ( bd -> block_length >> 3 ) - 1 , 2 , sconf -> max_order + 1 ) ) ; 70
* bd -> opt_order = get_bits ( gb , opt_order_length ); 72
* bd -> opt_order = sconf -> max_order; 74
opt_order = * bd -> opt_order; 77
if ( sconf -> long_term_prediction )  128
* bd -> use_ltp = get_bits1 ( gb ); 129
if ( * bd -> use_ltp )  131
int r , c ; 132
bd -> ltp_gain [ 0 ] = decode_rice ( gb , 1 ) << 3; 134
bd -> ltp_gain [ 1 ] = decode_rice ( gb , 2 ) << 3; 135
r = get_unary ( gb , 0 , 4 ); 137
c = get_bits ( gb , 2 ); 138
bd -> ltp_gain [ 2 ] = ltp_gain_values [ r ] [ c ]; 139
bd -> ltp_gain [ 3 ] = decode_rice ( gb , 2 ) << 3; 141
bd -> ltp_gain [ 4 ] = decode_rice ( gb , 1 ) << 3; 142
* bd -> ltp_lag = get_bits ( gb , ctx -> ltp_lag_length ); 144
* bd -> ltp_lag += FFMAX ( 4 , opt_order + 1 ); 145
if ( bd -> ra_block )  150
if ( opt_order )  151
bd -> raw_samples [ 0 ] = decode_rice ( gb , avctx -> bits_per_raw_sample - 4 ); 152
if ( opt_order > 1 )  153
bd -> raw_samples [ 1 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 3 , ctx -> s_max ) ); 154
if ( opt_order > 2 )  155
bd -> raw_samples [ 2 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 1 , ctx -> s_max ) ); 156
start = FFMIN ( opt_order , 3 ); 158
if ( sconf -> bgmc )  162
current_res = bd -> raw_samples + start; 192
int32_t res = * current_res ; 200
if ( res == cur_tail_code )  202
if ( res > cur_tail_code )  214
res --; 215
if ( res & 1 )  217
res = - res; 218
res >>= 1; 220
res <<= cur_k; 223
res |= get_bits_long ( gb , cur_k ); 224
* current_res ++ = res; 228
------------------------------
311 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c current_res = bd -> raw_samples + start 175
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
ALSSpecificConfig * sconf = & ctx -> sconf ; 3
AVCodecContext * avctx = ctx -> avctx ; 4
GetBitContext * gb = & ctx -> gb ; 5
unsigned int k ; 6
unsigned int s [ 8 ] ; 7
unsigned int sx [ 8 ] ; 8
unsigned int sub_blocks , log2_sub_blocks , sb_length ; 9
unsigned int start = 0 ; 10
unsigned int opt_order ; 11
int32_t * current_res ; 14
* bd -> const_block = 0; 18
* bd -> opt_order = 1; 20
bd -> js_blocks = get_bits1 ( gb ); 21
opt_order = * bd -> opt_order; 23
if ( ! sconf -> bgmc && ! sconf -> sb_part )  26
log2_sub_blocks = 0; 27
if ( sconf -> bgmc && sconf -> sb_part )  29
log2_sub_blocks = get_bits ( gb , 2 ); 30
log2_sub_blocks = 2 * get_bits1 ( gb ); 32
sub_blocks = 1 << log2_sub_blocks; 35
if ( bd -> block_length & ( sub_blocks - 1 ) )  39
if ( sconf -> bgmc )  47
s [ 0 ] = get_bits ( gb , 8 + ( sconf -> resolution > 1 ) ); 48
for (k = 1; k < sub_blocks; k++) 49
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 2 ); 50
for (k = 0; k < sub_blocks; k++) 52
sx [ k ] = s [ k ] & 0x0F; 53
s [ k ] >>= 4; 54
s [ 0 ] = get_bits ( gb , 4 + ( sconf -> resolution > 1 ) ); 57
for (k = 1; k < sub_blocks; k++) 58
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 0 ); 59
if ( get_bits1 ( gb ) )  62
* bd -> shift_lsbs = get_bits ( gb , 4 ) + 1; 63
* bd -> store_prev_samples = ( bd -> js_blocks && bd -> raw_other ) || * bd -> shift_lsbs; 65
if ( ! sconf -> rlslms )  68
if ( sconf -> adapt_order )  69
int opt_order_length = av_ceil_log2 ( av_clip ( ( bd -> block_length >> 3 ) - 1 , 2 , sconf -> max_order + 1 ) ) ; 70
* bd -> opt_order = get_bits ( gb , opt_order_length ); 72
* bd -> opt_order = sconf -> max_order; 74
opt_order = * bd -> opt_order; 77
if ( sconf -> long_term_prediction )  128
* bd -> use_ltp = get_bits1 ( gb ); 129
if ( * bd -> use_ltp )  131
int r , c ; 132
bd -> ltp_gain [ 0 ] = decode_rice ( gb , 1 ) << 3; 134
bd -> ltp_gain [ 1 ] = decode_rice ( gb , 2 ) << 3; 135
r = get_unary ( gb , 0 , 4 ); 137
c = get_bits ( gb , 2 ); 138
bd -> ltp_gain [ 2 ] = ltp_gain_values [ r ] [ c ]; 139
bd -> ltp_gain [ 3 ] = decode_rice ( gb , 2 ) << 3; 141
bd -> ltp_gain [ 4 ] = decode_rice ( gb , 1 ) << 3; 142
* bd -> ltp_lag = get_bits ( gb , ctx -> ltp_lag_length ); 144
* bd -> ltp_lag += FFMAX ( 4 , opt_order + 1 ); 145
if ( bd -> ra_block )  150
if ( opt_order )  151
bd -> raw_samples [ 0 ] = decode_rice ( gb , avctx -> bits_per_raw_sample - 4 ); 152
if ( opt_order > 1 )  153
bd -> raw_samples [ 1 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 3 , ctx -> s_max ) ); 154
if ( opt_order > 2 )  155
bd -> raw_samples [ 2 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 1 , ctx -> s_max ) ); 156
start = FFMIN ( opt_order , 3 ); 158
if ( sconf -> bgmc )  162
current_res = bd -> raw_samples + start; 175
ff_bgmc_decode ( gb , sb_length , current_res , delta [ sb ] , sx [ sb ] , & high , & low , & value , ctx -> bgmc_lut , ctx -> bgmc_lut_status ); 181
current_res += sb_length; 184
int32_t res = * current_res ; 200
if ( res == cur_tail_code )  202
if ( res > cur_tail_code )  214
res --; 215
if ( res & 1 )  217
res = - res; 218
res >>= 1; 220
res <<= cur_k; 223
res |= get_bits_long ( gb , cur_k ); 224
* current_res ++ = res; 228
------------------------------
312 /home/SySeVR/data/CVE_2012_2797_PATCHED_decode_frame_mp3on4.c s -> frame -> nb_samples = out_size / ( avctx -> channels * sizeof ( OUT_INT ) ) 83
static int CVE_2012_2797_PATCHED_decode_frame_mp3on4(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
MP3On4DecodeContext * s = avctx -> priv_data ; 6
MPADecodeContext * m ; 7
int fsize , len = buf_size , out_size = 0 ; 8
uint32_t header ; 9
OUT_INT * out_samples ; 10
OUT_INT * outptr , * bp ; 11
int fr , j , n , ch , ret ; 12
s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE; 15
if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 )  16
out_samples = ( OUT_INT * ) s -> frame -> data [ 0 ]; 20
if ( buf_size < HEADER_SIZE )  23
outptr = s -> frames == 1 ? out_samples : s -> decoded_buf; 27
avctx -> bit_rate = 0; 29
ch = 0; 31
for (fr = 0; fr < s->frames; fr++) 32
fsize = AV_RB16 ( buf ) >> 4; 33
fsize = FFMIN3 ( fsize , len , MPA_MAX_CODED_FRAME_SIZE ); 34
m = s -> mp3decctx [ fr ]; 35
if ( fsize < HEADER_SIZE )  38
header = ( AV_RB32 ( buf ) & 0x000fffff ) | s -> syncword; 42
if ( ff_mpa_check_header ( header ) < 0 )  44
if ( ch + m -> nb_channels > avctx -> channels )  49
ch += m -> nb_channels; 54
out_size += mp_decode_frame ( m , outptr , buf , fsize ); 56
buf += fsize; 57
len -= fsize; 58
avctx -> bit_rate += m -> bit_rate; 77
avctx -> sample_rate = s -> mp3decctx [ 0 ] -> sample_rate; 81
s -> frame -> nb_samples = out_size / ( avctx -> channels * sizeof ( OUT_INT ) ); 83
* ( AVFrame * ) data = * s -> frame; 85
------------------------------
313 /home/SySeVR/data/CVE_2012_2797_PATCHED_decode_frame_mp3on4.c bp = out_samples + s -> coff [ fr ] 63
static int CVE_2012_2797_PATCHED_decode_frame_mp3on4(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
MP3On4DecodeContext * s = avctx -> priv_data ; 6
MPADecodeContext * m ; 7
int fsize , len = buf_size , out_size = 0 ; 8
uint32_t header ; 9
OUT_INT * out_samples ; 10
OUT_INT * outptr , * bp ; 11
int fr , j , n , ch , ret ; 12
s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE; 15
if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 )  16
out_samples = ( OUT_INT * ) s -> frame -> data [ 0 ]; 20
if ( buf_size < HEADER_SIZE )  23
avctx -> bit_rate = 0; 29
ch = 0; 31
for (fr = 0; fr < s->frames; fr++) 32
fsize = AV_RB16 ( buf ) >> 4; 33
fsize = FFMIN3 ( fsize , len , MPA_MAX_CODED_FRAME_SIZE ); 34
m = s -> mp3decctx [ fr ]; 35
if ( fsize < HEADER_SIZE )  38
header = ( AV_RB32 ( buf ) & 0x000fffff ) | s -> syncword; 42
if ( ff_mpa_check_header ( header ) < 0 )  44
if ( ch + m -> nb_channels > avctx -> channels )  49
ch += m -> nb_channels; 54
buf += fsize; 57
len -= fsize; 58
if ( s -> frames > 1 )  60
bp = out_samples + s -> coff [ fr ]; 63
* bp = s -> decoded_buf [ j ]; 66
bp += avctx -> channels; 67
for (j = 0; j < n; j++) 70
bp [ 0 ] = s -> decoded_buf [ j ++ ]; 71
bp [ 1 ] = s -> decoded_buf [ j ]; 72
bp += avctx -> channels; 73
avctx -> bit_rate += m -> bit_rate; 77
------------------------------
314 /home/SySeVR/data/CVE_2012_2797_PATCHED_decode_frame_mp3on4.c n = m -> avctx -> frame_size * m -> nb_channels 61
static int CVE_2012_2797_PATCHED_decode_frame_mp3on4(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
MP3On4DecodeContext * s = avctx -> priv_data ; 6
MPADecodeContext * m ; 7
int fsize , len = buf_size , out_size = 0 ; 8
uint32_t header ; 9
int fr , j , n , ch , ret ; 12
s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE; 15
if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 )  16
if ( buf_size < HEADER_SIZE )  23
avctx -> bit_rate = 0; 29
ch = 0; 31
for (fr = 0; fr < s->frames; fr++) 32
fsize = AV_RB16 ( buf ) >> 4; 33
fsize = FFMIN3 ( fsize , len , MPA_MAX_CODED_FRAME_SIZE ); 34
m = s -> mp3decctx [ fr ]; 35
if ( fsize < HEADER_SIZE )  38
header = ( AV_RB32 ( buf ) & 0x000fffff ) | s -> syncword; 42
if ( ff_mpa_check_header ( header ) < 0 )  44
if ( ch + m -> nb_channels > avctx -> channels )  49
ch += m -> nb_channels; 54
buf += fsize; 57
len -= fsize; 58
if ( s -> frames > 1 )  60
n = m -> avctx -> frame_size * m -> nb_channels; 61
for (j = 0; j < n; j++) 65
for (j = 0; j < n; j++) 70
avctx -> bit_rate += m -> bit_rate; 77
------------------------------
315 /home/SySeVR/data/CVE_2012_2797_PATCHED_decode_frame_mp3on4.c s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE 15
static int CVE_2012_2797_PATCHED_decode_frame_mp3on4(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
MP3On4DecodeContext * s = avctx -> priv_data ; 6
s -> frame -> nb_samples = s -> frames * MPA_FRAME_SIZE; 15
if ( ( ret = avctx -> get_buffer ( avctx , s -> frame ) ) < 0 )  16
return ret ; 18
out_samples = ( OUT_INT * ) s -> frame -> data [ 0 ]; 20
outptr = s -> frames == 1 ? out_samples : s -> decoded_buf; 27
for (fr = 0; fr < s->frames; fr++) 32
m = s -> mp3decctx [ fr ]; 35
assert ( m != NULL ); 36
header = ( AV_RB32 ( buf ) & 0x000fffff ) | s -> syncword; 42
if ( ff_mpa_check_header ( header ) < 0 )  44
avpriv_mpegaudio_decode_header ( ( MPADecodeHeader * ) m , header ); 47
if ( ch + m -> nb_channels > avctx -> channels )  49
ch += m -> nb_channels; 54
out_size += mp_decode_frame ( m , outptr , buf , fsize ); 56
if ( s -> frames > 1 )  60
n = m -> avctx -> frame_size * m -> nb_channels; 61
bp = out_samples + s -> coff [ fr ]; 63
if ( m -> nb_channels == 1 )  64
for (j = 0; j < n; j++) 65
* bp = s -> decoded_buf [ j ]; 66
bp += avctx -> channels; 67
for (j = 0; j < n; j++) 70
bp [ 0 ] = s -> decoded_buf [ j ++ ]; 71
bp [ 1 ] = s -> decoded_buf [ j ]; 72
bp += avctx -> channels; 73
avctx -> bit_rate += m -> bit_rate; 77
avctx -> sample_rate = s -> mp3decctx [ 0 ] -> sample_rate; 81
s -> frame -> nb_samples = out_size / ( avctx -> channels * sizeof ( OUT_INT ) ); 83
* ( AVFrame * ) data = * s -> frame; 85
------------------------------
316 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c p_block -> i_pts = u_pnum * INT64_C ( 1000000 ) / p_stream -> f_rate / 2 250
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
block_t * p_block ; 6
bool b_selected ; 7
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )  100
p_stream -> i_headers = 0; 103
p_stream -> p_headers = NULL; 104
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
p_stream -> fmt . i_extra = p_stream -> i_headers; 113
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers ); 114
if ( p_stream -> fmt . p_extra )  115
p_stream -> fmt . i_extra = 0; 119
b_selected = false; 134
if ( p_stream -> fmt . i_codec == VLC_CODEC_VORBIS || p_stream -> fmt . i_codec == VLC_CODEC_SPEEX || p_stream -> fmt . i_codec == VLC_CODEC_FLAC )  138
if ( p_stream -> i_pcr >= 0 )  142
p_stream -> i_previous_pcr = p_stream -> i_pcr; 156
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> i_pcr >= 0 )  185
p_stream -> i_previous_pcr = p_stream -> i_pcr; 190
if ( ! b_selected )  196
if ( p_oggpacket -> bytes <= 0 )  203
if ( ! ( p_block = block_New ( p_demux , p_oggpacket -> bytes ) ) )  206
if ( p_stream -> i_skip_frames > 0 )  210
p_stream -> i_skip_frames --; 213
if ( p_stream -> fmt . i_cat == AUDIO_ES )  222
if ( p_stream -> fmt . i_cat == SPU_ES )  224
if ( p_stream -> fmt . i_codec == VLC_CODEC_THEORA )  229
if ( p_stream -> fmt . i_codec == VLC_CODEC_DIRAC )  237
ogg_int64_t dts = p_oggpacket -> granulepos >> 31 ; 239
ogg_int64_t delay = ( p_oggpacket -> granulepos >> 9 ) & 0x1fff ; 240
uint64_t u_pnum = dts + delay ; 242
p_block -> i_dts = p_stream -> i_pcr; 244
p_block -> i_pts = VLC_TS_INVALID; 245
if ( - 1 != p_oggpacket -> granulepos )  249
p_block -> i_pts = u_pnum * INT64_C ( 1000000 ) / p_stream -> f_rate / 2; 250
if ( p_block -> i_buffer >= ( unsigned int ) i_header_len )  295
p_block -> i_buffer -= i_header_len; 296
memcpy ( p_block -> p_buffer , p_oggpacket -> packet + i_header_len , p_oggpacket -> bytes - i_header_len ); 309
es_out_Send ( p_demux -> out , p_stream -> p_es , p_block ); 312
------------------------------
317 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c extrema [ i ] = sourceData [ targIndex + i ] 37
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRInt32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint8 extrema [ 4 ] ; 21
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 22
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRInt32 startY = NS_MAX ( 0 , y - ry ) ; 26
PRInt32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRInt32 startX = NS_MAX ( 0 , x - rx ) ; 32
PRInt32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
PRInt32 targIndex = y * stride + 4 * x ; 34
for (PRInt32 i = 0; i < 4; i++) 36
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRInt32 y1 = startY; y1 <= endY; y1++) 39
for (PRInt32 x1 = startX; x1 <= endX; x1++) 40
for (PRInt32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
318 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c extrema [ i ] = sourceData [ targIndex + i ] 37
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint8 extrema [ 4 ] ; 21
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 22
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 26
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 32
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
PRUint32 targIndex = y * stride + 4 * x ; 34
for (PRUint32 i = 0; i < 4; i++) 36
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRUint32 y1 = startY; y1 <= endY; y1++) 39
for (PRUint32 x1 = startX; x1 <= endX; x1++) 40
for (PRUint32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
319 /home/SySeVR/data/CVE_2012_4186_PATCHED_nsWaveReader__LoadFormatChunk.c PR_STATIC_ASSERT ( PR_UINT16_MAX + ( PR_UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) ) 65
bool
CVE_2012_4186_PATCHED_nsWaveReader::LoadFormatChunk() 2
PRUint32 fmtSize , rate , channels , frameSize , sampleFormat ; 4
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ScanForwardUntil ( FRMT_CHUNK_MAGIC , & fmtSize ) )  14
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  18
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  28
p += 4; 37
if ( fmtSize > WAVE_FORMAT_CHUNK_SIZE )  48
char extLength [ 2 ] ; 49
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  52
PRUint16 extra = ReadUint16LE ( & p ) ; 57
if ( fmtSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  58
extra += extra % 2; 62
if ( extra > 0 )  64
PR_STATIC_ASSERT ( PR_UINT16_MAX + ( PR_UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) ); 65
------------------------------
320 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
321 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
322 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
323 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
324 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
325 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
326 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
327 /home/SySeVR/data/CVE_2012_4287_VULN_dissect_bson_document.c final_offset = offset + document_length 22
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
proto_item * ti , * elements , * element , * objectid , * js_code , * js_scope ; 6
proto_tree * doc_tree , * elements_tree , * element_sub_tree , * objectid_sub_tree , * js_code_sub_tree , * js_scope_sub_tree ; 7
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
ti = proto_tree_add_item ( tree , hf_mongo_doc , tvb , offset , document_length , ENC_NA ); 17
doc_tree = proto_item_add_subtree ( ti , ett_mongo_doc ); 18
final_offset = offset + document_length; 22
offset += 4; 23
elements = proto_tree_add_item ( doc_tree , hf_mongo_elements , tvb , offset , document_length - 5 , ENC_NA ); 25
elements_tree = proto_item_add_subtree ( elements , ett_mongo_elements ); 26
gint str_len = - 1 ; 31
e_type = tvb_get_guint8 ( tvb , offset ); 35
element = proto_tree_add_item ( elements_tree , hf_mongo_element_name , tvb , offset + 1 , str_len - 1 , ENC_UTF_8 | ENC_NA ); 38
element_sub_tree = proto_item_add_subtree ( element , ett_mongo_element ); 39
offset += str_len + 1; 42
switch ( e_type )  44
offset += 8; 47
str_len = tvb_get_letohl ( tvb , offset ); 52
offset += str_len + 4; 55
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , element_sub_tree , hf_mongo_document ); 59
e_len = tvb_get_letohl ( tvb , offset ); 62
offset += e_len + 5; 66
offset += 12; 82
offset += 1; 86
offset += str_len; 92
offset += str_len; 96
str_len = tvb_get_letohl ( tvb , offset ); 99
offset += str_len; 102
offset += 12; 104
e_len = tvb_get_letohl ( tvb , offset ); 109
offset += 4; 110
str_len = tvb_get_letohl ( tvb , offset ); 111
offset += str_len + 4; 116
doc_len = e_len - ( str_len + 8 ); 117
js_scope = proto_tree_add_item ( element_sub_tree , hf_mongo_element_value_js_scope , tvb , offset , doc_len , ENC_NA ); 118
js_scope_sub_tree = proto_item_add_subtree ( js_scope , ett_mongo_code ); 119
offset += CVE_2012_4287_VULN_dissect_bson_document ( tvb , offset , js_scope_sub_tree , hf_mongo_document ); 120
offset += 4; 124
offset += 8; 132
while ( offset < final_offset - 1 )  137
static int
CVE_2012_4287_VULN_dissect_bson_document(tvbuff_t *tvb, guint offset, proto_tree *tree, int hf_mongo_doc) 2
gint32 document_length ; 4
guint final_offset ; 5
document_length = tvb_get_letohl ( tvb , offset ); 9
if ( document_length == 5 )  10
final_offset = offset + document_length; 22
while ( offset < final_offset - 1 )  137
------------------------------
328 /home/SySeVR/data/CVE_2012_4288_VULN_dissect_xtp_ecntl.c len = len + XTP_HEADER_LEN - offset 41
static void
CVE_2012_4288_VULN_dissect_xtp_ecntl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
guint32 offset) 3
guint32 len = tvb_length_remaining ( tvb , offset ) ; 4
if ( len < MIN_XTP_ECNTL_PKT_LEN )  17
offset += 8; 29
offset += 8; 34
offset += 4; 37
offset += 4; 40
len = len + XTP_HEADER_LEN - offset; 41
if ( len != spans_len )  43
proto_item_append_text ( top_ti , ", bogus spans field length (%u, must be %u)" , len , spans_len ); 44
------------------------------
329 /home/SySeVR/data/CVE_2012_4293_PATCHED_dissect_ecat_eoe.c anItem = proto_tree_add_item ( ecat_fraghead_tree , hf_ecat_mailbox_eoe_macfilter , tvb , offset , MIN ( eoe_length - offset , ETHERCAT_EOE_MACFILTER_LEN ) , ENC_NA ) 134
static void CVE_2012_4293_PATCHED_dissect_ecat_eoe(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree) 1
proto_item * anItem = NULL , * aparent = NULL ; 6
guint eoe_length = tvb_reported_length ( tvb ) - offset ; 11
if ( tree )  13
anItem = proto_tree_add_item ( tree , hf_ecat_mailbox_eoe , tvb , offset , eoe_length , ENC_NA ); 15
if ( eoe_length >= ETHERCAT_EOE_HEADER_LEN )  22
ETHERCAT_EOE_HEADER eoe ; 24
ecat_eoe_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe ); 33
anItem = proto_tree_add_item ( ecat_eoe_tree , hf_ecat_mailbox_eoe_fraghead , tvb , offset , 4 , ENC_NA ); 35
ecat_fraghead_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_fraghead ); 37
switch ( eoe . anEoeHeaderInfoUnion . v . Type )  43
offset += ETHERCAT_EOE_HEADER_LEN; 94
if ( eoe_length - offset >= ETHERCAT_EOE_INIT_LEN )  96
offset += 4; 107
offset += ETHERNET_ADDRESS_LEN; 110
offset += 4; 113
offset += 4; 116
offset += 4; 119
offset += 4; 122
offset += ETHERCAT_EOE_HEADER_LEN; 133
anItem = proto_tree_add_item ( ecat_fraghead_tree , hf_ecat_mailbox_eoe_macfilter , tvb , offset , MIN ( eoe_length - offset , ETHERCAT_EOE_MACFILTER_LEN ) , ENC_NA ); 134
ecat_eoe_macfilter_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_macfilter ); 139
proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_macfiltercount , tvb , offset , 2 , ENC_LITTLE_ENDIAN ); 147
proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_maskcount , tvb , offset , 2 , ENC_LITTLE_ENDIAN ); 148
proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_nobroadcasts , tvb , offset , 2 , ENC_LITTLE_ENDIAN ); 149
anItem = proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_filter , tvb , offset , 16 * ETHERNET_ADDRESS_LEN , ENC_NA ); 153
ecat_eoe_macfilter_filter_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_macfilter_filter ); 154
proto_tree_add_item ( ecat_eoe_macfilter_filter_tree , hf_ecat_mailbox_eoe_macfilter_filters [ nCnt ] , tvb , offset + nCnt * ETHERNET_ADDRESS_LEN , ETHERNET_ADDRESS_LEN , ENC_NA ); 156
anItem = proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_filtermask , tvb , offset , 4 * sizeof ( guint32 ) , ENC_NA ); 159
ecat_eoe_macfilter_filtermask_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_macfilter_filtermask ); 160
proto_tree_add_item ( ecat_eoe_macfilter_filtermask_tree , hf_ecat_mailbox_eoe_macfilter_filtermasks [ nCnt ] , tvb , offset + nCnt * sizeof ( guint32 ) , sizeof ( guint32 ) , ENC_NA ); 162
proto_item_append_text ( anItem , " - Invalid length!" ); 165
------------------------------
330 /home/SySeVR/data/CVE_2012_4293_PATCHED_dissect_ecat_eoe.c anItem = proto_tree_add_item ( ecat_fraghead_tree , hf_ecat_mailbox_eoe_init , tvb , offset , MIN ( eoe_length - offset , ETHERCAT_EOE_INIT_LEN ) , ENC_NA ) 95
static void CVE_2012_4293_PATCHED_dissect_ecat_eoe(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree) 1
proto_item * anItem = NULL , * aparent = NULL ; 6
guint eoe_length = tvb_reported_length ( tvb ) - offset ; 11
if ( tree )  13
anItem = proto_tree_add_item ( tree , hf_ecat_mailbox_eoe , tvb , offset , eoe_length , ENC_NA ); 15
if ( eoe_length >= ETHERCAT_EOE_HEADER_LEN )  22
ETHERCAT_EOE_HEADER eoe ; 24
ecat_eoe_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe ); 33
anItem = proto_tree_add_item ( ecat_eoe_tree , hf_ecat_mailbox_eoe_fraghead , tvb , offset , 4 , ENC_NA ); 35
ecat_fraghead_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_fraghead ); 37
switch ( eoe . anEoeHeaderInfoUnion . v . Type )  43
offset += ETHERCAT_EOE_HEADER_LEN; 94
anItem = proto_tree_add_item ( ecat_fraghead_tree , hf_ecat_mailbox_eoe_init , tvb , offset , MIN ( eoe_length - offset , ETHERCAT_EOE_INIT_LEN ) , ENC_NA ); 95
ecat_eoe_init_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_init ); 98
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_contains_macaddr , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 100
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_contains_ipaddr , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 101
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_contains_subnetmask , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 102
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_contains_defaultgateway , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 103
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_contains_dnsserver , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 104
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_contains_dnsname , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 105
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_append_timestamp , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 106
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_macaddr , tvb , offset , ETHERNET_ADDRESS_LEN , ENC_NA ); 109
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_ipaddr , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 112
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_subnetmask , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 115
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_defaultgateway , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 118
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_dnsserver , tvb , offset , 4 , ENC_LITTLE_ENDIAN ); 121
proto_tree_add_item ( ecat_eoe_init_tree , hf_ecat_mailbox_eoe_init_dnsname , tvb , offset , 32 , ENC_ASCII | ENC_NA ); 124
proto_item_append_text ( anItem , " - Invalid length!" ); 127
ecat_eoe_macfilter_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_macfilter ); 139
proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_macfiltercount , tvb , offset , 2 , ENC_LITTLE_ENDIAN ); 147
proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_maskcount , tvb , offset , 2 , ENC_LITTLE_ENDIAN ); 148
proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_nobroadcasts , tvb , offset , 2 , ENC_LITTLE_ENDIAN ); 149
anItem = proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_filter , tvb , offset , 16 * ETHERNET_ADDRESS_LEN , ENC_NA ); 153
ecat_eoe_macfilter_filter_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_macfilter_filter ); 154
proto_tree_add_item ( ecat_eoe_macfilter_filter_tree , hf_ecat_mailbox_eoe_macfilter_filters [ nCnt ] , tvb , offset + nCnt * ETHERNET_ADDRESS_LEN , ETHERNET_ADDRESS_LEN , ENC_NA ); 156
anItem = proto_tree_add_item ( ecat_eoe_macfilter_tree , hf_ecat_mailbox_eoe_macfilter_filtermask , tvb , offset , 4 * sizeof ( guint32 ) , ENC_NA ); 159
ecat_eoe_macfilter_filtermask_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe_macfilter_filtermask ); 160
proto_tree_add_item ( ecat_eoe_macfilter_filtermask_tree , hf_ecat_mailbox_eoe_macfilter_filtermasks [ nCnt ] , tvb , offset + nCnt * sizeof ( guint32 ) , sizeof ( guint32 ) , ENC_NA ); 162
proto_item_append_text ( anItem , " - Invalid length!" ); 165
------------------------------
331 /home/SySeVR/data/CVE_2012_4293_PATCHED_dissect_ecat_eoe.c next_tvb = tvb_new_subset ( tvb , offset , eoe_length - offset , eoe_length - offset ) 79
static void CVE_2012_4293_PATCHED_dissect_ecat_eoe(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree) 1
tvbuff_t * next_tvb ; 5
guint eoe_length = tvb_reported_length ( tvb ) - offset ; 11
if ( eoe_length >= ETHERCAT_EOE_HEADER_LEN )  22
ETHERCAT_EOE_HEADER eoe ; 24
switch ( eoe . anEoeHeaderInfoUnion . v . Type )  43
offset += ETHERCAT_EOE_HEADER_LEN; 74
if ( eoe . anEoeHeaderDataUnion . v . Fragment == 0 )  77
next_tvb = tvb_new_subset ( tvb , offset , eoe_length - offset , eoe_length - offset ); 79
call_dissector ( eth_handle , next_tvb , pinfo , ecat_eoe_tree ); 80
------------------------------
332 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c e_hdr_len = STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN 138
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
guint16 e_hdr_len ; 22
e_hdr_len = STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN; 138
wth -> phdr . len = ( actual_octets - 4 ) + e_hdr_len; 139
wth -> phdr . caplen = ( msdu_length - 4 ) + e_hdr_len; 140
wth -> phdr . presence_flags = WTAP_HAS_TS; 142
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
------------------------------
333 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c delta_b = sig_ts - s_time 125
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
guint8 flow_seq ; 8
guint16 l4id , info , validityBits ; 14
guint32 flow_id , d_time ; 17
int f_flow ; 18
guint32 frame_type ; 19
int mac_len , sig_off , pay_off ; 23
guint64 sig_ts , tsid ; 24
guint64 delta_b ; 25
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ]; 41
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] ); 42
if ( vwr -> FPGA_VERSION == vVW510024_E_FPGA )  44
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] ); 45
f_flow = validityBits & vwr -> FLOW_VALID; 46
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14; 48
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID; 54
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14; 55
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] ); 64
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
if ( frame_type & vwr -> IS_TCP )  91
pay_off = mac_len + 40; 93
if ( frame_type & vwr -> IS_UDP )  95
pay_off = mac_len + 28; 97
if ( frame_type & vwr -> IS_ICMP )  99
pay_off = mac_len + 24; 101
if ( frame_type & vwr -> IS_IGMP )  103
pay_off = mac_len + 28; 105
pay_off = mac_len + 20; 109
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq ); 112
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )  113
sig_ts = get_signature_ts ( m_ptr , sig_off ); 114
sig_ts = 0; 116
if ( ! IS_TX )  119
if ( sig_ts < s_time )  120
delta_b = sig_ts - s_time; 125
if ( delta_b > 0x10000000 )  126
latency = ( guint32 ) delta_b; 129
common_hdr . vw_latency = ( guint32 ) latency; 163
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
334 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c latency = ( guint32 ) ( s_time - sig_ts ) 121
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
guint16 msdu_length , actual_octets ; 7
guint8 flow_seq ; 8
guint16 l4id , info , validityBits ; 14
guint32 flow_id , d_time ; 17
int f_flow ; 18
guint32 frame_type ; 19
int mac_len , sig_off , pay_off ; 23
guint64 sig_ts , tsid ; 24
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ]; 41
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] ); 42
if ( vwr -> FPGA_VERSION == vVW510024_E_FPGA )  44
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] ); 45
f_flow = validityBits & vwr -> FLOW_VALID; 46
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14; 48
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID; 54
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14; 55
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] ); 64
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
if ( frame_type & vwr -> IS_TCP )  91
pay_off = mac_len + 40; 93
if ( frame_type & vwr -> IS_UDP )  95
pay_off = mac_len + 28; 97
if ( frame_type & vwr -> IS_ICMP )  99
pay_off = mac_len + 24; 101
if ( frame_type & vwr -> IS_IGMP )  103
pay_off = mac_len + 28; 105
pay_off = mac_len + 20; 109
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq ); 112
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )  113
sig_ts = get_signature_ts ( m_ptr , sig_off ); 114
sig_ts = 0; 116
if ( ! IS_TX )  119
if ( sig_ts < s_time )  120
latency = ( guint32 ) ( s_time - sig_ts ); 121
common_hdr . vw_latency = ( guint32 ) latency; 163
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
335 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c end_time = e_time / NS_IN_US 89
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint64 end_time ; 13
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] ); 78
end_time = e_time / NS_IN_US; 89
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
336 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c s_usec = start_time - ( s_sec * US_IN_SEC ) 86
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
------------------------------
337 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c s_sec = ( start_time / US_IN_SEC ) 85
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
------------------------------
338 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c start_time = s_time / NS_IN_US 84
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
339 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c d_time = ( guint32 ) ( ( e_time - s_time ) ) 81
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint32 flow_id , d_time ; 17
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] ); 78
d_time = ( guint32 ) ( ( e_time - s_time ) ); 81
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
340 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ] 70
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint64 sig_ts , tsid ; 24
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
tsid = ( s_ptr [ vwr -> LATVAL_OFF + 6 ] << 8 ) | ( s_ptr [ vwr -> LATVAL_OFF + 7 ] ); 68
for (i = 0; i < 4; i++) 69
tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ]; 70
------------------------------
341 /home/SySeVR/data/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ) 30
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
vc_id = pntohs ( & s_ptr [ vwr -> VCID_OFF ] ) & vwr -> VCID_MASK; 40
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ]; 41
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] ); 42
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] ); 45
f_flow = validityBits & vwr -> FLOW_VALID; 46
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14; 48
errors = pntohs ( & s_ptr [ vwr -> ERRORS_OFF ] ); 51
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID; 54
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14; 55
errors = pntohs ( & s_ptr [ vwr -> ERRORS_OFF ] ); 59
info = pntohs ( & s_ptr [ vwr -> INFO_OFF ] ); 62
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] ); 64
tsid = ( s_ptr [ vwr -> LATVAL_OFF + 6 ] << 8 ) | ( s_ptr [ vwr -> LATVAL_OFF + 7 ] ); 68
tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ]; 70
l4id = pntohs ( & s_ptr [ vwr -> L4ID_OFF ] ); 73
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] ); 78
d_time = ( guint32 ) ( ( e_time - s_time ) ); 81
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
end_time = e_time / NS_IN_US; 89
if ( frame_type & vwr -> IS_TCP )  91
pay_off = mac_len + 40; 93
if ( frame_type & vwr -> IS_UDP )  95
pay_off = mac_len + 28; 97
if ( frame_type & vwr -> IS_ICMP )  99
pay_off = mac_len + 24; 101
if ( frame_type & vwr -> IS_IGMP )  103
pay_off = mac_len + 28; 105
pay_off = mac_len + 20; 109
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq ); 112
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )  113
sig_ts = get_signature_ts ( m_ptr , sig_off ); 114
if ( sig_ts < s_time )  120
latency = ( guint32 ) ( s_time - sig_ts ); 121
delta_b = sig_ts - s_time; 125
if ( delta_b > 0x10000000 )  126
latency = ( guint32 ) delta_b; 129
wth -> phdr . len = ( actual_octets - 4 ) + e_hdr_len; 139
wth -> phdr . caplen = ( msdu_length - 4 ) + e_hdr_len; 140
wth -> phdr . presence_flags = WTAP_HAS_TS; 142
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
etap_hdr . vw_errors = ( guint32 ) errors; 153
etap_hdr . vw_info = ( guint16 ) info; 154
common_hdr . vw_msdu_length = ( guint16 ) msdu_length; 155
common_hdr . vw_flowid = ( guint32 ) flow_id; 158
common_hdr . vw_vcid = ( guint16 ) vc_id; 159
common_hdr . vw_seqnum = ( guint16 ) flow_seq; 160
if ( ! IS_TX && ( sig_ts != 0 ) )  162
common_hdr . vw_latency = ( guint32 ) latency; 163
common_hdr . vw_latency = 0; 165
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
etap_hdr . vw_l4id = ( guint32 ) l4id; 167
etap_hdr . vw_flags = 0; 168
etap_hdr . vw_flags |= RADIOTAP_VWF_TXF; 170
if ( errors & vwr -> FCS_ERROR )  171
etap_hdr . vw_flags |= RADIOTAP_VWF_FCSERR; 172
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
etap_hdr . it_pad2 = 0; 177
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
phtoles ( & data_ptr [ bytes_written ] , etap_hdr . it_len ); 210
phtoles ( & data_ptr [ bytes_written ] , etap_hdr . vw_flags ); 212
phtoles ( & data_ptr [ bytes_written ] , etap_hdr . vw_info ); 214
phtolel ( & data_ptr [ bytes_written ] , etap_hdr . vw_errors ); 219
phtolel ( & data_ptr [ bytes_written ] , etap_hdr . vw_l4id ); 221
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
342 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c e_hdr_len = STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN 138
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
guint16 e_hdr_len ; 22
e_hdr_len = STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN; 138
wth -> phdr . len = ( actual_octets - 4 ) + e_hdr_len; 139
wth -> phdr . caplen = ( msdu_length - 4 ) + e_hdr_len; 140
wth -> phdr . presence_flags = WTAP_HAS_TS; 142
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
------------------------------
343 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c delta_b = sig_ts - s_time 125
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
guint8 flow_seq ; 8
guint16 l4id , info , validityBits ; 14
guint32 flow_id , d_time ; 17
int f_flow ; 18
guint32 frame_type ; 19
int mac_len , sig_off , pay_off ; 23
guint64 sig_ts , tsid ; 24
guint64 delta_b ; 25
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ]; 41
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] ); 42
if ( vwr -> FPGA_VERSION == vVW510024_E_FPGA )  44
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] ); 45
f_flow = validityBits & vwr -> FLOW_VALID; 46
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14; 48
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID; 54
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14; 55
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] ); 64
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
if ( frame_type & vwr -> IS_TCP )  91
pay_off = mac_len + 40; 93
if ( frame_type & vwr -> IS_UDP )  95
pay_off = mac_len + 28; 97
if ( frame_type & vwr -> IS_ICMP )  99
pay_off = mac_len + 24; 101
if ( frame_type & vwr -> IS_IGMP )  103
pay_off = mac_len + 28; 105
pay_off = mac_len + 20; 109
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq ); 112
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )  113
sig_ts = get_signature_ts ( m_ptr , sig_off ); 114
sig_ts = 0; 116
if ( ! IS_TX )  119
if ( sig_ts < s_time )  120
delta_b = sig_ts - s_time; 125
if ( delta_b > 0x10000000 )  126
latency = ( guint32 ) delta_b; 129
common_hdr . vw_latency = ( guint32 ) latency; 163
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
344 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c latency = ( guint32 ) ( s_time - sig_ts ) 121
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
register int i ;
register guint8 * s_ptr , * m_ptr ; 6
gint16 msdu_length , actual_octets ; 7
guint8 flow_seq ; 8
guint16 l4id , info , validityBits ; 14
guint32 flow_id , d_time ; 17
int f_flow ; 18
guint32 frame_type ; 19
int mac_len , sig_off , pay_off ; 23
guint64 sig_ts , tsid ; 24
m_ptr = & ( rec [ 0 ] ); 29
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN ); 37
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ]; 41
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] ); 42
if ( vwr -> FPGA_VERSION == vVW510024_E_FPGA )  44
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] ); 45
f_flow = validityBits & vwr -> FLOW_VALID; 46
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14; 48
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID; 54
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14; 55
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] ); 64
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
if ( frame_type & vwr -> IS_TCP )  91
pay_off = mac_len + 40; 93
if ( frame_type & vwr -> IS_UDP )  95
pay_off = mac_len + 28; 97
if ( frame_type & vwr -> IS_ICMP )  99
pay_off = mac_len + 24; 101
if ( frame_type & vwr -> IS_IGMP )  103
pay_off = mac_len + 28; 105
pay_off = mac_len + 20; 109
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq ); 112
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )  113
sig_ts = get_signature_ts ( m_ptr , sig_off ); 114
sig_ts = 0; 116
if ( ! IS_TX )  119
if ( sig_ts < s_time )  120
latency = ( guint32 ) ( s_time - sig_ts ); 121
common_hdr . vw_latency = ( guint32 ) latency; 163
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
345 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c end_time = e_time / NS_IN_US 89
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint64 end_time ; 13
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] ); 78
end_time = e_time / NS_IN_US; 89
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
346 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c s_usec = start_time - ( s_sec * US_IN_SEC ) 86
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
------------------------------
347 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c s_sec = ( start_time / US_IN_SEC ) 85
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
------------------------------
348 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c start_time = s_time / NS_IN_US 84
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
349 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c d_time = ( guint32 ) ( ( e_time - s_time ) ) 81
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint32 flow_id , d_time ; 17
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] ); 78
d_time = ( guint32 ) ( ( e_time - s_time ) ); 81
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
------------------------------
350 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ] 70
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint64 sig_ts , tsid ; 24
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
tsid = ( s_ptr [ vwr -> LATVAL_OFF + 6 ] << 8 ) | ( s_ptr [ vwr -> LATVAL_OFF + 7 ] ); 68
for (i = 0; i < 4; i++) 69
tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ]; 70
------------------------------
351 /home/SySeVR/data/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ) 30
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] ); 30
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] ); 32
actual_octets = msdu_length; 33
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )  36
vc_id = pntohs ( & s_ptr [ vwr -> VCID_OFF ] ) & vwr -> VCID_MASK; 40
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ]; 41
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] ); 42
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] ); 45
f_flow = validityBits & vwr -> FLOW_VALID; 46
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14; 48
errors = pntohs ( & s_ptr [ vwr -> ERRORS_OFF ] ); 51
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID; 54
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14; 55
errors = pntohs ( & s_ptr [ vwr -> ERRORS_OFF ] ); 59
info = pntohs ( & s_ptr [ vwr -> INFO_OFF ] ); 62
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] ); 64
tsid = ( s_ptr [ vwr -> LATVAL_OFF + 6 ] << 8 ) | ( s_ptr [ vwr -> LATVAL_OFF + 7 ] ); 68
tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ]; 70
l4id = pntohs ( & s_ptr [ vwr -> L4ID_OFF ] ); 73
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] ); 77
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] ); 78
d_time = ( guint32 ) ( ( e_time - s_time ) ); 81
start_time = s_time / NS_IN_US; 84
s_sec = ( start_time / US_IN_SEC ); 85
s_usec = start_time - ( s_sec * US_IN_SEC ); 86
end_time = e_time / NS_IN_US; 89
if ( frame_type & vwr -> IS_TCP )  91
pay_off = mac_len + 40; 93
if ( frame_type & vwr -> IS_UDP )  95
pay_off = mac_len + 28; 97
if ( frame_type & vwr -> IS_ICMP )  99
pay_off = mac_len + 24; 101
if ( frame_type & vwr -> IS_IGMP )  103
pay_off = mac_len + 28; 105
pay_off = mac_len + 20; 109
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq ); 112
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )  113
sig_ts = get_signature_ts ( m_ptr , sig_off ); 114
if ( sig_ts < s_time )  120
latency = ( guint32 ) ( s_time - sig_ts ); 121
delta_b = sig_ts - s_time; 125
if ( delta_b > 0x10000000 )  126
latency = ( guint32 ) delta_b; 129
wth -> phdr . len = ( actual_octets - 4 ) + e_hdr_len; 139
wth -> phdr . caplen = ( msdu_length - 4 ) + e_hdr_len; 140
wth -> phdr . presence_flags = WTAP_HAS_TS; 142
wth -> phdr . ts . secs = ( time_t ) s_sec; 144
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 ); 145
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE; 146
etap_hdr . vw_errors = ( guint32 ) errors; 153
etap_hdr . vw_info = ( guint16 ) info; 154
common_hdr . vw_msdu_length = ( guint16 ) msdu_length; 155
common_hdr . vw_flowid = ( guint32 ) flow_id; 158
common_hdr . vw_vcid = ( guint16 ) vc_id; 159
common_hdr . vw_seqnum = ( guint16 ) flow_seq; 160
if ( ! IS_TX && ( sig_ts != 0 ) )  162
common_hdr . vw_latency = ( guint32 ) latency; 163
common_hdr . vw_latency = 0; 165
common_hdr . vw_pktdur = ( guint32 ) d_time; 166
etap_hdr . vw_l4id = ( guint32 ) l4id; 167
etap_hdr . vw_flags = 0; 168
etap_hdr . vw_flags |= RADIOTAP_VWF_TXF; 170
if ( errors & vwr -> FCS_ERROR )  171
etap_hdr . vw_flags |= RADIOTAP_VWF_FCSERR; 172
common_hdr . vw_startt = start_time; 173
common_hdr . vw_endt = end_time; 174
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts ); 175
etap_hdr . it_pad2 = 0; 177
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type ); 180
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len ); 182
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length ); 184
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid ); 189
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid ); 191
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum ); 193
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency ); 195
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts ); 197
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt ); 199
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt ); 201
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur ); 203
phtoles ( & data_ptr [ bytes_written ] , etap_hdr . it_len ); 210
phtoles ( & data_ptr [ bytes_written ] , etap_hdr . vw_flags ); 212
phtoles ( & data_ptr [ bytes_written ] , etap_hdr . vw_info ); 214
phtolel ( & data_ptr [ bytes_written ] , etap_hdr . vw_errors ); 219
phtolel ( & data_ptr [ bytes_written ] , etap_hdr . vw_l4id ); 221
if ( rec_size < ( ( int ) actual_octets + ( int ) vwr -> STATS_LEN ) )  228
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 230
if ( msdu_length >= 4 )  231
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length - 4 ); 232
memcpy ( & data_ptr [ bytes_written ] , m_ptr , msdu_length ); 234
------------------------------
352 /home/SySeVR/data/CVE_2012_4530_PATCHED_load_script.c cp = bprm -> buf + BINPRM_BUF_SIZE - 1 23
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
353 /home/SySeVR/data/CVE_2012_4530_VULN_load_script.c cp = bprm -> buf + BINPRM_BUF_SIZE - 1 23
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char * cp , * i_name , * i_arg ; 3
if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) || ( bprm -> recursion_depth > BINPRM_MAX_RECURSION ) )  8
bprm -> recursion_depth ++; 16
bprm -> file = NULL; 19
bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\0'; 21
if ( ( cp = strchr ( bprm -> buf , '\n' ) ) == NULL )  22
cp = bprm -> buf + BINPRM_BUF_SIZE - 1; 23
* cp = '\0'; 24
while ( cp > bprm -> buf )  25
cp --; 26
if ( ( * cp == ' ' ) || ( * cp == '\t' ) )  27
* cp = '\0'; 28
for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++); 32
if ( * cp == '\0' )  33
i_name = cp; 35
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) 37
while ( ( * cp == ' ' ) || ( * cp == '\t' ) )  39
* cp ++ = '\0'; 40
if ( * cp )  41
i_arg = cp; 42
strcpy ( interp , i_name ); 43
if ( i_arg )  60
retval = copy_strings_kernel ( 1 , & i_arg , bprm ); 61
if ( retval < 0 )  62
return retval ; 62
retval = copy_strings_kernel ( 1 , & i_name , bprm ); 65
if ( retval )  66
return retval ; 66
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
354 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c offset = offset2 + len + 2 274
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
guint8 type , len ; 115
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_group_state_tlv , tvb , offset , 2 , type , "Group State TLV: Type=%d Len=%d" , type , len ); 136
offset += 2; 139
opcode = tvb_get_guint8 ( tvb , offset + 1 ); 141
col_add_fstr ( pinfo -> cinfo , COL_INFO , "%s" , val_to_str ( opcode , hsrp2_opcode_vals , "Unknown" ) ); 143
state = tvb_get_guint8 ( tvb , offset + 2 ); 147
col_append_fstr ( pinfo -> cinfo , COL_INFO , " (state %s)" , val_to_str ( state , hsrp2_state_vals , "Unknown" ) ); 149
if ( tree )  153
group_state_tlv = proto_item_add_subtree ( ti , ett_hsrp2_group_state_tlv ); 155
proto_tree_add_item ( group_state_tlv , hf_hsrp2_version , tvb , offset , 1 , ENC_BIG_ENDIAN ); 156
offset ++; 157
proto_tree_add_uint ( group_state_tlv , hf_hsrp2_opcode , tvb , offset , 1 , opcode ); 158
offset ++; 159
proto_tree_add_uint ( group_state_tlv , hf_hsrp2_state , tvb , offset , 1 , state ); 160
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
proto_tree_add_uint ( group_state_tlv , hf_hsrp2_ipversion , tvb , offset , 1 , ipver ); 163
offset ++; 164
proto_tree_add_item ( group_state_tlv , hf_hsrp2_group , tvb , offset , 2 , ENC_BIG_ENDIAN ); 165
offset += 2; 166
proto_tree_add_item ( group_state_tlv , hf_hsrp2_identifier , tvb , offset , 6 , ENC_NA ); 167
offset += 6; 168
proto_tree_add_item ( group_state_tlv , hf_hsrp2_priority , tvb , offset , 4 , ENC_BIG_ENDIAN ); 169
offset += 4; 170
hellotime = tvb_get_ntohl ( tvb , offset ); 172
proto_tree_add_uint_format ( group_state_tlv , hf_hsrp2_hellotime , tvb , offset , 4 , hellotime , "Hellotime: %sDefault (%u)" , ( hellotime == HSRP2_DEFAULT_HELLOTIME ) ? "" : "Non-" , hellotime ); 173
offset += 4; 177
holdtime = tvb_get_ntohl ( tvb , offset ); 178
proto_tree_add_uint_format ( group_state_tlv , hf_hsrp2_holdtime , tvb , offset , 4 , holdtime , "Holdtime: %sDefault (%u)" , ( holdtime == HSRP2_DEFAULT_HOLDTIME ) ? "" : "Non-" , holdtime ); 179
offset += 4; 183
if ( ipver == 4 )  184
proto_tree_add_item ( group_state_tlv , hf_hsrp2_virt_ip_addr , tvb , offset , 4 , ENC_BIG_ENDIAN ); 186
if ( ipver == 6 )  187
proto_tree_add_item ( group_state_tlv , hf_hsrp2_virt_ip_addr_v6 , tvb , offset , 16 , ENC_NA ); 189
next_tvb = tvb_new_subset_remaining ( tvb , offset ); 192
call_dissector ( data_handle , next_tvb , pinfo , hsrp_tree ); 193
if ( type == 2 && len == 4 )  198
active = tvb_get_ntohs ( tvb , offset + 2 ); 201
passive = tvb_get_ntohs ( tvb , offset + 4 ); 202
col_add_fstr ( pinfo -> cinfo , COL_INFO , "Interface State TLV (Act=%d Pass=%d)" , active , passive ); 205
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_interface_state_tlv , tvb , offset , 1 , type , "Interface State TLV: Type=%d Len=%d" , type , len ); 210
offset += 2; 212
interface_state_tlv = proto_item_add_subtree ( ti , ett_hsrp2_interface_state_tlv ); 215
proto_tree_add_item ( interface_state_tlv , hf_hsrp2_active_group , tvb , offset , 2 , ENC_BIG_ENDIAN ); 216
offset += 2; 217
proto_tree_add_item ( interface_state_tlv , hf_hsrp2_passive_group , tvb , offset , 2 , ENC_BIG_ENDIAN ); 218
if ( type == 3 && len == 8 )  221
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "Text Authentication TLV: Type=%d Len=%d" , type , len ); 227
offset += 2; 229
text_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_text_auth_tlv ); 232
tvb_memcpy ( tvb , auth_buf , offset , 8 ); 234
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
ti = proto_tree_add_uint_format ( hsrp_tree , hf_hsrp2_text_auth_tlv , tvb , offset , 1 , type , "MD5 Authentication TLV: Type=%d Len=%d" , type , len ); 247
offset += 2; 249
md5_auth_tlv = proto_item_add_subtree ( ti , ett_hsrp2_md5_auth_tlv ); 252
proto_tree_add_item ( md5_auth_tlv , hf_hsrp2_md5_algorithm , tvb , offset , 1 , ENC_BIG_ENDIAN ); 253
offset ++; 254
offset ++; 256
proto_tree_add_item ( md5_auth_tlv , hf_hsrp2_md5_flags , tvb , offset , 2 , ENC_BIG_ENDIAN ); 257
offset += 2; 258
proto_tree_add_item ( md5_auth_tlv , hf_hsrp2_md5_ip_address , tvb , offset , 4 , ENC_BIG_ENDIAN ); 259
offset += 4; 260
proto_tree_add_item ( md5_auth_tlv , hf_hsrp2_md5_key_id , tvb , offset , 4 , ENC_BIG_ENDIAN ); 261
offset += 4; 262
proto_tree_add_item ( md5_auth_tlv , hf_hsrp2_md5_auth_data , tvb , offset , 16 , ENC_BIG_ENDIAN ); 263
next_tvb = tvb_new_subset_remaining ( tvb , offset ); 269
call_dissector ( data_handle , next_tvb , pinfo , hsrp_tree ); 270
offset = offset2 + len + 2; 274
------------------------------
355 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c bitmap_size = glyph -> bpr * glyph -> bbx . height 456
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )  328
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )  344
if ( ft_memcmp ( line , "BBX" , 3 ) == 0 )  372
if ( ft_memcmp ( line , "BITMAP" , 6 ) == 0 )  440
unsigned long bitmap_size ; 442
if ( ! ( p -> flags & _BDF_BBX ) )  445
glyph -> bpr = ( glyph -> bbx . width * p -> font -> bpp + 7 ) >> 3; 454
bitmap_size = glyph -> bpr * glyph -> bbx . height; 456
if ( glyph -> bpr > 0xFFFFU || bitmap_size > 0xFFFFU )  457
glyph -> bytes = ( unsigned short ) bitmap_size; 464
if ( FT_NEW_ARRAY ( glyph -> bitmap , glyph -> bytes ) )  466
------------------------------
356 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c glyph -> bpr = ( glyph -> bbx . width * p -> font -> bpp + 7 ) >> 3 454
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )  328
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )  344
if ( ft_memcmp ( line , "BBX" , 3 ) == 0 )  372
if ( ft_memcmp ( line , "BITMAP" , 6 ) == 0 )  440
if ( ! ( p -> flags & _BDF_BBX ) )  445
glyph -> bpr = ( glyph -> bbx . width * p -> font -> bpp + 7 ) >> 3; 454
bitmap_size = glyph -> bpr * glyph -> bbx . height; 456
if ( glyph -> bpr > 0xFFFFU || bitmap_size > 0xFFFFU )  457
glyph -> bytes = ( unsigned short ) bitmap_size; 464
if ( FT_NEW_ARRAY ( glyph -> bitmap , glyph -> bytes ) )  466
------------------------------
357 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c p -> rbearing = ( short ) ( glyph -> bbx . width + glyph -> bbx . x_offset ) 395
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )  328
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )  344
if ( ft_memcmp ( line , "BBX" , 3 ) == 0 )  372
if ( ! ( p -> flags & _BDF_ENCODING ) )  374
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen ); 377
if ( error )  378
glyph -> bbx . width = _bdf_atos ( p -> list . field [ 1 ] , 0 , 10 ); 381
glyph -> bbx . height = _bdf_atos ( p -> list . field [ 2 ] , 0 , 10 ); 382
glyph -> bbx . x_offset = _bdf_atos ( p -> list . field [ 3 ] , 0 , 10 ); 383
glyph -> bbx . y_offset = _bdf_atos ( p -> list . field [ 4 ] , 0 , 10 ); 384
glyph -> bbx . ascent = ( short ) ( glyph -> bbx . height + glyph -> bbx . y_offset ); 387
glyph -> bbx . descent = ( short ) ( - glyph -> bbx . y_offset ); 388
p -> maxas = ( short ) FT_MAX ( glyph -> bbx . ascent , p -> maxas ); 392
p -> maxds = ( short ) FT_MAX ( glyph -> bbx . descent , p -> maxds ); 393
p -> rbearing = ( short ) ( glyph -> bbx . width + glyph -> bbx . x_offset ); 395
p -> maxrb = ( short ) FT_MAX ( p -> rbearing , p -> maxrb ); 397
p -> minlb = ( short ) FT_MIN ( glyph -> bbx . x_offset , p -> minlb ); 398
p -> maxlb = ( short ) FT_MAX ( glyph -> bbx . x_offset , p -> maxlb ); 399
if ( ! ( p -> flags & _BDF_DWIDTH ) )  401
if ( p -> opts -> correct_metrics != 0 )  411
if ( p -> glyph_enc == - 1 )  424
p -> flags |= _BDF_SWIDTH_ADJ; 430
p -> flags |= _BDF_BBX; 435
if ( error && ( p -> flags & _BDF_GLYPH ) )  485
FT_FREE ( p -> glyph_name ); 486
------------------------------
358 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c glyph -> bbx . ascent = ( short ) ( glyph -> bbx . height + glyph -> bbx . y_offset ) 387
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )  328
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )  344
if ( ft_memcmp ( line , "BBX" , 3 ) == 0 )  372
if ( ! ( p -> flags & _BDF_ENCODING ) )  374
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen ); 377
if ( error )  378
glyph -> bbx . width = _bdf_atos ( p -> list . field [ 1 ] , 0 , 10 ); 381
glyph -> bbx . height = _bdf_atos ( p -> list . field [ 2 ] , 0 , 10 ); 382
glyph -> bbx . x_offset = _bdf_atos ( p -> list . field [ 3 ] , 0 , 10 ); 383
glyph -> bbx . y_offset = _bdf_atos ( p -> list . field [ 4 ] , 0 , 10 ); 384
glyph -> bbx . ascent = ( short ) ( glyph -> bbx . height + glyph -> bbx . y_offset ); 387
glyph -> bbx . descent = ( short ) ( - glyph -> bbx . y_offset ); 388
p -> maxas = ( short ) FT_MAX ( glyph -> bbx . ascent , p -> maxas ); 392
p -> maxds = ( short ) FT_MAX ( glyph -> bbx . descent , p -> maxds ); 393
p -> rbearing = ( short ) ( glyph -> bbx . width + glyph -> bbx . x_offset ); 395
p -> maxrb = ( short ) FT_MAX ( p -> rbearing , p -> maxrb ); 397
p -> minlb = ( short ) FT_MIN ( glyph -> bbx . x_offset , p -> minlb ); 398
p -> maxlb = ( short ) FT_MAX ( glyph -> bbx . x_offset , p -> maxlb ); 399
if ( ! ( p -> flags & _BDF_DWIDTH ) )  401
glyph -> dwidth = glyph -> bbx . width; 406
if ( p -> opts -> correct_metrics != 0 )  411
unsigned short sw = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) ) ; 414
if ( sw != glyph -> swidth )  420
glyph -> swidth = sw; 422
if ( p -> glyph_enc == - 1 )  424
_bdf_set_glyph_modified ( font -> nmod , glyph -> encoding ); 428
p -> flags |= _BDF_SWIDTH_ADJ; 430
p -> flags |= _BDF_BBX; 435
if ( error && ( p -> flags & _BDF_GLYPH ) )  485
FT_FREE ( p -> glyph_name ); 486
------------------------------
359 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c glyph -> swidth = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) ) 361
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )  328
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )  344
if ( ! ( p -> flags & _BDF_ENCODING ) )  346
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen ); 349
if ( error )  350
glyph -> dwidth = ( unsigned short ) _bdf_atoul ( p -> list . field [ 1 ] , 0 , 10 ); 353
if ( ! ( p -> flags & _BDF_SWIDTH ) )  355
glyph -> swidth = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) ); 361
------------------------------
360 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c mask_index = ( glyph -> bbx . width * p -> font -> bpp ) & 7 309
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
int c , mask_index ; 8
unsigned long i , slen , nibbles ; 11
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( p -> row >= ( unsigned long ) glyph -> bbx . height )  271
nibbles = glyph -> bpr << 1; 285
for ( i = 0; i < nibbles; i++ ) 288
c = line [ i ]; 290
if ( ! isdigok ( hdigits , c ) )  291
if ( i < nibbles && ! ( p -> flags & _BDF_GLYPH_WIDTH_CHECK ) )  300
p -> flags |= _BDF_GLYPH_WIDTH_CHECK; 304
mask_index = ( glyph -> bbx . width * p -> font -> bpp ) & 7; 309
* bp &= nibble_mask [ mask_index ]; 311
------------------------------
361 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c bp = glyph -> bitmap + p -> row * glyph -> bpr 286
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
unsigned char * bp ; 10
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( p -> row >= ( unsigned long ) glyph -> bbx . height )  271
bp = glyph -> bitmap + p -> row * glyph -> bpr; 286
* bp = ( FT_Byte ) ( ( * bp << 4 ) + a2i [ c ] ); 293
* ++ bp = 0; 295
* bp &= nibble_mask [ mask_index ]; 311
------------------------------
362 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c glyph = font -> unencoded + font -> unencoded_used 239
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( ! ( p -> flags & _BDF_GLYPH ) )  147
error = BDF_Err_Missing_Startchar_Field; 151
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen ); 155
if ( error )  156
p -> glyph_enc = _bdf_atol ( p -> list . field [ 1 ] , 0 , 10 ); 159
if ( p -> glyph_enc < - 1 )  163
p -> glyph_enc = - 1; 164
if ( p -> glyph_enc == - 1 && p -> list . used > 2 )  167
p -> glyph_enc = _bdf_atol ( p -> list . field [ 2 ] , 0 , 10 ); 168
if ( p -> glyph_enc > 0 && ( size_t ) p -> glyph_enc >= sizeof ( p -> have ) / sizeof ( unsigned long ) * 32 )  174
if ( p -> glyph_enc >= 0 )  186
if ( _bdf_glyph_modified ( p -> have , p -> glyph_enc ) )  188
p -> glyph_enc = - 1; 194
font -> modified = 1; 195
if ( p -> glyph_enc >= 0 )  201
if ( p -> opts -> keep_unencoded != 0 )  226
if ( font -> unencoded_used == font -> unencoded_size )  229
if ( FT_RENEW_ARRAY ( font -> unencoded , font -> unencoded_size , font -> unencoded_size + 4 ) )  231
font -> unencoded_size += 4; 236
glyph = font -> unencoded + font -> unencoded_used; 239
glyph -> name = p -> glyph_name; 240
glyph -> encoding = font -> unencoded_used ++; 241
------------------------------
363 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c glyph = font -> glyphs + font -> glyphs_used ++ 215
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( ! ( p -> flags & _BDF_GLYPH ) )  147
error = BDF_Err_Missing_Startchar_Field; 151
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen ); 155
if ( error )  156
p -> glyph_enc = _bdf_atol ( p -> list . field [ 1 ] , 0 , 10 ); 159
if ( p -> glyph_enc < - 1 )  163
p -> glyph_enc = - 1; 164
if ( p -> glyph_enc == - 1 && p -> list . used > 2 )  167
p -> glyph_enc = _bdf_atol ( p -> list . field [ 2 ] , 0 , 10 ); 168
if ( p -> glyph_enc > 0 && ( size_t ) p -> glyph_enc >= sizeof ( p -> have ) / sizeof ( unsigned long ) * 32 )  174
if ( p -> glyph_enc >= 0 )  186
if ( _bdf_glyph_modified ( p -> have , p -> glyph_enc ) )  188
p -> glyph_enc = - 1; 194
font -> modified = 1; 195
if ( p -> glyph_enc >= 0 )  201
if ( font -> glyphs_used == font -> glyphs_size )  205
if ( FT_RENEW_ARRAY ( font -> glyphs , font -> glyphs_size , font -> glyphs_size + 64 ) )  207
font -> glyphs_size += 64; 212
glyph = font -> glyphs + font -> glyphs_used ++; 215
glyph -> name = p -> glyph_name; 216
glyph -> encoding = p -> glyph_enc; 217
------------------------------
364 /home/SySeVR/data/CVE_2012_6053_VULN_dissect_usb_interface_descriptor.c offset = old_offset + len 75
static int
CVE_2012_6053_VULN_dissect_usb_interface_descriptor(packet_info *pinfo, proto_tree *parent_tree, tvbuff_t *tvb, int offset, usb_trans_info_t *usb_trans_info, usb_conv_info_t *usb_conv_info) 2
int old_offset = offset ; 6
guint8 len ; 7
len = tvb_get_guint8 ( tvb , offset ); 16
offset = old_offset + len; 75
return offset ; 77
------------------------------
365 /home/SySeVR/data/CVE_2012_6616_PATCHED_mov_text_decode_frame.c end = ptr + FFMIN ( 2 + AV_RB16 ( ptr ) , avpkt -> size ) 28
static int CVE_2012_6616_PATCHED_mov_text_decode_frame(AVCodecContext *avctx,
void *data, int *got_sub_ptr, AVPacket *avpkt) 2
const char * ptr = avpkt -> data ; 7
const char * end ; 8
if ( ! ptr || avpkt -> size < 2 )  10
if ( avpkt -> size == 2 )  20
end = ptr + FFMIN ( 2 + AV_RB16 ( ptr ) , avpkt -> size ); 28
text_to_ass ( & buf , ptr , end ); 40
------------------------------
366 /home/SySeVR/data/CVE_2012_6616_VULN_mov_text_decode_frame.c end = ptr + FFMAX ( 2 + AV_RB16 ( ptr ) , avpkt -> size ) 28
static int CVE_2012_6616_VULN_mov_text_decode_frame(AVCodecContext *avctx,
void *data, int *got_sub_ptr, AVPacket *avpkt) 2
const char * ptr = avpkt -> data ; 7
const char * end ; 8
if ( ! ptr || avpkt -> size < 2 )  10
if ( avpkt -> size == 2 )  20
end = ptr + FFMAX ( 2 + AV_RB16 ( ptr ) , avpkt -> size ); 28
text_to_ass ( & buf , ptr , end ); 40
------------------------------
367 /home/SySeVR/data/CVE_2012_6618_PATCHED_av_probe_input_buffer.c buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ) 32
int CVE_2012_6618_PATCHED_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
av_free ( buf ); 34
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
av_free ( buf ); 41
return ret ; 42
score = 0; 44
ret = 0; 45
pd . buf_size = buf_offset += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
av_free ( buf ); 63
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
av_free ( buf ); 69
return ret ; 71
------------------------------
368 /home/SySeVR/data/CVE_2012_6618_VULN_av_probe_input_buffer.c buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ) 32
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,
const char *filename, void *logctx,
unsigned int offset, unsigned int max_probe_size) 3
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ; 5
unsigned char * buf = NULL ; 6
if ( ! max_probe_size )  9
max_probe_size = PROBE_BUF_MAX; 10
if ( max_probe_size > PROBE_BUF_MAX )  11
max_probe_size = PROBE_BUF_MAX; 12
if ( max_probe_size < PROBE_BUF_MIN )  13
if ( offset >= max_probe_size )  17
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) 22
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ; 24
void * buftmp ; 25
if ( probe_size < offset )  27
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ); 32
if ( ! buftmp )  33
av_free ( buf ); 34
buf = buftmp; 37
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  38
if ( ret != AVERROR_EOF )  40
av_free ( buf ); 41
return ret ; 42
score = 0; 44
ret = 0; 45
pd . buf_size += ret; 47
pd . buf = & buf [ offset ]; 48
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE ); 50
* fmt = av_probe_input_format2 ( & pd , 1 , & score ); 53
if ( * fmt )  54
av_log ( logctx , AV_LOG_WARNING , "Format %s detected only with low score of %d, misdetection possible!\n" , ( * fmt ) -> name , score ); 56
av_log ( logctx , AV_LOG_DEBUG , "Format %s probed with size=%d and score=%d\n" , ( * fmt ) -> name , probe_size , score ); 58
if ( ! * fmt )  62
av_free ( buf ); 63
if ( ( ret = ffio_rewind_with_probe_data ( pb , buf , pd . buf_size ) ) < 0 )  68
av_free ( buf ); 69
return ret ; 71
------------------------------
369 /home/SySeVR/data/CVE_2013_0310_PATCHED_cipso_v4_validate.c * option = opt + err_offset 136
int CVE_2013_0310_PATCHED_cipso_v4_validate(const struct sk_buff *skb, unsigned char **option) 1
unsigned char * opt = * option ; 3
unsigned char * tag ; 4
unsigned char opt_iter ; 5
unsigned char err_offset = 0 ; 6
u8 opt_len ; 7
u8 tag_len ; 8
u32 tag_iter ; 10
opt_len = opt [ 1 ]; 13
if ( opt_len < 8 )  14
err_offset = 1; 15
doi_def = cipso_v4_doi_search ( get_unaligned_be32 ( & opt [ 2 ] ) ); 20
if ( doi_def == NULL )  21
err_offset = 2; 22
opt_iter = CIPSO_V4_HDR_LEN; 26
tag = opt + opt_iter; 27
while ( opt_iter < opt_len )  28
for (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];) 29
if ( doi_def -> tags [ tag_iter ] == CIPSO_V4_TAG_INVALID || ++ tag_iter == CIPSO_V4_TAG_MAXCNT )  30
err_offset = opt_iter; 32
tag_len = tag [ 1 ]; 36
if ( tag_len > ( opt_len - opt_iter ) )  37
err_offset = opt_iter + 1; 38
switch ( tag [ 0 ] )  42
if ( tag_len < CIPSO_V4_TAG_RBM_BLEN )  44
err_offset = opt_iter + 1; 45
if ( cipso_v4_rbm_strictvalid )  56
if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 )  57
err_offset = opt_iter + 3; 59
if ( tag_len > CIPSO_V4_TAG_RBM_BLEN && cipso_v4_map_cat_rbm_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 )  62
err_offset = opt_iter + 4; 66
if ( tag_len < CIPSO_V4_TAG_ENUM_BLEN )  72
err_offset = opt_iter + 1; 73
if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 )  77
err_offset = opt_iter + 3; 79
if ( tag_len > CIPSO_V4_TAG_ENUM_BLEN && cipso_v4_map_cat_enum_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 )  82
err_offset = opt_iter + 4; 86
if ( tag_len < CIPSO_V4_TAG_RNG_BLEN )  91
err_offset = opt_iter + 1; 92
if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 )  96
err_offset = opt_iter + 3; 98
if ( tag_len > CIPSO_V4_TAG_RNG_BLEN && cipso_v4_map_cat_rng_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 )  101
err_offset = opt_iter + 4; 105
if ( skb == NULL || ! ( skb -> dev -> flags & IFF_LOOPBACK ) )  115
err_offset = opt_iter; 116
if ( tag_len != CIPSO_V4_TAG_LOC_BLEN )  119
err_offset = opt_iter + 1; 120
err_offset = opt_iter; 125
tag += tag_len; 129
opt_iter += tag_len; 130
* option = opt + err_offset; 136
------------------------------
370 /home/SySeVR/data/CVE_2013_0310_PATCHED_cipso_v4_validate.c tag = opt + opt_iter 27
int CVE_2013_0310_PATCHED_cipso_v4_validate(const struct sk_buff *skb, unsigned char **option) 1
unsigned char * opt = * option ; 3
unsigned char * tag ; 4
unsigned char opt_iter ; 5
u8 opt_len ; 7
opt_len = opt [ 1 ]; 13
if ( opt_len < 8 )  14
doi_def = cipso_v4_doi_search ( get_unaligned_be32 ( & opt [ 2 ] ) ); 20
if ( doi_def == NULL )  21
opt_iter = CIPSO_V4_HDR_LEN; 26
tag = opt + opt_iter; 27
while ( opt_iter < opt_len )  28
for (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];) 29
err_offset = opt_iter; 32
tag_len = tag [ 1 ]; 36
if ( tag_len > ( opt_len - opt_iter ) )  37
err_offset = opt_iter + 1; 38
switch ( tag [ 0 ] )  42
if ( tag_len < CIPSO_V4_TAG_RBM_BLEN )  44
err_offset = opt_iter + 1; 45
if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 )  57
err_offset = opt_iter + 3; 59
if ( tag_len > CIPSO_V4_TAG_RBM_BLEN && cipso_v4_map_cat_rbm_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 )  62
err_offset = opt_iter + 4; 66
if ( tag_len < CIPSO_V4_TAG_ENUM_BLEN )  72
err_offset = opt_iter + 1; 73
if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 )  77
err_offset = opt_iter + 3; 79
if ( tag_len > CIPSO_V4_TAG_ENUM_BLEN && cipso_v4_map_cat_enum_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 )  82
err_offset = opt_iter + 4; 86
if ( tag_len < CIPSO_V4_TAG_RNG_BLEN )  91
err_offset = opt_iter + 1; 92
if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 )  96
err_offset = opt_iter + 3; 98
if ( tag_len > CIPSO_V4_TAG_RNG_BLEN && cipso_v4_map_cat_rng_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 )  101
err_offset = opt_iter + 4; 105
err_offset = opt_iter; 116
if ( tag_len != CIPSO_V4_TAG_LOC_BLEN )  119
err_offset = opt_iter + 1; 120
err_offset = opt_iter; 125
tag += tag_len; 129
opt_iter += tag_len; 130
* option = opt + err_offset; 136
return err_offset ; 137
------------------------------
371 /home/SySeVR/data/CVE_2013_0311_VULN_translate_desc.c _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) 27
static int CVE_2013_0311_VULN_translate_desc(struct vhost_dev *dev, u64 addr, u32 len,
struct iovec iov[], int iov_size) 2
const struct vhost_memory_region * reg ; 4
struct vhost_memory * mem ; 5
struct iovec * _iov ; 6
u64 s = 0 ; 7
int ret = 0 ; 8
mem = rcu_dereference ( dev -> memory ); 12
while ( ( u64 ) len > s )  13
u64 size ; 14
if ( unlikely ( ret >= iov_size ) )  15
reg = find_region ( mem , addr , len ); 19
if ( unlikely ( ! reg ) )  20
_iov = iov + ret; 24
size = reg -> memory_size - addr + reg -> guest_phys_addr; 25
_iov -> iov_len = min ( ( u64 ) len , size ); 26
_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ); 27
s += size; 29
addr += size; 30
------------------------------
372 /home/SySeVR/data/CVE_2013_0311_VULN_translate_desc.c size = reg -> memory_size - addr + reg -> guest_phys_addr 25
static int CVE_2013_0311_VULN_translate_desc(struct vhost_dev *dev, u64 addr, u32 len,
struct iovec iov[], int iov_size) 2
const struct vhost_memory_region * reg ; 4
struct vhost_memory * mem ; 5
u64 s = 0 ; 7
int ret = 0 ; 8
mem = rcu_dereference ( dev -> memory ); 12
while ( ( u64 ) len > s )  13
u64 size ; 14
if ( unlikely ( ret >= iov_size ) )  15
reg = find_region ( mem , addr , len ); 19
if ( unlikely ( ! reg ) )  20
size = reg -> memory_size - addr + reg -> guest_phys_addr; 25
_iov -> iov_len = min ( ( u64 ) len , size ); 26
_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ); 27
s += size; 29
addr += size; 30
------------------------------
373 /home/SySeVR/data/CVE_2013_0311_VULN_translate_desc.c _iov = iov + ret 24
static int CVE_2013_0311_VULN_translate_desc(struct vhost_dev *dev, u64 addr, u32 len,
struct iovec iov[], int iov_size) 2
const struct vhost_memory_region * reg ; 4
struct vhost_memory * mem ; 5
struct iovec * _iov ; 6
u64 s = 0 ; 7
int ret = 0 ; 8
mem = rcu_dereference ( dev -> memory ); 12
while ( ( u64 ) len > s )  13
u64 size ; 14
if ( unlikely ( ret >= iov_size ) )  15
reg = find_region ( mem , addr , len ); 19
if ( unlikely ( ! reg ) )  20
_iov = iov + ret; 24
size = reg -> memory_size - addr + reg -> guest_phys_addr; 25
_iov -> iov_len = min ( ( u64 ) len , size ); 26
_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ); 27
s += size; 29
addr += size; 30
------------------------------
374 /home/SySeVR/data/CVE_2013_0756_PATCHED_obj_toSource.c vlength = end - vchars - parenChomp 144
static JSBool
CVE_2013_0756_PATCHED_obj_toSource(JSContext *cx, unsigned argc, Value *vp) 2
CallArgs args = CallArgsFromVp ( argc , vp ) ; 4
RootedObject obj ( cx , ToObject ( cx , args . thisv ( ) ) ) ; 7
if ( ! obj )  8
bool outermost = ( cx -> cycleDetectorSet . count ( ) == 0 ) ; 12
AutoCycleDetector detector ( cx , obj ) ; 14
if ( ! detector . init ( ) )  15
if ( detector . foundCycle ( ) )  17
StringBuffer buf ( cx ) ; 25
if ( outermost && ! buf . append ( '(' ) )  26
if ( ! buf . append ( '{' ) )  28
Value val [ 2 ] ; 31
JSString * gsop [ 2 ] ; 35
AutoIdVector idv ( cx ) ; 38
if ( ! GetPropertyNames ( cx , obj , JSITER_OWNONLY , & idv ) )  39
bool comma = false ; 42
for (size_t i = 0; i < idv.length(); ++i) 43
RootedId id ( cx , idv [ i ] ) ; 44
RootedObject obj2 ( cx ) ; 45
RootedShape shape ( cx ) ; 46
if ( ! JSObject :: lookupGeneric ( cx , obj , id , & obj2 , & shape ) )  47
int valcnt = 0 ; 51
if ( shape )  52
bool doGet = true ; 53
if ( obj2 -> isNative ( ) )  54
unsigned attrs = shape -> attributes ( ) ; 55
if ( attrs & JSPROP_GETTER )  56
doGet = false; 57
val [ valcnt ] = shape -> getterValue ( ); 58
gsop [ valcnt ] = cx -> runtime -> atomState . getAtom; 59
valcnt ++; 60
if ( attrs & JSPROP_SETTER )  62
doGet = false; 63
val [ valcnt ] = shape -> setterValue ( ); 64
gsop [ valcnt ] = cx -> runtime -> atomState . setAtom; 65
valcnt ++; 66
if ( doGet )  69
valcnt = 1; 70
gsop [ 0 ] = NULL; 71
MutableHandleValue vp = MutableHandleValue :: fromMarkedLocation ( & val [ 0 ] ) ; 72
if ( ! JSObject :: getGeneric ( cx , obj , obj , id , vp ) )  73
RawString s = ToString ( cx , IdToValue ( id ) ) ; 79
if ( ! s )  80
Rooted < JSLinearString * > idstr ( cx , s -> ensureLinear ( cx ) ) ; 82
if ( ! idstr )  83
if ( JSID_IS_ATOM ( id ) ? ! IsIdentifier ( idstr ) : ( ! JSID_IS_INT ( id ) || JSID_TO_INT ( id ) < 0 ) )  90
s = js_QuoteString ( cx , idstr , jschar ( '\'' ) ); 94
if ( ! s || ! ( idstr = s -> ensureLinear ( cx ) ) )  95
for (int j = 0; j < valcnt; j++) 99
if ( gsop [ j ] && val [ j ] . isUndefined ( ) )  104
RootedString valstr ( cx , js_ValueToSource ( cx , val [ j ] ) ) ; 108
if ( ! valstr )  109
const jschar * vchars = valstr -> getChars ( cx ) ; 111
if ( ! vchars )  112
size_t vlength = valstr -> length ( ) ; 114
if ( gsop [ j ] && IsFunctionObject ( val [ j ] ) )  120
const jschar * start = vchars ; 121
const jschar * end = vchars + vlength ; 122
uint8_t parenChomp = 0 ; 124
if ( vchars [ 0 ] == '(' )  125
vchars ++; 126
parenChomp = 1; 127
if ( vchars )  131
vchars = js_strchr_limit ( vchars , ' ' , end ); 132
if ( vchars )  138
vchars = js_strchr_limit ( vchars , '(' , end ); 139
if ( vchars )  141
if ( * vchars == ' ' )  142
vchars ++; 143
vlength = end - vchars - parenChomp; 144
gsop [ j ] = NULL; 146
vchars = start; 147
if ( comma && ! buf . append ( ", " ) )  151
comma = true; 153
if ( gsop [ j ] )  155
if ( ! buf . append ( gsop [ j ] ) || ! buf . append ( ' ' ) )  156
if ( ! buf . append ( idstr ) )  159
if ( ! buf . append ( gsop [ j ] ? ' ' : ':' ) )  161
if ( ! buf . append ( vchars , vlength ) )  164
------------------------------
375 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c aMetrics . height = aMetrics . ascent + descent 395
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
uint32_t flowEndInTextRun ; 66
nsIFrame * lineContainer = aLineLayout . GetLineContainerFrame ( ) ; 67
gfxContext * ctx = aRenderingContext -> ThebesContext ( ) ; 68
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
gfxSkipCharsIterator iter = EnsureTextRun ( nsTextFrame :: eInflated , ctx , lineContainer , aLineLayout . GetLine ( ) , & flowEndInTextRun ) ; 182
if ( mTextRun && iter . GetOriginalEnd ( ) < offset + length )  189
iter = EnsureTextRun ( nsTextFrame :: eInflated , ctx , lineContainer , aLineLayout . GetLine ( ) , & flowEndInTextRun ); 195
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
uint32_t transformedOffset = provider . GetStart ( ) . GetSkippedOffset ( ) ; 222
gfxTextRun :: Metrics textMetrics ; 225
gfxFont :: BoundingBoxType boundingBoxType = IsFloatingFirstLetterChild ( ) ? gfxFont :: TIGHT_HINTED_OUTLINE_EXTENTS : gfxFont :: LOOSE_INK_EXTENTS ; 226
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
bool forceBreakAfter = false ; 234
if ( forceBreak >= offset + length )  235
forceBreakAfter = forceBreak == offset + length; 236
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
uint32_t transformedLength ; 246
if ( offset + limitLength >= int32_t ( frag -> GetLength ( ) ) )  247
transformedLength = flowEndInTextRun - transformedOffset; 252
gfxSkipCharsIterator iter ( provider . GetStart ( ) ) ; 256
transformedLength = iter . GetSkippedOffset ( ) - transformedOffset; 258
bool usedHyphenation ; 261
gfxFloat trimmedWidth = 0 ; 262
gfxFloat availWidth = aAvailableWidth ; 263
bool canTrimTrailingWhitespace = ! textStyle -> WhiteSpaceIsSignificant ( ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) ; 264
uint32_t transformedCharsFit = mTextRun -> BreakAndMeasureText ( transformedOffset , transformedLength , ( GetStateBits ( ) & TEXT_START_OF_LINE ) != 0 , availWidth , & provider , ! aLineLayout . LineIsBreakable ( ) , canTrimTrailingWhitespace ? & trimmedWidth : nullptr , & textMetrics , boundingBoxType , ctx , & usedHyphenation , & transformedLastBreak , textStyle -> WordCanWrap ( ) , & breakPriority ) ; 269
if ( ! length && ! textMetrics . mAscent && ! textMetrics . mDescent )  278
nsFontMetrics * fm = provider . GetFontMetrics ( ) ; 281
if ( fm )  282
textMetrics . mAscent = gfxFloat ( fm -> MaxAscent ( ) ); 283
textMetrics . mDescent = gfxFloat ( fm -> MaxDescent ( ) ); 284
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
if ( ( forceBreak >= 0 || forceBreakAfter ) && HasSoftHyphenBefore ( frag , mTextRun , offset , end ) )  314
usedHyphenation = true; 316
bool brokeText = forceBreak >= 0 || transformedCharsFit < transformedLength ; 326
if ( canTrimTrailingWhitespace )  327
if ( brokeText || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  334
if ( ! ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  339
textMetrics . mAdvanceWidth += trimmedWidth; 344
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
if ( GetStateBits ( ) & TEXT_FIRST_LETTER )  370
textMetrics . mAscent = NS_MAX ( gfxFloat ( 0.0 ) , - textMetrics . mBoundingBox . Y ( ) ); 371
textMetrics . mDescent = NS_MAX ( gfxFloat ( 0.0 ) , textMetrics . mBoundingBox . YMost ( ) ); 372
aMetrics . width = NSToCoordCeil ( NS_MAX ( gfxFloat ( 0.0 ) , textMetrics . mAdvanceWidth ) ); 377
if ( transformedCharsFit == 0 && ! usedHyphenation )  379
if ( boundingBoxType != gfxFont :: LOOSE_INK_EXTENTS )  382
nsFontMetrics * fm = provider . GetFontMetrics ( ) ; 390
nscoord fontAscent = fm -> MaxAscent ( ) ; 391
nscoord fontDescent = fm -> MaxDescent ( ) ; 392
aMetrics . ascent = NS_MAX ( NSToCoordCeil ( textMetrics . mAscent ) , fontAscent ); 393
nscoord descent = NS_MAX ( NSToCoordCeil ( textMetrics . mDescent ) , fontDescent ) ; 394
aMetrics . height = aMetrics . ascent + descent; 395
NS_ASSERTION ( aMetrics . ascent >= 0 , "Negative ascent???" ); 398
NS_ASSERTION ( aMetrics . height - aMetrics . ascent >= 0 , "Negative descent???" ); 399
mAscent = aMetrics . ascent; 401
nsRect boundingBox = RoundOut ( textMetrics . mBoundingBox ) + nsPoint ( 0 , mAscent ) ; 404
aMetrics . SetOverflowAreasToDesiredBounds ( ); 405
aMetrics . VisualOverflow ( ) . UnionRect ( aMetrics . VisualOverflow ( ) , boundingBox ); 406
UnionAdditionalOverflow ( presContext , * aLineLayout . GetLineContainerRS ( ) , provider , & aMetrics . VisualOverflow ( ) , false ); 411
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
Invalidate ( aMetrics . VisualOverflow ( ) ); 515
printf ( ": desiredSize=%d,%d(b=%d) status=%x\n" , aMetrics . width , aMetrics . height , aMetrics . ascent , aStatus ); 519
------------------------------
376 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c aMetrics . height = aMetrics . ascent + NSToCoordCeil ( textMetrics . mDescent ) 385
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
uint32_t flowEndInTextRun ; 66
nsIFrame * lineContainer = aLineLayout . GetLineContainerFrame ( ) ; 67
gfxContext * ctx = aRenderingContext -> ThebesContext ( ) ; 68
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
gfxSkipCharsIterator iter = EnsureTextRun ( nsTextFrame :: eInflated , ctx , lineContainer , aLineLayout . GetLine ( ) , & flowEndInTextRun ) ; 182
if ( mTextRun && iter . GetOriginalEnd ( ) < offset + length )  189
iter = EnsureTextRun ( nsTextFrame :: eInflated , ctx , lineContainer , aLineLayout . GetLine ( ) , & flowEndInTextRun ); 195
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
uint32_t transformedOffset = provider . GetStart ( ) . GetSkippedOffset ( ) ; 222
gfxTextRun :: Metrics textMetrics ; 225
gfxFont :: BoundingBoxType boundingBoxType = IsFloatingFirstLetterChild ( ) ? gfxFont :: TIGHT_HINTED_OUTLINE_EXTENTS : gfxFont :: LOOSE_INK_EXTENTS ; 226
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
bool forceBreakAfter = false ; 234
if ( forceBreak >= offset + length )  235
forceBreakAfter = forceBreak == offset + length; 236
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
uint32_t transformedLength ; 246
if ( offset + limitLength >= int32_t ( frag -> GetLength ( ) ) )  247
transformedLength = flowEndInTextRun - transformedOffset; 252
gfxSkipCharsIterator iter ( provider . GetStart ( ) ) ; 256
transformedLength = iter . GetSkippedOffset ( ) - transformedOffset; 258
bool usedHyphenation ; 261
gfxFloat trimmedWidth = 0 ; 262
gfxFloat availWidth = aAvailableWidth ; 263
bool canTrimTrailingWhitespace = ! textStyle -> WhiteSpaceIsSignificant ( ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) ; 264
uint32_t transformedCharsFit = mTextRun -> BreakAndMeasureText ( transformedOffset , transformedLength , ( GetStateBits ( ) & TEXT_START_OF_LINE ) != 0 , availWidth , & provider , ! aLineLayout . LineIsBreakable ( ) , canTrimTrailingWhitespace ? & trimmedWidth : nullptr , & textMetrics , boundingBoxType , ctx , & usedHyphenation , & transformedLastBreak , textStyle -> WordCanWrap ( ) , & breakPriority ) ; 269
if ( ! length && ! textMetrics . mAscent && ! textMetrics . mDescent )  278
nsFontMetrics * fm = provider . GetFontMetrics ( ) ; 281
if ( fm )  282
textMetrics . mAscent = gfxFloat ( fm -> MaxAscent ( ) ); 283
textMetrics . mDescent = gfxFloat ( fm -> MaxDescent ( ) ); 284
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
if ( ( forceBreak >= 0 || forceBreakAfter ) && HasSoftHyphenBefore ( frag , mTextRun , offset , end ) )  314
usedHyphenation = true; 316
bool brokeText = forceBreak >= 0 || transformedCharsFit < transformedLength ; 326
if ( canTrimTrailingWhitespace )  327
if ( brokeText || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  334
if ( ! ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  339
textMetrics . mAdvanceWidth += trimmedWidth; 344
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
if ( GetStateBits ( ) & TEXT_FIRST_LETTER )  370
textMetrics . mAscent = NS_MAX ( gfxFloat ( 0.0 ) , - textMetrics . mBoundingBox . Y ( ) ); 371
textMetrics . mDescent = NS_MAX ( gfxFloat ( 0.0 ) , textMetrics . mBoundingBox . YMost ( ) ); 372
aMetrics . width = NSToCoordCeil ( NS_MAX ( gfxFloat ( 0.0 ) , textMetrics . mAdvanceWidth ) ); 377
if ( transformedCharsFit == 0 && ! usedHyphenation )  379
if ( boundingBoxType != gfxFont :: LOOSE_INK_EXTENTS )  382
aMetrics . ascent = NSToCoordCeil ( textMetrics . mAscent ); 384
aMetrics . height = aMetrics . ascent + NSToCoordCeil ( textMetrics . mDescent ); 385
NS_ASSERTION ( aMetrics . ascent >= 0 , "Negative ascent???" ); 398
NS_ASSERTION ( aMetrics . height - aMetrics . ascent >= 0 , "Negative descent???" ); 399
mAscent = aMetrics . ascent; 401
nsRect boundingBox = RoundOut ( textMetrics . mBoundingBox ) + nsPoint ( 0 , mAscent ) ; 404
aMetrics . SetOverflowAreasToDesiredBounds ( ); 405
aMetrics . VisualOverflow ( ) . UnionRect ( aMetrics . VisualOverflow ( ) , boundingBox ); 406
UnionAdditionalOverflow ( presContext , * aLineLayout . GetLineContainerRS ( ) , provider , & aMetrics . VisualOverflow ( ) , false ); 411
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
Invalidate ( aMetrics . VisualOverflow ( ) ); 515
printf ( ": desiredSize=%d,%d(b=%d) status=%x\n" , aMetrics . width , aMetrics . height , aMetrics . ascent , aStatus ); 519
------------------------------
377 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c lastBreak = end . ConvertSkippedToOriginal ( transformedOffset + transformedLastBreak ) 309
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
uint32_t transformedOffset = provider . GetStart ( ) . GetSkippedOffset ( ) ; 222
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
if ( forceBreak >= offset + length )  235
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
uint32_t transformedLastBreak = 0 ; 260
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
if ( transformedLastBreak != PR_UINT32_MAX )  306
lastBreak = end . ConvertSkippedToOriginal ( transformedOffset + transformedLastBreak ); 309
if ( ! brokeText && lastBreak >= 0 )  354
aLineLayout . NotifyOptionalBreakPosition ( mContent , lastBreak , true , breakPriority ); 359
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
------------------------------
378 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c transformedLength = flowEndInTextRun - transformedOffset 252
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
uint32_t flowEndInTextRun ; 66
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
uint32_t transformedOffset = provider . GetStart ( ) . GetSkippedOffset ( ) ; 222
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
if ( forceBreak >= offset + length )  235
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
uint32_t transformedLength ; 246
if ( offset + limitLength >= int32_t ( frag -> GetLength ( ) ) )  247
transformedLength = flowEndInTextRun - transformedOffset; 252
uint32_t transformedCharsFit = mTextRun -> BreakAndMeasureText ( transformedOffset , transformedLength , ( GetStateBits ( ) & TEXT_START_OF_LINE ) != 0 , availWidth , & provider , ! aLineLayout . LineIsBreakable ( ) , canTrimTrailingWhitespace ? & trimmedWidth : nullptr , & textMetrics , boundingBoxType , ctx , & usedHyphenation , & transformedLastBreak , textStyle -> WordCanWrap ( ) , & breakPriority ) ; 269
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
end . SetSkippedOffset ( transformedOffset + transformedCharsFit ); 291
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
bool brokeText = forceBreak >= 0 || transformedCharsFit < transformedLength ; 326
if ( brokeText || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  334
if ( ! brokeText && lastBreak >= 0 )  354
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
if ( transformedCharsFit == 0 && ! usedHyphenation )  379
if ( transformedCharsFit > 0 )  423
if ( ! breakAfter && charsFit == length && ! emptyTextAtStartOfLine && transformedOffset + transformedLength == mTextRun -> GetLength ( ) && ( mTextRun -> GetFlags ( ) & nsTextFrameUtils :: TEXT_HAS_TRAILING_BREAK ) )  438
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
------------------------------
379 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c limitLength = forceBreak - offset 241
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
if ( forceBreak >= offset + length )  235
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
NS_ASSERTION ( limitLength >= 0 , "Weird break found!" ); 242
if ( offset + limitLength >= int32_t ( frag -> GetLength ( ) ) )  247
NS_ASSERTION ( offset + limitLength == int32_t ( frag -> GetLength ( ) ) , "Content offset/length out of bounds" ); 248
iter . SetOriginalOffset ( offset + limitLength ); 257
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
end . SetOriginalOffset ( offset + charsFit ); 311
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
if ( charsFit > 0 && charsFit == length && textStyle -> mHyphens != NS_STYLE_HYPHENS_NONE && HasSoftHyphenBefore ( frag , mTextRun , offset , end ) )  427
if ( ! breakAfter && charsFit == length && ! emptyTextAtStartOfLine && transformedOffset + transformedLength == mTextRun -> GetLength ( ) && ( mTextRun -> GetFlags ( ) & nsTextFrameUtils :: TEXT_HAS_TRAILING_BREAK ) )  438
aStatus = contentLength == maxContentLength ? NS_FRAME_COMPLETE : NS_FRAME_NOT_COMPLETE; 458
if ( charsFit == 0 && length > 0 && ! usedHyphenation )  461
if ( contentLength > 0 && mContentOffset + contentLength - 1 == newLineOffset )  464
aStatus = NS_INLINE_LINE_BREAK_AFTER ( aStatus ); 466
aStatus = NS_INLINE_LINE_BREAK_AFTER ( aStatus ); 469
aStatus |= NS_INLINE_BREAK_FIRST_LETTER_COMPLETE; 473
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
int32_t numJustifiableCharacters = provider . ComputeJustifiableCharacters ( offset , charsFit ) ; 504
NS_ASSERTION ( numJustifiableCharacters <= charsFit , "Bad justifiable character count" ); 507
aLineLayout . SetTextJustificationWeights ( numJustifiableCharacters , charsFit - numJustifiableCharacters ); 509
SetLength ( contentLength , & aLineLayout , ALLOW_FRAME_CREATION_AND_DESTRUCTION ); 513
printf ( ": desiredSize=%d,%d(b=%d) status=%x\n" , aMetrics . width , aMetrics . height , aMetrics . ascent , aStatus ); 519
------------------------------
380 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c forceBreakAfter = forceBreak == offset + length 236
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
if ( forceBreak >= offset + length )  235
forceBreakAfter = forceBreak == offset + length; 236
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
if ( ( forceBreak >= 0 || forceBreakAfter ) && HasSoftHyphenBefore ( frag , mTextRun , offset , end ) )  314
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
bool breakAfter = forceBreakAfter ; 435
if ( ! breakAfter && charsFit == length && ! emptyTextAtStartOfLine && transformedOffset + transformedLength == mTextRun -> GetLength ( ) && ( mTextRun -> GetFlags ( ) & nsTextFrameUtils :: TEXT_HAS_TRAILING_BREAK ) )  438
if ( breakAfter )  468
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
------------------------------
381 /home/SySeVR/data/CVE_2013_0772_PATCHED_nsGIFDecoder2__DoLzw.c rowend = rowp + mGIFStruct . width 36
bool
CVE_2013_0772_PATCHED_nsGIFDecoder2::DoLzw(const uint8_t *q) 2
if ( ! mGIFStruct . rows_remaining )  4
uint32_t bpr = mGIFStruct . width ; 26
if ( ! mGIFStruct . images_decoded )  27
bpr *= sizeof ( uint32_t ); 28
if ( ! OutputRow ( ) )  33
rowp = mImageData + mGIFStruct . irow * bpr; 35
rowend = rowp + mGIFStruct . width; 36
if ( rowp == rowend )  72
if ( rowp == rowend )  122
------------------------------
382 /home/SySeVR/data/CVE_2013_0772_PATCHED_nsGIFDecoder2__DoLzw.c rowp = mImageData + mGIFStruct . irow * bpr 35
bool
CVE_2013_0772_PATCHED_nsGIFDecoder2::DoLzw(const uint8_t *q) 2
if ( ! mGIFStruct . rows_remaining )  4
uint32_t bpr = mGIFStruct . width ; 26
if ( ! mGIFStruct . images_decoded )  27
bpr *= sizeof ( uint32_t ); 28
if ( ! OutputRow ( ) )  33
rowp = mImageData + mGIFStruct . irow * bpr; 35
rowend = rowp + mGIFStruct . width; 36
* rowp ++ = suffix [ code ] & mColorMask; 71
if ( rowp == rowend )  72
* rowp ++ = * -- stackp & mColorMask; 121
if ( rowp == rowend )  122
mGIFStruct . rowp = rowp; 140
------------------------------
383 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__DoLzw.c rowend = rowp + mGIFStruct . width 36
bool
CVE_2013_0772_VULN_nsGIFDecoder2::DoLzw(const uint8_t *q) 2
if ( ! mGIFStruct . rows_remaining )  4
uint32_t bpr = mGIFStruct . width ; 26
if ( ! mGIFStruct . images_decoded )  27
bpr *= sizeof ( uint32_t ); 28
if ( ! OutputRow ( ) )  33
rowp = mImageData + mGIFStruct . irow * bpr; 35
rowend = rowp + mGIFStruct . width; 36
if ( rowp == rowend )  72
if ( rowp == rowend )  122
------------------------------
384 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__DoLzw.c rowp = mImageData + mGIFStruct . irow * bpr 35
bool
CVE_2013_0772_VULN_nsGIFDecoder2::DoLzw(const uint8_t *q) 2
if ( ! mGIFStruct . rows_remaining )  4
uint32_t bpr = mGIFStruct . width ; 26
if ( ! mGIFStruct . images_decoded )  27
bpr *= sizeof ( uint32_t ); 28
if ( ! OutputRow ( ) )  33
rowp = mImageData + mGIFStruct . irow * bpr; 35
rowend = rowp + mGIFStruct . width; 36
* rowp ++ = suffix [ code ]; 71
if ( rowp == rowend )  72
* rowp ++ = * -- stackp; 121
if ( rowp == rowend )  122
mGIFStruct . rowp = rowp; 140
------------------------------
385 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c drow_end = drow_start + row_dup 25
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
if ( mGIFStruct . progressive_display && mGIFStruct . interlaced && ( mGIFStruct . ipass < 4 ) )  19
const uint32_t row_dup = 15 >> mGIFStruct . ipass ; 21
const uint32_t row_shift = row_dup >> 1 ; 22
drow_start -= row_shift; 24
drow_end = drow_start + row_dup; 25
if ( ( ( mGIFStruct . height - 1 ) - drow_end ) <= row_shift )  28
if ( ( unsigned ) drow_end >= mGIFStruct . height )  34
if ( drow_end > drow_start )  70
for (int r = drow_start; r <= drow_end; r++) 72
mCurrentRow = drow_end; 80
------------------------------
386 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__DoCharsetConversion.c dstLength = bufferLength - pos2 80
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::DoCharsetConversion(const PRUnichar *inString, char **outString) 2
nsresult rv ; 8
int32_t inStringLength = NS_strlen ( inString ) ; 9
int32_t bufferLength ; 10
int32_t srcLength = inStringLength ; 11
int32_t dstLength ; 12
int32_t pos1 , pos2 ; 13
rv = mEncoder -> GetMaxLength ( inString , inStringLength , & dstLength ); 17
if ( NS_FAILED ( rv ) )  18
bufferLength = dstLength + RESERVE_FALLBACK_BYTES; 20
char * dstPtr = ( char * ) PR_Malloc ( bufferLength + 1 ) ; 24
if ( ! dstPtr )  25
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;) 29
dstLength = bufferLength - pos2; 31
rv = mEncoder -> Convert ( & inString [ pos1 ] , & srcLength , & dstPtr [ pos2 ] , & dstLength ); 33
pos1 += srcLength ? srcLength : 1; 35
pos2 += dstLength; 36
if ( NS_ERROR_UENC_NOMAPPING != rv )  40
rv = NS_OK; 44
dstLength = bufferLength - pos2; 47
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 48
if ( NS_SUCCEEDED ( rv ) )  49
pos2 += dstLength; 50
dstPtr [ pos2 ] = '\0'; 51
srcLength = inStringLength - pos1; 54
if ( ! ATTR_NO_FALLBACK ( mAttribute ) )  57
uint32_t unMappedChar ; 58
if ( NS_IS_HIGH_SURROGATE ( inString [ pos1 - 1 ] ) && inStringLength > pos1 && NS_IS_LOW_SURROGATE ( inString [ pos1 ] ) )  59
unMappedChar = SURROGATE_TO_UCS4 ( inString [ pos1 - 1 ] , inString [ pos1 ] ); 61
pos1 ++; 62
unMappedChar = inString [ pos1 - 1 ]; 64
rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ); 67
if ( NS_FAILED ( rv ) )  68
rv = HandleFallBack ( unMappedChar , & dstPtr , & bufferLength , & pos2 , dstLength ); 71
if ( NS_FAILED ( rv ) )  72
dstPtr [ pos2 ] = '\0'; 74
if ( NS_SUCCEEDED ( rv ) )  78
dstLength = bufferLength - pos2; 80
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 81
if ( NS_SUCCEEDED ( rv ) )  82
pos2 += dstLength; 83
dstPtr [ pos2 ] = '\0'; 84
if ( NS_FAILED ( rv ) )  88
PR_FREEIF ( dstPtr ); 89
return rv ; 90
* outString = dstPtr; 93
return rv ; 100
------------------------------
387 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__DoCharsetConversion.c rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ) 67
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::DoCharsetConversion(const PRUnichar *inString, char **outString) 2
nsresult rv ; 8
int32_t inStringLength = NS_strlen ( inString ) ; 9
int32_t bufferLength ; 10
int32_t srcLength = inStringLength ; 11
int32_t dstLength ; 12
int32_t pos1 , pos2 ; 13
rv = mEncoder -> GetMaxLength ( inString , inStringLength , & dstLength ); 17
if ( NS_FAILED ( rv ) )  18
bufferLength = dstLength + RESERVE_FALLBACK_BYTES; 20
char * dstPtr = ( char * ) PR_Malloc ( bufferLength + 1 ) ; 24
if ( ! dstPtr )  25
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;) 29
dstLength = bufferLength - pos2; 31
rv = mEncoder -> Convert ( & inString [ pos1 ] , & srcLength , & dstPtr [ pos2 ] , & dstLength ); 33
pos1 += srcLength ? srcLength : 1; 35
pos2 += dstLength; 36
if ( NS_ERROR_UENC_NOMAPPING != rv )  40
rv = NS_OK; 44
dstLength = bufferLength - pos2; 47
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 48
if ( NS_SUCCEEDED ( rv ) )  49
pos2 += dstLength; 50
dstPtr [ pos2 ] = '\0'; 51
srcLength = inStringLength - pos1; 54
if ( ! ATTR_NO_FALLBACK ( mAttribute ) )  57
uint32_t unMappedChar ; 58
if ( NS_IS_HIGH_SURROGATE ( inString [ pos1 - 1 ] ) && inStringLength > pos1 && NS_IS_LOW_SURROGATE ( inString [ pos1 ] ) )  59
unMappedChar = SURROGATE_TO_UCS4 ( inString [ pos1 - 1 ] , inString [ pos1 ] ); 61
pos1 ++; 62
unMappedChar = inString [ pos1 - 1 ]; 64
rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ); 67
if ( NS_FAILED ( rv ) )  68
rv = HandleFallBack ( unMappedChar , & dstPtr , & bufferLength , & pos2 , dstLength ); 71
if ( NS_FAILED ( rv ) )  72
if ( NS_SUCCEEDED ( rv ) )  78
if ( NS_FAILED ( rv ) )  88
return rv ; 90
return rv ; 100
------------------------------
388 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__DoCharsetConversion.c srcLength = inStringLength - pos1 54
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::DoCharsetConversion(const PRUnichar *inString, char **outString) 2
nsresult rv ; 8
int32_t inStringLength = NS_strlen ( inString ) ; 9
int32_t bufferLength ; 10
int32_t srcLength = inStringLength ; 11
int32_t dstLength ; 12
int32_t pos1 , pos2 ; 13
rv = mEncoder -> GetMaxLength ( inString , inStringLength , & dstLength ); 17
if ( NS_FAILED ( rv ) )  18
bufferLength = dstLength + RESERVE_FALLBACK_BYTES; 20
char * dstPtr = ( char * ) PR_Malloc ( bufferLength + 1 ) ; 24
if ( ! dstPtr )  25
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;) 29
dstLength = bufferLength - pos2; 31
rv = mEncoder -> Convert ( & inString [ pos1 ] , & srcLength , & dstPtr [ pos2 ] , & dstLength ); 33
pos1 += srcLength ? srcLength : 1; 35
pos2 += dstLength; 36
if ( NS_ERROR_UENC_NOMAPPING != rv )  40
saveResult = rv; 43
rv = NS_OK; 44
dstLength = bufferLength - pos2; 47
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 48
if ( NS_SUCCEEDED ( rv ) )  49
pos2 += dstLength; 50
dstPtr [ pos2 ] = '\0'; 51
srcLength = inStringLength - pos1; 54
if ( ! ATTR_NO_FALLBACK ( mAttribute ) )  57
uint32_t unMappedChar ; 58
if ( NS_IS_HIGH_SURROGATE ( inString [ pos1 - 1 ] ) && inStringLength > pos1 && NS_IS_LOW_SURROGATE ( inString [ pos1 ] ) )  59
unMappedChar = SURROGATE_TO_UCS4 ( inString [ pos1 - 1 ] , inString [ pos1 ] ); 61
pos1 ++; 62
unMappedChar = inString [ pos1 - 1 ]; 64
rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ); 67
if ( NS_FAILED ( rv ) )  68
rv = HandleFallBack ( unMappedChar , & dstPtr , & bufferLength , & pos2 , dstLength ); 71
if ( NS_FAILED ( rv ) )  72
if ( NS_SUCCEEDED ( rv ) )  78
if ( NS_FAILED ( rv ) )  88
return rv ; 90
if ( NS_ERROR_UENC_NOMAPPING == saveResult )  96
return rv ; 100
------------------------------
389 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__DoCharsetConversion.c dstLength = bufferLength - pos2 47
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::DoCharsetConversion(const PRUnichar *inString, char **outString) 2
nsresult rv ; 8
int32_t inStringLength = NS_strlen ( inString ) ; 9
int32_t bufferLength ; 10
int32_t srcLength = inStringLength ; 11
int32_t dstLength ; 12
int32_t pos1 , pos2 ; 13
rv = mEncoder -> GetMaxLength ( inString , inStringLength , & dstLength ); 17
if ( NS_FAILED ( rv ) )  18
bufferLength = dstLength + RESERVE_FALLBACK_BYTES; 20
char * dstPtr = ( char * ) PR_Malloc ( bufferLength + 1 ) ; 24
if ( ! dstPtr )  25
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;) 29
dstLength = bufferLength - pos2; 31
NS_ASSERTION ( dstLength >= 0 , "out of bounds write" ); 32
rv = mEncoder -> Convert ( & inString [ pos1 ] , & srcLength , & dstPtr [ pos2 ] , & dstLength ); 33
pos1 += srcLength ? srcLength : 1; 35
pos2 += dstLength; 36
dstPtr [ pos2 ] = '\0'; 37
if ( NS_ERROR_UENC_NOMAPPING != rv )  40
saveResult = rv; 43
rv = NS_OK; 44
dstLength = bufferLength - pos2; 47
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 48
if ( NS_SUCCEEDED ( rv ) )  49
pos2 += dstLength; 50
dstPtr [ pos2 ] = '\0'; 51
srcLength = inStringLength - pos1; 54
if ( ! ATTR_NO_FALLBACK ( mAttribute ) )  57
uint32_t unMappedChar ; 58
if ( NS_IS_HIGH_SURROGATE ( inString [ pos1 - 1 ] ) && inStringLength > pos1 && NS_IS_LOW_SURROGATE ( inString [ pos1 ] ) )  59
unMappedChar = SURROGATE_TO_UCS4 ( inString [ pos1 - 1 ] , inString [ pos1 ] ); 61
pos1 ++; 62
unMappedChar = inString [ pos1 - 1 ]; 64
rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ); 67
if ( NS_FAILED ( rv ) )  68
rv = HandleFallBack ( unMappedChar , & dstPtr , & bufferLength , & pos2 , dstLength ); 71
if ( NS_FAILED ( rv ) )  72
dstPtr [ pos2 ] = '\0'; 74
if ( NS_SUCCEEDED ( rv ) )  78
dstLength = bufferLength - pos2; 80
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 81
if ( NS_SUCCEEDED ( rv ) )  82
pos2 += dstLength; 83
dstPtr [ pos2 ] = '\0'; 84
if ( NS_FAILED ( rv ) )  88
PR_FREEIF ( dstPtr ); 89
return rv ; 90
* outString = dstPtr; 93
if ( NS_ERROR_UENC_NOMAPPING == saveResult )  96
return rv ; 100
------------------------------
390 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__DoCharsetConversion.c dstLength = bufferLength - pos2 31
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::DoCharsetConversion(const PRUnichar *inString, char **outString) 2
nsresult rv ; 8
int32_t inStringLength = NS_strlen ( inString ) ; 9
int32_t bufferLength ; 10
int32_t srcLength = inStringLength ; 11
int32_t dstLength ; 12
int32_t pos1 , pos2 ; 13
rv = mEncoder -> GetMaxLength ( inString , inStringLength , & dstLength ); 17
if ( NS_FAILED ( rv ) )  18
bufferLength = dstLength + RESERVE_FALLBACK_BYTES; 20
char * dstPtr = ( char * ) PR_Malloc ( bufferLength + 1 ) ; 24
if ( ! dstPtr )  25
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;) 29
dstLength = bufferLength - pos2; 31
NS_ASSERTION ( dstLength >= 0 , "out of bounds write" ); 32
rv = mEncoder -> Convert ( & inString [ pos1 ] , & srcLength , & dstPtr [ pos2 ] , & dstLength ); 33
pos1 += srcLength ? srcLength : 1; 35
pos2 += dstLength; 36
dstPtr [ pos2 ] = '\0'; 37
if ( NS_ERROR_UENC_NOMAPPING != rv )  40
saveResult = rv; 43
rv = NS_OK; 44
dstLength = bufferLength - pos2; 47
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 48
if ( NS_SUCCEEDED ( rv ) )  49
pos2 += dstLength; 50
dstPtr [ pos2 ] = '\0'; 51
srcLength = inStringLength - pos1; 54
if ( ! ATTR_NO_FALLBACK ( mAttribute ) )  57
uint32_t unMappedChar ; 58
if ( NS_IS_HIGH_SURROGATE ( inString [ pos1 - 1 ] ) && inStringLength > pos1 && NS_IS_LOW_SURROGATE ( inString [ pos1 ] ) )  59
unMappedChar = SURROGATE_TO_UCS4 ( inString [ pos1 - 1 ] , inString [ pos1 ] ); 61
pos1 ++; 62
unMappedChar = inString [ pos1 - 1 ]; 64
rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ); 67
if ( NS_FAILED ( rv ) )  68
rv = HandleFallBack ( unMappedChar , & dstPtr , & bufferLength , & pos2 , dstLength ); 71
if ( NS_FAILED ( rv ) )  72
dstPtr [ pos2 ] = '\0'; 74
if ( NS_SUCCEEDED ( rv ) )  78
dstLength = bufferLength - pos2; 80
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 81
if ( NS_SUCCEEDED ( rv ) )  82
pos2 += dstLength; 83
dstPtr [ pos2 ] = '\0'; 84
if ( NS_FAILED ( rv ) )  88
PR_FREEIF ( dstPtr ); 89
return rv ; 90
* outString = dstPtr; 93
if ( NS_ERROR_UENC_NOMAPPING == saveResult )  96
return rv ; 100
------------------------------
391 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__DoCharsetConversion.c bufferLength = dstLength + RESERVE_FALLBACK_BYTES 20
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::DoCharsetConversion(const PRUnichar *inString, char **outString) 2
nsresult rv ; 8
int32_t inStringLength = NS_strlen ( inString ) ; 9
int32_t bufferLength ; 10
int32_t dstLength ; 12
rv = mEncoder -> GetMaxLength ( inString , inStringLength , & dstLength ); 17
if ( NS_FAILED ( rv ) )  18
bufferLength = dstLength + RESERVE_FALLBACK_BYTES; 20
char * dstPtr = ( char * ) PR_Malloc ( bufferLength + 1 ) ; 24
if ( ! dstPtr )  25
dstLength = bufferLength - pos2; 31
NS_ASSERTION ( dstLength >= 0 , "out of bounds write" ); 32
rv = mEncoder -> Convert ( & inString [ pos1 ] , & srcLength , & dstPtr [ pos2 ] , & dstLength ); 33
pos2 += dstLength; 36
dstPtr [ pos2 ] = '\0'; 37
if ( NS_ERROR_UENC_NOMAPPING != rv )  40
saveResult = rv; 43
dstLength = bufferLength - pos2; 47
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 48
if ( NS_SUCCEEDED ( rv ) )  49
pos2 += dstLength; 50
dstPtr [ pos2 ] = '\0'; 51
rv = mEncoder -> GetMaxLength ( inString + pos1 , inStringLength - pos1 , & dstLength ); 67
if ( NS_FAILED ( rv ) )  68
rv = HandleFallBack ( unMappedChar , & dstPtr , & bufferLength , & pos2 , dstLength ); 71
if ( NS_FAILED ( rv ) )  72
dstPtr [ pos2 ] = '\0'; 74
if ( NS_SUCCEEDED ( rv ) )  78
dstLength = bufferLength - pos2; 80
rv = mEncoder -> Finish ( & dstPtr [ pos2 ] , & dstLength ); 81
if ( NS_SUCCEEDED ( rv ) )  82
pos2 += dstLength; 83
dstPtr [ pos2 ] = '\0'; 84
if ( NS_FAILED ( rv ) )  88
PR_FREEIF ( dstPtr ); 89
return rv ; 90
* outString = dstPtr; 93
if ( NS_ERROR_UENC_NOMAPPING == saveResult )  96
return rv ; 100
------------------------------
392 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ) 679
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
GetByteContext gb ; 13
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
for (channel = 0; channel < avctx->channels; channel++) 259
cs = & c -> status [ channel ]; 260
cs -> predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 261
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 262
if ( cs -> step_index > 88u )  263
for (n = nb_samples >> (1 - st); n > 0; n--) 270
int v1 , v2 ; 271
int v = bytestream2_get_byteu ( & gb ) ; 272
if ( st )  274
v1 = v >> 4; 275
v2 = v & 0x0F; 276
v2 = v >> 4; 278
v1 = v & 0x0F; 279
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
while ( bytestream2_get_bytes_left ( & gb ) > 0 )  286
int v = bytestream2_get_byteu ( & gb ) ; 287
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
if ( c -> vqa_version == 3 )  293
for (n = nb_samples / 2; n > 0; n--) 306
for (channel = 0; channel < avctx->channels; channel++) 307
int v = bytestream2_get_byteu ( & gb ) ; 308
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
while ( bytestream2_get_bytes_left ( & gb ) >= 128 )  318
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
c -> status [ i ] . step_index = bytestream2_get_le32u ( & gb ); 328
if ( c -> status [ i ] . step_index > 88u )  329
for (i=0; i<=st; i++) 335
c -> status [ i ] . predictor = bytestream2_get_le32u ( & gb ); 336
for (n = nb_samples >> (1 - st); n > 0; n--) 338
int byte = bytestream2_get_byteu ( & gb ) ; 339
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
int byte = bytestream2_get_byteu ( & gb ) ; 346
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
int previous_left_sample , previous_right_sample ; 353
int current_left_sample , current_right_sample ; 354
int next_left_sample , next_right_sample ; 355
int coeff1l , coeff2l , coeff1r , coeff2r ; 356
int shift_left , shift_right ; 357
if ( avctx -> channels != 2 )  362
current_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 365
previous_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 366
current_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 367
previous_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 368
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
int byte = bytestream2_get_byteu ( & gb ) ; 371
coeff1l = ea_adpcm_table [ byte >> 4 ]; 372
coeff2l = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 373
coeff1r = ea_adpcm_table [ byte & 0x0F ]; 374
coeff2r = ea_adpcm_table [ ( byte & 0x0F ) + 4 ]; 375
byte = bytestream2_get_byteu ( & gb ); 377
shift_left = 20 - ( byte >> 4 ); 378
shift_right = 20 - ( byte & 0x0F ); 379
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
next_left_sample = sign_extend ( byte >> 4 , 4 ) << shift_left; 383
next_right_sample = sign_extend ( byte , 4 ) << shift_right; 384
next_left_sample = ( next_left_sample + ( current_left_sample * coeff1l ) + ( previous_left_sample * coeff2l ) + 0x80 ) >> 8; 386
next_right_sample = ( next_right_sample + ( current_right_sample * coeff1r ) + ( previous_right_sample * coeff2r ) + 0x80 ) >> 8; 389
previous_left_sample = current_left_sample; 393
current_left_sample = av_clip_int16 ( next_left_sample ); 394
previous_right_sample = current_right_sample; 395
current_right_sample = av_clip_int16 ( next_right_sample ); 396
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
int coeff [ 2 ] [ 2 ] , shift [ 2 ] 408
for(channel = 0; channel < avctx->channels; channel++) 410
int byte = bytestream2_get_byteu ( & gb ) ; 411
for (i=0; i<2; i++) 412
coeff [ channel ] [ i ] = ea_adpcm_table [ ( byte >> 4 ) + 4 * i ]; 413
shift [ channel ] = 20 - ( byte & 0x0F ); 414
for (count1 = 0; count1 < nb_samples / 2; count1++) 416
int byte [ 2 ] ; 417
byte [ 0 ] = bytestream2_get_byteu ( & gb ); 419
if ( st )  420
byte [ 1 ] = bytestream2_get_byteu ( & gb ); 420
for(i = 4; i >= 0; i-=4) 421
for(channel = 0; channel < avctx->channels; channel++) 422
int sample = sign_extend ( byte [ channel ] >> i , 4 ) << shift [ channel ] ; 423
sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8; 424
c -> status [ channel ] . sample2 = c -> status [ channel ] . sample1; 427
c -> status [ channel ] . sample1 = av_clip_int16 ( sample ); 428
* samples ++ = c -> status [ channel ] . sample1; 429
const int big_endian = avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R3 ; 443
int previous_sample , current_sample , next_sample ; 444
int coeff1 , coeff2 ; 445
int shift ; 446
unsigned int channel ; 447
int count = 0 ; 449
int offsets [ 6 ] ; 450
for (channel=0; channel<avctx->channels; channel++) 452
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R1 )  461
current_sample = sign_extend ( bytestream2_get_le16 ( & gb ) , 16 ); 462
previous_sample = sign_extend ( bytestream2_get_le16 ( & gb ) , 16 ); 463
current_sample = c -> status [ channel ] . predictor; 465
previous_sample = c -> status [ channel ] . prev_sample; 466
for (count1 = 0; count1 < nb_samples / 28; count1++) 469
int byte = bytestream2_get_byte ( & gb ) ; 470
if ( byte == 0xEE )  471
current_sample = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 472
previous_sample = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 473
coeff1 = ea_adpcm_table [ byte >> 4 ]; 480
coeff2 = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 481
shift = 20 - ( byte & 0x0F ); 482
for (count2=0; count2<28; count2++) 484
if ( count2 & 1 )  485
next_sample = sign_extend ( byte , 4 ) << shift; 486
byte = bytestream2_get_byte ( & gb ); 488
next_sample = sign_extend ( byte >> 4 , 4 ) << shift; 489
next_sample += ( current_sample * coeff1 ) + ( previous_sample * coeff2 ); 492
next_sample = av_clip_int16 ( next_sample >> 8 ); 494
previous_sample = current_sample; 496
current_sample = next_sample; 497
if ( ! count )  503
count = count1; 504
if ( count != count1 )  505
count = FFMAX ( count , count1 ); 507
if ( avctx -> codec -> id != AV_CODEC_ID_ADPCM_EA_R1 )  510
c -> status [ channel ] . predictor = current_sample; 511
c -> status [ channel ] . prev_sample = previous_sample; 512
c -> frame . nb_samples = count * 28; 516
for (channel=0; channel<avctx->channels; channel++) 521
int coeff [ 2 ] [ 4 ] , shift [ 4 ] 522
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
int val = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ) ; 525
for (i=0; i<2; i++) 526
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
val = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 530
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
for (m=2; m<32; m+=2) 535
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 552
c -> status [ 0 ] . step_index = bytestream2_get_le16u ( & gb ); 553
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 556
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 557
if ( c -> status [ 0 ] . step_index > 88u )  560
for (n = nb_samples >> (1 - st); n > 0; n--) 566
int hi , lo , v = bytestream2_get_byteu ( & gb ) ; 567
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
hi = v & 0x0F; 570
lo = v >> 4; 571
lo = v & 0x0F; 573
hi = v >> 4; 574
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
int v = bytestream2_get_byteu ( & gb ) ; 583
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
if ( ! c -> status [ 0 ] . step_index )  591
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
if ( st )  594
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
c -> status [ 0 ] . step_index = 1; 596
nb_samples --; 597
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
int byte = bytestream2_get_byteu ( & gb ) ; 601
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
for (n = nb_samples / 3; n > 0; n--) 608
int byte = bytestream2_get_byteu ( & gb ) ; 609
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
for (n = nb_samples >> (2 - st); n > 0; n--) 618
int byte = bytestream2_get_byteu ( & gb ) ; 619
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
for (n = nb_samples >> (1 - st); n > 0; n--) 636
int v = bytestream2_get_byteu ( & gb ) ; 637
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
int table [ 2 ] [ 16 ]
int prev [ 2 ] [ 2 ] 645
int ch ; 646
for (i = 0; i < 2; i++) 648
for (n = 0; n < 16; n++) 649
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (ch = 0; ch <= st; ch++) 657
samples = ( short * ) c -> frame . data [ 0 ] + ch; 658
for (i = 0; i < nb_samples / 14; i++) 661
int byte = bytestream2_get_byteu ( & gb ) ; 662
int index = ( byte >> 4 ) & 7 ; 663
unsigned int exp = byte & 0x0F ; 664
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
int32_t sampledat ; 670
if ( n & 1 )  672
sampledat = sign_extend ( byte , 4 ); 673
byte = bytestream2_get_byteu ( & gb ); 675
sampledat = sign_extend ( byte >> 4 , 4 ); 676
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
393 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ) 543
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
GetByteContext gb ; 13
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
for (channel = 0; channel < avctx->channels; channel++) 259
cs = & c -> status [ channel ]; 260
cs -> predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 261
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 262
if ( cs -> step_index > 88u )  263
for (n = nb_samples >> (1 - st); n > 0; n--) 270
int v1 , v2 ; 271
int v = bytestream2_get_byteu ( & gb ) ; 272
if ( st )  274
v1 = v >> 4; 275
v2 = v & 0x0F; 276
v2 = v >> 4; 278
v1 = v & 0x0F; 279
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
while ( bytestream2_get_bytes_left ( & gb ) > 0 )  286
int v = bytestream2_get_byteu ( & gb ) ; 287
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
if ( c -> vqa_version == 3 )  293
for (n = nb_samples / 2; n > 0; n--) 306
for (channel = 0; channel < avctx->channels; channel++) 307
int v = bytestream2_get_byteu ( & gb ) ; 308
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
while ( bytestream2_get_bytes_left ( & gb ) >= 128 )  318
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
c -> status [ i ] . step_index = bytestream2_get_le32u ( & gb ); 328
if ( c -> status [ i ] . step_index > 88u )  329
for (i=0; i<=st; i++) 335
c -> status [ i ] . predictor = bytestream2_get_le32u ( & gb ); 336
for (n = nb_samples >> (1 - st); n > 0; n--) 338
int byte = bytestream2_get_byteu ( & gb ) ; 339
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
int byte = bytestream2_get_byteu ( & gb ) ; 346
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
int previous_left_sample , previous_right_sample ; 353
int current_left_sample , current_right_sample ; 354
int next_left_sample , next_right_sample ; 355
int coeff1l , coeff2l , coeff1r , coeff2r ; 356
int shift_left , shift_right ; 357
if ( avctx -> channels != 2 )  362
current_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 365
previous_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 366
current_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 367
previous_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 368
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
int byte = bytestream2_get_byteu ( & gb ) ; 371
coeff1l = ea_adpcm_table [ byte >> 4 ]; 372
coeff2l = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 373
coeff1r = ea_adpcm_table [ byte & 0x0F ]; 374
coeff2r = ea_adpcm_table [ ( byte & 0x0F ) + 4 ]; 375
byte = bytestream2_get_byteu ( & gb ); 377
shift_left = 20 - ( byte >> 4 ); 378
shift_right = 20 - ( byte & 0x0F ); 379
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
next_left_sample = sign_extend ( byte >> 4 , 4 ) << shift_left; 383
next_right_sample = sign_extend ( byte , 4 ) << shift_right; 384
next_left_sample = ( next_left_sample + ( current_left_sample * coeff1l ) + ( previous_left_sample * coeff2l ) + 0x80 ) >> 8; 386
next_right_sample = ( next_right_sample + ( current_right_sample * coeff1r ) + ( previous_right_sample * coeff2r ) + 0x80 ) >> 8; 389
previous_left_sample = current_left_sample; 393
current_left_sample = av_clip_int16 ( next_left_sample ); 394
previous_right_sample = current_right_sample; 395
current_right_sample = av_clip_int16 ( next_right_sample ); 396
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
int coeff [ 2 ] [ 2 ] , shift [ 2 ] 408
for(channel = 0; channel < avctx->channels; channel++) 410
int byte = bytestream2_get_byteu ( & gb ) ; 411
for (i=0; i<2; i++) 412
coeff [ channel ] [ i ] = ea_adpcm_table [ ( byte >> 4 ) + 4 * i ]; 413
shift [ channel ] = 20 - ( byte & 0x0F ); 414
for (count1 = 0; count1 < nb_samples / 2; count1++) 416
int byte [ 2 ] ; 417
byte [ 0 ] = bytestream2_get_byteu ( & gb ); 419
if ( st )  420
byte [ 1 ] = bytestream2_get_byteu ( & gb ); 420
for(i = 4; i >= 0; i-=4) 421
for(channel = 0; channel < avctx->channels; channel++) 422
int sample = sign_extend ( byte [ channel ] >> i , 4 ) << shift [ channel ] ; 423
sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8; 424
c -> status [ channel ] . sample2 = c -> status [ channel ] . sample1; 427
c -> status [ channel ] . sample1 = av_clip_int16 ( sample ); 428
* samples ++ = c -> status [ channel ] . sample1; 429
const int big_endian = avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R3 ; 443
int previous_sample , current_sample , next_sample ; 444
int coeff1 , coeff2 ; 445
int shift ; 446
unsigned int channel ; 447
int offsets [ 6 ] ; 450
for (channel=0; channel<avctx->channels; channel++) 452
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R1 )  461
current_sample = sign_extend ( bytestream2_get_le16 ( & gb ) , 16 ); 462
previous_sample = sign_extend ( bytestream2_get_le16 ( & gb ) , 16 ); 463
current_sample = c -> status [ channel ] . predictor; 465
previous_sample = c -> status [ channel ] . prev_sample; 466
for (count1 = 0; count1 < nb_samples / 28; count1++) 469
int byte = bytestream2_get_byte ( & gb ) ; 470
if ( byte == 0xEE )  471
current_sample = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 472
previous_sample = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 473
coeff1 = ea_adpcm_table [ byte >> 4 ]; 480
coeff2 = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 481
shift = 20 - ( byte & 0x0F ); 482
for (count2=0; count2<28; count2++) 484
if ( count2 & 1 )  485
next_sample = sign_extend ( byte , 4 ) << shift; 486
byte = bytestream2_get_byte ( & gb ); 488
next_sample = sign_extend ( byte >> 4 , 4 ) << shift; 489
next_sample += ( current_sample * coeff1 ) + ( previous_sample * coeff2 ); 492
next_sample = av_clip_int16 ( next_sample >> 8 ); 494
previous_sample = current_sample; 496
current_sample = next_sample; 497
if ( avctx -> codec -> id != AV_CODEC_ID_ADPCM_EA_R1 )  510
c -> status [ channel ] . predictor = current_sample; 511
c -> status [ channel ] . prev_sample = previous_sample; 512
for (channel=0; channel<avctx->channels; channel++) 521
int coeff [ 2 ] [ 4 ] , shift [ 4 ] 522
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
int val = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ) ; 525
for (i=0; i<2; i++) 526
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
val = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 530
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
for (m=2; m<32; m+=2) 535
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
int byte = bytestream2_get_byteu ( & gb ) ; 538
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
------------------------------
394 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c s = & samples [ m * avctx -> channels + channel ] 536
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
GetByteContext gb ; 13
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
for (channel = 0; channel < avctx->channels; channel++) 259
cs = & c -> status [ channel ]; 260
cs -> predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 261
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 262
if ( cs -> step_index > 88u )  263
for (n = nb_samples >> (1 - st); n > 0; n--) 270
int v1 , v2 ; 271
int v = bytestream2_get_byteu ( & gb ) ; 272
if ( st )  274
v1 = v >> 4; 275
v2 = v & 0x0F; 276
v2 = v >> 4; 278
v1 = v & 0x0F; 279
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
while ( bytestream2_get_bytes_left ( & gb ) > 0 )  286
int v = bytestream2_get_byteu ( & gb ) ; 287
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
if ( c -> vqa_version == 3 )  293
for (n = nb_samples / 2; n > 0; n--) 306
for (channel = 0; channel < avctx->channels; channel++) 307
int v = bytestream2_get_byteu ( & gb ) ; 308
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
while ( bytestream2_get_bytes_left ( & gb ) >= 128 )  318
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
c -> status [ i ] . step_index = bytestream2_get_le32u ( & gb ); 328
if ( c -> status [ i ] . step_index > 88u )  329
for (i=0; i<=st; i++) 335
c -> status [ i ] . predictor = bytestream2_get_le32u ( & gb ); 336
for (n = nb_samples >> (1 - st); n > 0; n--) 338
int byte = bytestream2_get_byteu ( & gb ) ; 339
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
int byte = bytestream2_get_byteu ( & gb ) ; 346
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
int previous_left_sample , previous_right_sample ; 353
int current_left_sample , current_right_sample ; 354
int next_left_sample , next_right_sample ; 355
int coeff1l , coeff2l , coeff1r , coeff2r ; 356
int shift_left , shift_right ; 357
if ( avctx -> channels != 2 )  362
current_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 365
previous_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 366
current_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 367
previous_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 368
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
int byte = bytestream2_get_byteu ( & gb ) ; 371
coeff1l = ea_adpcm_table [ byte >> 4 ]; 372
coeff2l = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 373
coeff1r = ea_adpcm_table [ byte & 0x0F ]; 374
coeff2r = ea_adpcm_table [ ( byte & 0x0F ) + 4 ]; 375
byte = bytestream2_get_byteu ( & gb ); 377
shift_left = 20 - ( byte >> 4 ); 378
shift_right = 20 - ( byte & 0x0F ); 379
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
next_left_sample = sign_extend ( byte >> 4 , 4 ) << shift_left; 383
next_right_sample = sign_extend ( byte , 4 ) << shift_right; 384
next_left_sample = ( next_left_sample + ( current_left_sample * coeff1l ) + ( previous_left_sample * coeff2l ) + 0x80 ) >> 8; 386
next_right_sample = ( next_right_sample + ( current_right_sample * coeff1r ) + ( previous_right_sample * coeff2r ) + 0x80 ) >> 8; 389
previous_left_sample = current_left_sample; 393
current_left_sample = av_clip_int16 ( next_left_sample ); 394
previous_right_sample = current_right_sample; 395
current_right_sample = av_clip_int16 ( next_right_sample ); 396
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
int coeff [ 2 ] [ 2 ] , shift [ 2 ] 408
for(channel = 0; channel < avctx->channels; channel++) 410
int byte = bytestream2_get_byteu ( & gb ) ; 411
for (i=0; i<2; i++) 412
coeff [ channel ] [ i ] = ea_adpcm_table [ ( byte >> 4 ) + 4 * i ]; 413
shift [ channel ] = 20 - ( byte & 0x0F ); 414
for (count1 = 0; count1 < nb_samples / 2; count1++) 416
int byte [ 2 ] ; 417
byte [ 0 ] = bytestream2_get_byteu ( & gb ); 419
if ( st )  420
byte [ 1 ] = bytestream2_get_byteu ( & gb ); 420
for(i = 4; i >= 0; i-=4) 421
for(channel = 0; channel < avctx->channels; channel++) 422
int sample = sign_extend ( byte [ channel ] >> i , 4 ) << shift [ channel ] ; 423
sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8; 424
c -> status [ channel ] . sample2 = c -> status [ channel ] . sample1; 427
c -> status [ channel ] . sample1 = av_clip_int16 ( sample ); 428
* samples ++ = c -> status [ channel ] . sample1; 429
const int big_endian = avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R3 ; 443
int previous_sample , current_sample , next_sample ; 444
int coeff1 , coeff2 ; 445
int shift ; 446
unsigned int channel ; 447
int offsets [ 6 ] ; 450
for (channel=0; channel<avctx->channels; channel++) 452
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R1 )  461
current_sample = sign_extend ( bytestream2_get_le16 ( & gb ) , 16 ); 462
previous_sample = sign_extend ( bytestream2_get_le16 ( & gb ) , 16 ); 463
current_sample = c -> status [ channel ] . predictor; 465
previous_sample = c -> status [ channel ] . prev_sample; 466
for (count1 = 0; count1 < nb_samples / 28; count1++) 469
int byte = bytestream2_get_byte ( & gb ) ; 470
if ( byte == 0xEE )  471
current_sample = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 472
previous_sample = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 473
coeff1 = ea_adpcm_table [ byte >> 4 ]; 480
coeff2 = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 481
shift = 20 - ( byte & 0x0F ); 482
for (count2=0; count2<28; count2++) 484
if ( count2 & 1 )  485
next_sample = sign_extend ( byte , 4 ) << shift; 486
byte = bytestream2_get_byte ( & gb ); 488
next_sample = sign_extend ( byte >> 4 , 4 ) << shift; 489
next_sample += ( current_sample * coeff1 ) + ( previous_sample * coeff2 ); 492
next_sample = av_clip_int16 ( next_sample >> 8 ); 494
previous_sample = current_sample; 496
current_sample = next_sample; 497
if ( avctx -> codec -> id != AV_CODEC_ID_ADPCM_EA_R1 )  510
c -> status [ channel ] . predictor = current_sample; 511
c -> status [ channel ] . prev_sample = previous_sample; 512
for (channel=0; channel<avctx->channels; channel++) 521
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
int val = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ) ; 525
s [ 0 ] = val & ~0x0F; 528
val = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 530
s [ avctx -> channels ] = val & ~0x0F; 532
for (m=2; m<32; m+=2) 535
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
for (n = nb_samples >> (1 - st); n > 0; n--) 566
for (n = nb_samples >> (1 - st); n > 0; n--) 582
for (n = nb_samples >> (1 - st); n > 0; n--) 600
for (i = 0; i < 2; i++) 648
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
395 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c samplesC = samples + channel 459
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
const uint8_t * buf = avpkt -> data ; 4
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
GetByteContext gb ; 13
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
for (channel = 0; channel < avctx->channels; channel++) 259
cs = & c -> status [ channel ]; 260
cs -> predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 261
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 262
if ( cs -> step_index > 88u )  263
for (n = nb_samples >> (1 - st); n > 0; n--) 270
int v1 , v2 ; 271
int v = bytestream2_get_byteu ( & gb ) ; 272
if ( st )  274
v1 = v >> 4; 275
v2 = v & 0x0F; 276
v2 = v >> 4; 278
v1 = v & 0x0F; 279
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
while ( bytestream2_get_bytes_left ( & gb ) > 0 )  286
int v = bytestream2_get_byteu ( & gb ) ; 287
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
if ( c -> vqa_version == 3 )  293
for (n = nb_samples / 2; n > 0; n--) 306
for (channel = 0; channel < avctx->channels; channel++) 307
int v = bytestream2_get_byteu ( & gb ) ; 308
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
while ( bytestream2_get_bytes_left ( & gb ) >= 128 )  318
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
c -> status [ i ] . step_index = bytestream2_get_le32u ( & gb ); 328
if ( c -> status [ i ] . step_index > 88u )  329
for (i=0; i<=st; i++) 335
c -> status [ i ] . predictor = bytestream2_get_le32u ( & gb ); 336
for (n = nb_samples >> (1 - st); n > 0; n--) 338
int byte = bytestream2_get_byteu ( & gb ) ; 339
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
int byte = bytestream2_get_byteu ( & gb ) ; 346
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
int previous_left_sample , previous_right_sample ; 353
int current_left_sample , current_right_sample ; 354
int next_left_sample , next_right_sample ; 355
int coeff1l , coeff2l , coeff1r , coeff2r ; 356
int shift_left , shift_right ; 357
if ( avctx -> channels != 2 )  362
current_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 365
previous_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 366
current_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 367
previous_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 368
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
int byte = bytestream2_get_byteu ( & gb ) ; 371
coeff1l = ea_adpcm_table [ byte >> 4 ]; 372
coeff2l = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 373
coeff1r = ea_adpcm_table [ byte & 0x0F ]; 374
coeff2r = ea_adpcm_table [ ( byte & 0x0F ) + 4 ]; 375
byte = bytestream2_get_byteu ( & gb ); 377
shift_left = 20 - ( byte >> 4 ); 378
shift_right = 20 - ( byte & 0x0F ); 379
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
next_left_sample = sign_extend ( byte >> 4 , 4 ) << shift_left; 383
next_right_sample = sign_extend ( byte , 4 ) << shift_right; 384
next_left_sample = ( next_left_sample + ( current_left_sample * coeff1l ) + ( previous_left_sample * coeff2l ) + 0x80 ) >> 8; 386
next_right_sample = ( next_right_sample + ( current_right_sample * coeff1r ) + ( previous_right_sample * coeff2r ) + 0x80 ) >> 8; 389
previous_left_sample = current_left_sample; 393
current_left_sample = av_clip_int16 ( next_left_sample ); 394
previous_right_sample = current_right_sample; 395
current_right_sample = av_clip_int16 ( next_right_sample ); 396
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
int coeff [ 2 ] [ 2 ] , shift [ 2 ] 408
for(channel = 0; channel < avctx->channels; channel++) 410
int byte = bytestream2_get_byteu ( & gb ) ; 411
for (i=0; i<2; i++) 412
coeff [ channel ] [ i ] = ea_adpcm_table [ ( byte >> 4 ) + 4 * i ]; 413
shift [ channel ] = 20 - ( byte & 0x0F ); 414
for (count1 = 0; count1 < nb_samples / 2; count1++) 416
int byte [ 2 ] ; 417
byte [ 0 ] = bytestream2_get_byteu ( & gb ); 419
if ( st )  420
byte [ 1 ] = bytestream2_get_byteu ( & gb ); 420
for(i = 4; i >= 0; i-=4) 421
for(channel = 0; channel < avctx->channels; channel++) 422
int sample = sign_extend ( byte [ channel ] >> i , 4 ) << shift [ channel ] ; 423
sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8; 424
c -> status [ channel ] . sample2 = c -> status [ channel ] . sample1; 427
c -> status [ channel ] . sample1 = av_clip_int16 ( sample ); 428
* samples ++ = c -> status [ channel ] . sample1; 429
const int big_endian = avctx -> codec -> id == AV_CODEC_ID_ADPCM_EA_R3 ; 443
unsigned int channel ; 447
uint16_t * samplesC ; 448
int offsets [ 6 ] ; 450
for (channel=0; channel<avctx->channels; channel++) 452
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
------------------------------
396 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8 424
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
GetByteContext gb ; 13
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
for (channel = 0; channel < avctx->channels; channel++) 259
cs = & c -> status [ channel ]; 260
cs -> predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 261
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 262
if ( cs -> step_index > 88u )  263
for (n = nb_samples >> (1 - st); n > 0; n--) 270
int v1 , v2 ; 271
int v = bytestream2_get_byteu ( & gb ) ; 272
if ( st )  274
v1 = v >> 4; 275
v2 = v & 0x0F; 276
v2 = v >> 4; 278
v1 = v & 0x0F; 279
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
while ( bytestream2_get_bytes_left ( & gb ) > 0 )  286
int v = bytestream2_get_byteu ( & gb ) ; 287
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
if ( c -> vqa_version == 3 )  293
for (n = nb_samples / 2; n > 0; n--) 306
for (channel = 0; channel < avctx->channels; channel++) 307
int v = bytestream2_get_byteu ( & gb ) ; 308
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
for (i=0; i<=st; i++) 327
c -> status [ i ] . step_index = bytestream2_get_le32u ( & gb ); 328
if ( c -> status [ i ] . step_index > 88u )  329
for (i=0; i<=st; i++) 335
c -> status [ i ] . predictor = bytestream2_get_le32u ( & gb ); 336
if ( avctx -> channels != 2 )  362
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
byte = bytestream2_get_byteu ( & gb ); 377
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
int coeff [ 2 ] [ 2 ] , shift [ 2 ] 408
for(channel = 0; channel < avctx->channels; channel++) 410
int byte = bytestream2_get_byteu ( & gb ) ; 411
for (i=0; i<2; i++) 412
coeff [ channel ] [ i ] = ea_adpcm_table [ ( byte >> 4 ) + 4 * i ]; 413
shift [ channel ] = 20 - ( byte & 0x0F ); 414
for (count1 = 0; count1 < nb_samples / 2; count1++) 416
int byte [ 2 ] ; 417
byte [ 0 ] = bytestream2_get_byteu ( & gb ); 419
if ( st )  420
byte [ 1 ] = bytestream2_get_byteu ( & gb ); 420
for(i = 4; i >= 0; i-=4) 421
for(channel = 0; channel < avctx->channels; channel++) 422
int sample = sign_extend ( byte [ channel ] >> i , 4 ) << shift [ channel ] ; 423
sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8; 424
c -> status [ channel ] . sample2 = c -> status [ channel ] . sample1; 427
c -> status [ channel ] . sample1 = av_clip_int16 ( sample ); 428
* samples ++ = c -> status [ channel ] . sample1; 429
for (channel=0; channel<avctx->channels; channel++) 452
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
bytestream2_seek ( & gb , offsets [ channel ] , SEEK_SET ); 458
samplesC = samples + channel; 459
current_sample = c -> status [ channel ] . predictor; 465
previous_sample = c -> status [ channel ] . prev_sample; 466
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
next_sample += ( current_sample * coeff1 ) + ( previous_sample * coeff2 ); 492
next_sample = av_clip_int16 ( next_sample >> 8 ); 494
previous_sample = current_sample; 496
current_sample = next_sample; 497
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
c -> status [ channel ] . predictor = current_sample; 511
c -> status [ channel ] . prev_sample = previous_sample; 512
c -> frame . nb_samples = count * 28; 516
for (channel=0; channel<avctx->channels; channel++) 521
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 552
c -> status [ 0 ] . step_index = bytestream2_get_le16u ( & gb ); 553
if ( c -> status [ 0 ] . step_index > 88u )  560
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
if ( ! c -> status [ 0 ] . step_index )  591
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
samples = ( short * ) c -> frame . data [ 0 ] + ch; 658
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
* ( AVFrame * ) data = c -> frame; 699
------------------------------
397 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c next_right_sample = ( next_right_sample + ( current_right_sample * coeff1r ) + ( previous_right_sample * coeff2r ) + 0x80 ) >> 8 389
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
switch ( avctx -> codec -> id )  40
int previous_left_sample , previous_right_sample ; 353
int current_left_sample , current_right_sample ; 354
int next_left_sample , next_right_sample ; 355
int coeff1l , coeff2l , coeff1r , coeff2r ; 356
int shift_left , shift_right ; 357
if ( avctx -> channels != 2 )  362
current_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 367
previous_right_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 368
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
int byte = bytestream2_get_byteu ( & gb ) ; 371
coeff1r = ea_adpcm_table [ byte & 0x0F ]; 374
coeff2r = ea_adpcm_table [ ( byte & 0x0F ) + 4 ]; 375
byte = bytestream2_get_byteu ( & gb ); 377
shift_right = 20 - ( byte & 0x0F ); 379
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
next_right_sample = sign_extend ( byte , 4 ) << shift_right; 384
next_right_sample = ( next_right_sample + ( current_right_sample * coeff1r ) + ( previous_right_sample * coeff2r ) + 0x80 ) >> 8; 389
previous_right_sample = current_right_sample; 395
current_right_sample = av_clip_int16 ( next_right_sample ); 396
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
* samples ++ = c -> status [ channel ] . sample1; 429
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
398 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c next_left_sample = ( next_left_sample + ( current_left_sample * coeff1l ) + ( previous_left_sample * coeff2l ) + 0x80 ) >> 8 386
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
switch ( avctx -> codec -> id )  40
int previous_left_sample , previous_right_sample ; 353
int current_left_sample , current_right_sample ; 354
int next_left_sample , next_right_sample ; 355
int coeff1l , coeff2l , coeff1r , coeff2r ; 356
int shift_left , shift_right ; 357
if ( avctx -> channels != 2 )  362
current_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 365
previous_left_sample = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 366
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
int byte = bytestream2_get_byteu ( & gb ) ; 371
coeff1l = ea_adpcm_table [ byte >> 4 ]; 372
coeff2l = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 373
byte = bytestream2_get_byteu ( & gb ); 377
shift_left = 20 - ( byte >> 4 ); 378
for (count2 = 0; count2 < 28; count2++) 381
byte = bytestream2_get_byteu ( & gb ); 382
next_left_sample = sign_extend ( byte >> 4 , 4 ) << shift_left; 383
next_left_sample = ( next_left_sample + ( current_left_sample * coeff1l ) + ( previous_left_sample * coeff2l ) + 0x80 ) >> 8; 386
previous_left_sample = current_left_sample; 393
current_left_sample = av_clip_int16 ( next_left_sample ); 394
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
* samples ++ = c -> status [ channel ] . sample1; 429
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
399 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c * samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor 254
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
int16_t * smp = samples + channel ; 295
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 299
smp += avctx -> channels; 300
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 301
smp += avctx -> channels; 302
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
return ret ; 321
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
for (i=0; i<=st; i++) 335
for (n = nb_samples >> (1 - st); n > 0; n--) 338
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
if ( st )  420
* samples ++ = c -> status [ channel ] . sample1; 429
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
if ( st )  594
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
for (n = nb_samples >> (2 - st); n > 0; n--) 618
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
for (n = nb_samples >> (1 - st); n > 0; n--) 636
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
for (n = 0; n < 16; n++) 649
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (ch = 0; ch <= st; ch++) 657
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
400 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c * samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor 253
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
int16_t * smp = samples + channel ; 295
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 299
smp += avctx -> channels; 300
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 301
smp += avctx -> channels; 302
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
return ret ; 321
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
for (i=0; i<=st; i++) 335
for (n = nb_samples >> (1 - st); n > 0; n--) 338
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
if ( st )  420
* samples ++ = c -> status [ channel ] . sample1; 429
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
if ( st )  594
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
for (n = nb_samples >> (2 - st); n > 0; n--) 618
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
for (n = nb_samples >> (1 - st); n > 0; n--) 636
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
for (n = 0; n < 16; n++) 649
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (ch = 0; ch <= st; ch++) 657
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
401 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c diff_channel = ( diff_channel + c -> status [ 1 ] . predictor ) / 2 252
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
int diff_channel ; 202
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
diff_channel = c -> status [ 1 ] . predictor; 216
while ( samples < samples_end )  229
diff_channel = ( diff_channel + c -> status [ 1 ] . predictor ) / 2; 243
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
diff_channel = ( diff_channel + c -> status [ 1 ] . predictor ) / 2; 252
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
------------------------------
402 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c * samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor 245
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
int16_t * smp = samples + channel ; 295
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 299
smp += avctx -> channels; 300
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 301
smp += avctx -> channels; 302
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
return ret ; 321
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
for (i=0; i<=st; i++) 335
for (n = nb_samples >> (1 - st); n > 0; n--) 338
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
if ( st )  420
* samples ++ = c -> status [ channel ] . sample1; 429
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
if ( st )  594
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
for (n = nb_samples >> (2 - st); n > 0; n--) 618
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
for (n = nb_samples >> (1 - st); n > 0; n--) 636
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
for (n = 0; n < 16; n++) 649
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (ch = 0; ch <= st; ch++) 657
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
403 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c * samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor 244
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
int16_t * smp = samples + channel ; 295
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 299
smp += avctx -> channels; 300
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 301
smp += avctx -> channels; 302
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 309
samples [ st ] = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 310
samples += avctx -> channels; 312
if ( ( ret = xa_decode ( avctx , samples , buf + bytestream2_tell ( & gb ) , & c -> status [ 0 ] , & c -> status [ 1 ] , avctx -> channels ) ) < 0 )  319
return ret ; 321
samples += 28 * 8; 323
for (i=0; i<=st; i++) 327
for (i=0; i<=st; i++) 335
for (n = nb_samples >> (1 - st); n > 0; n--) 338
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 3 ); 340
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 3 ); 341
for (n = nb_samples >> (1 - st); n > 0; n--) 345
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 6 ); 347
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 6 ); 348
* samples ++ = current_left_sample; 397
* samples ++ = current_right_sample; 398
if ( st )  420
* samples ++ = c -> status [ channel ] . sample1; 429
samplesC = samples + channel; 459
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
if ( st )  594
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
for (n = nb_samples >> (2 - st); n > 0; n--) 618
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
for (n = nb_samples >> (1 - st); n > 0; n--) 636
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
for (n = 0; n < 16; n++) 649
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
for (ch = 0; ch <= st; ch++) 657
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
------------------------------
404 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c diff_channel = ( diff_channel + c -> status [ 1 ] . predictor ) / 2 243
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
int diff_channel ; 202
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
diff_channel = c -> status [ 1 ] . predictor; 216
while ( samples < samples_end )  229
diff_channel = ( diff_channel + c -> status [ 1 ] . predictor ) / 2; 243
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
diff_channel = ( diff_channel + c -> status [ 1 ] . predictor ) / 2; 252
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
------------------------------
405 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c id_list [ i ] = h -> short_ref_count + k 750
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
h -> ref_count [ 1 ] = 1; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> list_count = 1; 582
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
h -> use_weight = 0; 612
for (i = 0; i < 2; i++) 613
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
h0 -> max_contexts = 1; 703
if ( ! h0 -> single_decode_warning )  704
h0 -> single_decode_warning = 1; 707
if ( h != h0 )  709
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h0 -> last_slice_type = slice_type; 723
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
for (j = 0; j < 2; j++) 735
int id_list [ 16 ] ; 736
for (i = 0; i < 16; i++) 738
id_list [ i ] = 60; 739
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
int k ; 741
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
------------------------------
406 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ) 646
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
h -> ref_count [ 1 ] = 1; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> list_count = 1; 582
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
h -> use_weight = 0; 612
for (i = 0; i < 2; i++) 613
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
407 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE 517
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
if ( s -> picture_structure == PICT_FRAME )  522
get_ue_golomb ( & s -> gb ); 531
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
init_poc ( h ); 547
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
h -> ref_count [ 1 ] = 1; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
ff_h264_fill_default_ref_list ( h ); 587
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 597
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 601
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  626
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  632
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 639
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
408 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 356
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 433
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 440
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 441
ff_generate_sliding_window_mmcos ( h ); 442
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 454
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
if ( ff_h264_frame_start ( h ) < 0 )  497
ff_release_unused_pictures ( s , 0 ); 502
if ( h != h0 )  505
clone_slice ( h , h0 ); 506
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 513
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> nal_unit_type == NAL_IDR_SLICE )  530
get_ue_golomb ( & s -> gb ); 531
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
init_poc ( h ); 547
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
h -> ref_count [ 1 ] = 1; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
ff_h264_fill_default_ref_list ( h ); 587
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 597
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 601
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  626
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  632
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 639
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
409 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ) 327
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
av_log ( h -> s . avctx , AV_LOG_ERROR , "Changing field mode (%d -> %d) between slices is not allowed\n" , last_pic_structure , s -> picture_structure ); 338
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid field mode combination %d/%d\n" , last_pic_structure , s -> picture_structure ); 404
if ( last_pic_dropable != s -> dropable )  410
av_log ( s -> avctx , AV_LOG_ERROR , "Cannot combine reference and non-reference fields in the same frame\n" ); 411
av_log_ask_for_sample ( s -> avctx , NULL ); 413
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 433
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 440
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 441
ff_generate_sliding_window_mmcos ( h ); 442
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 454
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
if ( ff_h264_frame_start ( h ) < 0 )  497
ff_release_unused_pictures ( s , 0 ); 502
if ( h != h0 )  505
clone_slice ( h , h0 ); 506
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 513
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> nal_unit_type == NAL_IDR_SLICE )  530
get_ue_golomb ( & s -> gb ); 531
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
init_poc ( h ); 547
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
h -> ref_count [ 1 ] = 1; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
ff_h264_fill_default_ref_list ( h ); 587
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 597
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 601
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  626
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  632
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 639
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
410 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c id_list [ i ] = h -> short_ref_count + k 750
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> list_count = 1; 582
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
h -> use_weight = 0; 612
for (i = 0; i < 2; i++) 613
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
h0 -> max_contexts = 1; 703
if ( ! h0 -> single_decode_warning )  704
h0 -> single_decode_warning = 1; 707
if ( h != h0 )  709
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h0 -> last_slice_type = slice_type; 723
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
for (j = 0; j < 2; j++) 735
int id_list [ 16 ] ; 736
for (i = 0; i < 16; i++) 738
id_list [ i ] = 60; 739
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
int k ; 741
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
id_list [ i ] = k; 745
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
------------------------------
411 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ) 646
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> list_count = 1; 582
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
h -> use_weight = 0; 612
for (i = 0; i < 2; i++) 613
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
412 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE 517
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
if ( s -> picture_structure == PICT_FRAME )  522
get_ue_golomb ( & s -> gb ); 531
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
init_poc ( h ); 547
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
ff_h264_fill_default_ref_list ( h ); 587
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 597
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 601
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
pred_weight_table ( h ); 607
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
implicit_weight_table ( h , - 1 ); 610
h -> use_weight = 0; 612
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
ff_h264_fill_mbaff_ref_list ( h ); 624
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  626
implicit_weight_table ( h , 0 ); 627
implicit_weight_table ( h , 1 ); 628
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  632
ff_h264_direct_dist_scale_factor ( h ); 633
ff_h264_direct_ref_list_init ( h ); 634
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 639
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
413 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 356
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 433
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 440
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 441
ff_generate_sliding_window_mmcos ( h ); 442
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 454
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
if ( ff_h264_frame_start ( h ) < 0 )  497
ff_release_unused_pictures ( s , 0 ); 502
if ( h != h0 )  505
clone_slice ( h , h0 ); 506
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 513
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> nal_unit_type == NAL_IDR_SLICE )  530
get_ue_golomb ( & s -> gb ); 531
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
init_poc ( h ); 547
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
ff_h264_fill_default_ref_list ( h ); 587
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 597
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 601
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
pred_weight_table ( h ); 607
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
implicit_weight_table ( h , - 1 ); 610
h -> use_weight = 0; 612
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
ff_h264_fill_mbaff_ref_list ( h ); 624
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  626
implicit_weight_table ( h , 0 ); 627
implicit_weight_table ( h , 1 ); 628
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  632
ff_h264_direct_dist_scale_factor ( h ); 633
ff_h264_direct_ref_list_init ( h ); 634
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 639
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
414 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ) 327
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
if ( h -> sps . frame_mbs_only_flag )  319
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
av_log ( h -> s . avctx , AV_LOG_ERROR , "Changing field mode (%d -> %d) between slices is not allowed\n" , last_pic_structure , s -> picture_structure ); 338
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid field mode combination %d/%d\n" , last_pic_structure , s -> picture_structure ); 404
if ( last_pic_dropable != s -> dropable )  410
av_log ( s -> avctx , AV_LOG_ERROR , "Cannot combine reference and non-reference fields in the same frame\n" ); 411
av_log_ask_for_sample ( s -> avctx , NULL ); 413
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 433
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 440
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 441
ff_generate_sliding_window_mmcos ( h ); 442
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 454
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
if ( ff_h264_frame_start ( h ) < 0 )  497
ff_release_unused_pictures ( s , 0 ); 502
if ( h != h0 )  505
clone_slice ( h , h0 ); 506
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
assert ( s -> mb_num == s -> mb_width * s -> mb_height ); 510
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 513
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
assert ( s -> mb_y < s -> mb_height ); 520
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> nal_unit_type == NAL_IDR_SLICE )  530
get_ue_golomb ( & s -> gb ); 531
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
init_poc ( h ); 547
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
ff_h264_fill_default_ref_list ( h ); 587
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 597
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 601
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
pred_weight_table ( h ); 607
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
implicit_weight_table ( h , - 1 ); 610
h -> use_weight = 0; 612
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
ff_h264_fill_mbaff_ref_list ( h ); 624
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  626
implicit_weight_table ( h , 0 ); 627
implicit_weight_table ( h , 1 ); 628
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  632
ff_h264_direct_dist_scale_factor ( h ); 633
ff_h264_direct_ref_list_init ( h ); 634
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 639
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 648
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  655
get_bits1 ( & s -> gb ); 656
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  657
get_se_golomb ( & s -> gb ); 659
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 667
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 680
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h -> deblocking_filter = 2; 701
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 705
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 710
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 716
h -> slice_num = ++ h0 -> current_slice; 724
if ( h -> slice_num )  726
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 727
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  728
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 732
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 737
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
for (k = 0; k < h->short_ref_count; k++) 743
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
for (k = 0; k < h->long_ref_count; k++) 748
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 756
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 769
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 773
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  775
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 776
------------------------------
415 /home/SySeVR/data/CVE_2013_0856_PATCHED_lpc_prediction.c val = d - pred [ j ] 54
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,
int nb_samples, int bps, int16_t *lpc_coefs,
int lpc_order, int lpc_quant) 3
int i ; 5
int32_t * pred = buffer_out ; 6
* buffer_out = * error_buffer; 9
if ( nb_samples <= 1 )  11
if ( ! lpc_order )  14
if ( lpc_order == 31 )  20
for (i = 1; i <= lpc_order && i < nb_samples; i++) 30
buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps ); 31
for (; i < nb_samples; i++) 35
int j ; 36
int val = 0 ; 37
int error_val = error_buffer [ i ] ; 38
int error_sign ; 39
int d = * pred ++ ; 40
for (j = 0; j < lpc_order; j++) 43
val += ( pred [ j ] - d ) * lpc_coefs [ j ]; 44
val = ( val + ( 1 << ( lpc_quant - 1 ) ) ) >> lpc_quant; 45
val += d + error_val; 46
buffer_out [ i ] = sign_extend ( val , bps ); 47
error_sign = sign_only ( error_val ); 50
if ( error_sign )  51
for (j = 0; j < lpc_order && error_val * error_sign > 0; j++) 52
int sign ; 53
val = d - pred [ j ]; 54
sign = sign_only ( val ) * error_sign; 55
lpc_coefs [ j ] -= sign; 56
val *= sign; 57
error_val -= ( val >> lpc_quant ) * ( j + 1 ); 58
------------------------------
416 /home/SySeVR/data/CVE_2013_0859_PATCHED_add_doubles_metadata.c dp = av_malloc ( count * sizeof ( double ) ) 14
static int CVE_2013_0859_PATCHED_add_doubles_metadata(int count,
const char *name, const char *sep,
TiffContext *s) 3
double * dp ; 7
if ( count >= INT_MAX / sizeof ( int64_t ) || count <= 0 )  9
if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) )  11
dp = av_malloc ( count * sizeof ( double ) ); 14
if ( ! dp )  15
dp [ i ] = tget_double ( & s -> gb , s -> le ); 19
ap = doubles2str ( dp , count , sep ); 20
av_freep ( & dp ); 21
if ( ! ap )  22
av_dict_set ( & s -> picture . metadata , name , ap , AV_DICT_DONT_STRDUP_VAL ); 24
------------------------------
417 /home/SySeVR/data/CVE_2013_0859_VULN_add_doubles_metadata.c dp = av_malloc ( count * sizeof ( double ) ) 14
static int CVE_2013_0859_VULN_add_doubles_metadata(int count,
const char *name, const char *sep,
TiffContext *s) 3
double * dp ; 7
if ( count >= INT_MAX / sizeof ( int64_t ) )  9
if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) )  11
dp = av_malloc ( count * sizeof ( double ) ); 14
if ( ! dp )  15
dp [ i ] = tget_double ( & s -> gb , s -> le ); 19
ap = doubles2str ( dp , count , sep ); 20
av_freep ( & dp ); 21
if ( ! ap )  22
av_dict_set ( & s -> picture . metadata , name , ap , AV_DICT_DONT_STRDUP_VAL ); 24
------------------------------
418 /home/SySeVR/data/CVE_2013_0862_VULN_process_frame_obj.c ctx -> avctx -> height = FFMAX ( top + h , ctx -> height ) 13
static int CVE_2013_0862_VULN_process_frame_obj(SANMVideoContext *ctx) 1
uint16_t codec , top , left , w , h ; 3
left = bytestream2_get_le16u ( & ctx -> gb ); 6
top = bytestream2_get_le16u ( & ctx -> gb ); 7
w = bytestream2_get_le16u ( & ctx -> gb ); 8
h = bytestream2_get_le16u ( & ctx -> gb ); 9
if ( ctx -> width < left + w || ctx -> height < top + h )  11
ctx -> avctx -> width = FFMAX ( left + w , ctx -> width ); 12
ctx -> avctx -> height = FFMAX ( top + h , ctx -> height ); 13
init_sizes ( ctx , left + w , top + h ); 14
if ( init_buffers ( ctx ) )  15
av_log ( ctx -> avctx , AV_LOG_ERROR , "error resizing buffers\n" ); 16
bytestream2_skip ( & ctx -> gb , 4 ); 20
av_dlog ( ctx -> avctx , "subcodec %d\n" , codec ); 22
return old_codec1 ( ctx , top , left , w , h ) ; 26
return old_codec37 ( ctx , top , left , w , h ) ; 29
return old_codec47 ( ctx , top , left , w , h ) ; 32
av_log_ask_for_sample ( ctx -> avctx , "unknown subcodec %d\n" , codec ); 35
------------------------------
419 /home/SySeVR/data/CVE_2013_0862_VULN_process_frame_obj.c ctx -> avctx -> width = FFMAX ( left + w , ctx -> width ) 12
static int CVE_2013_0862_VULN_process_frame_obj(SANMVideoContext *ctx) 1
uint16_t codec , top , left , w , h ; 3
left = bytestream2_get_le16u ( & ctx -> gb ); 6
top = bytestream2_get_le16u ( & ctx -> gb ); 7
w = bytestream2_get_le16u ( & ctx -> gb ); 8
h = bytestream2_get_le16u ( & ctx -> gb ); 9
if ( ctx -> width < left + w || ctx -> height < top + h )  11
ctx -> avctx -> width = FFMAX ( left + w , ctx -> width ); 12
ctx -> avctx -> height = FFMAX ( top + h , ctx -> height ); 13
init_sizes ( ctx , left + w , top + h ); 14
if ( init_buffers ( ctx ) )  15
av_log ( ctx -> avctx , AV_LOG_ERROR , "error resizing buffers\n" ); 16
bytestream2_skip ( & ctx -> gb , 4 ); 20
av_dlog ( ctx -> avctx , "subcodec %d\n" , codec ); 22
return old_codec1 ( ctx , top , left , w , h ) ; 26
return old_codec37 ( ctx , top , left , w , h ) ; 29
return old_codec47 ( ctx , top , left , w , h ) ; 32
av_log_ask_for_sample ( ctx -> avctx , "unknown subcodec %d\n" , codec ); 35
------------------------------
420 /home/SySeVR/data/CVE_2013_0864_PATCHED_gif_copy_img_rect.c src_pr = src_px + w 14
static void CVE_2013_0864_PATCHED_gif_copy_img_rect(const uint32_t *src, uint32_t *dst,
int linesize, int l, int t, int w, int h) 2
const int y_start = t * linesize ; 4
const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
const uint32_t * src_pb = src_py + h * linesize ; 8
for (; src_py < src_pb; src_py += linesize, dst_py += linesize) 11
src_px = src_py + l; 12
src_pr = src_px + w; 14
for (; src_px < src_pr; src_px++, dst_px++) 16
------------------------------
421 /home/SySeVR/data/CVE_2013_0864_PATCHED_gif_copy_img_rect.c dst_px = ( uint32_t * ) dst_py + l 13
static void CVE_2013_0864_PATCHED_gif_copy_img_rect(const uint32_t *src, uint32_t *dst,
int linesize, int l, int t, int w, int h) 2
const int y_start = t * linesize ; 4
const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
const uint32_t * src_pb = src_py + h * linesize ; 8
uint32_t * dst_px ; 9
for (; src_py < src_pb; src_py += linesize, dst_py += linesize) 11
dst_px = ( uint32_t * ) dst_py + l; 13
for (; src_px < src_pr; src_px++, dst_px++) 16
* dst_px = * src_px; 17
------------------------------
422 /home/SySeVR/data/CVE_2013_0864_PATCHED_gif_copy_img_rect.c src_px = src_py + l 12
static void CVE_2013_0864_PATCHED_gif_copy_img_rect(const uint32_t *src, uint32_t *dst,
int linesize, int l, int t, int w, int h) 2
const int y_start = t * linesize ; 4
const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
const uint32_t * src_pb = src_py + h * linesize ; 8
for (; src_py < src_pb; src_py += linesize, dst_py += linesize) 11
src_px = src_py + l; 12
src_pr = src_px + w; 14
for (; src_px < src_pr; src_px++, dst_px++) 16
* dst_px = * src_px; 17
------------------------------
423 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c id_list [ i ] = h -> short_ref_count + k 651
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  220
if ( ! s0 -> current_picture_ptr )  228
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( s0 -> first_field )  357
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
s0 -> current_picture_ptr = NULL; 366
s0 -> first_field = FIELD_PICTURE; 367
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
s0 -> first_field = 1; 375
s0 -> current_picture_ptr = NULL; 376
s0 -> first_field = 0; 379
s0 -> first_field = FIELD_PICTURE; 384
if ( ! FIELD_PICTURE || s0 -> first_field )  387
if ( ff_h264_frame_start ( h ) < 0 )  388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  396
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
if ( s -> picture_structure == PICT_FRAME )  413
h -> curr_pic_num = h -> frame_num; 414
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 415
h -> curr_pic_num = 2 * h -> frame_num + 1; 417
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 418
if ( h -> sps . poc_type == 0 )  424
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
unsigned max [ 2 ] ; 448
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  451
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 452
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 453
if ( num_ref_idx_active_override_flag )  455
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 456
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 458
h -> ref_count [ 1 ] = 1; 461
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  470
h -> list_count = 2; 471
h -> list_count = 1; 473
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 475
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  480
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  486
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 487
s -> last_picture_ptr -> owner2 = s; 488
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  491
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 492
s -> next_picture_ptr -> owner2 = s; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & s -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
s -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 554
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & s -> gb ); 566
if ( tmp > 2 )  567
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h -> deblocking_filter = 2; 602
h0 -> max_contexts = 1; 604
if ( ! h0 -> single_decode_warning )  605
h0 -> single_decode_warning = 1; 608
if ( h != h0 )  610
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 617
h0 -> last_slice_type = slice_type; 624
h -> slice_num = ++ h0 -> current_slice; 625
if ( h -> slice_num )  627
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 628
for (j = 0; j < 2; j++) 636
int id_list [ 16 ] ; 637
for (i = 0; i < 16; i++) 639
id_list [ i ] = 60; 640
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  641
int k ; 642
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 643
for (k = 0; k < h->short_ref_count; k++) 644
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  645
for (k = 0; k < h->long_ref_count; k++) 649
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  650
id_list [ i ] = h -> short_ref_count + k; 651
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 660
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 662
for (i = 16; i < 48; i++) 664
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 665
------------------------------
424 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ) 547
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  220
if ( ! s0 -> current_picture_ptr )  228
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( s0 -> first_field )  357
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
s0 -> current_picture_ptr = NULL; 366
s0 -> first_field = FIELD_PICTURE; 367
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
s0 -> first_field = 1; 375
s0 -> current_picture_ptr = NULL; 376
s0 -> first_field = 0; 379
s0 -> first_field = FIELD_PICTURE; 384
if ( ! FIELD_PICTURE || s0 -> first_field )  387
if ( ff_h264_frame_start ( h ) < 0 )  388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  396
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
if ( s -> picture_structure == PICT_FRAME )  413
h -> curr_pic_num = h -> frame_num; 414
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 415
h -> curr_pic_num = 2 * h -> frame_num + 1; 417
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 418
if ( h -> sps . poc_type == 0 )  424
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
unsigned max [ 2 ] ; 448
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  451
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 452
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 453
if ( num_ref_idx_active_override_flag )  455
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 456
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 458
h -> ref_count [ 1 ] = 1; 461
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  470
h -> list_count = 2; 471
h -> list_count = 1; 473
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 475
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  480
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  486
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 487
s -> last_picture_ptr -> owner2 = s; 488
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  491
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 492
s -> next_picture_ptr -> owner2 = s; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & s -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 549
s -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 554
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  556
get_bits1 ( & s -> gb ); 557
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  558
get_se_golomb ( & s -> gb ); 560
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & s -> gb ); 566
if ( tmp > 2 )  567
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 568
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 581
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h -> deblocking_filter = 2; 602
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 606
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 611
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 617
h -> slice_num = ++ h0 -> current_slice; 625
if ( h -> slice_num )  627
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 628
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  629
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 633
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 638
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  641
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 643
for (k = 0; k < h->short_ref_count; k++) 644
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  645
for (k = 0; k < h->long_ref_count; k++) 649
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  650
id_list [ i ] = h -> short_ref_count + k; 651
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 657
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 660
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 662
for (i = 16; i < 48; i++) 664
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 665
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 670
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 674
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  676
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 677
------------------------------
425 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE 408
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  220
if ( ! s0 -> current_picture_ptr )  228
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( s0 -> first_field )  357
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
s0 -> current_picture_ptr = NULL; 366
s0 -> first_field = FIELD_PICTURE; 367
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
s0 -> first_field = 1; 375
s0 -> current_picture_ptr = NULL; 376
s0 -> first_field = 0; 379
s0 -> first_field = FIELD_PICTURE; 384
if ( ! FIELD_PICTURE || s0 -> first_field )  387
if ( ff_h264_frame_start ( h ) < 0 )  388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  396
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
av_assert1 ( s -> mb_y < s -> mb_height ); 411
if ( s -> picture_structure == PICT_FRAME )  413
get_ue_golomb ( & s -> gb ); 422
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
init_poc ( h ); 438
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  451
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 452
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 453
if ( num_ref_idx_active_override_flag )  455
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 456
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 458
h -> ref_count [ 1 ] = 1; 461
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 465
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 466
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  470
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 475
ff_h264_fill_default_ref_list ( h ); 478
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  480
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  486
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 487
s -> last_picture_ptr -> owner2 = s; 488
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 489
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  491
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 492
s -> next_picture_ptr -> owner2 = s; 493
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 494
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  527
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  533
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & s -> gb ); 538
if ( tmp > 2 )  539
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 540
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 549
s -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 554
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  556
get_bits1 ( & s -> gb ); 557
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  558
get_se_golomb ( & s -> gb ); 560
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & s -> gb ); 566
if ( tmp > 2 )  567
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 568
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 581
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h -> deblocking_filter = 2; 602
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 606
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 611
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 617
h -> slice_num = ++ h0 -> current_slice; 625
if ( h -> slice_num )  627
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 628
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  629
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 633
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 638
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  641
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 643
for (k = 0; k < h->short_ref_count; k++) 644
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  645
for (k = 0; k < h->long_ref_count; k++) 649
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  650
id_list [ i ] = h -> short_ref_count + k; 651
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 657
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 660
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 662
for (i = 16; i < 48; i++) 664
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 665
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 670
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 674
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  676
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 677
------------------------------
426 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 245
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 322
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 329
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 330
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
return ret ; 333
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 345
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
if ( ff_h264_frame_start ( h ) < 0 )  388
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
av_assert1 ( s -> mb_num == s -> mb_width * s -> mb_height ); 401
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 404
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
av_assert1 ( s -> mb_y < s -> mb_height ); 411
if ( s -> picture_structure == PICT_FRAME )  413
h -> curr_pic_num = h -> frame_num; 414
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 415
h -> curr_pic_num = 2 * h -> frame_num + 1; 417
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 418
if ( h -> nal_unit_type == NAL_IDR_SLICE )  421
get_ue_golomb ( & s -> gb ); 422
if ( h -> sps . poc_type == 0 )  424
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
init_poc ( h ); 438
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  451
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 452
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 453
if ( num_ref_idx_active_override_flag )  455
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 456
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 458
h -> ref_count [ 1 ] = 1; 461
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 465
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 466
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  470
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 475
ff_h264_fill_default_ref_list ( h ); 478
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  480
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  486
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 487
s -> last_picture_ptr -> owner2 = s; 488
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 489
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  491
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 492
s -> next_picture_ptr -> owner2 = s; 493
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 494
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  527
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  533
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & s -> gb ); 538
if ( tmp > 2 )  539
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 540
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 549
s -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 554
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  556
get_bits1 ( & s -> gb ); 557
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  558
get_se_golomb ( & s -> gb ); 560
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & s -> gb ); 566
if ( tmp > 2 )  567
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 568
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 581
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h -> deblocking_filter = 2; 602
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 606
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 611
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 617
h -> slice_num = ++ h0 -> current_slice; 625
if ( h -> slice_num )  627
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 628
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  629
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 633
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 638
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  641
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 643
for (k = 0; k < h->short_ref_count; k++) 644
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  645
for (k = 0; k < h->long_ref_count; k++) 649
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  650
id_list [ i ] = h -> short_ref_count + k; 651
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 657
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 660
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 662
for (i = 16; i < 48; i++) 664
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 665
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 670
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 674
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  676
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 677
------------------------------
427 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ) 211
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
if ( h -> sps . frame_mbs_only_flag )  203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  220
av_log ( h -> s . avctx , AV_LOG_ERROR , "Changing field mode (%d -> %d) between slices is not allowed\n" , last_pic_structure , s -> picture_structure ); 222
av_log ( s -> avctx , AV_LOG_ERROR , "unset current_picture_ptr on %d. slice\n" , h0 -> current_slice + 1 ); 229
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid field mode combination %d/%d\n" , last_pic_structure , s -> picture_structure ); 293
if ( last_pic_droppable != s -> droppable )  299
av_log ( s -> avctx , AV_LOG_ERROR , "Cannot combine reference and non-reference fields in the same frame\n" ); 300
av_log_ask_for_sample ( s -> avctx , NULL ); 302
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 322
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 329
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 330
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
return ret ; 333
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 345
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
if ( ff_h264_frame_start ( h ) < 0 )  388
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
av_assert1 ( s -> mb_num == s -> mb_width * s -> mb_height ); 401
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 404
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
av_assert1 ( s -> mb_y < s -> mb_height ); 411
if ( s -> picture_structure == PICT_FRAME )  413
h -> curr_pic_num = h -> frame_num; 414
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 415
h -> curr_pic_num = 2 * h -> frame_num + 1; 417
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 418
if ( h -> nal_unit_type == NAL_IDR_SLICE )  421
get_ue_golomb ( & s -> gb ); 422
if ( h -> sps . poc_type == 0 )  424
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
init_poc ( h ); 438
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  451
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 452
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 453
if ( num_ref_idx_active_override_flag )  455
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 456
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 458
h -> ref_count [ 1 ] = 1; 461
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 465
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 466
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  470
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 475
ff_h264_fill_default_ref_list ( h ); 478
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  480
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 482
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  486
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 487
s -> last_picture_ptr -> owner2 = s; 488
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 489
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  491
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 492
s -> next_picture_ptr -> owner2 = s; 493
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 494
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  527
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  533
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & s -> gb ); 538
if ( tmp > 2 )  539
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 540
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 549
s -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 554
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  556
get_bits1 ( & s -> gb ); 557
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  558
get_se_golomb ( & s -> gb ); 560
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & s -> gb ); 566
if ( tmp > 2 )  567
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 568
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 581
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h -> deblocking_filter = 2; 602
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 606
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 611
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 617
h -> slice_num = ++ h0 -> current_slice; 625
if ( h -> slice_num )  627
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 628
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  629
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 633
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 638
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  641
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 643
for (k = 0; k < h->short_ref_count; k++) 644
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  645
for (k = 0; k < h->long_ref_count; k++) 649
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  650
id_list [ i ] = h -> short_ref_count + k; 651
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 657
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 660
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 662
for (i = 16; i < 48; i++) 664
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 665
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 670
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 674
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  676
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 677
------------------------------
428 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c id_list [ i ] = h -> short_ref_count + k 650
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  219
if ( ! s0 -> current_picture_ptr )  227
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( s0 -> first_field )  356
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
s0 -> current_picture_ptr = NULL; 365
s0 -> first_field = FIELD_PICTURE; 366
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
s0 -> first_field = 1; 374
s0 -> current_picture_ptr = NULL; 375
s0 -> first_field = 0; 378
s0 -> first_field = FIELD_PICTURE; 383
if ( ! FIELD_PICTURE || s0 -> first_field )  386
if ( ff_h264_frame_start ( h ) < 0 )  387
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
if ( s -> picture_structure == PICT_FRAME )  412
h -> curr_pic_num = h -> frame_num; 413
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 414
h -> curr_pic_num = 2 * h -> frame_num + 1; 416
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 417
if ( h -> sps . poc_type == 0 )  423
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
unsigned max [ 2 ] ; 447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  450
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 451
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 452
if ( num_ref_idx_active_override_flag )  454
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  456
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 457
h -> ref_count [ 1 ] = 1; 460
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 465
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  469
h -> list_count = 2; 470
h -> list_count = 1; 472
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 474
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  479
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 481
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  485
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 486
s -> last_picture_ptr -> owner2 = s; 487
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  490
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 491
s -> next_picture_ptr -> owner2 = s; 492
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  496
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  500
h -> use_weight = 0; 504
for (i = 0; i < 2; i++) 505
h -> luma_weight_flag [ i ] = 0; 506
h -> chroma_weight_flag [ i ] = 0; 507
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  516
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  536
tmp = get_ue_golomb_31 ( & s -> gb ); 537
if ( tmp > 2 )  538
h -> cabac_init_idc = tmp; 542
h -> last_qscale_diff = 0; 545
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 546
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  547
s -> qscale = tmp; 551
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 552
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 553
h -> deblocking_filter = 1; 561
h -> slice_alpha_c0_offset = 52; 562
h -> slice_beta_offset = 52; 563
if ( h -> pps . deblocking_filter_parameters_present )  564
tmp = get_ue_golomb_31 ( & s -> gb ); 565
if ( tmp > 2 )  566
h -> deblocking_filter = tmp; 571
if ( h -> deblocking_filter < 2 )  572
h -> deblocking_filter ^= 1; 573
if ( h -> deblocking_filter )  575
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 576
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 577
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  578
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  588
h -> deblocking_filter = 0; 595
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  597
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  598
h -> deblocking_filter = 2; 601
h0 -> max_contexts = 1; 603
if ( ! h0 -> single_decode_warning )  604
h0 -> single_decode_warning = 1; 607
if ( h != h0 )  609
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 616
h0 -> last_slice_type = slice_type; 623
h -> slice_num = ++ h0 -> current_slice; 624
if ( h -> slice_num )  626
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 627
for (j = 0; j < 2; j++) 635
int id_list [ 16 ] ; 636
for (i = 0; i < 16; i++) 638
id_list [ i ] = 60; 639
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  640
int k ; 641
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 642
for (k = 0; k < h->short_ref_count; k++) 643
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  644
id_list [ i ] = k; 645
for (k = 0; k < h->long_ref_count; k++) 648
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  649
id_list [ i ] = h -> short_ref_count + k; 650
for (i = 0; i < 16; i++) 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 659
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 661
for (i = 16; i < 48; i++) 663
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 664
------------------------------
429 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ) 546
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  219
if ( ! s0 -> current_picture_ptr )  227
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( s0 -> first_field )  356
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
s0 -> current_picture_ptr = NULL; 365
s0 -> first_field = FIELD_PICTURE; 366
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
s0 -> first_field = 1; 374
s0 -> current_picture_ptr = NULL; 375
s0 -> first_field = 0; 378
s0 -> first_field = FIELD_PICTURE; 383
if ( ! FIELD_PICTURE || s0 -> first_field )  386
if ( ff_h264_frame_start ( h ) < 0 )  387
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
if ( s -> picture_structure == PICT_FRAME )  412
h -> curr_pic_num = h -> frame_num; 413
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 414
h -> curr_pic_num = 2 * h -> frame_num + 1; 416
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 417
if ( h -> sps . poc_type == 0 )  423
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
unsigned max [ 2 ] ; 447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  450
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 451
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 452
if ( num_ref_idx_active_override_flag )  454
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  456
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 457
h -> ref_count [ 1 ] = 1; 460
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 465
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  469
h -> list_count = 2; 470
h -> list_count = 1; 472
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 474
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  479
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 481
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  485
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 486
s -> last_picture_ptr -> owner2 = s; 487
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  490
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 491
s -> next_picture_ptr -> owner2 = s; 492
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  496
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  500
h -> use_weight = 0; 504
for (i = 0; i < 2; i++) 505
h -> luma_weight_flag [ i ] = 0; 506
h -> chroma_weight_flag [ i ] = 0; 507
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  516
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  536
tmp = get_ue_golomb_31 ( & s -> gb ); 537
if ( tmp > 2 )  538
h -> cabac_init_idc = tmp; 542
h -> last_qscale_diff = 0; 545
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 546
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  547
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 548
s -> qscale = tmp; 551
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 552
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 553
if ( h -> slice_type == AV_PICTURE_TYPE_SP )  555
get_bits1 ( & s -> gb ); 556
if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI )  557
get_se_golomb ( & s -> gb ); 559
h -> deblocking_filter = 1; 561
h -> slice_alpha_c0_offset = 52; 562
h -> slice_beta_offset = 52; 563
if ( h -> pps . deblocking_filter_parameters_present )  564
tmp = get_ue_golomb_31 ( & s -> gb ); 565
if ( tmp > 2 )  566
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking_filter_idc %u out of range\n" , tmp ); 567
h -> deblocking_filter = tmp; 571
if ( h -> deblocking_filter < 2 )  572
h -> deblocking_filter ^= 1; 573
if ( h -> deblocking_filter )  575
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 576
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 577
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  578
av_log ( s -> avctx , AV_LOG_ERROR , "deblocking filter parameters %d %d out of range\n" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ); 580
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  588
h -> deblocking_filter = 0; 595
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  597
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  598
h -> deblocking_filter = 2; 601
av_log ( s -> avctx , AV_LOG_INFO , "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n" ); 605
av_log ( h -> s . avctx , AV_LOG_ERROR , "Deblocking switched inside frame.\n" ); 610
h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ); 616
h -> slice_num = ++ h0 -> current_slice; 624
if ( h -> slice_num )  626
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 627
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  628
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 632
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 637
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  640
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 642
for (k = 0; k < h->short_ref_count; k++) 643
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  644
for (k = 0; k < h->long_ref_count; k++) 648
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  649
id_list [ i ] = h -> short_ref_count + k; 650
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 656
for (i = 0; i < 16; i++) 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 659
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 661
for (i = 16; i < 48; i++) 663
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 664
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 669
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 673
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  675
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 676
------------------------------
430 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE 407
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  219
if ( ! s0 -> current_picture_ptr )  227
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( s0 -> first_field )  356
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
s0 -> current_picture_ptr = NULL; 365
s0 -> first_field = FIELD_PICTURE; 366
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
s0 -> first_field = 1; 374
s0 -> current_picture_ptr = NULL; 375
s0 -> first_field = 0; 378
s0 -> first_field = FIELD_PICTURE; 383
if ( ! FIELD_PICTURE || s0 -> first_field )  386
if ( ff_h264_frame_start ( h ) < 0 )  387
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
av_assert1 ( s -> mb_y < s -> mb_height ); 410
if ( s -> picture_structure == PICT_FRAME )  412
get_ue_golomb ( & s -> gb ); 421
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
init_poc ( h ); 437
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  450
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 451
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 452
if ( num_ref_idx_active_override_flag )  454
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  456
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 457
h -> ref_count [ 1 ] = 1; 460
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 464
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 465
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  469
h -> list_count = 2; 470
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 474
ff_h264_fill_default_ref_list ( h ); 477
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  479
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 481
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  485
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 486
s -> last_picture_ptr -> owner2 = s; 487
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 488
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  490
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 491
s -> next_picture_ptr -> owner2 = s; 492
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  496
pred_weight_table ( h ); 499
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  500
implicit_weight_table ( h , - 1 ); 502
h -> use_weight = 0; 504
h -> luma_weight_flag [ i ] = 0; 506
h -> chroma_weight_flag [ i ] = 0; 507
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  516
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  526
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  532
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  536
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 539
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 548
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  588
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  598
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 627
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  628
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 632
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 637
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  640
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 642
for (k = 0; k < h->short_ref_count; k++) 643
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  644
for (k = 0; k < h->long_ref_count; k++) 648
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  649
id_list [ i ] = h -> short_ref_count + k; 650
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 656
for (i = 0; i < 16; i++) 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 659
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 661
for (i = 16; i < 48; i++) 663
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 664
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 669
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 673
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  675
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 676
------------------------------
431 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 244
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 321
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 328
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 329
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
return ret ; 332
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
if ( ff_h264_frame_start ( h ) < 0 )  387
ff_release_unused_pictures ( s , 0 ); 392
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
return ret ; 396
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
av_assert1 ( s -> mb_num == s -> mb_width * s -> mb_height ); 400
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 403
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
av_assert1 ( s -> mb_y < s -> mb_height ); 410
if ( s -> picture_structure == PICT_FRAME )  412
h -> curr_pic_num = h -> frame_num; 413
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 414
h -> curr_pic_num = 2 * h -> frame_num + 1; 416
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 417
if ( h -> nal_unit_type == NAL_IDR_SLICE )  420
get_ue_golomb ( & s -> gb ); 421
if ( h -> sps . poc_type == 0 )  423
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
init_poc ( h ); 437
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  450
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 451
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 452
if ( num_ref_idx_active_override_flag )  454
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  456
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 457
h -> ref_count [ 1 ] = 1; 460
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 464
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 465
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  469
h -> list_count = 2; 470
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 474
ff_h264_fill_default_ref_list ( h ); 477
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  479
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 481
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  485
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 486
s -> last_picture_ptr -> owner2 = s; 487
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 488
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  490
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 491
s -> next_picture_ptr -> owner2 = s; 492
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  496
pred_weight_table ( h ); 499
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  500
implicit_weight_table ( h , - 1 ); 502
h -> use_weight = 0; 504
h -> luma_weight_flag [ i ] = 0; 506
h -> chroma_weight_flag [ i ] = 0; 507
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  516
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  526
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  532
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  536
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 539
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 548
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  588
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  598
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 627
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  628
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 632
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 637
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  640
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 642
for (k = 0; k < h->short_ref_count; k++) 643
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  644
for (k = 0; k < h->long_ref_count; k++) 648
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  649
id_list [ i ] = h -> short_ref_count + k; 650
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 656
for (i = 0; i < 16; i++) 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 659
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 661
for (i = 16; i < 48; i++) 663
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 664
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 669
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 673
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  675
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 676
------------------------------
432 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ) 210
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
if ( h -> sps . frame_mbs_only_flag )  202
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  219
av_log ( h -> s . avctx , AV_LOG_ERROR , "Changing field mode (%d -> %d) between slices is not allowed\n" , last_pic_structure , s -> picture_structure ); 221
av_log ( s -> avctx , AV_LOG_ERROR , "unset current_picture_ptr on %d. slice\n" , h0 -> current_slice + 1 ); 228
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid field mode combination %d/%d\n" , last_pic_structure , s -> picture_structure ); 292
if ( last_pic_droppable != s -> droppable )  298
av_log ( s -> avctx , AV_LOG_ERROR , "Cannot combine reference and non-reference fields in the same frame\n" ); 299
av_log_ask_for_sample ( s -> avctx , NULL ); 301
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
av_log ( h -> s . avctx , AV_LOG_DEBUG , "Frame num gap %d %d\n" , h -> frame_num , h -> prev_frame_num ); 321
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ); 328
ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 1 ); 329
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
return ret ; 332
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , s -> avctx -> pix_fmt , s -> mb_width * 16 , s -> mb_height * 16 ); 344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
if ( ff_h264_frame_start ( h ) < 0 )  387
ff_release_unused_pictures ( s , 0 ); 392
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
return ret ; 396
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
av_assert1 ( s -> mb_num == s -> mb_width * s -> mb_height ); 400
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
av_log ( h -> s . avctx , AV_LOG_ERROR , "first_mb_in_slice overflow\n" ); 403
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
av_assert1 ( s -> mb_y < s -> mb_height ); 410
if ( s -> picture_structure == PICT_FRAME )  412
h -> curr_pic_num = h -> frame_num; 413
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 414
h -> curr_pic_num = 2 * h -> frame_num + 1; 416
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 417
if ( h -> nal_unit_type == NAL_IDR_SLICE )  420
get_ue_golomb ( & s -> gb ); 421
if ( h -> sps . poc_type == 0 )  423
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
init_poc ( h ); 437
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  450
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 451
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 452
if ( num_ref_idx_active_override_flag )  454
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  456
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 457
h -> ref_count [ 1 ] = 1; 460
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 464
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 465
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  469
h -> list_count = 2; 470
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 474
ff_h264_fill_default_ref_list ( h ); 477
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  479
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 481
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  485
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 486
s -> last_picture_ptr -> owner2 = s; 487
ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ); 488
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  490
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 491
s -> next_picture_ptr -> owner2 = s; 492
ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ); 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  496
pred_weight_table ( h ); 499
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  500
implicit_weight_table ( h , - 1 ); 502
h -> use_weight = 0; 504
h -> luma_weight_flag [ i ] = 0; 506
h -> chroma_weight_flag [ i ] = 0; 507
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  516
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  526
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred )  532
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  536
av_log ( s -> avctx , AV_LOG_ERROR , "cabac_init_idc overflow\n" ); 539
av_log ( s -> avctx , AV_LOG_ERROR , "QP %u out of range\n" , tmp ); 548
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  588
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  598
h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = s -> resync_mb_y; 627
if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= s -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= s -> resync_mb_y && h -> slice_num >= MAX_SLICES )  628
av_log ( s -> avctx , AV_LOG_WARNING , "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n" , h -> slice_num , MAX_SLICES ); 632
int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; 637
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  640
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 642
for (k = 0; k < h->short_ref_count; k++) 643
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  644
for (k = 0; k < h->long_ref_count; k++) 648
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  649
id_list [ i ] = h -> short_ref_count + k; 650
ref2frm [ 0 ] = ref2frm [ 1 ] = - 1; 656
for (i = 0; i < 16; i++) 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 659
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 661
for (i = 16; i < 48; i++) 663
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 664
h -> emu_edge_width = ( s -> flags & CODEC_FLAG_EMU_EDGE || ( ! h -> sps . frame_mbs_only_flag && s -> avctx -> active_thread_type ) ) ? 0 : 16; 669
h -> emu_edge_height = ( FRAME_MBAFF || FIELD_PICTURE ) ? 0 : h -> emu_edge_width; 673
if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )  675
av_log ( h -> s . avctx , AV_LOG_DEBUG , "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n" , h -> slice_num , ( s -> picture_structure == PICT_FRAME ? "F" : s -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? " fix" : "" , h -> nal_unit_type == NAL_IDR_SLICE ? " IDR" : "" , pps_id , h -> frame_num , s -> current_picture_ptr -> field_poc [ 0 ] , s -> current_picture_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , s -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ); 676
------------------------------
433 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c map [ i ] [ R ] = g + r 59
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 || ! len0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit || ! len1 )  16
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
uint8_t ( * map ) [ 4 ] = ( uint8_t ( * ) [ 4 ] ) s -> pix_bgr_map 31
int i , b , g , r , code ; 32
int p0 = s -> decorrelate ; 33
int p1 = ! s -> decorrelate ; 34
for (i = 0, g = -16; g < 16; g++) 38
int len0 = s -> len [ p0 ] [ g & 255 ] ; 39
int limit0 = VLC_BITS - len0 ; 40
if ( limit0 < 2 || ! len0 )  41
for (b = -16; b < 16; b++) 43
int len1 = s -> len [ p1 ] [ b & 255 ] ; 44
int limit1 = limit0 - len1 ; 45
if ( limit1 < 1 || ! len1 )  46
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ]; 48
for (r = -16; r < 16; r++) 49
int len2 = s -> len [ 2 ] [ r & 255 ] ; 50
if ( len2 > limit1 || ! len2 )  51
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
if ( s -> decorrelate )  56
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
------------------------------
434 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c map [ i ] [ B ] = g + b 58
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 || ! len0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit || ! len1 )  16
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
uint8_t ( * map ) [ 4 ] = ( uint8_t ( * ) [ 4 ] ) s -> pix_bgr_map 31
int i , b , g , r , code ; 32
int p0 = s -> decorrelate ; 33
int p1 = ! s -> decorrelate ; 34
for (i = 0, g = -16; g < 16; g++) 38
int len0 = s -> len [ p0 ] [ g & 255 ] ; 39
int limit0 = VLC_BITS - len0 ; 40
if ( limit0 < 2 || ! len0 )  41
for (b = -16; b < 16; b++) 43
int len1 = s -> len [ p1 ] [ b & 255 ] ; 44
int limit1 = limit0 - len1 ; 45
if ( limit1 < 1 || ! len1 )  46
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ]; 48
for (r = -16; r < 16; r++) 49
int len2 = s -> len [ 2 ] [ r & 255 ] ; 50
if ( len2 > limit1 || ! len2 )  51
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
if ( s -> decorrelate )  56
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
------------------------------
435 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c len [ i ] = len0 + len1 + len2 54
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 || ! len0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit || ! len1 )  16
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
int i , b , g , r , code ; 32
int p0 = s -> decorrelate ; 33
int p1 = ! s -> decorrelate ; 34
for (i = 0, g = -16; g < 16; g++) 38
int len0 = s -> len [ p0 ] [ g & 255 ] ; 39
int limit0 = VLC_BITS - len0 ; 40
if ( limit0 < 2 || ! len0 )  41
for (b = -16; b < 16; b++) 43
int len1 = s -> len [ p1 ] [ b & 255 ] ; 44
int limit1 = limit0 - len1 ; 45
if ( limit1 < 1 || ! len1 )  46
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ]; 48
for (r = -16; r < 16; r++) 49
int len2 = s -> len [ 2 ] [ r & 255 ] ; 50
if ( len2 > limit1 || ! len2 )  51
av_assert0 ( i < ( 1 << VLC_BITS ) ); 53
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
if ( s -> decorrelate )  56
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 70
------------------------------
436 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c len [ i ] = len0 + len1 19
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 || ! len0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit || ! len1 )  16
av_assert0 ( i < ( 1 << VLC_BITS ) ); 18
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 27
av_assert0 ( i < ( 1 << VLC_BITS ) ); 53
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 70
------------------------------
437 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c map [ i ] [ R ] = g + r 57
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit )  16
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
uint8_t ( * map ) [ 4 ] = ( uint8_t ( * ) [ 4 ] ) s -> pix_bgr_map 30
int i , b , g , r , code ; 31
int p0 = s -> decorrelate ; 32
int p1 = ! s -> decorrelate ; 33
for (i = 0, g = -16; g < 16; g++) 37
int len0 = s -> len [ p0 ] [ g & 255 ] ; 38
int limit0 = VLC_BITS - len0 ; 39
if ( limit0 < 2 )  40
for (b = -16; b < 16; b++) 42
int len1 = s -> len [ p1 ] [ b & 255 ] ; 43
int limit1 = limit0 - len1 ; 44
if ( limit1 < 1 )  45
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ]; 47
for (r = -16; r < 16; r++) 48
int len2 = s -> len [ 2 ] [ r & 255 ] ; 49
if ( len2 > limit1 )  50
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
if ( s -> decorrelate )  54
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
------------------------------
438 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c map [ i ] [ B ] = g + b 56
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit )  16
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
uint8_t ( * map ) [ 4 ] = ( uint8_t ( * ) [ 4 ] ) s -> pix_bgr_map 30
int i , b , g , r , code ; 31
int p0 = s -> decorrelate ; 32
int p1 = ! s -> decorrelate ; 33
for (i = 0, g = -16; g < 16; g++) 37
int len0 = s -> len [ p0 ] [ g & 255 ] ; 38
int limit0 = VLC_BITS - len0 ; 39
if ( limit0 < 2 )  40
for (b = -16; b < 16; b++) 42
int len1 = s -> len [ p1 ] [ b & 255 ] ; 43
int limit1 = limit0 - len1 ; 44
if ( limit1 < 1 )  45
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ]; 47
for (r = -16; r < 16; r++) 48
int len2 = s -> len [ 2 ] [ r & 255 ] ; 49
if ( len2 > limit1 )  50
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
if ( s -> decorrelate )  54
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
------------------------------
439 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c len [ i ] = len0 + len1 + len2 52
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit )  16
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
int i , b , g , r , code ; 31
int p0 = s -> decorrelate ; 32
int p1 = ! s -> decorrelate ; 33
for (i = 0, g = -16; g < 16; g++) 37
int len0 = s -> len [ p0 ] [ g & 255 ] ; 38
int limit0 = VLC_BITS - len0 ; 39
if ( limit0 < 2 )  40
for (b = -16; b < 16; b++) 42
int len1 = s -> len [ p1 ] [ b & 255 ] ; 43
int limit1 = limit0 - len1 ; 44
if ( limit1 < 1 )  45
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ]; 47
for (r = -16; r < 16; r++) 48
int len2 = s -> len [ 2 ] [ r & 255 ] ; 49
if ( len2 > limit1 )  50
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
if ( s -> decorrelate )  54
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 68
------------------------------
440 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c len [ i ] = len0 + len1 18
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
uint16_t bits [ 1 << VLC_BITS ] ; 4
uint8_t len [ 1 << VLC_BITS ] ; 5
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 )  12
for (u = 0; u < 256; u++) 14
int len1 = s -> len [ p ] [ u ] ; 15
if ( len1 > limit )  16
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 26
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 68
------------------------------
441 /home/SySeVR/data/CVE_2013_0874_PATCHED_doubles2str.c ap = av_malloc ( component_len * count + 1 ) 10
static char *CVE_2013_0874_PATCHED_doubles2str(double *dp, int count, const char *sep) 1
char * ap , * ap0 ; 4
uint64_t component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15L L + strlen ( sep ) 7
if ( count >= ( INT_MAX - 1 ) / component_len )  8
ap = av_malloc ( component_len * count + 1 ); 10
if ( ! ap )  11
ap0 = ap; 13
ap [ 0 ] = '\0'; 14
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 16
if ( l >= component_len )  17
av_free ( ap0 ); 18
ap += l; 21
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 23
return ap0 ; 24
------------------------------
442 /home/SySeVR/data/CVE_2013_0874_VULN_doubles2str.c ap = av_malloc ( component_len * count ) 8
static char *CVE_2013_0874_VULN_doubles2str(double *dp, int count, const char *sep) 1
char * ap , * ap0 ; 4
int component_len ; 5
if ( ! sep )  6
sep = ", "; 6
component_len = 15 + strlen ( sep ); 7
ap = av_malloc ( component_len * count ); 8
if ( ! ap )  9
ap0 = ap; 11
ap [ 0 ] = '\0'; 12
unsigned l = snprintf ( ap , component_len , "%f%s" , dp [ i ] , sep ) ; 14
if ( l >= component_len )  15
av_free ( ap0 ); 16
ap += l; 19
ap0 [ strlen ( ap0 ) - strlen ( sep ) ] = '\0'; 21
return ap0 ; 22
------------------------------
443 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = param_end_offset - next_offset + 1 434
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
offset = param_end_offset; 432
tokenlen = param_end_offset - next_offset + 1; 434
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
offset = param_end_offset; 437
------------------------------
444 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 423
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
offset = next_offset + 1; 371
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 372
if ( next_offset != - 1 )  392
offset = next_offset + 1; 393
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 394
if ( next_offset == - 1 )  395
if ( next_offset < param_end_offset )  396
next_offset = param_end_offset; 397
if ( next_offset != - 1 )  400
offset = next_offset + 1; 405
if ( offset > param_end_offset )  411
next_offset = - 1; 412
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 414
if ( next_offset != - 1 )  416
offset = next_offset + 1; 419
next_offset = param_end_offset; 422
tokenlen = next_offset - offset; 423
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
offset = param_end_offset; 432
offset = param_end_offset; 437
------------------------------
445 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 417
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
offset = next_offset + 1; 371
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 372
if ( next_offset != - 1 )  392
offset = next_offset + 1; 393
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 394
if ( next_offset == - 1 )  395
if ( next_offset < param_end_offset )  396
next_offset = param_end_offset; 397
if ( next_offset != - 1 )  400
offset = next_offset + 1; 405
if ( offset > param_end_offset )  411
next_offset = - 1; 412
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 414
if ( next_offset != - 1 )  416
tokenlen = next_offset - offset; 417
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
offset = param_end_offset; 432
offset = param_end_offset; 437
------------------------------
446 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 402
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
offset = next_offset + 1; 371
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 372
if ( next_offset != - 1 )  392
offset = next_offset + 1; 393
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 394
if ( next_offset == - 1 )  395
if ( next_offset < param_end_offset )  396
next_offset = param_end_offset; 397
if ( next_offset != - 1 )  400
tokenlen = next_offset - offset; 402
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
offset = param_end_offset; 432
offset = param_end_offset; 437
------------------------------
447 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 376
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
offset = next_offset + 1; 371
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 372
if ( next_offset == - 1 )  373
tokenlen = next_offset - offset; 376
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
offset = param_end_offset; 432
offset = param_end_offset; 437
------------------------------
448 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = param_end_offset - offset 374
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
offset = next_offset + 1; 371
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' ); 372
if ( next_offset == - 1 )  373
tokenlen = param_end_offset - offset; 374
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
offset = param_end_offset; 432
offset = param_end_offset; 437
------------------------------
449 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c parameter_item = proto_tree_add_text ( sdp_media_attribute_tree , tvb , offset , param_end_offset - offset , "Key parameters" ) 357
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
offset = next_offset + 1; 344
while ( has_more_pars == TRUE )  347
int param_end_offset ; 348
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 352
if ( param_end_offset == - 1 )  353
has_more_pars = FALSE; 354
param_end_offset = tvb_length ( tvb ); 355
parameter_item = proto_tree_add_text ( sdp_media_attribute_tree , tvb , offset , param_end_offset - offset , "Key parameters" ); 357
parameter_tree = proto_item_add_subtree ( parameter_item , ett_sdp_crypto_key_parameters ); 359
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 362
if ( next_offset == - 1 )  363
expert_add_info_format ( pinfo , parameter_item , PI_MALFORMED , PI_NOTE , "Invalid key-param (no ':' delimiter)" ); 364
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )  368
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
offset = param_end_offset; 432
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
offset = param_end_offset; 437
------------------------------
450 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 309
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
offset = next_offset + 1; 305
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 308
tokenlen = next_offset - offset; 309
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
451 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 302
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 301
tokenlen = next_offset - offset; 302
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
452 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c msrp_port_number = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , port_offset + 1 , port_end_offset - port_offset - 1 ) ) 242
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 * attribute_value ; 8
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
const char * msrp_res = "msrp://" ; 12
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
attribute_value = tvb_get_ephemeral_string ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 44
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
offset = next_offset + 1; 202
if ( strncmp ( ( char * ) attribute_value , msrp_res , strlen ( msrp_res ) ) == 0 )  224
int address_offset , port_offset , port_end_offset ; 225
address_offset = offset + ( int ) strlen ( msrp_res ); 228
port_offset = tvb_find_guint8 ( tvb , address_offset , - 1 , ':' ); 231
if ( port_offset != - 1 )  233
port_end_offset = tvb_find_guint8 ( tvb , port_offset , - 1 , '/' ); 235
if ( inet_pton ( AF_INET , ( char * ) tvb_get_ephemeral_string ( tvb , address_offset , port_offset - address_offset ) , & msrp_ipaddr ) > 0 )  238
msrp_port_number = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , port_offset + 1 , port_end_offset - port_offset - 1 ) ); 242
------------------------------
453 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 191
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
gboolean has_more_pars = TRUE ; 14
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
if ( sdp_media_attribute_tree )  149
guint8 media_format ; 150
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
offset = next_offset + 1; 179
while ( has_more_pars == TRUE )  181
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' ); 182
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 183
if ( next_offset == - 1 )  185
has_more_pars = FALSE; 186
next_offset = tvb_length ( tvb ); 187
tokenlen = next_offset - offset; 191
fmtp_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format_specific_parameter , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 192
fmtp_tree = proto_item_add_subtree ( fmtp_item , ett_sdp_fmtp ); 196
decode_sdp_fmtp ( fmtp_tree , tvb , pinfo , offset , tokenlen , transport_info -> encoding_name [ media_format ] ); 198
offset = next_offset + 1; 202
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
454 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 160
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
proto_tree * sdp_media_attribute_tree , * parameter_item ; 2
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
offset = 0; 19
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute ); 22
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
if ( sdp_media_attribute_tree )  149
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 153
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 155
if ( next_offset == - 1 )  157
tokenlen = next_offset - offset; 160
media_format_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 163
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
proto_item_append_text ( media_format_item , " [%s]" , transport_info -> encoding_name [ media_format ] ); 172
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 176
fmtp_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format_specific_parameter , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 192
fmtp_tree = proto_item_add_subtree ( fmtp_item , ett_sdp_fmtp ); 196
decode_sdp_fmtp ( fmtp_tree , tvb , pinfo , offset , tokenlen , transport_info -> encoding_name [ media_format ] ); 198
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
455 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 96
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
guint8 * payload_type ; 7
guint8 pt ; 10
gint sdp_media_attrbute_code ; 11
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
next_offset = next_offset + 1; 89
offset = next_offset; 90
while ( length - 1 >= next_offset )  91
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )  92
next_offset ++; 94
tokenlen = next_offset - offset; 96
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_sample_rate , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 97
transport_info -> sample_rate [ pt ] = atoi ( tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 99
if ( transport_info -> media_count == 0 )  117
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 120
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 121
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key , encoding_name_and_rate ); 123
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key2 , encoding_name_and_rate ); 129
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 139
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 140
if ( transport_info -> media_count == SDP_MAX_RTP_CHANNELS - 1 )  141
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count ] . rtp_dyn_payload , key , encoding_name_and_rate ); 142
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count - 1 ] . rtp_dyn_payload , key , encoding_name_and_rate ); 145
media_format_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 163
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
proto_item_append_text ( media_format_item , " [%s]" , transport_info -> encoding_name [ media_format ] ); 172
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 176
fmtp_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format_specific_parameter , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 192
fmtp_tree = proto_item_add_subtree ( fmtp_item , ett_sdp_fmtp ); 196
decode_sdp_fmtp ( fmtp_tree , tvb , pinfo , offset , tokenlen , transport_info -> encoding_name [ media_format ] ); 198
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( transport_info -> encryption_algorithm == SRTP_ENC_ALG_NOT_SET )  315
transport_info -> encryption_algorithm = SRTP_ENC_ALG_AES_CM; 316
transport_info -> auth_algorithm = SRTP_AUTH_ALG_HMAC_SHA1; 317
transport_info -> auth_tag_len = 10; 319
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
456 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 74
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
gint sdp_media_attrbute_code ; 11
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
offset = next_offset + 1; 66
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' ); 68
if ( next_offset == - 1 )  70
tokenlen = next_offset - offset; 74
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_encoding_name , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 76
transport_info -> encoding_name [ pt ] = ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 87
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_sample_rate , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 97
transport_info -> sample_rate [ pt ] = atoi ( tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 99
if ( transport_info -> media_count == 0 )  117
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 120
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 121
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key , encoding_name_and_rate ); 123
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key2 , encoding_name_and_rate ); 129
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 139
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 140
if ( transport_info -> media_count == SDP_MAX_RTP_CHANNELS - 1 )  141
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count ] . rtp_dyn_payload , key , encoding_name_and_rate ); 142
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count - 1 ] . rtp_dyn_payload , key , encoding_name_and_rate ); 145
media_format_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 163
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
proto_item_append_text ( media_format_item , " [%s]" , transport_info -> encoding_name [ media_format ] ); 172
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 176
fmtp_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format_specific_parameter , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 192
fmtp_tree = proto_item_add_subtree ( fmtp_item , ett_sdp_fmtp ); 196
decode_sdp_fmtp ( fmtp_tree , tvb , pinfo , offset , tokenlen , transport_info -> encoding_name [ media_format ] ); 198
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( transport_info -> encryption_algorithm == SRTP_ENC_ALG_NOT_SET )  315
transport_info -> encryption_algorithm = SRTP_ENC_ALG_AES_CM; 316
transport_info -> auth_algorithm = SRTP_AUTH_ALG_HMAC_SHA1; 317
transport_info -> auth_tag_len = 10; 319
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
457 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 59
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
gint sdp_media_attrbute_code ; 11
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
offset = colon_offset + 1; 39
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) ); 41
switch ( sdp_media_attrbute_code )  51
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' ); 54
if ( next_offset == - 1 )  56
tokenlen = next_offset - offset; 59
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 61
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_encoding_name , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 76
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
* key = atol ( ( char * ) payload_type ); 85
transport_info -> encoding_name [ pt ] = ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 87
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_sample_rate , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 97
transport_info -> sample_rate [ pt ] = atoi ( tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 99
if ( transport_info -> media_count == 0 )  117
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 120
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 121
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key , encoding_name_and_rate ); 123
* key2 = atol ( ( char * ) payload_type ); 128
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key2 , encoding_name_and_rate ); 129
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 139
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 140
if ( transport_info -> media_count == SDP_MAX_RTP_CHANNELS - 1 )  141
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count ] . rtp_dyn_payload , key , encoding_name_and_rate ); 142
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count - 1 ] . rtp_dyn_payload , key , encoding_name_and_rate ); 145
media_format_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 163
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
proto_item_append_text ( media_format_item , " [%s]" , transport_info -> encoding_name [ media_format ] ); 172
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 176
fmtp_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format_specific_parameter , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 192
fmtp_tree = proto_item_add_subtree ( fmtp_item , ett_sdp_fmtp ); 196
decode_sdp_fmtp ( fmtp_tree , tvb , pinfo , offset , tokenlen , transport_info -> encoding_name [ media_format ] ); 198
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( transport_info -> encryption_algorithm == SRTP_ENC_ALG_NOT_SET )  315
transport_info -> encryption_algorithm = SRTP_ENC_ALG_AES_CM; 316
transport_info -> auth_algorithm = SRTP_AUTH_ALG_HMAC_SHA1; 317
transport_info -> auth_tag_len = 10; 319
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
458 /home/SySeVR/data/CVE_2013_1576_VULN_dissect_sdp_media_attribute.c tokenlen = colon_offset - offset 31
static void CVE_2013_1576_VULN_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info) 1
gint offset , next_offset , tokenlen , n , colon_offset ; 5
offset = 0; 19
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' ); 25
if ( colon_offset == - 1 )  27
tokenlen = colon_offset - offset; 31
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_attribute_field , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 32
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen ); 36
switch ( sdp_media_attrbute_code )  51
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 61
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 64
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_encoding_name , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 76
pt = atoi ( ( char * ) payload_type ); 79
if ( pt >= SDP_NO_OF_PT )  80
* key = atol ( ( char * ) payload_type ); 85
transport_info -> encoding_name [ pt ] = ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 87
proto_tree_add_item ( sdp_media_attribute_tree , hf_media_sample_rate , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 97
transport_info -> sample_rate [ pt ] = atoi ( tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 99
if ( transport_info -> media_count == 0 )  117
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 120
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 121
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key , encoding_name_and_rate ); 123
* key2 = atol ( ( char * ) payload_type ); 128
g_hash_table_insert ( transport_info -> media [ n ] . rtp_dyn_payload , key2 , encoding_name_and_rate ); 129
encoding_name_and_rate -> encoding_name = se_strdup ( transport_info -> encoding_name [ pt ] ); 139
encoding_name_and_rate -> sample_rate = transport_info -> sample_rate [ pt ]; 140
if ( transport_info -> media_count == SDP_MAX_RTP_CHANNELS - 1 )  141
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count ] . rtp_dyn_payload , key , encoding_name_and_rate ); 142
g_hash_table_insert ( transport_info -> media [ transport_info -> media_count - 1 ] . rtp_dyn_payload , key , encoding_name_and_rate ); 145
media_format_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 163
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 166
if ( media_format >= SDP_NO_OF_PT )  167
proto_item_append_text ( media_format_item , " [%s]" , transport_info -> encoding_name [ media_format ] ); 172
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 176
fmtp_item = proto_tree_add_item ( sdp_media_attribute_tree , hf_media_format_specific_parameter , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 192
fmtp_tree = proto_item_add_subtree ( fmtp_item , ett_sdp_fmtp ); 196
decode_sdp_fmtp ( fmtp_tree , tvb , pinfo , offset , tokenlen , transport_info -> encoding_name [ media_format ] ); 198
proto_tree_add_uint ( sdp_media_attribute_tree , hf_sdp_crypto_tag , tvb , offset , tokenlen , atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ) ); 303
proto_tree_add_item ( sdp_media_attribute_tree , hf_sdp_crypto_crypto_suite , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 310
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_80" , tokenlen ) == 0 )  312
if ( transport_info -> encryption_algorithm == SRTP_ENC_ALG_NOT_SET )  315
transport_info -> encryption_algorithm = SRTP_ENC_ALG_AES_CM; 316
transport_info -> auth_algorithm = SRTP_AUTH_ALG_HMAC_SHA1; 317
transport_info -> auth_tag_len = 10; 319
if ( tvb_strncaseeql ( tvb , offset , "AES_CM_128_HMAC_SHA1_32" , tokenlen ) == 0 )  323
if ( tvb_strncaseeql ( tvb , offset , "F8_128_HMAC_SHA1_80" , tokenlen ) == 0 )  333
data_p = tvb_get_ephemeral_string ( tvb , offset , tokenlen ); 378
key_salt_tvb = base64_to_tvb ( tvb , data_p ); 379
add_new_data_source ( pinfo , key_salt_tvb , "Key_Salt_tvb" ); 380
proto_tree_add_text ( parameter_tree , tvb , offset , tokenlen , "Key and Salt" ); 382
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_key , key_salt_tvb , 0 , master_key_length , ENC_ASCII | ENC_NA ); 383
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_master_salt , key_salt_tvb , master_key_length , master_salt_length , ENC_ASCII | ENC_NA ); 385
proto_tree_add_text ( parameter_tree , key_salt_tvb , 0 , - 1 , "Key and Salt" ); 388
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_lifetime , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 403
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 418
transport_info -> mki_len = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) ); 427
proto_tree_add_item ( parameter_tree , hf_sdp_crypto_mki_length , tvb , offset , tokenlen , ENC_ASCII | ENC_NA ); 428
proto_tree_add_text ( parameter_tree , tvb , next_offset + 1 , tokenlen , "%s" , tvb_get_ephemeral_string ( tvb , next_offset + 1 , tokenlen ) ); 435
------------------------------
459 /home/SySeVR/data/CVE_2013_1583_PATCHED_dissect_version_4_primary_header.c bundle_custodian = ep_strdup_printf ( "%s:%s" , tvb_get_ephemeral_stringz ( tvb , offset + cust_scheme_offset , NULL ) , tvb_get_ephemeral_stringz ( tvb , offset + cust_ssp_offset , NULL ) ) 312
static int
CVE_2013_1583_PATCHED_dissect_version_4_primary_header(packet_info *pinfo, proto_tree *primary_tree, tvbuff_t *tvb) 2
int bundle_header_length ; 5
int bundle_header_dict_length ; 6
int offset ; 7
int sdnv_length ; 8
int report_scheme_offset , report_ssp_offset , cust_scheme_offset , cust_ssp_offset ; 10
offset = 1; 29
bundle_header_length = evaluate_sdnv ( tvb , offset , & sdnv_length ); 76
if ( bundle_header_length < 0 )  77
offset += sdnv_length; 85
offset += 2; 96
offset += 2; 102
offset += 2; 109
offset += 2; 115
offset += 2; 122
offset += 2; 128
cust_scheme_offset = tvb_get_ntohs ( tvb , offset ); 130
offset += 2; 135
cust_ssp_offset = tvb_get_ntohs ( tvb , offset ); 137
offset += 2; 141
offset += 8; 145
offset += 4; 148
bundle_header_dict_length = evaluate_sdnv ( tvb , offset , & sdnv_length ); 150
if ( bundle_header_dict_length < 0 )  151
offset += sdnv_length; 157
if ( bundle_header_dict_length == 0 )  174
bundle_custodian = ep_strdup_printf ( "%s:%s" , tvb_get_ephemeral_stringz ( tvb , offset + cust_scheme_offset , NULL ) , tvb_get_ephemeral_stringz ( tvb , offset + cust_ssp_offset , NULL ) ); 312
------------------------------
460 /home/SySeVR/data/CVE_2013_1584_PATCHED_dissect_version_5_and_6_primary_header.c bundle_custodian = ep_strdup_printf ( "%s:%s" , tvb_get_ephemeral_stringz ( tvb , offset + cust_scheme_offset , NULL ) , tvb_get_ephemeral_stringz ( tvb , offset + cust_ssp_offset , NULL ) ) 456
static int
CVE_2013_1584_PATCHED_dissect_version_5_and_6_primary_header(packet_info *pinfo,
proto_tree *primary_tree, tvbuff_t *tvb) 3
guint64 bundle_processing_control_flags ; 5
guint8 cosflags ; 6
int bundle_header_length ; 7
int bundle_header_dict_length ; 8
int offset ; 9
int sdnv_length ; 10
int dest_scheme_offset , dest_ssp_offset , source_scheme_offset , source_ssp_offset ; 11
int report_scheme_offset , report_ssp_offset , cust_scheme_offset , cust_ssp_offset ; 12
int timestamp ; 17
int timestamp_sequence ; 19
int lifetime ; 20
offset = 1; 38
bundle_processing_control_flags = evaluate_sdnv_64 ( tvb , offset , & sdnv_length ); 39
if ( sdnv_length < 1 || sdnv_length > 8 )  44
cosflags = ( guint8 ) ( ( bundle_processing_control_flags >> 7 ) & 0x7f ); 71
if ( ( cosflags & BUNDLE_COSFLAGS_PRIORITY_MASK ) == BUNDLE_COSFLAGS_PRIORITY_BULK )  75
if ( ( cosflags & BUNDLE_COSFLAGS_PRIORITY_MASK ) == BUNDLE_COSFLAGS_PRIORITY_NORMAL )  79
if ( ( cosflags & BUNDLE_COSFLAGS_PRIORITY_MASK ) == BUNDLE_COSFLAGS_PRIORITY_EXP )  84
offset += sdnv_length; 111
bundle_header_length = evaluate_sdnv ( tvb , offset , & sdnv_length ); 114
if ( bundle_header_length < 0 )  115
offset += sdnv_length; 123
dest_scheme_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 131
if ( ( dest_scheme_offset < 0 ) || ( dest_scheme_offset > bundle_header_length ) )  135
offset += sdnv_length; 142
dest_ssp_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 145
if ( ( dest_ssp_offset < 0 ) || ( dest_ssp_offset > bundle_header_length ) )  148
offset += sdnv_length; 155
source_scheme_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 159
if ( ( source_scheme_offset < 0 ) || ( source_scheme_offset > bundle_header_length ) )  163
offset += sdnv_length; 170
source_ssp_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 173
if ( ( source_ssp_offset < 0 ) || ( source_ssp_offset > bundle_header_length ) )  176
offset += sdnv_length; 183
report_scheme_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 187
if ( ( report_scheme_offset < 0 ) || ( report_scheme_offset > bundle_header_length ) )  191
offset += sdnv_length; 198
report_ssp_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 201
if ( ( report_ssp_offset < 0 ) || ( report_ssp_offset > bundle_header_length ) )  204
offset += sdnv_length; 211
cust_scheme_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 215
if ( ( cust_scheme_offset < 0 ) || ( cust_scheme_offset > bundle_header_length ) )  219
offset += sdnv_length; 226
cust_ssp_offset = evaluate_sdnv ( tvb , offset , & sdnv_length ); 229
if ( ( cust_ssp_offset < 0 ) || ( cust_ssp_offset > bundle_header_length ) )  232
offset += sdnv_length; 239
timestamp = evaluate_sdnv ( tvb , offset , & sdnv_length ); 243
if ( timestamp < 0 )  244
offset += sdnv_length; 253
timestamp_sequence = evaluate_sdnv ( tvb , offset , & sdnv_length ); 256
if ( timestamp_sequence < 0 )  257
gint64 ts_seq ; 258
if ( ( ts_seq = evaluate_sdnv_64 ( tvb , offset , & sdnv_length ) ) < 0 )  260
offset += sdnv_length; 272
lifetime = evaluate_sdnv ( tvb , offset , & sdnv_length ); 275
if ( lifetime < 0 )  276
offset += sdnv_length; 283
bundle_header_dict_length = evaluate_sdnv ( tvb , offset , & sdnv_length ); 286
if ( bundle_header_dict_length < 0 )  287
offset += sdnv_length; 294
if ( bundle_header_dict_length == 0 )  312
bundle_custodian = ep_strdup_printf ( "%s:%s" , tvb_get_ephemeral_stringz ( tvb , offset + cust_scheme_offset , NULL ) , tvb_get_ephemeral_stringz ( tvb , offset + cust_ssp_offset , NULL ) ); 456
------------------------------
461 /home/SySeVR/data/CVE_2013_1587_PATCHED_dissect_rohc_ir_packet.c offset = offset + val_len 65
static int
CVE_2013_1587_PATCHED_dissect_rohc_ir_packet(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo,
int offset, guint16 cid, gboolean is_add_cid, rohc_info *p_rohc_info) 3
guint8 oct , profile , val_len ; 10
offset ++; 61
if ( p_rohc_info -> large_cid_present == TRUE )  62
offset = offset + val_len; 65
profile = tvb_get_guint8 ( tvb , offset ); 69
if ( profile == ROHC_PROFILE_RTP )  71
proto_tree_add_item ( ir_tree , hf_rohc_profile , tvb , offset , 1 , ENC_BIG_ENDIAN ); 74
offset ++; 75
proto_tree_add_item ( ir_tree , hf_rohc_rtp_crc , tvb , offset , 1 , ENC_BIG_ENDIAN ); 77
offset ++; 78
rohc_cid_context -> profile = profile; 96
rohc_cid_context -> prev_ir_frame_number = tmp_prev_ir_frame_number; 97
rohc_cid_context -> ir_frame_number = pinfo -> fd -> num; 98
rohc_cid_context -> rohc_ip_version = tmp_prev_rohc_ip_version; 99
rohc_cid_context -> mode = tmp_prev_mode; 100
g_hash_table_replace ( rohc_cid_hash , GUINT_TO_POINTER ( key ) , rohc_cid_context ); 102
p_add_proto_data ( pinfo -> fd , proto_rohc , rohc_cid_context ); 103
rohc_cid_context -> profile = profile; 112
rohc_cid_context -> prev_ir_frame_number = - 1; 113
rohc_cid_context -> ir_frame_number = pinfo -> fd -> num; 114
rohc_cid_context -> rohc_ip_version = p_rohc_info -> rohc_ip_version; 115
rohc_cid_context -> mode = p_rohc_info -> mode; 116
g_hash_table_insert ( rohc_cid_hash , GUINT_TO_POINTER ( key ) , rohc_cid_context ); 120
p_add_proto_data ( pinfo -> fd , proto_rohc , rohc_cid_context ); 121
switch ( profile )  128
next_tvb = tvb_new_subset_remaining ( tvb , offset ); 133
call_dissector ( ipv6_handle , next_tvb , pinfo , tree ); 135
call_dissector ( ip_handle , next_tvb , pinfo , tree ); 138
offset = dissect_rohc_ir_rtp_udp_profile_static ( tvb , ir_tree , pinfo , offset , d , profile , rohc_cid_context ); 144
offset = dissect_rohc_ir_rtp_udp_profile_static ( tvb , ir_tree , pinfo , offset , d , profile , rohc_cid_context ); 147
proto_tree_add_text ( ir_tree , tvb , offset , feedback_data_len , "profile-specific information[Not dissected yet]" ); 150
if ( offset != - 1 )  155
proto_item_set_len ( ir_item , offset - ir_item_start ); 157
return offset ; 160
------------------------------
462 /home/SySeVR/data/CVE_2013_1588_PATCHED_dissect_pft_fec_detailed.c got = ep_alloc ( fcount * sizeof ( guint32 ) ) 45
static tvbuff_t *
CVE_2013_1588_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
if ( fcount > MAX_FRAGMENTS )  19
if ( fdx )  30
guint32 * got ; 37
got = ep_alloc ( fcount * sizeof ( guint32 ) ); 45
for (fd_head = fd; fd_head != NULL && fragments < fcount; fd_head = fd_head->next) 49
got [ fragments ++ ] = fd_head -> offset; 51
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
for(i=0; i<fragments; i++) 67
guint next_fragment_we_have = got [ i ] ; 68
if ( next_fragment_we_have > MAX_FRAGMENTS )  69
proto_tree_add_text ( tree , tvb , 0 , - 1 , "[Reassembly of %d fragments not attempted]" , next_fragment_we_have ); 71
for(; current_findex<next_fragment_we_have; current_findex++) 74
------------------------------
463 /home/SySeVR/data/CVE_2013_1588_PATCHED_dissect_pft_fec_detailed.c rx_min = c_max * rsk / plen 27
static tvbuff_t *
CVE_2013_1588_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
guint32 rx_min ; 16
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
------------------------------
464 /home/SySeVR/data/CVE_2013_1588_PATCHED_dissect_pft_fec_detailed.c c_max = fcount * plen / ( rsk + PFT_RS_P ) 26
static tvbuff_t *
CVE_2013_1588_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 103
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 105
------------------------------
465 /home/SySeVR/data/CVE_2013_1588_PATCHED_dissect_pft_fec_detailed.c decoded_size = fcount * plen 25
static tvbuff_t *
CVE_2013_1588_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint16 decoded_size ; 14
if ( fcount > MAX_FRAGMENTS )  19
decoded_size = fcount * plen; 25
guint8 * output = ( guint8 * ) g_malloc ( decoded_size ) ; 96
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 103
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 105
new_tvb = tvb_new_child_real_data ( dtvb , output , decoded_size , decoded_size ); 107
add_new_data_source ( pinfo , new_tvb , "RS Error Corrected Data" ); 108
tvb_set_free_cb ( new_tvb , g_free ); 109
return new_tvb ; 111
------------------------------
466 /home/SySeVR/data/CVE_2013_1588_VULN_dissect_pft_fec_detailed.c got = ep_alloc ( fcount * sizeof ( guint32 ) ) 45
static tvbuff_t *
CVE_2013_1588_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
if ( fcount > MAX_FRAGMENTS )  19
if ( fdx )  30
guint32 * got ; 37
got = ep_alloc ( fcount * sizeof ( guint32 ) ); 45
got [ fragments ++ ] = fd_head -> offset; 51
got [ fragments ++ ] = fcount; 55
if ( fragments >= rx_min )  57
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 64
for(i=0; i<fragments; i++) 69
guint next_fragment_we_have = got [ i ] ; 70
if ( next_fragment_we_have > MAX_FRAGMENTS )  71
proto_tree_add_text ( tree , tvb , 0 , - 1 , "[Reassembly of %d fragments not attempted]" , next_fragment_we_have ); 73
for(; current_findex<next_fragment_we_have; current_findex++) 76
------------------------------
467 /home/SySeVR/data/CVE_2013_1588_VULN_dissect_pft_fec_detailed.c rx_min = c_max * rsk / plen 27
static tvbuff_t *
CVE_2013_1588_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
guint32 rx_min ; 16
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  57
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 64
------------------------------
468 /home/SySeVR/data/CVE_2013_1588_VULN_dissect_pft_fec_detailed.c c_max = fcount * plen / ( rsk + PFT_RS_P ) 26
static tvbuff_t *
CVE_2013_1588_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  57
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 64
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 105
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 107
------------------------------
469 /home/SySeVR/data/CVE_2013_1588_VULN_dissect_pft_fec_detailed.c decoded_size = fcount * plen 25
static tvbuff_t *
CVE_2013_1588_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint16 decoded_size ; 14
if ( fcount > MAX_FRAGMENTS )  19
decoded_size = fcount * plen; 25
guint8 * output = ( guint8 * ) g_malloc ( decoded_size ) ; 98
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 105
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 107
new_tvb = tvb_new_child_real_data ( dtvb , output , decoded_size , decoded_size ); 109
add_new_data_source ( pinfo , new_tvb , "RS Error Corrected Data" ); 110
tvb_set_free_cb ( new_tvb , g_free ); 111
return new_tvb ; 113
------------------------------
470 /home/SySeVR/data/CVE_2013_1676_VULN_nsBidiPresUtils__ResolveParagraph.c runLength = logicalLimit - lineOffset 112
nsresult
CVE_2013_1676_VULN_nsBidiPresUtils::ResolveParagraph(nsBlockFrame* aBlockFrame,
BidiParagraphData* aBpd) 3
if ( aBpd -> BufferLength ( ) < 1 )  7
int32_t runCount ; 12
rv = aBpd -> CountRuns ( & runCount ); 19
int32_t runLength = 0 ; 22
int32_t logicalLimit = 0 ; 24
int32_t numRun = - 1 ; 25
int32_t fragmentLength = 0 ; 26
int32_t frameIndex = - 1 ; 27
int32_t frameCount = aBpd -> FrameCount ( ) ; 28
int32_t contentOffset = 0 ; 29
bool isTextFrame = false ; 30
nsIFrame * frame = nullptr ; 31
nsIContent * content = nullptr ; 32
int32_t contentTextLength = 0 ; 33
if ( fragmentLength <= 0 )  53
if ( ++ frameIndex >= frameCount )  55
frame = aBpd -> FrameAt ( frameIndex ); 58
if ( frame == NS_BIDI_CONTROL_FRAME || nsGkAtoms :: textFrame != frame -> GetType ( ) )  59
isTextFrame = false; 65
fragmentLength = 1; 66
content = frame -> GetContent ( ); 74
if ( ! content )  75
contentTextLength = content -> TextLength ( ); 79
if ( contentTextLength == 0 )  80
int32_t start , end ; 92
fragmentLength = NS_MIN ( contentTextLength , end - start ); 96
contentOffset = start; 97
isTextFrame = true; 98
if ( runLength <= 0 )  102
if ( ++ numRun >= runCount )  104
lineOffset = logicalLimit; 107
if ( NS_FAILED ( aBpd -> GetLogicalRun ( lineOffset , & logicalLimit , & embeddingLevel ) ) )  108
runLength = logicalLimit - lineOffset; 112
if ( frame == NS_BIDI_CONTROL_FRAME )  115
frame = nullptr; 116
if ( isTextFrame )  126
if ( ( runLength > 0 ) && ( runLength < fragmentLength ) )  127
nsIFrame * nextBidi ; 133
int32_t runEnd = contentOffset + runLength ; 134
rv = EnsureBidiContinuation ( frame , & nextBidi , frameIndex , contentOffset , runEnd ); 135
if ( NS_FAILED ( rv ) )  138
nextBidi -> AdjustOffsetsForBidi ( runEnd , contentOffset + fragmentLength ); 141
lastFrame = frame = nextBidi; 143
contentOffset = runEnd; 144
if ( contentOffset + fragmentLength == contentTextLength )  147
int32_t newIndex = aBpd -> GetLastFrameForContent ( content ) ; 153
if ( newIndex > frameIndex )  154
frameIndex = newIndex; 157
lastFrame = frame = aBpd -> FrameAt ( frameIndex ); 158
if ( fragmentLength > 0 && runLength > fragmentLength )  160
if ( runLength == fragmentLength )  175
frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ); 186
int32_t temp = runLength ; 194
runLength -= fragmentLength; 195
fragmentLength -= temp; 196
if ( frame && fragmentLength <= 0 )  198
if ( runLength <= 0 && ! frame -> GetNextInFlow ( ) )  205
return rv ; 274
------------------------------
471 /home/SySeVR/data/CVE_2013_1676_VULN_nsBidiPresUtils__ResolveParagraph.c fragmentLength = NS_MIN ( contentTextLength , end - start ) 96
nsresult
CVE_2013_1676_VULN_nsBidiPresUtils::ResolveParagraph(nsBlockFrame* aBlockFrame,
BidiParagraphData* aBpd) 3
if ( aBpd -> BufferLength ( ) < 1 )  7
int32_t runCount ; 12
rv = aBpd -> CountRuns ( & runCount ); 19
int32_t runLength = 0 ; 22
int32_t logicalLimit = 0 ; 24
int32_t numRun = - 1 ; 25
int32_t fragmentLength = 0 ; 26
int32_t frameIndex = - 1 ; 27
int32_t frameCount = aBpd -> FrameCount ( ) ; 28
int32_t contentOffset = 0 ; 29
bool isTextFrame = false ; 30
nsIFrame * frame = nullptr ; 31
nsIContent * content = nullptr ; 32
int32_t contentTextLength = 0 ; 33
if ( fragmentLength <= 0 )  53
if ( ++ frameIndex >= frameCount )  55
frame = aBpd -> FrameAt ( frameIndex ); 58
if ( frame == NS_BIDI_CONTROL_FRAME || nsGkAtoms :: textFrame != frame -> GetType ( ) )  59
isTextFrame = false; 65
fragmentLength = 1; 66
content = frame -> GetContent ( ); 74
if ( ! content )  75
contentTextLength = content -> TextLength ( ); 79
if ( contentTextLength == 0 )  80
int32_t start , end ; 92
fragmentLength = NS_MIN ( contentTextLength , end - start ); 96
contentOffset = start; 97
isTextFrame = true; 98
if ( runLength <= 0 )  102
if ( ++ numRun >= runCount )  104
lineOffset = logicalLimit; 107
if ( NS_FAILED ( aBpd -> GetLogicalRun ( lineOffset , & logicalLimit , & embeddingLevel ) ) )  108
runLength = logicalLimit - lineOffset; 112
if ( frame == NS_BIDI_CONTROL_FRAME )  115
frame = nullptr; 116
if ( isTextFrame )  126
if ( ( runLength > 0 ) && ( runLength < fragmentLength ) )  127
nsIFrame * nextBidi ; 133
int32_t runEnd = contentOffset + runLength ; 134
rv = EnsureBidiContinuation ( frame , & nextBidi , frameIndex , contentOffset , runEnd ); 135
if ( NS_FAILED ( rv ) )  138
nextBidi -> AdjustOffsetsForBidi ( runEnd , contentOffset + fragmentLength ); 141
lastFrame = frame = nextBidi; 143
contentOffset = runEnd; 144
if ( contentOffset + fragmentLength == contentTextLength )  147
int32_t newIndex = aBpd -> GetLastFrameForContent ( content ) ; 153
if ( newIndex > frameIndex )  154
frameIndex = newIndex; 157
lastFrame = frame = aBpd -> FrameAt ( frameIndex ); 158
if ( fragmentLength > 0 && runLength > fragmentLength )  160
if ( runLength == fragmentLength )  175
frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ); 186
int32_t temp = runLength ; 194
runLength -= fragmentLength; 195
fragmentLength -= temp; 196
if ( frame && fragmentLength <= 0 )  198
if ( runLength <= 0 && ! frame -> GetNextInFlow ( ) )  205
return rv ; 274
------------------------------
472 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c extrema [ i ] = sourceData [ targIndex + i ] 48
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint32 xExt [ 4 ] , yExt [ 4 ] ; 21
PRUint8 extrema [ 4 ] ; 22
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 23
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 33
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 37
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 38
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 39
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 40
PRUint32 targIndex = y * stride + 4 * x ; 41
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
PRUint32 i ; 46
for (i = 0; i < 4; i++) 47
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (PRUint32 y1 = startY; y1 <= endY; y1++) 50
for (PRUint32 x1 = startX; x1 <= endX; x1++) 51
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
for (PRUint32 y1 = startY; y1 <= endY; y1++) 66
for (PRUint32 i = 0; i < 4; i++) 67
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
473 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ) 243
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gSourcePath = argv [ 1 ]; 23
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ); 243
------------------------------
474 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ) 214
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 214
------------------------------
475 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ) 208
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
------------------------------
476 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , gDestinationPath ) 196
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , gDestinationPath ); 196
------------------------------
477 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ) 243
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gSourcePath = argv [ 1 ]; 23
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ); 243
------------------------------
478 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ) 214
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 214
------------------------------
479 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ) 208
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
------------------------------
480 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , gDestinationPath ) 196
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , gDestinationPath ); 196
------------------------------
481 /home/SySeVR/data/CVE_2013_1708_VULN_WaveReader__LoadListChunk.c PR_STATIC_ASSERT ( MAX_CHUNK_SIZE < UINT_MAX / sizeof ( char ) ) 10
bool
CVE_2013_1708_VULN_WaveReader::LoadListChunk(uint32_t aChunkSize,
nsAutoPtr<nsHTMLMediaElement::MetadataTags> &aTags) 3
static const unsigned int MAX_CHUNK_SIZE = 1 << 16 ; 9
PR_STATIC_ASSERT ( MAX_CHUNK_SIZE < UINT_MAX / sizeof ( char ) ); 10
------------------------------
482 /home/SySeVR/data/CVE_2013_1722_VULN_nsAnimationManager__BuildAnimations.c aDest . mStartTime = now + TimeDuration :: FromMilliseconds ( aSrc . GetDelay ( ) ) 22
void
CVE_2013_1722_VULN_nsAnimationManager::BuildAnimations(nsStyleContext* aStyleContext,
InfallibleTArray<ElementAnimation>& aAnimations) 3
const nsStyleDisplay * disp = aStyleContext -> GetStyleDisplay ( ) ; 9
TimeStamp now = mPresContext -> RefreshDriver ( ) -> MostRecentRefresh ( ) ; 10
for (uint32_t animIdx = 0, animEnd = disp->mAnimations.Length();
animIdx != animEnd; ++animIdx) 12
const nsAnimation & aSrc = disp -> mAnimations [ animIdx ] ; 13
ElementAnimation & aDest = * aAnimations . AppendElement ( ) ; 14
aDest . mName = aSrc . GetName ( ); 16
aDest . mIterationCount = aSrc . GetIterationCount ( ); 17
aDest . mDirection = aSrc . GetDirection ( ); 18
aDest . mFillMode = aSrc . GetFillMode ( ); 19
aDest . mPlayState = aSrc . GetPlayState ( ); 20
aDest . mStartTime = now + TimeDuration :: FromMilliseconds ( aSrc . GetDelay ( ) ); 22
if ( aDest . IsPaused ( ) )  23
aDest . mPauseStart = now; 24
aDest . mPauseStart = TimeStamp ( ); 26
aDest . mIterationDuration = TimeDuration :: FromMilliseconds ( aSrc . GetDuration ( ) ); 29
nsCSSKeyframesRule * rule = KeyframesRuleFor ( aDest . mName ) ; 31
if ( ! rule )  32
for (uint32_t ruleIdx = 0, ruleEnd = rule->StyleRuleCount();
ruleIdx != ruleEnd; ++ruleIdx) 47
css :: Rule * cssRule = rule -> GetStyleRuleAt ( ruleIdx ) ; 48
NS_ABORT_IF_FALSE ( cssRule , "must have rule" ); 49
NS_ABORT_IF_FALSE ( cssRule -> GetType ( ) == css :: Rule :: KEYFRAME_RULE , "must be keyframe rule" ); 50
data -> mIndex = ruleIdx; 65
data -> mRule = kfRule; 66
AnimationProperty & propData = * aDest . mProperties . AppendElement ( ) ; 120
propData . mProperty = prop; 121
interpolated = interpolated && BuildSegment ( propData . mSegments , prop , aSrc , fromKeyframe -> mKey , fromContext , fromKeyframe -> mRule -> Declaration ( ) , toKeyframe . mKey , toContext ); 135
interpolated = interpolated && BuildSegment ( propData . mSegments , prop , aSrc , 0.0f , aStyleContext , nullptr , toKeyframe . mKey , toContext ); 144
interpolated = interpolated && BuildSegment ( propData . mSegments , prop , aSrc , fromKeyframe -> mKey , fromContext , fromKeyframe -> mRule -> Declaration ( ) , 1.0f , aStyleContext ); 158
if ( ! interpolated )  171
aDest . mProperties . RemoveElementAt ( aDest . mProperties . Length ( ) - 1 ); 172
------------------------------
483 /home/SySeVR/data/CVE_2013_1732_VULN_nsBlockFrame__Reflow.c perLineDelta = delta / lines 321
NS_IMETHODIMP
CVE_2013_1732_VULN_nsBlockFrame::Reflow(nsPresContext*           aPresContext,
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
nsReflowStatus&          aStatus) 5
PRTime start = 0 ; 18
if ( gLameReflowMetrics )  20
start = PR_Now ( ); 21
const nsHTMLReflowState * reflowState = & aReflowState ; 26
nsAutoPtr < nsHTMLReflowState > mutableReflowState ; 27
if ( aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE && aReflowState . ComputedHeight ( ) != NS_AUTOHEIGHT && ApplyOverflowClipping ( this , aReflowState . mStyleDisplay ) )  30
nsMargin heightExtras = aReflowState . mComputedBorderPadding ; 33
if ( GetSkipSides ( ) & NS_SIDE_TOP )  34
heightExtras . top = 0; 35
heightExtras . top += aReflowState . mComputedMargin . top; 39
if ( GetEffectiveComputedHeight ( aReflowState ) + heightExtras . TopBottom ( ) <= aReflowState . availableHeight )  42
mutableReflowState = new nsHTMLReflowState ( aReflowState ); 44
mutableReflowState -> availableHeight = NS_UNCONSTRAINEDSIZE; 45
reflowState = mutableReflowState; 46
if ( IsFrameTreeTooDeep ( * reflowState , aMetrics , aStatus ) )  71
nsBlockReflowState state ( * reflowState , aPresContext , this , aMetrics , topMarginRoot , bottomMarginRoot , needFloatManager ) ; 77
state . mOverflowTracker = & tracker; 107
nsOverflowAreas fcBounds ; 111
nsReflowStatus fcStatus = NS_FRAME_COMPLETE ; 112
rv = ReflowPushedFloats ( state , fcBounds , fcStatus ); 113
rv = ReflowDirtyLines ( state ); 125
if ( NS_FAILED ( rv ) )  127
if ( gLameReflowMetrics )  312
PRTime end = PR_Now ( ) ; 313
int32_t numLines = mLines . size ( ) ; 316
if ( ! numLines )  317
numLines = 1; 317
PRTime delta , perLineDelta , lines ; 318
lines = int64_t ( numLines ); 319
delta = end - start; 320
perLineDelta = delta / lines; 321
PR_snprintf ( buf , sizeof ( buf ) , ": %lld elapsed (%lld per line) (%d lines; %d new lines)" , delta , perLineDelta , numLines , ectc - ctc ); 325
------------------------------
484 /home/SySeVR/data/CVE_2013_1732_VULN_nsBlockFrame__Reflow.c delta = end - start 320
NS_IMETHODIMP
CVE_2013_1732_VULN_nsBlockFrame::Reflow(nsPresContext*           aPresContext,
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
nsReflowStatus&          aStatus) 5
PRTime start = 0 ; 18
if ( gLameReflowMetrics )  20
start = PR_Now ( ); 21
const nsHTMLReflowState * reflowState = & aReflowState ; 26
nsAutoPtr < nsHTMLReflowState > mutableReflowState ; 27
if ( aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE && aReflowState . ComputedHeight ( ) != NS_AUTOHEIGHT && ApplyOverflowClipping ( this , aReflowState . mStyleDisplay ) )  30
nsMargin heightExtras = aReflowState . mComputedBorderPadding ; 33
if ( GetSkipSides ( ) & NS_SIDE_TOP )  34
heightExtras . top = 0; 35
heightExtras . top += aReflowState . mComputedMargin . top; 39
if ( GetEffectiveComputedHeight ( aReflowState ) + heightExtras . TopBottom ( ) <= aReflowState . availableHeight )  42
mutableReflowState = new nsHTMLReflowState ( aReflowState ); 44
mutableReflowState -> availableHeight = NS_UNCONSTRAINEDSIZE; 45
reflowState = mutableReflowState; 46
if ( IsFrameTreeTooDeep ( * reflowState , aMetrics , aStatus ) )  71
nsBlockReflowState state ( * reflowState , aPresContext , this , aMetrics , topMarginRoot , bottomMarginRoot , needFloatManager ) ; 77
state . mOverflowTracker = & tracker; 107
nsOverflowAreas fcBounds ; 111
nsReflowStatus fcStatus = NS_FRAME_COMPLETE ; 112
rv = ReflowPushedFloats ( state , fcBounds , fcStatus ); 113
rv = ReflowDirtyLines ( state ); 125
if ( NS_FAILED ( rv ) )  127
if ( gLameReflowMetrics )  312
PRTime end = PR_Now ( ) ; 313
PRTime delta , perLineDelta , lines ; 318
delta = end - start; 320
perLineDelta = delta / lines; 321
PR_snprintf ( buf , sizeof ( buf ) , ": %lld elapsed (%lld per line) (%d lines; %d new lines)" , delta , perLineDelta , numLines , ectc - ctc ); 325
------------------------------
485 /home/SySeVR/data/CVE_2013_1732_VULN_nsBlockFrame__Reflow.c bbox . y = position . mBaseline - metrics . ascent 189
NS_IMETHODIMP
CVE_2013_1732_VULN_nsBlockFrame::Reflow(nsPresContext*           aPresContext,
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
nsReflowStatus&          aStatus) 5
const nsHTMLReflowState * reflowState = & aReflowState ; 26
nsAutoPtr < nsHTMLReflowState > mutableReflowState ; 27
if ( aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE && aReflowState . ComputedHeight ( ) != NS_AUTOHEIGHT && ApplyOverflowClipping ( this , aReflowState . mStyleDisplay ) )  30
nsMargin heightExtras = aReflowState . mComputedBorderPadding ; 33
if ( GetSkipSides ( ) & NS_SIDE_TOP )  34
heightExtras . top = 0; 35
heightExtras . top += aReflowState . mComputedMargin . top; 39
if ( GetEffectiveComputedHeight ( aReflowState ) + heightExtras . TopBottom ( ) <= aReflowState . availableHeight )  42
mutableReflowState = new nsHTMLReflowState ( aReflowState ); 44
mutableReflowState -> availableHeight = NS_UNCONSTRAINEDSIZE; 45
reflowState = mutableReflowState; 46
if ( IsFrameTreeTooDeep ( * reflowState , aMetrics , aStatus ) )  71
nsBlockReflowState state ( * reflowState , aPresContext , this , aMetrics , topMarginRoot , bottomMarginRoot , needFloatManager ) ; 77
state . mOverflowTracker = & tracker; 107
nsOverflowAreas fcBounds ; 111
nsReflowStatus fcStatus = NS_FRAME_COMPLETE ; 112
rv = ReflowPushedFloats ( state , fcBounds , fcStatus ); 113
rv = ReflowDirtyLines ( state ); 125
if ( NS_FAILED ( rv ) )  127
if ( HasOutsideBullet ( ) && ! mLines . empty ( ) && ( mLines . front ( ) -> IsBlock ( ) || ( 0 == mLines . front ( ) -> mBounds . height && mLines . front ( ) != mLines . back ( ) && mLines . begin ( ) . next ( ) -> IsBlock ( ) ) ) )  164
nsHTMLReflowMetrics metrics ; 170
nsLayoutUtils :: LinePosition position ; 172
bool havePosition = nsLayoutUtils :: GetFirstLinePosition ( this , & position ) ; 173
nsIFrame * bullet = GetOutsideBullet ( ) ; 176
if ( havePosition && ! BulletIsEmpty ( ) )  181
nsRect bbox = bullet -> GetRect ( ) ; 188
bbox . y = position . mBaseline - metrics . ascent; 189
bullet -> SetRect ( bbox ); 190
------------------------------
486 /home/SySeVR/data/CVE_2013_1735_VULN_ImageDocument__ScrollImageTo.c sf -> ScrollTo ( nsPoint ( nsPresContext :: CSSPixelsToAppUnits ( aX / ratio ) - portRect . width / 2 , nsPresContext :: CSSPixelsToAppUnits ( aY / ratio ) - portRect . height / 2 ) , nsIScrollableFrame :: INSTANT ) 20
void
CVE_2013_1735_VULN_ImageDocument::ScrollImageTo(int32_t aX, int32_t aY, bool restoreImage) 2
float ratio = GetRatio ( ) ; 4
nsIPresShell * shell = GetShell ( ) ; 11
if ( ! shell )  12
nsIScrollableFrame * sf = shell -> GetRootScrollFrameAsScrollable ( ) ; 15
if ( ! sf )  16
nsRect portRect = sf -> GetScrollPortRect ( ) ; 19
sf -> ScrollTo ( nsPoint ( nsPresContext :: CSSPixelsToAppUnits ( aX / ratio ) - portRect . width / 2 , nsPresContext :: CSSPixelsToAppUnits ( aY / ratio ) - portRect . height / 2 ) , nsIScrollableFrame :: INSTANT ); 20
------------------------------
487 /home/SySeVR/data/CVE_2013_1767_PATCHED_shmem_remount_fs.c sbinfo -> free_inodes = config . max_inodes - inodes 31
static int CVE_2013_1767_PATCHED_shmem_remount_fs(struct super_block *sb, int *flags, char *data) 1
struct shmem_sb_info * sbinfo = SHMEM_SB ( sb ) ; 3
struct shmem_sb_info config = * sbinfo ; 4
unsigned long inodes ; 5
config . mpol = NULL; 8
if ( shmem_parse_options ( data , & config , true ) )  9
inodes = sbinfo -> max_inodes - sbinfo -> free_inodes; 13
if ( percpu_counter_compare ( & sbinfo -> used_blocks , config . max_blocks ) > 0 )  14
if ( config . max_inodes < inodes )  16
if ( config . max_blocks && ! sbinfo -> max_blocks )  23
if ( config . max_inodes && ! sbinfo -> max_inodes )  25
sbinfo -> max_blocks = config . max_blocks; 29
sbinfo -> max_inodes = config . max_inodes; 30
sbinfo -> free_inodes = config . max_inodes - inodes; 31
mpol_put ( sbinfo -> mpol ); 37
sbinfo -> mpol = config . mpol; 38
spin_unlock ( & sbinfo -> stat_lock ); 41
------------------------------
488 /home/SySeVR/data/CVE_2013_1767_PATCHED_shmem_remount_fs.c inodes = sbinfo -> max_inodes - sbinfo -> free_inodes 13
static int CVE_2013_1767_PATCHED_shmem_remount_fs(struct super_block *sb, int *flags, char *data) 1
struct shmem_sb_info * sbinfo = SHMEM_SB ( sb ) ; 3
struct shmem_sb_info config = * sbinfo ; 4
unsigned long inodes ; 5
config . mpol = NULL; 8
if ( shmem_parse_options ( data , & config , true ) )  9
inodes = sbinfo -> max_inodes - sbinfo -> free_inodes; 13
if ( config . max_inodes < inodes )  16
sbinfo -> free_inodes = config . max_inodes - inodes; 31
mpol_put ( sbinfo -> mpol ); 37
sbinfo -> mpol = config . mpol; 38
spin_unlock ( & sbinfo -> stat_lock ); 41
------------------------------
489 /home/SySeVR/data/CVE_2013_1767_VULN_shmem_remount_fs.c sbinfo -> free_inodes = config . max_inodes - inodes 30
static int CVE_2013_1767_VULN_shmem_remount_fs(struct super_block *sb, int *flags, char *data) 1
struct shmem_sb_info * sbinfo = SHMEM_SB ( sb ) ; 3
struct shmem_sb_info config = * sbinfo ; 4
unsigned long inodes ; 5
if ( shmem_parse_options ( data , & config , true ) )  8
inodes = sbinfo -> max_inodes - sbinfo -> free_inodes; 12
if ( percpu_counter_compare ( & sbinfo -> used_blocks , config . max_blocks ) > 0 )  13
if ( config . max_inodes < inodes )  15
if ( config . max_blocks && ! sbinfo -> max_blocks )  22
if ( config . max_inodes && ! sbinfo -> max_inodes )  24
sbinfo -> max_blocks = config . max_blocks; 28
sbinfo -> max_inodes = config . max_inodes; 29
sbinfo -> free_inodes = config . max_inodes - inodes; 30
mpol_put ( sbinfo -> mpol ); 32
sbinfo -> mpol = config . mpol; 33
spin_unlock ( & sbinfo -> stat_lock ); 35
------------------------------
490 /home/SySeVR/data/CVE_2013_1767_VULN_shmem_remount_fs.c inodes = sbinfo -> max_inodes - sbinfo -> free_inodes 12
static int CVE_2013_1767_VULN_shmem_remount_fs(struct super_block *sb, int *flags, char *data) 1
struct shmem_sb_info * sbinfo = SHMEM_SB ( sb ) ; 3
unsigned long inodes ; 5
if ( shmem_parse_options ( data , & config , true ) )  8
inodes = sbinfo -> max_inodes - sbinfo -> free_inodes; 12
if ( config . max_inodes < inodes )  15
sbinfo -> free_inodes = config . max_inodes - inodes; 30
mpol_put ( sbinfo -> mpol ); 32
sbinfo -> mpol = config . mpol; 33
spin_unlock ( & sbinfo -> stat_lock ); 35
------------------------------
491 /home/SySeVR/data/CVE_2013_1772_PATCHED_call_console_drivers.c buf_prefix [ i ] = LOG_BUF ( cur_index + i ) 19
static void CVE_2013_1772_PATCHED_call_console_drivers(unsigned start, unsigned end) 1
unsigned cur_index , start_print ; 3
static int msg_level = - 1 ; 4
cur_index = start; 8
while ( cur_index != end )  10
if ( msg_level < 0 && ( ( end - cur_index ) > 2 ) )  11
char buf_prefix [ SYSLOG_PRI_MAX_LENGTH + 1 ] ; 16
unsigned i ; 17
for (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) 18
buf_prefix [ i ] = LOG_BUF ( cur_index + i ); 19
buf_prefix [ i ] = '\0'; 21
cur_index += log_prefix ( ( const char * ) & buf_prefix , & msg_level , NULL ); 24
start_print = cur_index; 25
while ( cur_index != end )  27
char c = LOG_BUF ( cur_index ) ; 28
cur_index ++; 30
if ( c == '\n' )  31
_call_console_drivers ( start_print , cur_index , msg_level ); 41
msg_level = - 1; 42
start_print = cur_index; 43
_call_console_drivers ( start_print , end , msg_level ); 48
------------------------------
492 /home/SySeVR/data/CVE_2013_2486_PATCHED_dissect_diagnosticrequest.c extensions_length = tvb_get_ntohl ( tvb , offset + local_offset ) 38
static int CVE_2013_2486_PATCHED_dissect_diagnosticrequest(int anchor, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length) 1
proto_item * ti_local ; 2
proto_tree * local_tree ; 3
guint16 local_offset = 0 ; 4
int hf = hf_reload_diagnosticrequest ; 6
if ( anchor >= 0 )  8
hf = anchor; 9
ti_local = proto_tree_add_item ( tree , hf , tvb , offset , length , ENC_NA ); 12
local_tree = proto_item_add_subtree ( ti_local , ett_reload_diagnosticrequest ); 13
local_offset += 8; 16
local_offset += 8; 19
local_length = tvb_get_ntohl ( tvb , offset + local_offset ); 20
local_offset += 4; 22
local_offset += dissect_dmflag ( tvb , local_tree , offset + local_offset ); 24
if ( local_offset + local_length > length )  25
local_length = length - local_offset; 27
if ( local_length > 0 )  29
extensions_length = tvb_get_ntohl ( tvb , offset + local_offset ); 38
if ( extensions_length + 4 > local_length )  39
proto_item_append_text ( ti_extensions , " (DiagnosticExtension<%d>)" , extensions_length ); 43
while ( extensions_offset < extensions_length )  45
int local_increment = dissect_diagnosticextension ( tvb , pinfo , extensions_tree , offset + 4 + local_offset + extensions_offset , extensions_length - extensions_offset ) ; 46
if ( local_increment <= 0 )  47
extensions_offset += local_increment; 48
------------------------------
493 /home/SySeVR/data/CVE_2013_2486_PATCHED_dissect_diagnosticrequest.c ti_extensions = proto_tree_add_item ( local_tree , hf_reload_diagnosticrequest_extensions , tvb , offset + local_offset , local_length , ENC_NA ) 36
static int CVE_2013_2486_PATCHED_dissect_diagnosticrequest(int anchor, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length) 1
proto_item * ti_local ; 2
proto_tree * local_tree ; 3
guint16 local_offset = 0 ; 4
int hf = hf_reload_diagnosticrequest ; 6
if ( anchor >= 0 )  8
hf = anchor; 9
ti_local = proto_tree_add_item ( tree , hf , tvb , offset , length , ENC_NA ); 12
local_tree = proto_item_add_subtree ( ti_local , ett_reload_diagnosticrequest ); 13
local_offset += 8; 16
local_offset += 8; 19
local_length = tvb_get_ntohl ( tvb , offset + local_offset ); 20
local_offset += 4; 22
local_offset += dissect_dmflag ( tvb , local_tree , offset + local_offset ); 24
if ( local_offset + local_length > length )  25
local_length = length - local_offset; 27
if ( local_length > 0 )  29
proto_item * ti_extensions ; 30
ti_extensions = proto_tree_add_item ( local_tree , hf_reload_diagnosticrequest_extensions , tvb , offset + local_offset , local_length , ENC_NA ); 36
extensions_tree = proto_item_add_subtree ( ti_extensions , ett_reload_diagnosticrequest_extensions ); 37
expert_add_info_format ( pinfo , ti_extensions , PI_PROTOCOL , PI_ERROR , "Truncated Diagnostic extensions" ); 40
proto_item_append_text ( ti_extensions , " (DiagnosticExtension<%d>)" , extensions_length ); 43
proto_tree_add_item ( extensions_tree , hf_reload_length_uint32 , tvb , offset + local_offset , 4 , ENC_BIG_ENDIAN ); 44
while ( extensions_offset < extensions_length )  45
int local_increment = dissect_diagnosticextension ( tvb , pinfo , extensions_tree , offset + 4 + local_offset + extensions_offset , extensions_length - extensions_offset ) ; 46
if ( local_increment <= 0 )  47
extensions_offset += local_increment; 48
proto_item_append_text ( ti_extensions , " : %d elements" , nExtensions ); 51
------------------------------
494 /home/SySeVR/data/CVE_2013_2486_PATCHED_dissect_diagnosticrequest.c local_length = length - local_offset 27
static int CVE_2013_2486_PATCHED_dissect_diagnosticrequest(int anchor, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length) 1
proto_item * ti_local ; 2
proto_tree * local_tree ; 3
guint16 local_offset = 0 ; 4
int hf = hf_reload_diagnosticrequest ; 6
if ( anchor >= 0 )  8
hf = anchor; 9
ti_local = proto_tree_add_item ( tree , hf , tvb , offset , length , ENC_NA ); 12
local_tree = proto_item_add_subtree ( ti_local , ett_reload_diagnosticrequest ); 13
local_offset += 8; 16
local_offset += 8; 19
local_length = tvb_get_ntohl ( tvb , offset + local_offset ); 20
local_offset += 4; 22
local_offset += dissect_dmflag ( tvb , local_tree , offset + local_offset ); 24
if ( local_offset + local_length > length )  25
local_length = length - local_offset; 27
if ( local_length > 0 )  29
ti_extensions = proto_tree_add_item ( local_tree , hf_reload_diagnosticrequest_extensions , tvb , offset + local_offset , local_length , ENC_NA ); 36
extensions_tree = proto_item_add_subtree ( ti_extensions , ett_reload_diagnosticrequest_extensions ); 37
if ( extensions_length + 4 > local_length )  39
expert_add_info_format ( pinfo , ti_extensions , PI_PROTOCOL , PI_ERROR , "Truncated Diagnostic extensions" ); 40
extensions_length = local_length - 4; 41
proto_item_append_text ( ti_extensions , " (DiagnosticExtension<%d>)" , extensions_length ); 43
proto_tree_add_item ( extensions_tree , hf_reload_length_uint32 , tvb , offset + local_offset , 4 , ENC_BIG_ENDIAN ); 44
while ( extensions_offset < extensions_length )  45
int local_increment = dissect_diagnosticextension ( tvb , pinfo , extensions_tree , offset + 4 + local_offset + extensions_offset , extensions_length - extensions_offset ) ; 46
if ( local_increment <= 0 )  47
extensions_offset += local_increment; 48
proto_item_append_text ( ti_extensions , " : %d elements" , nExtensions ); 51
local_offset += local_length; 53
return local_offset ; 54
------------------------------
495 /home/SySeVR/data/CVE_2013_2486_PATCHED_dissect_diagnosticrequest.c local_length = tvb_get_ntohl ( tvb , offset + local_offset ) 20
static int CVE_2013_2486_PATCHED_dissect_diagnosticrequest(int anchor, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length) 1
guint16 local_offset = 0 ; 4
local_offset += 8; 16
local_offset += 8; 19
local_length = tvb_get_ntohl ( tvb , offset + local_offset ); 20
if ( local_offset + local_length > length )  25
if ( local_length > 0 )  29
ti_extensions = proto_tree_add_item ( local_tree , hf_reload_diagnosticrequest_extensions , tvb , offset + local_offset , local_length , ENC_NA ); 36
extensions_tree = proto_item_add_subtree ( ti_extensions , ett_reload_diagnosticrequest_extensions ); 37
if ( extensions_length + 4 > local_length )  39
expert_add_info_format ( pinfo , ti_extensions , PI_PROTOCOL , PI_ERROR , "Truncated Diagnostic extensions" ); 40
extensions_length = local_length - 4; 41
proto_item_append_text ( ti_extensions , " (DiagnosticExtension<%d>)" , extensions_length ); 43
proto_tree_add_item ( extensions_tree , hf_reload_length_uint32 , tvb , offset + local_offset , 4 , ENC_BIG_ENDIAN ); 44
while ( extensions_offset < extensions_length )  45
int local_increment = dissect_diagnosticextension ( tvb , pinfo , extensions_tree , offset + 4 + local_offset + extensions_offset , extensions_length - extensions_offset ) ; 46
if ( local_increment <= 0 )  47
extensions_offset += local_increment; 48
proto_item_append_text ( ti_extensions , " : %d elements" , nExtensions ); 51
local_offset += local_length; 53
return local_offset ; 54
------------------------------
496 /home/SySeVR/data/CVE_2013_2850_PATCHED_iscsi_decode_text_input.c end = ( start + length ) 20
int CVE_2013_2850_PATCHED_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
------------------------------
497 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c end = ( start + length ) 20
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
------------------------------
498 /home/SySeVR/data/CVE_2013_3559_PATCHED_dissect_pft_fec_detailed.c got = ep_alloc ( fcount * sizeof ( guint32 ) ) 45
static tvbuff_t *
CVE_2013_3559_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
if ( fcount > MAX_FRAGMENTS )  19
if ( fdx )  30
guint32 * got ; 37
got = ep_alloc ( fcount * sizeof ( guint32 ) ); 45
for (fd_head = fd; fd_head != NULL && fragments < fcount; fd_head = fd_head->next) 49
got [ fragments ++ ] = fd_head -> offset; 51
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
for(i=0; i<fragments; i++) 67
guint next_fragment_we_have = got [ i ] ; 68
if ( next_fragment_we_have > MAX_FRAGMENTS )  69
proto_tree_add_text ( tree , tvb , 0 , - 1 , "[Reassembly of %d fragments not attempted]" , next_fragment_we_have ); 70
if ( next_fragment_we_have - current_findex > MAX_FRAG_GAP )  73
proto_tree_add_text ( tree , tvb , 0 , - 1 , "[Missing %d consecutive packets. Don't attempt reassembly]" , next_fragment_we_have - current_findex ); 74
for(; current_findex<next_fragment_we_have; current_findex++) 79
------------------------------
499 /home/SySeVR/data/CVE_2013_3559_PATCHED_dissect_pft_fec_detailed.c rx_min = c_max * rsk / plen 27
static tvbuff_t *
CVE_2013_3559_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
guint32 rx_min ; 16
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
------------------------------
500 /home/SySeVR/data/CVE_2013_3559_PATCHED_dissect_pft_fec_detailed.c c_max = fcount * plen / ( rsk + PFT_RS_P ) 26
static tvbuff_t *
CVE_2013_3559_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 108
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 110
------------------------------
501 /home/SySeVR/data/CVE_2013_3559_PATCHED_dissect_pft_fec_detailed.c decoded_size = fcount * plen 25
static tvbuff_t *
CVE_2013_3559_PATCHED_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 decoded_size ; 14
if ( fcount > MAX_FRAGMENTS )  19
decoded_size = fcount * plen; 25
guint8 * output = ( guint8 * ) g_malloc ( decoded_size ) ; 101
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 108
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 110
new_tvb = tvb_new_child_real_data ( dtvb , output , decoded_size , decoded_size ); 112
add_new_data_source ( pinfo , new_tvb , "RS Error Corrected Data" ); 113
tvb_set_free_cb ( new_tvb , g_free ); 114
return new_tvb ; 116
------------------------------
502 /home/SySeVR/data/CVE_2013_3559_VULN_dissect_pft_fec_detailed.c got = ep_alloc ( fcount * sizeof ( guint32 ) ) 45
static tvbuff_t *
CVE_2013_3559_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
if ( fcount > MAX_FRAGMENTS )  19
if ( fdx )  30
guint32 * got ; 37
got = ep_alloc ( fcount * sizeof ( guint32 ) ); 45
for (fd_head = fd; fd_head != NULL && fragments < fcount; fd_head = fd_head->next) 49
got [ fragments ++ ] = fd_head -> offset; 51
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
for(i=0; i<fragments; i++) 67
guint next_fragment_we_have = got [ i ] ; 68
if ( next_fragment_we_have > MAX_FRAGMENTS )  69
proto_tree_add_text ( tree , tvb , 0 , - 1 , "[Reassembly of %d fragments not attempted]" , next_fragment_we_have ); 70
if ( next_fragment_we_have - current_findex > MAX_FRAG_GAP )  73
proto_tree_add_text ( tree , tvb , 0 , - 1 , "[Missing %d consecutive packets. Don't attempt reassembly]" , next_fragment_we_have - current_findex ); 74
for(; current_findex<next_fragment_we_have; current_findex++) 79
------------------------------
503 /home/SySeVR/data/CVE_2013_3559_VULN_dissect_pft_fec_detailed.c rx_min = c_max * rsk / plen 27
static tvbuff_t *
CVE_2013_3559_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
guint32 rx_min ; 16
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
------------------------------
504 /home/SySeVR/data/CVE_2013_3559_VULN_dissect_pft_fec_detailed.c c_max = fcount * plen / ( rsk + PFT_RS_P ) 26
static tvbuff_t *
CVE_2013_3559_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint32 c_max ; 15
if ( fcount > MAX_FRAGMENTS )  19
c_max = fcount * plen / ( rsk + PFT_RS_P ); 26
rx_min = c_max * rsk / plen; 27
if ( rx_min * plen < c_max * rsk )  28
rx_min ++; 29
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 42
if ( fragments >= rx_min )  55
proto_tree_add_text ( tree , tvb , 0 , - 1 , "want %d, got %d need %d" , fcount , fragments , rx_min ); 62
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 108
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 110
------------------------------
505 /home/SySeVR/data/CVE_2013_3559_VULN_dissect_pft_fec_detailed.c decoded_size = fcount * plen 25
static tvbuff_t *
CVE_2013_3559_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,
guint32 findex _U_,
guint32 fcount,
guint16 seq,
gint offset,
guint16 plen,
gboolean fec _U_,
guint16 rsk,
guint16 rsz,
fragment_data *fdx
) 12
guint16 decoded_size ; 14
if ( fcount > MAX_FRAGMENTS )  19
decoded_size = fcount * plen; 25
guint8 * output = ( guint8 * ) g_malloc ( decoded_size ) ; 101
decoded = rs_correct_data ( deinterleaved , output , c_max , rsk , rsz ); 108
proto_tree_add_boolean ( tree , hf_edcp_rs_ok , tvb , offset , 2 , decoded ); 110
new_tvb = tvb_new_child_real_data ( dtvb , output , decoded_size , decoded_size ); 112
add_new_data_source ( pinfo , new_tvb , "RS Error Corrected Data" ); 113
tvb_set_free_cb ( new_tvb , g_free ); 114
return new_tvb ; 116
------------------------------
506 /home/SySeVR/data/CVE_2013_3670_PATCHED_rle_unpack.c ps_end = src + src_len 11
static int CVE_2013_3670_PATCHED_rle_unpack(const unsigned char *src, int src_len, int src_count,
unsigned char *dest, int dest_len) 2
const unsigned char * ps_end ; 5
ps_end = src + src_len; 11
if ( ps_end - ps < 1 )  14
if ( ps_end - ps < 1 )  22
if ( dest_end - pd < l || ps_end - ps < l )  27
if ( dest_end - pd < 2 * l || ps_end - ps < 2 )  33
------------------------------
507 /home/SySeVR/data/CVE_2013_3670_VULN_rle_unpack.c ps_end = src + src_len 11
static int CVE_2013_3670_VULN_rle_unpack(const unsigned char *src, int src_len, int src_count,
unsigned char *dest, int dest_len) 2
const unsigned char * ps_end ; 5
ps_end = src + src_len; 11
if ( ps_end - ps < 1 )  14
if ( ps_end - ps < 1 )  22
if ( dest_end - pd < l || ps_end - ps < l )  27
if ( dest_end - pd < i || ps_end - ps < 2 )  33
------------------------------
508 /home/SySeVR/data/CVE_2013_4076_PATCHED_dissect_iphc_crtp_fh.c ip_packet [ ip_hdr_len + 5 ] = ( length - ip_hdr_len ) 99
static void
CVE_2013_4076_PATCHED_dissect_iphc_crtp_fh(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
guint ip_hdr_len , flags ; 6
guint length ; 7
guint8 ip_version ; 12
guint8 next_protocol ; 13
guchar * ip_packet ; 14
length = tvb_reported_length ( tvb ); 16
ip_version = tvb_get_guint8 ( tvb , 0 ) >> 4; 22
next_protocol = tvb_get_guint8 ( tvb , 9 ); 25
ip_hdr_len = ( tvb_get_guint8 ( tvb , 0 ) & 0x0f ) * 4; 40
if ( ip_version != 4 )  45
if ( next_protocol != IP_PROTO_UDP )  52
ip_packet = tvb_memdup ( tvb , 0 , length ); 92
ip_packet [ 2 ] = length >> 8; 95
ip_packet [ 3 ] = length; 96
ip_packet [ ip_hdr_len + 4 ] = ( length - ip_hdr_len ) >> 8; 98
ip_packet [ ip_hdr_len + 5 ] = ( length - ip_hdr_len ); 99
next_tvb = tvb_new_child_real_data ( tvb , ip_packet , length , length ); 101
add_new_data_source ( pinfo , next_tvb , "Decompressed Data" ); 102
tvb_set_free_cb ( next_tvb , g_free ); 103
if ( ! dissector_try_uint ( ppp_subdissector_table , PPP_IP , next_tvb , pinfo , info_tree ) )  105
call_dissector_only ( data_handle , next_tvb , pinfo , info_tree ); 107
------------------------------
509 /home/SySeVR/data/CVE_2013_4076_PATCHED_dissect_iphc_crtp_fh.c ip_packet [ ip_hdr_len + 4 ] = ( length - ip_hdr_len ) >> 8 98
static void
CVE_2013_4076_PATCHED_dissect_iphc_crtp_fh(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
guint ip_hdr_len , flags ; 6
guint length ; 7
guint8 ip_version ; 12
guint8 next_protocol ; 13
guchar * ip_packet ; 14
length = tvb_reported_length ( tvb ); 16
ip_version = tvb_get_guint8 ( tvb , 0 ) >> 4; 22
next_protocol = tvb_get_guint8 ( tvb , 9 ); 25
ip_hdr_len = ( tvb_get_guint8 ( tvb , 0 ) & 0x0f ) * 4; 40
if ( ip_version != 4 )  45
if ( next_protocol != IP_PROTO_UDP )  52
ip_packet = tvb_memdup ( tvb , 0 , length ); 92
ip_packet [ 2 ] = length >> 8; 95
ip_packet [ 3 ] = length; 96
ip_packet [ ip_hdr_len + 4 ] = ( length - ip_hdr_len ) >> 8; 98
ip_packet [ ip_hdr_len + 5 ] = ( length - ip_hdr_len ); 99
next_tvb = tvb_new_child_real_data ( tvb , ip_packet , length , length ); 101
add_new_data_source ( pinfo , next_tvb , "Decompressed Data" ); 102
tvb_set_free_cb ( next_tvb , g_free ); 103
if ( ! dissector_try_uint ( ppp_subdissector_table , PPP_IP , next_tvb , pinfo , info_tree ) )  105
call_dissector_only ( data_handle , next_tvb , pinfo , info_tree ); 107
------------------------------
510 /home/SySeVR/data/CVE_2013_4082_VULN_vwr_read.c pkt_len = ( guint16 ) ( rec_size + STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN ) 32
static gboolean CVE_2013_4082_VULN_vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint8 rec [ B_SIZE ] ; 4
int rec_size = 0 , IS_TX ; 5
guint16 pkt_len ; 7
if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )  10
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )  17
if ( ( vwr -> FPGA_VERSION == vVW510021_W_FPGA ) || ( vwr -> FPGA_VERSION == vVW510006_W_FPGA ) )  27
pkt_len = ( guint16 ) ( rec_size + STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN ); 32
buffer_assure_space ( wth -> frame_buffer , pkt_len ); 33
------------------------------
511 /home/SySeVR/data/CVE_2013_4082_VULN_vwr_read.c pkt_len = ( guint16 ) ( rec_size + STATS_COMMON_FIELDS_LEN + EXT_RTAP_FIELDS_LEN ) 29
static gboolean CVE_2013_4082_VULN_vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) 1
vwr_t * vwr = ( vwr_t * ) wth -> priv ; 3
guint8 rec [ B_SIZE ] ; 4
int rec_size = 0 , IS_TX ; 5
guint16 pkt_len ; 7
if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )  10
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )  17
if ( ( vwr -> FPGA_VERSION == vVW510021_W_FPGA ) || ( vwr -> FPGA_VERSION == vVW510006_W_FPGA ) )  27
pkt_len = ( guint16 ) ( rec_size + STATS_COMMON_FIELDS_LEN + EXT_RTAP_FIELDS_LEN ); 29
buffer_assure_space ( wth -> frame_buffer , pkt_len ); 33
------------------------------
512 /home/SySeVR/data/CVE_2013_4163_PATCHED_ip6_append_data_mtu.c * maxfraglen = ( ( * mtu - fragheaderlen ) & ~7 ) + fragheaderlen - sizeof ( struct frag_hdr ) 22
static void CVE_2013_4163_PATCHED_ip6_append_data_mtu(unsigned int *mtu,
int *maxfraglen,
unsigned int fragheaderlen,
struct sk_buff *skb,
struct rt6_info *rt,
bool pmtuprobe) 6
if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) )  8
if ( skb == NULL )  9
* mtu = * mtu - rt -> dst . header_len; 11
* mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ); 18
* maxfraglen = ( ( * mtu - fragheaderlen ) & ~7 ) + fragheaderlen - sizeof ( struct frag_hdr ); 22
------------------------------
513 /home/SySeVR/data/CVE_2013_4163_PATCHED_ip6_append_data_mtu.c * mtu = * mtu - rt -> dst . header_len 11
static void CVE_2013_4163_PATCHED_ip6_append_data_mtu(unsigned int *mtu,
int *maxfraglen,
unsigned int fragheaderlen,
struct sk_buff *skb,
struct rt6_info *rt,
bool pmtuprobe) 6
if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) )  8
if ( skb == NULL )  9
* mtu = * mtu - rt -> dst . header_len; 11
* maxfraglen = ( ( * mtu - fragheaderlen ) & ~7 ) + fragheaderlen - sizeof ( struct frag_hdr ); 22
------------------------------
514 /home/SySeVR/data/CVE_2013_4163_VULN_ip6_append_data_mtu.c * maxfraglen = ( ( * mtu - fragheaderlen ) & ~7 ) + fragheaderlen - sizeof ( struct frag_hdr ) 19
static void CVE_2013_4163_VULN_ip6_append_data_mtu(int *mtu,
int *maxfraglen,
unsigned int fragheaderlen,
struct sk_buff *skb,
struct rt6_info *rt) 5
if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) )  7
if ( skb == NULL )  8
* mtu = * mtu - rt -> dst . header_len; 10
* mtu = dst_mtu ( rt -> dst . path ); 17
* maxfraglen = ( ( * mtu - fragheaderlen ) & ~7 ) + fragheaderlen - sizeof ( struct frag_hdr ); 19
------------------------------
515 /home/SySeVR/data/CVE_2013_4163_VULN_ip6_append_data_mtu.c * mtu = * mtu - rt -> dst . header_len 10
static void CVE_2013_4163_VULN_ip6_append_data_mtu(int *mtu,
int *maxfraglen,
unsigned int fragheaderlen,
struct sk_buff *skb,
struct rt6_info *rt) 5
if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) )  7
if ( skb == NULL )  8
* mtu = * mtu - rt -> dst . header_len; 10
* maxfraglen = ( ( * mtu - fragheaderlen ) & ~7 ) + fragheaderlen - sizeof ( struct frag_hdr ); 19
------------------------------
516 /home/SySeVR/data/CVE_2013_4247_PATCHED_build_unc_path_to_root.c pos = full_path + unc_len 14
static char *
CVE_2013_4247_PATCHED_build_unc_path_to_root(const struct smb_vol *vol,
const struct cifs_sb_info *cifs_sb) 3
char * full_path , * pos ; 5
unsigned int pplen = vol -> prepath ? strlen ( vol -> prepath ) + 1 : 0 ; 6
unsigned int unc_len = strnlen ( vol -> UNC , MAX_TREE_SIZE + 1 ) ; 7
full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ); 9
if ( full_path == NULL )  10
strncpy ( full_path , vol -> UNC , unc_len ); 13
pos = full_path + unc_len; 14
* pos = CIFS_DIR_SEP ( cifs_sb ); 17
strncpy ( pos + 1 , vol -> prepath , pplen ); 18
pos += pplen; 19
* pos = '\0'; 22
------------------------------
517 /home/SySeVR/data/CVE_2013_4247_PATCHED_build_unc_path_to_root.c full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ) 9
static char *
CVE_2013_4247_PATCHED_build_unc_path_to_root(const struct smb_vol *vol,
const struct cifs_sb_info *cifs_sb) 3
char * full_path , * pos ; 5
unsigned int pplen = vol -> prepath ? strlen ( vol -> prepath ) + 1 : 0 ; 6
unsigned int unc_len = strnlen ( vol -> UNC , MAX_TREE_SIZE + 1 ) ; 7
full_path = kmalloc ( unc_len + pplen + 1 , GFP_KERNEL ); 9
if ( full_path == NULL )  10
strncpy ( full_path , vol -> UNC , unc_len ); 13
pos = full_path + unc_len; 14
* pos = CIFS_DIR_SEP ( cifs_sb ); 17
strncpy ( pos + 1 , vol -> prepath , pplen ); 18
pos += pplen; 19
* pos = '\0'; 22
convert_delimiter ( full_path , CIFS_DIR_SEP ( cifs_sb ) ); 23
cFYI ( 1 , "%s: full_path=%s" , __func__ , full_path ); 24
return full_path ; 25
------------------------------
518 /home/SySeVR/data/CVE_2013_4470_PATCHED_ip6_ufo_append_data.c skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7 48
static inline int CVE_2013_4470_PATCHED_ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt) 6
struct sk_buff * skb ; 9
if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL )  17
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 18
if ( skb == NULL )  21
skb -> transport_header = skb -> network_header + fragheaderlen; 34
skb -> protocol = htons ( ETH_P_IPV6 ); 36
skb -> csum = 0; 37
if ( skb_is_gso ( skb ) )  40
skb -> ip_summed = CHECKSUM_PARTIAL; 44
skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7; 48
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 50
skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification; 52
------------------------------
519 /home/SySeVR/data/CVE_2013_4470_PATCHED_ip6_ufo_append_data.c skb -> transport_header = skb -> network_header + fragheaderlen 34
static inline int CVE_2013_4470_PATCHED_ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt) 6
struct sk_buff * skb ; 9
if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL )  17
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 18
if ( skb == NULL )  21
skb -> transport_header = skb -> network_header + fragheaderlen; 34
skb -> protocol = htons ( ETH_P_IPV6 ); 36
skb -> csum = 0; 37
__skb_queue_tail ( & sk -> sk_write_queue , skb ); 39
skb -> ip_summed = CHECKSUM_PARTIAL; 44
skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7; 48
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 50
skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification; 52
return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; 55
------------------------------
520 /home/SySeVR/data/CVE_2013_4470_PATCHED_ip6_ufo_append_data.c skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) 18
static inline int CVE_2013_4470_PATCHED_ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt) 6
struct sk_buff * skb ; 9
if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL )  17
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 18
if ( skb == NULL )  21
skb_reserve ( skb , hh_len ); 25
skb_put ( skb , fragheaderlen + transhdrlen ); 28
skb_reset_network_header ( skb ); 31
skb -> transport_header = skb -> network_header + fragheaderlen; 34
skb -> protocol = htons ( ETH_P_IPV6 ); 36
skb -> csum = 0; 37
__skb_queue_tail ( & sk -> sk_write_queue , skb ); 39
skb -> ip_summed = CHECKSUM_PARTIAL; 44
skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7; 48
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 50
skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification; 52
return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; 55
------------------------------
521 /home/SySeVR/data/CVE_2013_4470_PATCHED_ip_ufo_append_data.c skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen 45
static inline int CVE_2013_4470_PATCHED_ip_ufo_append_data(struct sock *sk,
struct sk_buff_head *queue,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int maxfraglen, unsigned int flags) 6
struct sk_buff * skb ; 8
if ( ( skb = skb_peek_tail ( queue ) ) == NULL )  15
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 16
if ( skb == NULL )  20
skb -> transport_header = skb -> network_header + fragheaderlen; 33
skb -> csum = 0; 35
if ( skb_is_gso ( skb ) )  39
skb -> ip_summed = CHECKSUM_PARTIAL; 43
skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen; 45
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 46
------------------------------
522 /home/SySeVR/data/CVE_2013_4470_PATCHED_ip_ufo_append_data.c skb -> transport_header = skb -> network_header + fragheaderlen 33
static inline int CVE_2013_4470_PATCHED_ip_ufo_append_data(struct sock *sk,
struct sk_buff_head *queue,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int maxfraglen, unsigned int flags) 6
struct sk_buff * skb ; 8
if ( ( skb = skb_peek_tail ( queue ) ) == NULL )  15
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 16
if ( skb == NULL )  20
skb -> transport_header = skb -> network_header + fragheaderlen; 33
skb -> csum = 0; 35
__skb_queue_tail ( queue , skb ); 38
skb -> ip_summed = CHECKSUM_PARTIAL; 43
skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen; 45
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 46
return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; 49
------------------------------
523 /home/SySeVR/data/CVE_2013_4470_PATCHED_ip_ufo_append_data.c skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) 16
static inline int CVE_2013_4470_PATCHED_ip_ufo_append_data(struct sock *sk,
struct sk_buff_head *queue,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int maxfraglen, unsigned int flags) 6
struct sk_buff * skb ; 8
if ( ( skb = skb_peek_tail ( queue ) ) == NULL )  15
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 16
if ( skb == NULL )  20
skb_reserve ( skb , hh_len ); 24
skb_put ( skb , fragheaderlen + transhdrlen ); 27
skb_reset_network_header ( skb ); 30
skb -> transport_header = skb -> network_header + fragheaderlen; 33
skb -> csum = 0; 35
__skb_queue_tail ( queue , skb ); 38
skb -> ip_summed = CHECKSUM_PARTIAL; 43
skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen; 45
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 46
return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; 49
------------------------------
524 /home/SySeVR/data/CVE_2013_4470_VULN_ip6_ufo_append_data.c skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7 44
static inline int CVE_2013_4470_VULN_ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt) 6
struct sk_buff * skb ; 9
if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL )  16
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 19
if ( skb == NULL )  22
skb -> transport_header = skb -> network_header + fragheaderlen; 35
skb -> protocol = htons ( ETH_P_IPV6 ); 37
skb -> ip_summed = CHECKSUM_PARTIAL; 38
skb -> csum = 0; 39
skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7; 44
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 46
skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification; 48
------------------------------
525 /home/SySeVR/data/CVE_2013_4470_VULN_ip6_ufo_append_data.c skb -> transport_header = skb -> network_header + fragheaderlen 35
static inline int CVE_2013_4470_VULN_ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt) 6
struct sk_buff * skb ; 9
if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL )  16
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 19
if ( skb == NULL )  22
skb -> transport_header = skb -> network_header + fragheaderlen; 35
skb -> protocol = htons ( ETH_P_IPV6 ); 37
skb -> ip_summed = CHECKSUM_PARTIAL; 38
skb -> csum = 0; 39
skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7; 44
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 46
skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification; 48
__skb_queue_tail ( & sk -> sk_write_queue , skb ); 49
return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; 52
------------------------------
526 /home/SySeVR/data/CVE_2013_4470_VULN_ip6_ufo_append_data.c skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) 19
static inline int CVE_2013_4470_VULN_ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt) 6
struct sk_buff * skb ; 9
if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL )  16
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ); 19
if ( skb == NULL )  22
skb_reserve ( skb , hh_len ); 26
skb_put ( skb , fragheaderlen + transhdrlen ); 29
skb_reset_network_header ( skb ); 32
skb -> transport_header = skb -> network_header + fragheaderlen; 35
skb -> protocol = htons ( ETH_P_IPV6 ); 37
skb -> ip_summed = CHECKSUM_PARTIAL; 38
skb -> csum = 0; 39
skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~7; 44
skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP; 46
skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification; 48
__skb_queue_tail ( & sk -> sk_write_queue , skb ); 49
return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; 52
------------------------------
527 /home/SySeVR/data/CVE_2013_4563_PATCHED_udp6_ufo_fragment.c packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset 60
static struct sk_buff *CVE_2013_4563_PATCHED_udp6_ufo_fragment(struct sk_buff *skb,
netdev_features_t features) 2
unsigned int mss ; 5
u8 * packet_start , * prevhdr ; 8
u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; 10
int offset ; 11
__wsum csum ; 12
int tnl_hlen ; 13
mss = skb_shinfo ( skb ) -> gso_size; 15
if ( unlikely ( skb -> len <= mss ) )  16
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )  19
offset = skb_checksum_start_offset ( skb ); 39
csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ); 40
offset += skb -> csum_offset; 41
* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ); 42
skb -> ip_summed = CHECKSUM_NONE; 43
tnl_hlen = skb_tnl_header_len ( skb ); 46
if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) )  47
if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) )  48
packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset; 60
memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ); 61
------------------------------
528 /home/SySeVR/data/CVE_2013_4563_PATCHED_udp6_ufo_fragment.c unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen 58
static struct sk_buff *CVE_2013_4563_PATCHED_udp6_ufo_fragment(struct sk_buff *skb,
netdev_features_t features) 2
unsigned int mss ; 5
unsigned int unfrag_ip6hlen , unfrag_len ; 6
u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; 10
int offset ; 11
__wsum csum ; 12
int tnl_hlen ; 13
mss = skb_shinfo ( skb ) -> gso_size; 15
if ( unlikely ( skb -> len <= mss ) )  16
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )  19
offset = skb_checksum_start_offset ( skb ); 39
csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ); 40
offset += skb -> csum_offset; 41
* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ); 42
skb -> ip_summed = CHECKSUM_NONE; 43
tnl_hlen = skb_tnl_header_len ( skb ); 46
if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) )  47
if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) )  48
unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ); 55
unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen; 58
memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ); 61
------------------------------
529 /home/SySeVR/data/CVE_2013_4563_PATCHED_udp6_ufo_fragment.c csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) 40
static struct sk_buff *CVE_2013_4563_PATCHED_udp6_ufo_fragment(struct sk_buff *skb,
netdev_features_t features) 2
unsigned int mss ; 5
int offset ; 11
__wsum csum ; 12
mss = skb_shinfo ( skb ) -> gso_size; 15
if ( unlikely ( skb -> len <= mss ) )  16
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )  19
offset = skb_checksum_start_offset ( skb ); 39
csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ); 40
* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ); 42
skb -> ip_summed = CHECKSUM_NONE; 43
tnl_hlen = skb_tnl_header_len ( skb ); 46
if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) )  47
if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) )  48
unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ); 55
unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen; 58
packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset; 60
memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ); 61
SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz; 63
skb -> mac_header -= frag_hdr_sz; 64
skb -> network_header -= frag_hdr_sz; 65
fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ); 67
fptr -> nexthdr = nexthdr; 68
fptr -> reserved = 0; 69
ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ); 70
segs = skb_segment ( skb , features ); 75
return segs ; 78
------------------------------
530 /home/SySeVR/data/CVE_2013_4591_PATCHED___nfs4_get_acl_uncached.c args . acl_len = npages * PAGE_SIZE 38
static ssize_t CVE_2013_4591_PATCHED___nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) 1
struct page * pages [ NFS4ACL_MAXPAGES ] = NULL ,
struct nfs_getaclargs args =
. fh = NFS_FH ( inode ) ,
. acl_pages = pages ,
. acl_len = buflen , 7
struct nfs_getaclres res =
. acl_len = buflen , 10
unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; 17
if ( npages == 0 )  22
npages = 1; 23
if ( npages > ARRAY_SIZE ( pages ) )  24
for (i = 0; i < npages; i++) 27
pages [ i ] = alloc_page ( GFP_KERNEL ); 28
if ( ! pages [ i ] )  29
res . acl_scratch = alloc_page ( GFP_KERNEL ); 34
if ( ! res . acl_scratch )  35
args . acl_len = npages * PAGE_SIZE; 38
args . acl_pgbase = 0; 39
dprintk ( "%s  buf %p buflen %zu npages %d args.acl_len %zu\n" , __func__ , buf , buflen , npages , args . acl_len ); 41
ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ); 43
if ( ret )  45
return ret ; 72
------------------------------
531 /home/SySeVR/data/CVE_2013_4932_PATCHED_elem_lv.c item = proto_tree_add_text ( tree , tvb , curr_offset , parm_len + 1 , "%s%s" , elem_name ? elem_name : "Unknown - aborting dissection" , ( name_add == NULL ) || ( name_add [ 0 ] == '\0' ) ? "" : name_add ) 23
guint16
CVE_2013_4932_PATCHED_elem_lv(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, gint pdu_type, int idx, guint32 offset, guint len _U_, const gchar *name_add) 2
guint8 parm_len ; 4
guint32 curr_offset ; 6
proto_item * item ; 8
const gchar * elem_name ; 11
curr_offset = offset; 14
parm_len = tvb_get_guint8 ( tvb , curr_offset ); 19
elem_name = try_val_to_str_ext ( idx , & elem_names_ext ); 21
item = proto_tree_add_text ( tree , tvb , curr_offset , parm_len + 1 , "%s%s" , elem_name ? elem_name : "Unknown - aborting dissection" , ( name_add == NULL ) || ( name_add [ 0 ] == '\0' ) ? "" : name_add ); 23
subtree = proto_item_add_subtree ( item , elem_ett [ idx ] ); 33
proto_tree_add_uint ( subtree , hf_gsm_a_length , tvb , curr_offset , 1 , parm_len ); 35
proto_tree_add_text ( subtree , tvb , curr_offset + 1 , parm_len , "Element Value" ); 42
consumed = ( * elem_funcs [ idx ] ) ( tvb , subtree , pinfo , curr_offset + 1 , parm_len , a_add_string , 1024 ); 54
proto_item_append_text ( item , "%s" , a_add_string ); 60
return ( consumed + 1 ) ; 65
------------------------------
532 /home/SySeVR/data/CVE_2013_4932_PATCHED_elem_tv_short.c item = proto_tree_add_text ( tree , tvb , curr_offset , - 1 , "%s%s" , elem_name ? elem_name : "Unknown - aborting dissection" , ( name_add == NULL ) || ( name_add [ 0 ] == '\0' ) ? "" : name_add ) 25
guint16 CVE_2013_4932_PATCHED_elem_tv_short(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar *name_add) 1
guint8 oct ; 3
guint32 curr_offset ; 5
proto_item * item ; 7
const gchar * elem_name ; 10
curr_offset = offset; 14
oct = tvb_get_guint8 ( tvb , curr_offset ); 19
if ( ( oct & 0xf0 ) == ( iei & 0xf0 ) )  21
elem_name = try_val_to_str_ext ( idx , & elem_names_ext ); 23
item = proto_tree_add_text ( tree , tvb , curr_offset , - 1 , "%s%s" , elem_name ? elem_name : "Unknown - aborting dissection" , ( name_add == NULL ) || ( name_add [ 0 ] == '\0' ) ? "" : name_add ); 25
subtree = proto_item_add_subtree ( item , elem_ett [ idx ] ); 35
proto_tree_add_text ( subtree , tvb , curr_offset , 1 , "%s = Element ID: 0x%1x-" , buf , oct >> 4 ); 38
proto_tree_add_text ( subtree , tvb , curr_offset , 1 , "No element dissector, rest of dissection may be incorrect" ); 47
consumed = ( * elem_funcs [ idx ] ) ( tvb , subtree , pinfo , curr_offset , RIGHT_NIBBLE , a_add_string , 1024 ); 59
proto_item_append_text ( item , "%s" , a_add_string ); 63
proto_item_set_len ( item , consumed ); 67
return ( consumed ) ; 70
------------------------------
533 /home/SySeVR/data/CVE_2013_5593_PATCHED_nsComboboxControlFrame__AbsolutelyPositionDropDown.c dropdownPosition . x = GetRect ( ) . width - dropdownSize . width 45
nsComboboxControlFrame::DropDownPositionState
CVE_2013_5593_PATCHED_nsComboboxControlFrame::AbsolutelyPositionDropDown() 2
nscoord above , below ; 5
if ( above <= 0 && below <= 0 )  8
nsSize dropdownSize = mDropdownFrame -> GetSize ( ) ; 18
nscoord height = std :: max ( above , below ) ; 19
nsListControlFrame * lcf = static_cast < nsListControlFrame * > mDropdownFrame 20
if ( height < dropdownSize . height )  21
if ( lcf -> GetNumDisplayRows ( ) > 1 )  22
if ( height > ( dropdownSize . height + lcf -> GetHeightOfARow ( ) * 1.5 ) && lcf -> GetDropdownCanGrow ( ) )  28
bool b = dropdownSize . height <= below || dropdownSize . height > above ; 41
nsPoint dropdownPosition ( 0 , b ? GetRect ( ) . height : - dropdownSize . height ) ; 42
if ( StyleVisibility ( ) -> mDirection == NS_STYLE_DIRECTION_RTL )  43
dropdownPosition . x = GetRect ( ) . width - dropdownSize . width; 45
const nsPoint newPos = dropdownPosition + translation ; 51
if ( currentPos != newPos )  52
mDropdownFrame -> SetPosition ( newPos ); 53
------------------------------
534 /home/SySeVR/data/CVE_2013_5593_VULN_nsComboboxControlFrame__AbsolutelyPositionDropDown.c dropdownPosition . x = GetRect ( ) . width - dropdownSize . width 44
nsComboboxControlFrame::DropDownPositionState
CVE_2013_5593_VULN_nsComboboxControlFrame::AbsolutelyPositionDropDown() 2
nscoord above , below ; 5
if ( above <= 0 && below <= 0 )  8
nsSize dropdownSize = mDropdownFrame -> GetSize ( ) ; 18
nscoord height = std :: max ( above , below ) ; 19
nsListControlFrame * lcf = static_cast < nsListControlFrame * > mDropdownFrame 20
if ( height < dropdownSize . height )  21
if ( lcf -> GetNumDisplayRows ( ) > 1 )  22
if ( height > ( dropdownSize . height + lcf -> GetHeightOfARow ( ) * 1.5 ) && lcf -> GetDropdownCanGrow ( ) )  28
bool b = dropdownSize . height <= below || below >= above ; 40
nsPoint dropdownPosition ( 0 , b ? GetRect ( ) . height : - dropdownSize . height ) ; 41
if ( StyleVisibility ( ) -> mDirection == NS_STYLE_DIRECTION_RTL )  42
dropdownPosition . x = GetRect ( ) . width - dropdownSize . width; 44
const nsPoint newPos = dropdownPosition + translation ; 50
if ( currentPos != newPos )  51
mDropdownFrame -> SetPosition ( newPos ); 52
------------------------------
535 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c codecs = m + len 287
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
ast_copy_string ( p -> offered_media [ SDP_TEXT ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_TEXT ] . codecs ) ); 288
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
ast_log ( LOG_WARNING , "Invalid syntax in RTP video format list: %s\n" , codecs ); 291
ast_verbose ( "Found RTP text format %d\n" , codec ); 296
ast_rtp_codecs_payloads_set_m_type ( & newtextrtp , NULL , codec ); 298
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
536 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c codecs = m + len 242
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
ast_copy_string ( p -> offered_media [ SDP_VIDEO ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_VIDEO ] . codecs ) ); 243
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
ast_log ( LOG_WARNING , "Invalid syntax in RTP video format list: %s\n" , codecs ); 246
ast_verbose ( "Found RTP video format %d\n" , codec ); 251
ast_rtp_codecs_payloads_set_m_type ( & newvideortp , NULL , codec ); 253
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
537 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c codecs = m + len 189
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
codecs = m + len; 189
ast_copy_string ( p -> offered_media [ SDP_AUDIO ] . codecs , codecs , sizeof ( p -> offered_media [ SDP_AUDIO ] . codecs ) ); 190
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
ast_log ( LOG_WARNING , "Invalid syntax in RTP audio format list: %s\n" , codecs ); 193
ast_verbose ( "Found RTP audio format %d\n" , codec ); 198
ast_rtp_codecs_payloads_set_m_type ( & newaudiortp , NULL , codec ); 201
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
------------------------------
538 /home/SySeVR/data/CVE_2013_6367_PATCHED_apic_get_tmcct.c tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ) 19
static u32 CVE_2013_6367_PATCHED_apic_get_tmcct(struct kvm_lapic *apic) 1
ktime_t remaining ; 3
s64 ns ; 4
u32 tmcct ; 5
if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 || apic -> lapic_timer . period == 0 )  10
remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ); 14
if ( ktime_to_ns ( remaining ) < 0 )  15
remaining = ktime_set ( 0 , 0 ); 16
ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ); 18
tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ); 19
return tmcct ; 22
------------------------------
539 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ) 173
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
u32 data_dir ; 13
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 55
if ( ! user_srbcmd )  56
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  61
flags = user_srbcmd -> flags; 69
switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  82
data_dir = DMA_TO_DEVICE; 84
data_dir = DMA_BIDIRECTIONAL; 87
data_dir = DMA_FROM_DEVICE; 90
data_dir = DMA_NONE; 93
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); 101
actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); 103
if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  106
if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  117
if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  123
if ( actual_fibsize64 == fibsize )  130
struct user_sgmap * usg ; 172
usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); 173
if ( ! usg )  175
memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); 180
for (i = 0; i < usg->count; i++) 184
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
kfree ( usg ); 192
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" ,
usg -> sg [ i ] . count , i , usg -> count ) ) 200
kfree ( usg ); 201
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
kfree ( usg ); 211
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
kfree ( usg ); 224
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
dprintk ( ( KERN_DEBUG "aacraid: Could not send raw srb fib to hba\n" ) ) 322
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
dprintk ( ( KERN_DEBUG "aacraid: Could not copy sg data to user\n" ) ) 334
dprintk ( ( KERN_DEBUG "aacraid: Could not copy reply to user\n" ) ) 344
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
------------------------------
540 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c user_reply = arg + fibsize 67
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
struct aac_srb_reply __user * user_reply ; 8
u32 fibsize = 0 ; 10
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 55
if ( ! user_srbcmd )  56
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  61
user_reply = arg + fibsize; 67
if ( copy_to_user ( user_reply , reply , sizeof ( struct aac_srb_reply ) ) )  343
------------------------------
541 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ) 172
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
u32 fibsize = 0 ; 10
u32 data_dir ; 13
void * sg_list [ 32 ] ; 15
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 54
if ( ! user_srbcmd )  55
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  60
flags = user_srbcmd -> flags; 68
switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  81
data_dir = DMA_TO_DEVICE; 83
data_dir = DMA_BIDIRECTIONAL; 86
data_dir = DMA_FROM_DEVICE; 89
data_dir = DMA_NONE; 92
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); 100
actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); 102
if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  105
if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  116
if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  122
if ( actual_fibsize64 == fibsize )  129
struct user_sgmap * usg ; 171
usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); 172
if ( ! usg )  174
memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); 179
for (i = 0; i < usg->count; i++) 183
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
kfree ( usg ); 191
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" ,
usg -> sg [ i ] . count , i , usg -> count ) ) 199
kfree ( usg ); 200
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
kfree ( usg ); 210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
kfree ( usg ); 223
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
dprintk ( ( KERN_DEBUG "aacraid: Could not send raw srb fib to hba\n" ) ) 321
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
dprintk ( ( KERN_DEBUG "aacraid: Could not copy sg data to user\n" ) ) 333
dprintk ( ( KERN_DEBUG "aacraid: Could not copy reply to user\n" ) ) 343
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
------------------------------
542 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c user_reply = arg + fibsize 66
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
struct fib * srbfib ; 3
struct user_aac_srb __user * user_srb = arg ; 7
struct aac_srb_reply __user * user_reply ; 8
u32 fibsize = 0 ; 10
if ( dev -> in_reset )  22
if ( ! capable ( CAP_SYS_ADMIN ) )  26
if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  33
if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  43
if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  49
user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); 54
if ( ! user_srbcmd )  55
if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  60
user_reply = arg + fibsize; 66
if ( copy_to_user ( user_reply , reply , sizeof ( struct aac_srb_reply ) ) )  342
------------------------------
543 /home/SySeVR/data/CVE_2013_6381_PATCHED_qeth_snmp_command.c rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) 43
int CVE_2013_6381_PATCHED_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_snmp_ureq * ureq ; 5
unsigned int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) )  22
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 26
if ( IS_ERR ( ureq ) )  27
qinfo . udata_len = ureq -> hdr . data_len; 31
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 32
if ( ! qinfo . udata )  33
qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ); 37
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 39
rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ); 43
if ( rc )  45
QETH_DBF_MESSAGE ( 2 , "SNMP command failed on %s: (0x%x)\n" , QETH_CARD_IFNAME ( card ) , rc ); 46
return rc ; 55
------------------------------
544 /home/SySeVR/data/CVE_2013_6381_PATCHED_qeth_snmp_command.c cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) 41
int CVE_2013_6381_PATCHED_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_ipa_cmd * cmd ; 4
struct qeth_snmp_ureq * ureq ; 5
unsigned int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) )  22
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 26
if ( IS_ERR ( ureq ) )  27
qinfo . udata_len = ureq -> hdr . data_len; 31
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 32
if ( ! qinfo . udata )  33
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 39
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 41
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 42
------------------------------
545 /home/SySeVR/data/CVE_2013_6381_PATCHED_qeth_snmp_command.c iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) 39
int CVE_2013_6381_PATCHED_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_snmp_ureq * ureq ; 5
unsigned int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) )  22
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 26
if ( IS_ERR ( ureq ) )  27
qinfo . udata_len = ureq -> hdr . data_len; 31
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 32
if ( ! qinfo . udata )  33
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 39
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 41
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 42
rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ); 43
if ( rc )  45
QETH_DBF_MESSAGE ( 2 , "SNMP command failed on %s: (0x%x)\n" , QETH_CARD_IFNAME ( card ) , rc ); 46
return rc ; 55
------------------------------
546 /home/SySeVR/data/CVE_2013_6381_PATCHED_qeth_snmp_command.c ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) 26
int CVE_2013_6381_PATCHED_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_snmp_ureq * ureq ; 5
unsigned int req_len ; 6
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) )  22
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 26
if ( IS_ERR ( ureq ) )  27
return PTR_ERR ( ureq ) ; 29
qinfo . udata_len = ureq -> hdr . data_len; 31
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 32
if ( ! qinfo . udata )  33
kfree ( ureq ); 34
qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ); 37
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 42
rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ); 43
if ( rc )  45
QETH_DBF_MESSAGE ( 2 , "SNMP command failed on %s: (0x%x)\n" , QETH_CARD_IFNAME ( card ) , rc ); 46
if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) )  49
kfree ( ureq ); 53
kfree ( qinfo . udata ); 54
return rc ; 55
------------------------------
547 /home/SySeVR/data/CVE_2013_6381_VULN_qeth_snmp_command.c rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) 39
int CVE_2013_6381_VULN_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_snmp_ureq * ureq ; 5
int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 22
if ( IS_ERR ( ureq ) )  23
qinfo . udata_len = ureq -> hdr . data_len; 27
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 28
if ( ! qinfo . udata )  29
qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ); 33
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 35
rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ); 39
if ( rc )  41
QETH_DBF_MESSAGE ( 2 , "SNMP command failed on %s: (0x%x)\n" , QETH_CARD_IFNAME ( card ) , rc ); 42
return rc ; 51
------------------------------
548 /home/SySeVR/data/CVE_2013_6381_VULN_qeth_snmp_command.c cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) 37
int CVE_2013_6381_VULN_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_ipa_cmd * cmd ; 4
struct qeth_snmp_ureq * ureq ; 5
int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 22
if ( IS_ERR ( ureq ) )  23
qinfo . udata_len = ureq -> hdr . data_len; 27
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 28
if ( ! qinfo . udata )  29
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 35
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 37
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 38
------------------------------
549 /home/SySeVR/data/CVE_2013_6381_VULN_qeth_snmp_command.c iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) 35
int CVE_2013_6381_VULN_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_cmd_buffer * iob ; 3
struct qeth_snmp_ureq * ureq ; 5
int req_len ; 6
struct qeth_arp_query_info qinfo = 0 , 7
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 22
if ( IS_ERR ( ureq ) )  23
qinfo . udata_len = ureq -> hdr . data_len; 27
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 28
if ( ! qinfo . udata )  29
iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ); 35
cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ); 37
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 38
rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ); 39
if ( rc )  41
QETH_DBF_MESSAGE ( 2 , "SNMP command failed on %s: (0x%x)\n" , QETH_CARD_IFNAME ( card ) , rc ); 42
return rc ; 51
------------------------------
550 /home/SySeVR/data/CVE_2013_6381_VULN_qeth_snmp_command.c ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) 22
int CVE_2013_6381_VULN_qeth_snmp_command(struct qeth_card *card, char __user *udata) 1
struct qeth_snmp_ureq * ureq ; 5
int req_len ; 6
if ( card -> info . guestlan )  12
if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) )  15
if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  20
ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ); 22
if ( IS_ERR ( ureq ) )  23
return PTR_ERR ( ureq ) ; 25
qinfo . udata_len = ureq -> hdr . data_len; 27
qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ); 28
if ( ! qinfo . udata )  29
kfree ( ureq ); 30
qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ); 33
memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ); 38
rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ); 39
if ( rc )  41
QETH_DBF_MESSAGE ( 2 , "SNMP command failed on %s: (0x%x)\n" , QETH_CARD_IFNAME ( card ) , rc ); 42
if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) )  45
kfree ( ureq ); 49
kfree ( qinfo . udata ); 50
return rc ; 51
------------------------------
551 /home/SySeVR/data/CVE_2013_7009_VULN_rpza_decode_stream.c block_ptr = row_ptr + pixel_ptr 138
static void CVE_2013_7009_VULN_rpza_decode_stream(RpzaContext *s) 1
int stream_ptr = 0 ; 6
int chunk_size ; 7
unsigned char opcode ; 8
int n_blocks ; 9
unsigned char index , idx ; 12
int row_ptr = 0 ; 16
int pixel_ptr = 0 ; 17
int block_ptr ; 18
int pixel_x , pixel_y ; 19
chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF; 28
stream_ptr += 4; 29
chunk_size = s -> size; 35
while ( stream_ptr < chunk_size )  41
opcode = s -> buf [ stream_ptr ++ ]; 42
n_blocks = ( opcode & 0x1f ) + 1; 44
if ( ( opcode & 0x80 ) == 0 )  47
colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ); 48
opcode = 0; 49
if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 )  50
opcode = 0x20; 54
n_blocks = 1; 55
switch ( opcode & 0xe0 )  59
while ( n_blocks -- )  63
stream_ptr += 2; 71
while ( n_blocks -- )  72
for (pixel_y = 0; pixel_y < 4; pixel_y++) 74
for (pixel_x = 0; pixel_x < 4; pixel_x++) 75
stream_ptr += 2; 88
stream_ptr += 2; 91
if ( s -> size - stream_ptr < n_blocks * 4 )  117
while ( n_blocks -- )  119
for (pixel_y = 0; pixel_y < 4; pixel_y++) 121
index = s -> buf [ stream_ptr ++ ]; 122
for (pixel_x = 0; pixel_x < 4; pixel_x++) 123
if ( s -> size - stream_ptr < 16 )  136
block_ptr = row_ptr + pixel_ptr; 138
for (pixel_y = 0; pixel_y < 4; pixel_y++) 139
for (pixel_x = 0; pixel_x < 4; pixel_x++) 140
if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) )  142
stream_ptr += 2; 144
pixels [ block_ptr ] = colorA; 146
block_ptr ++; 147
block_ptr += row_inc; 149
------------------------------
552 /home/SySeVR/data/CVE_2013_7009_VULN_rpza_decode_stream.c block_ptr = row_ptr + pixel_ptr 120
static void CVE_2013_7009_VULN_rpza_decode_stream(RpzaContext *s) 1
int stream_ptr = 0 ; 6
int chunk_size ; 7
unsigned char opcode ; 8
int n_blocks ; 9
unsigned char index , idx ; 12
int row_ptr = 0 ; 16
int pixel_ptr = 0 ; 17
int block_ptr ; 18
int pixel_x , pixel_y ; 19
chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF; 28
stream_ptr += 4; 29
chunk_size = s -> size; 35
while ( stream_ptr < chunk_size )  41
opcode = s -> buf [ stream_ptr ++ ]; 42
n_blocks = ( opcode & 0x1f ) + 1; 44
if ( ( opcode & 0x80 ) == 0 )  47
colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ); 48
opcode = 0; 49
if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 )  50
opcode = 0x20; 54
n_blocks = 1; 55
switch ( opcode & 0xe0 )  59
while ( n_blocks -- )  63
stream_ptr += 2; 71
while ( n_blocks -- )  72
for (pixel_y = 0; pixel_y < 4; pixel_y++) 74
for (pixel_x = 0; pixel_x < 4; pixel_x++) 75
stream_ptr += 2; 88
stream_ptr += 2; 91
if ( s -> size - stream_ptr < n_blocks * 4 )  117
while ( n_blocks -- )  119
block_ptr = row_ptr + pixel_ptr; 120
for (pixel_y = 0; pixel_y < 4; pixel_y++) 121
index = s -> buf [ stream_ptr ++ ]; 122
for (pixel_x = 0; pixel_x < 4; pixel_x++) 123
pixels [ block_ptr ] = color4 [ idx ]; 125
block_ptr ++; 126
block_ptr += row_inc; 128
if ( s -> size - stream_ptr < 16 )  136
for (pixel_y = 0; pixel_y < 4; pixel_y++) 139
for (pixel_x = 0; pixel_x < 4; pixel_x++) 140
if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) )  142
stream_ptr += 2; 144
pixels [ block_ptr ] = colorA; 146
block_ptr ++; 147
block_ptr += row_inc; 149
------------------------------
553 /home/SySeVR/data/CVE_2013_7009_VULN_rpza_decode_stream.c block_ptr = row_ptr + pixel_ptr 73
static void CVE_2013_7009_VULN_rpza_decode_stream(RpzaContext *s) 1
int stream_ptr = 0 ; 6
int chunk_size ; 7
unsigned char opcode ; 8
int n_blocks ; 9
unsigned char index , idx ; 12
int row_ptr = 0 ; 16
int pixel_ptr = 0 ; 17
int block_ptr ; 18
int pixel_x , pixel_y ; 19
chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF; 28
stream_ptr += 4; 29
chunk_size = s -> size; 35
while ( stream_ptr < chunk_size )  41
opcode = s -> buf [ stream_ptr ++ ]; 42
n_blocks = ( opcode & 0x1f ) + 1; 44
if ( ( opcode & 0x80 ) == 0 )  47
colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ); 48
opcode = 0; 49
if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 )  50
opcode = 0x20; 54
n_blocks = 1; 55
switch ( opcode & 0xe0 )  59
while ( n_blocks -- )  63
stream_ptr += 2; 71
while ( n_blocks -- )  72
block_ptr = row_ptr + pixel_ptr; 73
for (pixel_y = 0; pixel_y < 4; pixel_y++) 74
for (pixel_x = 0; pixel_x < 4; pixel_x++) 75
pixels [ block_ptr ] = colorA; 76
block_ptr ++; 77
block_ptr += row_inc; 79
stream_ptr += 2; 88
stream_ptr += 2; 91
if ( s -> size - stream_ptr < n_blocks * 4 )  117
while ( n_blocks -- )  119
for (pixel_y = 0; pixel_y < 4; pixel_y++) 121
index = s -> buf [ stream_ptr ++ ]; 122
for (pixel_x = 0; pixel_x < 4; pixel_x++) 123
pixels [ block_ptr ] = color4 [ idx ]; 125
block_ptr ++; 126
block_ptr += row_inc; 128
if ( s -> size - stream_ptr < 16 )  136
for (pixel_y = 0; pixel_y < 4; pixel_y++) 139
for (pixel_x = 0; pixel_x < 4; pixel_x++) 140
if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) )  142
stream_ptr += 2; 144
pixels [ block_ptr ] = colorA; 146
block_ptr ++; 147
block_ptr += row_inc; 149
------------------------------
554 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y 156
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
555 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x 155
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
556 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y 151
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
557 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x 150
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9; 64
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9; 65
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9; 66
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10; 74
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10; 75
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10; 76
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
558 /home/SySeVR/data/CVE_2013_7013_PATCHED_g2m_init_buffers.c c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) 26
static int CVE_2013_7013_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3; 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
559 /home/SySeVR/data/CVE_2013_7013_PATCHED_g2m_init_buffers.c c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) 24
static int CVE_2013_7013_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3; 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
560 /home/SySeVR/data/CVE_2013_7013_PATCHED_g2m_init_buffers.c c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) 23
static int CVE_2013_7013_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3; 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
561 /home/SySeVR/data/CVE_2013_7013_PATCHED_g2m_init_buffers.c c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) 22
static int CVE_2013_7013_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3; 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
562 /home/SySeVR/data/CVE_2013_7013_PATCHED_g2m_init_buffers.c c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) 9
static int CVE_2013_7013_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3; 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
av_free ( c -> synth_tile ); 18
av_free ( c -> jpeg_tile ); 19
av_free ( c -> kempf_buf ); 20
av_free ( c -> kempf_flags ); 21
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
563 /home/SySeVR/data/CVE_2013_7013_VULN_g2m_init_buffers.c c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) 26
static int CVE_2013_7013_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
564 /home/SySeVR/data/CVE_2013_7013_VULN_g2m_init_buffers.c c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) 24
static int CVE_2013_7013_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
565 /home/SySeVR/data/CVE_2013_7013_VULN_g2m_init_buffers.c c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) 23
static int CVE_2013_7013_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
566 /home/SySeVR/data/CVE_2013_7013_VULN_g2m_init_buffers.c c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) 22
static int CVE_2013_7013_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
567 /home/SySeVR/data/CVE_2013_7013_VULN_g2m_init_buffers.c c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) 9
static int CVE_2013_7013_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
av_free ( c -> synth_tile ); 18
av_free ( c -> jpeg_tile ); 19
av_free ( c -> kempf_buf ); 20
av_free ( c -> kempf_flags ); 21
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
568 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) 252
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
uint16_t Cx0 , Cy0 ; 242
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
569 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) 199
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
570 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y 185
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
------------------------------
571 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) 118
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
572 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) 105
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
573 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] 103
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
574 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) 252
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
uint16_t Cx0 , Cy0 ; 242
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
575 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) 199
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
576 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y 185
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
------------------------------
577 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) 118
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
578 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) 105
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
579 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] 103
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
580 /home/SySeVR/data/CVE_2013_7021_PATCHED_filter_frame.c s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) 89
static int CVE_2013_7021_PATCHED_filter_frame(AVFilterLink *inlink, AVFrame *buf) 1
AVFilterContext * ctx = inlink -> dst ; 3
FPSContext * s = ctx -> priv ; 4
AVFilterLink * outlink = ctx -> outputs [ 0 ] ; 5
int64_t delta ; 6
int i , ret ; 7
s -> frames_in ++; 9
if ( s -> pts == AV_NOPTS_VALUE )  11
if ( buf -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0 )  28
delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ); 33
if ( delta < 1 )  36
for (i = 0; i < delta; i++) 53
AVFrame * buf_out ; 54
if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 )  58
AVFrame * dup = av_frame_clone ( buf_out ) ; 59
if ( dup )  62
ret = write_to_fifo ( s -> fifo , dup ); 63
ret = AVERROR ( ENOMEM ); 65
if ( ret < 0 )  67
s -> dup ++; 73
buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out; 76
if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 )  79
s -> frames_out ++; 84
s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ); 89
------------------------------
581 /home/SySeVR/data/CVE_2013_7021_PATCHED_filter_frame.c delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) 33
static int CVE_2013_7021_PATCHED_filter_frame(AVFilterLink *inlink, AVFrame *buf) 1
AVFilterContext * ctx = inlink -> dst ; 3
FPSContext * s = ctx -> priv ; 4
AVFilterLink * outlink = ctx -> outputs [ 0 ] ; 5
int64_t delta ; 6
s -> frames_in ++; 9
if ( s -> pts == AV_NOPTS_VALUE )  11
if ( buf -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0 )  28
delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ); 33
if ( delta < 1 )  36
for (i = 0; i < delta; i++) 53
if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 )  58
------------------------------
582 /home/SySeVR/data/CVE_2013_7022_PATCHED_g2m_init_buffers.c c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) 26
static int CVE_2013_7022_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3; 6
aligned_height = c -> height + 15; 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
583 /home/SySeVR/data/CVE_2013_7022_PATCHED_g2m_init_buffers.c c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) 24
static int CVE_2013_7022_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3; 6
aligned_height = c -> height + 15; 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
584 /home/SySeVR/data/CVE_2013_7022_PATCHED_g2m_init_buffers.c c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) 23
static int CVE_2013_7022_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3; 6
aligned_height = c -> height + 15; 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
585 /home/SySeVR/data/CVE_2013_7022_PATCHED_g2m_init_buffers.c c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) 22
static int CVE_2013_7022_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3; 6
aligned_height = c -> height + 15; 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
586 /home/SySeVR/data/CVE_2013_7022_PATCHED_g2m_init_buffers.c c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) 9
static int CVE_2013_7022_PATCHED_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3; 6
aligned_height = c -> height + 15; 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
av_free ( c -> synth_tile ); 18
av_free ( c -> jpeg_tile ); 19
av_free ( c -> kempf_buf ); 20
av_free ( c -> kempf_flags ); 21
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
587 /home/SySeVR/data/CVE_2013_7022_VULN_g2m_init_buffers.c c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) 26
static int CVE_2013_7022_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
588 /home/SySeVR/data/CVE_2013_7022_VULN_g2m_init_buffers.c c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) 24
static int CVE_2013_7022_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
589 /home/SySeVR/data/CVE_2013_7022_VULN_g2m_init_buffers.c c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) 23
static int CVE_2013_7022_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
590 /home/SySeVR/data/CVE_2013_7022_VULN_g2m_init_buffers.c c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) 22
static int CVE_2013_7022_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
591 /home/SySeVR/data/CVE_2013_7022_VULN_g2m_init_buffers.c c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) 9
static int CVE_2013_7022_VULN_g2m_init_buffers(G2MContext *c) 1
int aligned_height ; 3
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )  5
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ); 6
aligned_height = FFALIGN ( c -> height , 16 ); 7
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ); 9
if ( ! c -> framebuf )  10
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )  13
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ); 16
aligned_height = FFALIGN ( c -> tile_height , 16 ); 17
av_free ( c -> synth_tile ); 18
av_free ( c -> jpeg_tile ); 19
av_free ( c -> kempf_buf ); 20
av_free ( c -> kempf_flags ); 21
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ); 22
c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ); 23
c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ); 24
c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ); 26
if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags )  27
------------------------------
592 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] 53
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
if ( next > - FF_INPUT_BUFFER_PADDING_SIZE )  43
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
for(;next < 0; next++) 51
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
------------------------------
593 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] 52
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
if ( next > - FF_INPUT_BUFFER_PADDING_SIZE )  43
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
for(;next < 0; next++) 51
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
------------------------------
594 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c * buf_size = pc -> overread_index = pc -> index + next 33
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
* buf = pc -> buffer; 47
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 60
------------------------------
595 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ) 139
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 118
uint16_t * linel ; 123
int planar = ! ! picture -> data [ 2 ] ; 126
int pixelsize = planar ? 1 : s -> ncomponents ; 127
int plane = 0 ; 128
if ( planar )  130
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 135
uint16_t * dst ; 136
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 138
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
596 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ) 134
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 118
uint16_t * linel ; 123
int planar = ! ! picture -> data [ 2 ] ; 126
int plane = 0 ; 128
if ( planar )  130
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
597 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar 93
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
uint8_t * line ; 7
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int planar = ! ! picture -> data [ 2 ] ; 79
int pixelsize = planar ? 1 : s -> ncomponents ; 80
int plane = 0 ; 81
if ( planar )  83
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 89
uint8_t * dst ; 90
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 92
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
------------------------------
598 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ] 88
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
uint8_t * line ; 7
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int planar = ! ! picture -> data [ 2 ] ; 79
int plane = 0 ; 81
if ( planar )  83
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
------------------------------
599 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y 30
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
------------------------------
600 /home/SySeVR/data/CVE_2013_7027_PATCHED_ieee80211_radiotap_iterator_init.c iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) 22
int CVE_2013_7027_PATCHED_ieee80211_radiotap_iterator_init(
struct ieee80211_radiotap_iterator *iterator,
struct ieee80211_radiotap_header *radiotap_header,
int max_length, const struct ieee80211_radiotap_vendor_namespaces *vns) 4
if ( max_length < sizeof ( struct ieee80211_radiotap_header ) )  7
if ( radiotap_header -> it_version )  11
if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) )  15
iterator -> _rtheader = radiotap_header; 18
iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ); 19
iterator -> _arg_index = 0; 20
iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ); 21
iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ); 22
iterator -> _reset_on_ext = 0; 23
iterator -> _next_bitmap = & radiotap_header -> it_present; 24
iterator -> _next_bitmap ++; 25
iterator -> _vns = vns; 26
iterator -> current_namespace = & radiotap_ns; 27
iterator -> is_radiotap_ns = 1; 28
if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) )  32
while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) )  33
iterator -> _arg += sizeof ( uint32_t ); 35
if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader + sizeof ( uint32_t ) > ( unsigned long ) iterator -> _max_length )  43
iterator -> _arg += sizeof ( uint32_t ); 50
iterator -> this_arg = iterator -> _arg; 59
------------------------------
601 /home/SySeVR/data/CVE_2014_0069_PATCHED_cifs_iovec_write.c cur_len = save_len - cur_len 76
static ssize_t
CVE_2014_0069_PATCHED_cifs_iovec_write(struct file *file, const struct iovec *iov,
unsigned long nr_segs, loff_t *poffset) 3
unsigned long nr_pages , i ; 5
size_t bytes , copied , len , cur_len ; 6
loff_t offset ; 8
struct cifsFileInfo * open_file ; 10
struct cifs_tcon * tcon ; 11
struct cifs_sb_info * cifs_sb ; 12
struct cifs_writedata * wdata , * tmp ; 13
int rc ; 15
pid_t pid ; 16
len = iov_length ( iov , nr_segs ); 18
if ( ! len )  19
rc = generic_write_checks ( file , poffset , & len , 0 ); 22
if ( rc )  23
cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ); 27
open_file = file -> private_data; 28
tcon = tlink_tcon ( open_file -> tlink ); 29
if ( ! tcon -> ses -> server -> ops -> async_writev )  31
offset = * poffset; 34
if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD )  36
pid = open_file -> pid; 37
pid = current -> tgid; 39
size_t save_len ; 43
nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ); 45
wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ); 46
if ( ! wdata )  48
rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ); 53
if ( rc )  54
kfree ( wdata ); 55
save_len = cur_len; 59
for (i = 0; i < nr_pages; i++) 60
bytes = min_t ( const size_t , cur_len , PAGE_SIZE ) 61
copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes ); 62
cur_len -= copied; 64
iov_iter_advance ( & it , copied ); 65
if ( copied < bytes )  73
cur_len = save_len - cur_len; 76
if ( ! cur_len )  84
for (i = 0; i < nr_pages; i++) 85
put_page ( wdata -> pages [ i ] ); 86
kfree ( wdata ); 87
for ( ; nr_pages > i + 1; nr_pages--) 97
put_page ( wdata -> pages [ nr_pages - 1 ] ); 98
wdata -> sync_mode = WB_SYNC_ALL; 100
wdata -> nr_pages = nr_pages; 101
wdata -> offset = ( __u64 ) offset; 102
wdata -> cfile = cifsFileInfo_get ( open_file ); 103
wdata -> pid = pid; 104
wdata -> bytes = cur_len; 105
wdata -> pagesz = PAGE_SIZE; 106
wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ); 107
rc = cifs_uncached_retry_writev ( wdata ); 108
if ( rc )  109
kref_put ( & wdata -> refcount , cifs_writedata_release ); 110
list_add_tail ( & wdata -> list , & wdata_list ); 114
offset += cur_len; 115
len -= cur_len; 116
while ( len > 0 )  117
list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) 134
if ( ! rc )  135
rc = wait_for_completion_killable ( & wdata -> done ); 137
if ( rc )  138
if ( wdata -> result )  140
rc = wdata -> result; 141
total_written += wdata -> bytes; 143
if ( rc == - EAGAIN )  146
rc = cifs_uncached_retry_writev ( wdata ); 147
list_del_init ( & wdata -> list ); 151
kref_put ( & wdata -> refcount , cifs_writedata_release ); 152
if ( total_written > 0 )  155
* poffset += total_written; 156
cifs_stats_bytes_written ( tcon , total_written ); 158
return total_written ? total_written : ( ssize_t ) rc ; 159
------------------------------
602 /home/SySeVR/data/CVE_2014_0160_PATCHED_tls1_process_heartbeat.c r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ) 43
int
CVE_2014_0160_PATCHED_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
if ( 1 + 2 + 16 > s -> s3 -> rrec . length )  15
hbtype = * p ++; 17
if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length )  19
if ( hbtype == TLS1_HB_REQUEST )  23
unsigned char * buffer , * bp ; 25
int r ; 26
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 32
r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ); 43
if ( r >= 0 && s -> msg_callback )  45
if ( r < 0 )  52
return r ; 53
------------------------------
603 /home/SySeVR/data/CVE_2014_0160_PATCHED_tls1_process_heartbeat.c buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ) 32
int
CVE_2014_0160_PATCHED_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
if ( 1 + 2 + 16 > s -> s3 -> rrec . length )  15
hbtype = * p ++; 17
if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length )  19
if ( hbtype == TLS1_HB_REQUEST )  23
unsigned char * buffer , * bp ; 25
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 32
bp = buffer; 33
* bp ++ = TLS1_HB_RESPONSE; 36
s2n ( payload , bp ); 37
memcpy ( bp , pl , payload ); 38
bp += payload; 39
RAND_pseudo_bytes ( bp , padding ); 41
r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ); 43
if ( r >= 0 && s -> msg_callback )  45
s -> msg_callback ( 1 , s -> version , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding , s , s -> msg_callback_arg ); 46
OPENSSL_free ( buffer ); 50
if ( r < 0 )  52
return r ; 53
------------------------------
604 /home/SySeVR/data/CVE_2014_0160_VULN_dtls1_process_heartbeat.c r = dtls1_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ) 39
int
CVE_2014_0160_VULN_dtls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
int r ; 22
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
r = dtls1_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ); 39
if ( r >= 0 && s -> msg_callback )  41
if ( r < 0 )  48
return r ; 49
------------------------------
605 /home/SySeVR/data/CVE_2014_0160_VULN_dtls1_process_heartbeat.c buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ) 28
int
CVE_2014_0160_VULN_dtls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
bp = buffer; 29
* bp ++ = TLS1_HB_RESPONSE; 32
s2n ( payload , bp ); 33
memcpy ( bp , pl , payload ); 34
bp += payload; 35
RAND_pseudo_bytes ( bp , padding ); 37
r = dtls1_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ); 39
if ( r >= 0 && s -> msg_callback )  41
s -> msg_callback ( 1 , s -> version , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding , s , s -> msg_callback_arg ); 42
OPENSSL_free ( buffer ); 46
if ( r < 0 )  48
return r ; 49
------------------------------
606 /home/SySeVR/data/CVE_2014_0160_VULN_tls1_process_heartbeat.c r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ) 39
int
CVE_2014_0160_VULN_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
int r ; 22
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ); 39
if ( r >= 0 && s -> msg_callback )  41
if ( r < 0 )  48
return r ; 49
------------------------------
607 /home/SySeVR/data/CVE_2014_0160_VULN_tls1_process_heartbeat.c buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ) 28
int
CVE_2014_0160_VULN_tls1_process_heartbeat(SSL *s) 2
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ; 4
unsigned short hbtype ; 5
unsigned int payload ; 6
unsigned int padding = 16 ; 7
hbtype = * p ++; 10
if ( hbtype == TLS1_HB_REQUEST )  19
unsigned char * buffer , * bp ; 21
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding ); 28
bp = buffer; 29
* bp ++ = TLS1_HB_RESPONSE; 32
s2n ( payload , bp ); 33
memcpy ( bp , pl , payload ); 34
bp += payload; 35
RAND_pseudo_bytes ( bp , padding ); 37
r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ); 39
if ( r >= 0 && s -> msg_callback )  41
s -> msg_callback ( 1 , s -> version , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding , s , s -> msg_callback_arg ); 42
OPENSSL_free ( buffer ); 46
if ( r < 0 )  48
return r ; 49
------------------------------
608 /home/SySeVR/data/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c static_assert ( UINT16_MAX + ( UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) , "chunkExtension array too large for iterator." ) 61
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
p += 4; 32
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
static_assert ( UINT16_MAX + ( UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) , "chunkExtension array too large for iterator." ); 61
------------------------------
609 /home/SySeVR/data/CVE_2014_1522_VULN_ComputeCustom.c aOutput [ i ] = tableInterpolationFactor * lower + ( 1 - tableInterpolationFactor ) * higher 36
void CVE_2014_1522_VULN_ComputeCustom(float* aOutput,
TrackTicks ticks,
uint32_t aStart,
uint32_t aEnd) 4
uint32_t periodicWaveSize = mPeriodicWave -> periodicWaveSize ( ) ; 8
float * higherWaveData = nullptr ; 9
float * lowerWaveData = nullptr ; 10
float tableInterpolationFactor ; 11
float rate = 1.0 / mSource -> SampleRate ( ) ; 12
for (uint32_t i = aStart; i < aEnd; ++i) 14
mPhase += periodicWaveSize * mFinalFrequency * rate; 21
if ( mPhase >= periodicWaveSize )  22
mPhase -= periodicWaveSize; 23
uint32_t j1 = floor ( mPhase ) ; 26
uint32_t j2 = j1 + 1 ; 27
if ( j2 >= periodicWaveSize )  28
j2 -= periodicWaveSize; 29
float sampleInterpolationFactor = mPhase - j1 ; 31
float lower = sampleInterpolationFactor * lowerWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * lowerWaveData [ j2 ] ; 32
float higher = sampleInterpolationFactor * higherWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * higherWaveData [ j2 ] ; 34
aOutput [ i ] = tableInterpolationFactor * lower + ( 1 - tableInterpolationFactor ) * higher; 36
------------------------------
610 /home/SySeVR/data/CVE_2014_1642_VULN_pirq_guest_bind.c irq = desc - irq_desc 20
int CVE_2014_1642_VULN_pirq_guest_bind(struct vcpu *v, struct pirq *pirq, int will_share) 1
unsigned int irq ; 3
struct irq_desc * desc ; 4
irq_guest_action_t * action , * newaction = NULL ; 5
desc = pirq_spin_lock_irq_desc ( pirq , NULL ); 12
if ( desc == NULL )  13
action = ( irq_guest_action_t * ) desc -> action; 19
irq = desc - irq_desc; 20
if ( ! ( desc -> status & IRQ_GUEST ) )  22
if ( desc -> action != NULL )  24
if ( newaction == NULL )  33
if ( ( newaction = xmalloc ( irq_guest_action_t ) ) != NULL && zalloc_cpumask_var ( & newaction -> cpu_eoi_map ) )  36
if ( ! will_share || ! action -> shareable )  65
if ( action -> nr_guests == 0 )  74
------------------------------
611 /home/SySeVR/data/CVE_2014_2282_VULN_dissect_protocol_data_parameter.c ulp_length = tvb_get_ntohs ( parameter_tvb , PARAMETER_LENGTH_OFFSET ) - PARAMETER_HEADER_LENGTH - DATA_HDR_LENGTH 54
static void
CVE_2014_2282_VULN_dissect_protocol_data_parameter(tvbuff_t *parameter_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *parameter_tree, proto_item *parameter_item) 2
guint16 ulp_length ; 4
ulp_length = tvb_get_ntohs ( parameter_tvb , PARAMETER_LENGTH_OFFSET ) - PARAMETER_HEADER_LENGTH - DATA_HDR_LENGTH; 54
proto_item_append_text ( parameter_item , " (SS7 message of %u byte%s)" , ulp_length , plurality ( ulp_length , "" , "s" ) ); 79
payload_tvb = tvb_new_subset ( parameter_tvb , DATA_ULP_OFFSET , ulp_length , ulp_length ); 101
if ( ! dissector_try_uint ( si_dissector_table , tvb_get_guint8 ( parameter_tvb , DATA_SI_OFFSET ) , payload_tvb , pinfo , tree ) )  102
call_dissector ( data_handle , payload_tvb , pinfo , tree ); 103
------------------------------
612 /home/SySeVR/data/CVE_2014_2282_VULN_dissect_protocol_data_parameter.c ulp_length = tvb_get_ntohs ( parameter_tvb , PARAMETER_LENGTH_OFFSET ) - PARAMETER_HEADER_LENGTH - DATA_HDR_LENGTH 14
static void
CVE_2014_2282_VULN_dissect_protocol_data_parameter(tvbuff_t *parameter_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *parameter_tree, proto_item *parameter_item) 2
guint16 ulp_length ; 4
ulp_length = tvb_get_ntohs ( parameter_tvb , PARAMETER_LENGTH_OFFSET ) - PARAMETER_HEADER_LENGTH - DATA_HDR_LENGTH; 14
payload_tvb = tvb_new_subset ( parameter_tvb , DATA_ULP_OFFSET , ulp_length , ulp_length ); 15
heuristic_standard = m3ua_heur_mtp3_standard ( payload_tvb , pinfo , opc , dpc , si ); 22
if ( heuristic_standard == HEURISTIC_FAILED_STANDARD )  23
gen_item = proto_tree_add_text ( tree , parameter_tvb , 0 , 0 , "%s" , val_to_str_const ( heuristic_standard , mtp3_standard_vals , "unknown" ) ); 26
mtp3_standard = heuristic_standard; 28
PROTO_ITEM_SET_GENERATED ( gen_item ); 35
mtp3_tap -> addr_dpc . type = ( Standard_Type ) mtp3_standard; 38
mtp3_tap -> addr_dpc . pc = dpc; 39
mtp3_tap -> addr_dpc . ni = tvb_get_guint8 ( parameter_tvb , DATA_NI_OFFSET ); 40
SET_ADDRESS ( & pinfo -> dst , AT_SS7PC , sizeof ( mtp3_addr_pc_t ) , ( guint8 * ) & mtp3_tap -> addr_dpc ); 41
mtp3_tap -> addr_opc . type = ( Standard_Type ) mtp3_standard; 44
mtp3_tap -> addr_opc . pc = opc; 45
mtp3_tap -> addr_opc . ni = tvb_get_guint8 ( parameter_tvb , DATA_NI_OFFSET ); 46
SET_ADDRESS ( & pinfo -> src , AT_SS7PC , sizeof ( mtp3_addr_pc_t ) , ( guint8 * ) & mtp3_tap -> addr_opc ); 47
mtp3_tap -> si_code = tvb_get_guint8 ( parameter_tvb , DATA_SI_OFFSET ); 49
mtp3_tap -> size = 0; 50
tap_queue_packet ( m3ua_tap , pinfo , mtp3_tap ); 52
if ( mtp3_tap -> addr_opc . ni == MTP3_NI_INT0 )  60
if ( mtp3_tap -> addr_dpc . ni == MTP3_NI_INT0 )  69
proto_item_append_text ( parameter_item , " (SS7 message of %u byte%s)" , ulp_length , plurality ( ulp_length , "" , "s" ) ); 79
payload_tvb = tvb_new_subset ( parameter_tvb , DATA_ULP_OFFSET , ulp_length , ulp_length ); 101
if ( ! dissector_try_uint ( si_dissector_table , tvb_get_guint8 ( parameter_tvb , DATA_SI_OFFSET ) , payload_tvb , pinfo , tree ) )  102
call_dissector ( data_handle , payload_tvb , pinfo , tree ); 103
------------------------------
613 /home/SySeVR/data/CVE_2014_2289_PATCHED_copy_body_types.c exten_state_sub -> body_types [ i ] = ast_malloc ( hdr -> values [ i ] . slen * sizeof ( char * ) + 1 ) 19
static void CVE_2014_2289_PATCHED_copy_body_types(pjsip_rx_data *rdata,
struct exten_state_subscription *exten_state_sub) 3
int i ; 5
pjsip_accept_hdr * hdr = ( pjsip_accept_hdr * ) pjsip_msg_find_hdr ( rdata -> msg_info . msg , PJSIP_H_ACCEPT , NULL ) ; 6
if ( ! hdr )  9
hdr = & default_presence_accept; 13
exten_state_sub -> body_types_count = hdr -> count; 15
exten_state_sub -> body_types = ast_malloc ( hdr -> count * sizeof ( char * ) ); 16
for (i = 0; i < hdr->count; ++i) 18
exten_state_sub -> body_types [ i ] = ast_malloc ( hdr -> values [ i ] . slen * sizeof ( char * ) + 1 ); 19
ast_copy_string ( exten_state_sub -> body_types [ i ] , pj_strbuf ( & hdr -> values [ i ] ) , hdr -> values [ i ] . slen + 1 ); 22
------------------------------
614 /home/SySeVR/data/CVE_2014_2289_PATCHED_copy_body_types.c exten_state_sub -> body_types = ast_malloc ( hdr -> count * sizeof ( char * ) ) 16
static void CVE_2014_2289_PATCHED_copy_body_types(pjsip_rx_data *rdata,
struct exten_state_subscription *exten_state_sub) 3
pjsip_accept_hdr * hdr = ( pjsip_accept_hdr * ) pjsip_msg_find_hdr ( rdata -> msg_info . msg , PJSIP_H_ACCEPT , NULL ) ; 6
if ( ! hdr )  9
hdr = & default_presence_accept; 13
exten_state_sub -> body_types_count = hdr -> count; 15
exten_state_sub -> body_types = ast_malloc ( hdr -> count * sizeof ( char * ) ); 16
exten_state_sub -> body_types [ i ] = ast_malloc ( hdr -> values [ i ] . slen * sizeof ( char * ) + 1 ); 19
ast_copy_string ( exten_state_sub -> body_types [ i ] , pj_strbuf ( & hdr -> values [ i ] ) , hdr -> values [ i ] . slen + 1 ); 22
------------------------------
615 /home/SySeVR/data/CVE_2014_2889_PATCHED_bpf_jit_compile.c addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ) 20
void CVE_2014_2889_PATCHED_bpf_jit_compile(struct sk_filter *fp) 1
unsigned int * addrs ; 13
int flen = fp -> len ; 15
if ( ! bpf_jit_enable )  17
addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ); 20
if ( addrs == NULL )  21
addrs [ i ] = proglen; 29
------------------------------
616 /home/SySeVR/data/CVE_2014_2889_VULN_bpf_jit_compile.c addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ) 20
void CVE_2014_2889_VULN_bpf_jit_compile(struct sk_filter *fp) 1
unsigned int * addrs ; 13
int flen = fp -> len ; 15
if ( ! bpf_jit_enable )  17
addrs = kmalloc ( flen * sizeof ( * addrs ) , GFP_KERNEL ); 20
if ( addrs == NULL )  21
addrs [ i ] = proglen; 29
------------------------------
617 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ) 359
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
ap_listen_rec * lr = ( ap_listen_rec * ) lr_ ; 14
winnt_conn_ctx_t * context = NULL ; 16
DWORD BytesRead ; 17
SOCKET nlsd ; 18
LPFN_ACCEPTEX lpfnAcceptEx = NULL ; 19
LPFN_GETACCEPTEXSOCKADDRS lpfnGetAcceptExSockaddrs = NULL ; 20
GUID GuidAcceptEx = WSAID_ACCEPTEX ; 21
GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS ; 22
core_server_config * core_sconf ; 23
const char * accf_name ; 24
int rv ; 25
int accf ; 26
int err_count = 0 ; 27
HANDLE events [ 3 ] ; 28
SOCKADDR_STORAGE ss_listen ; 30
core_sconf = ap_get_core_module_config ( ap_server_conf -> module_config ); 35
accf_name = apr_table_get ( core_sconf -> accf_map , lr -> protocol ); 36
if ( ! accf_name )  38
accf = 0; 39
accf_name = "none"; 40
if ( strcmp ( accf_name , "data" ) == 0 )  46
accf = 2; 47
if ( strcmp ( accf_name , "connect" ) == 0 )  48
accf = 1; 49
if ( strcmp ( accf_name , "none" ) == 0 )  50
accf = 0; 51
accf = 0; 53
if ( getsockname ( nlsd , ( struct sockaddr * ) & ss_listen , & namelen ) == SOCKET_ERROR )  64
if ( accf > 0 )  73
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidAcceptEx , sizeof GuidAcceptEx , & lpfnAcceptEx , sizeof lpfnAcceptEx , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  75
if ( WSAIoctl ( nlsd , SIO_GET_EXTENSION_FUNCTION_POINTER , & GuidGetAcceptExSockaddrs , sizeof GuidGetAcceptExSockaddrs , & lpfnGetAcceptExSockaddrs , sizeof lpfnGetAcceptExSockaddrs , & BytesRead , NULL , NULL ) == SOCKET_ERROR )  84
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
while ( ! shutdown_in_progress )  123
if ( ! context )  124
int timeout ; 125
context = mpm_get_completion_context ( & timeout ); 127
if ( ! context )  128
if ( ! timeout )  129
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  132
if ( accf > 0 )  144
DWORD len ; 146
char * buf ; 147
if ( context -> accept_socket == INVALID_SOCKET )  151
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 152
context -> socket_family = ss_listen . ss_family; 154
if ( context -> socket_family != ss_listen . ss_family )  156
closesocket ( context -> accept_socket ); 157
context -> accept_socket = socket ( ss_listen . ss_family , SOCK_STREAM , IPPROTO_TCP ); 158
context -> socket_family = ss_listen . ss_family; 160
if ( context -> accept_socket == INVALID_SOCKET )  167
if ( accf == 2 )  176
len = APR_BUCKET_BUFF_SIZE; 177
buf = apr_bucket_alloc ( len , context -> ba ); 178
len -= PADDED_ADDR_SIZE * 2; 179
len = 0; 182
buf = context -> buff; 183
if ( ! lpfnAcceptEx ( nlsd , context -> accept_socket , buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & BytesRead , & context -> overlapped ) )  189
rv = apr_get_netos_error ( ); 192
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
apr_bucket_free ( buf ); 200
closesocket ( context -> accept_socket ); 201
context -> accept_socket = INVALID_SOCKET; 202
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
apr_bucket_free ( buf ); 216
closesocket ( context -> accept_socket ); 217
context -> accept_socket = INVALID_SOCKET; 218
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  220
err_count = 0; 229
accf = 0; 230
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
apr_bucket_free ( buf ); 237
closesocket ( context -> accept_socket ); 238
context -> accept_socket = INVALID_SOCKET; 239
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  241
err_count = 0; 248
accf = 0; 249
err_count = 0; 255
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
if ( ( context -> accept_socket != INVALID_SOCKET ) && ! GetOverlappedResult ( ( HANDLE ) context -> accept_socket , & context -> overlapped , & BytesRead , FALSE ) )  263
closesocket ( context -> accept_socket ); 270
context -> accept_socket = INVALID_SOCKET; 271
closesocket ( context -> accept_socket ); 276
apr_bucket_free ( buf ); 279
if ( context -> accept_socket == INVALID_SOCKET )  283
apr_bucket_free ( buf ); 285
err_count = 0; 289
if ( setsockopt ( context -> accept_socket , SOL_SOCKET , SO_UPDATE_ACCEPT_CONTEXT , ( char * ) & nlsd , sizeof ( nlsd ) ) )  296
lpfnGetAcceptExSockaddrs ( buf , len , PADDED_ADDR_SIZE , PADDED_ADDR_SIZE , & context -> sa_server , & context -> sa_server_len , & context -> sa_client , & context -> sa_client_len ); 308
if ( accf == 2 && BytesRead )  315
apr_bucket * b ; 317
b = apr_bucket_heap_create ( buf , APR_BUCKET_BUFF_SIZE , apr_bucket_free , context -> ba ); 318
b -> length = BytesRead; 321
context -> overlapped . Pointer = b; 322
apr_bucket_free ( buf ); 326
context -> overlapped . Pointer = NULL; 328
if ( context -> accept_socket != INVALID_SOCKET )  334
closesocket ( context -> accept_socket ); 335
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
context -> sa_server = ( void * ) context -> buff; 356
context -> sa_server_len = sizeof ( context -> buff ) / 2; 357
context -> sa_client_len = context -> sa_server_len; 358
context -> sa_client = ( void * ) ( context -> buff + context -> sa_server_len ); 359
context -> accept_socket = accept ( nlsd , context -> sa_server , & context -> sa_server_len ); 362
if ( context -> accept_socket == INVALID_SOCKET )  365
rv = apr_get_netos_error ( ); 367
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
if ( err_count > MAX_ACCEPTEX_ERR_COUNT )  387
WSAEventSelect ( context -> accept_socket , 0 , 0 ); 402
context -> overlapped . Pointer = NULL; 403
err_count = 0; 404
context -> sa_server_len = sizeof ( context -> buff ) / 2; 406
if ( getsockname ( context -> accept_socket , context -> sa_server , & context -> sa_server_len ) == SOCKET_ERROR )  407
if ( ( getpeername ( context -> accept_socket , context -> sa_client , & context -> sa_client_len ) ) == SOCKET_ERROR )  413
memset ( & context -> sa_client , '\0' , sizeof ( context -> sa_client ) ); 417
sockinfo . os_sock = & context -> accept_socket; 421
sockinfo . local = context -> sa_server; 422
sockinfo . remote = context -> sa_client; 423
sockinfo . family = context -> sa_server -> sa_family; 424
sockinfo . type = SOCK_STREAM; 425
sockinfo . protocol = IPPROTO_TCP; 426
ioctlsocket ( context -> accept_socket , FIONBIO , & zero ); 432
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_RCVTIMEO , ( char * ) & zero , sizeof ( zero ) ); 433
setsockopt ( context -> accept_socket , SOL_SOCKET , SO_SNDTIMEO , ( char * ) & zero , sizeof ( zero ) ); 435
apr_os_sock_make ( & context -> sock , & sockinfo , context -> ptrans ); 437
PostQueuedCompletionStatus ( ThreadDispatchIOCP , BytesRead , IOCP_CONNECTION_ACCEPTED , & context -> overlapped ); 442
context = NULL; 445
CloseHandle ( events [ 2 ] ); 448
------------------------------
618 /home/SySeVR/data/CVE_2014_3601_VULN_kvm_iommu_map_pages.c end_gfn = gfn + slot -> npages 14
int CVE_2014_3601_VULN_kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot) 1
gfn_t gfn , end_gfn ; 3
struct iommu_domain * domain = kvm -> arch . iommu_domain ; 6
if ( ! domain )  10
gfn = slot -> base_gfn; 13
end_gfn = gfn + slot -> npages; 14
while ( gfn < end_gfn )  21
while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn )  34
------------------------------
619 /home/SySeVR/data/CVE_2014_3631_PATCHED_assoc_array_gc.c new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) 40
int CVE_2014_3631_PATCHED_assoc_array_gc(struct assoc_array *array,
const struct assoc_array_ops *ops,
bool (*iterator)(void *object, void *iterator_data),
void *iterator_data) 4
struct assoc_array_shortcut * shortcut , * new_s ; 6
struct assoc_array_node * node , * new_n ; 7
struct assoc_array_edit * edit ; 8
struct assoc_array_ptr * cursor , * ptr ; 9
struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; 10
int keylen , slot , nr_free , next_slot , i ; 12
if ( ! array -> root )  16
edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ); 19
if ( ! edit )  20
new_root = new_parent = NULL; 28
new_ptr_pp = & new_root; 29
cursor = array -> root; 30
if ( assoc_array_ptr_is_shortcut ( cursor ) )  36
shortcut = assoc_array_ptr_to_shortcut ( cursor ); 37
keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ); 38
keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; 39
new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ); 40
if ( ! new_s )  42
pr_devel ( "dup shortcut %p -> %p\n" , shortcut , new_s ); 44
memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ); 45
new_s -> back_pointer = new_parent; 47
new_s -> parent_slot = shortcut -> parent_slot; 48
* new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ); 49
new_ptr_pp = & new_s -> next_node; 50
cursor = shortcut -> next_node; 51
node = assoc_array_ptr_to_node ( cursor ); 55
new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ); 56
if ( ! new_n )  57
pr_devel ( "dup node %p -> %p\n" , node , new_n ); 59
new_n -> back_pointer = new_parent; 60
new_n -> parent_slot = node -> parent_slot; 61
* new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ); 62
slot = 0; 64
for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) 68
ptr = node -> slots [ slot ]; 69
if ( ! ptr )  70
if ( assoc_array_ptr_is_leaf ( ptr ) )  73
if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) )  74
new_n -> slots [ slot ] = ptr; 79
new_ptr_pp = & new_n -> slots [ slot ]; 83
cursor = ptr; 84
pr_devel ( "-- compress node %p --\n" , new_n ); 88
new_n -> nr_leaves_on_branch = 0; 93
nr_free = 0; 94
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 95
ptr = new_n -> slots [ slot ]; 96
if ( ! ptr )  97
nr_free ++; 98
if ( assoc_array_ptr_is_leaf ( ptr ) )  99
new_n -> nr_leaves_on_branch ++; 100
pr_devel ( "free=%d, leaves=%lu\n" , nr_free , new_n -> nr_leaves_on_branch ); 102
next_slot = 0; 105
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 106
struct assoc_array_shortcut * s ; 107
struct assoc_array_node * child ; 108
ptr = new_n -> slots [ slot ]; 110
if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) )  111
s = NULL; 114
if ( assoc_array_ptr_is_shortcut ( ptr ) )  115
s = assoc_array_ptr_to_shortcut ( ptr ); 116
ptr = s -> next_node; 117
child = assoc_array_ptr_to_node ( ptr ); 120
new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch; 121
if ( child -> nr_leaves_on_branch <= nr_free + 1 )  123
pr_devel ( "[%d] fold node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 125
BUG_ON ( s ); 132
new_n -> slots [ slot ] = NULL; 134
nr_free ++; 135
if ( slot < next_slot )  136
next_slot = slot; 137
for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) 138
struct assoc_array_ptr * p = child -> slots [ i ] ; 139
if ( ! p )  140
BUG_ON ( assoc_array_ptr_is_meta ( p ) ); 142
while ( new_n -> slots [ next_slot ] )  143
next_slot ++; 144
BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ); 145
new_n -> slots [ next_slot ++ ] = p; 146
nr_free --; 147
kfree ( child ); 149
pr_devel ( "[%d] retain node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); 151
pr_devel ( "after: %lu\n" , new_n -> nr_leaves_on_branch ); 157
nr_leaves_on_tree = new_n -> nr_leaves_on_branch; 159
if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 )  162
for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) 163
if ( ptr = new_n -> slots [ slot ] )  164
if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) )  167
pr_devel ( "excise node %p with 1 shortcut\n" , new_n ); 169
new_s = assoc_array_ptr_to_shortcut ( ptr ); 170
new_parent = new_n -> back_pointer; 171
slot = new_n -> parent_slot; 172
kfree ( new_n ); 173
if ( ! new_parent )  174
new_s -> back_pointer = NULL; 175
new_s -> parent_slot = 0; 176
new_root = ptr; 177
if ( assoc_array_ptr_is_shortcut ( new_parent ) )  181
struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; 183
new_parent = new_s -> back_pointer = s -> back_pointer; 188
slot = new_s -> parent_slot = s -> parent_slot; 189
kfree ( s ); 190
if ( ! new_parent )  191
new_s -> back_pointer = NULL; 192
new_s -> parent_slot = 0; 193
new_root = ptr; 194
new_s -> back_pointer = new_parent; 199
new_s -> parent_slot = slot; 200
new_n = assoc_array_ptr_to_node ( new_parent ); 201
new_n -> slots [ slot ] = ptr; 202
ptr = new_n -> back_pointer; 210
if ( ! ptr )  211
if ( assoc_array_ptr_is_shortcut ( ptr ) )  214
new_s = assoc_array_ptr_to_shortcut ( ptr ); 215
new_parent = new_s -> back_pointer; 216
slot = new_s -> parent_slot; 217
if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT )  219
struct assoc_array_node * n ; 220
new_n -> back_pointer = new_parent; 223
new_n -> parent_slot = slot; 224
kfree ( new_s ); 225
if ( ! new_parent )  226
new_root = assoc_array_node_to_ptr ( new_n ); 227
n = assoc_array_ptr_to_node ( new_parent ); 231
n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ); 232
new_parent = ptr; 235
new_n = assoc_array_ptr_to_node ( new_parent ); 237
ptr = node -> back_pointer; 240
if ( assoc_array_ptr_is_shortcut ( ptr ) )  241
shortcut = assoc_array_ptr_to_shortcut ( ptr ); 242
slot = shortcut -> parent_slot; 243
cursor = shortcut -> back_pointer; 244
if ( ! cursor )  245
slot = node -> parent_slot; 248
cursor = ptr; 249
BUG_ON ( ! cursor ); 251
node = assoc_array_ptr_to_node ( cursor ); 252
slot ++; 253
edit -> set [ 0 ] . to = new_root; 257
assoc_array_apply_edit ( edit ); 258
edit -> array -> nr_leaves_on_tree = nr_leaves_on_tree; 259
------------------------------
620 /home/SySeVR/data/CVE_2014_3640_VULN_udp_input.c uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ) 31
void
CVE_2014_3640_VULN_udp_input(register struct mbuf *m, int iphlen) 3
register struct ip * ip ;
register struct udphdr * uh ; 7
if ( iphlen > sizeof ( struct ip ) )  22
iphlen = sizeof ( struct ip ); 24
ip = mtod ( m , struct ip * ) 30
uh = ( struct udphdr * ) ( ( caddr_t ) ip + iphlen ); 31
len = ntohs ( ( u_int16_t ) uh -> uh_ulen ); 37
if ( ip -> ip_len != len )  39
if ( len > ip -> ip_len )  40
m_adj ( m , len - ip -> ip_len ); 43
ip -> ip_len = len; 44
save_ip = * ip; 51
save_ip . ip_len += iphlen; 52
if ( uh -> uh_sum )  57
memset ( & ( ( struct ipovly * ) ip ) -> ih_mbuf , 0 , sizeof ( struct mbuf_ptr ) ); 58
( ( struct ipovly * ) ip ) -> ih_x1 = 0; 59
( ( struct ipovly * ) ip ) -> ih_len = uh -> uh_ulen; 60
if ( cksum ( m , len + sizeof ( struct ip ) ) )  61
if ( ntohs ( uh -> uh_dport ) == BOOTP_SERVER )  69
if ( ntohs ( uh -> uh_dport ) == TFTP_SERVER )  81
if ( so -> so_lport != uh -> uh_sport || so -> so_laddr . s_addr != ip -> ip_src . s_addr )  90
if ( tmp -> so_lport == uh -> uh_sport && tmp -> so_laddr . s_addr == ip -> ip_src . s_addr )  96
so -> so_laddr = ip -> ip_src; 128
so -> so_lport = uh -> uh_sport; 129
if ( ( so -> so_iptos = udp_tos ( so ) ) == 0 )  131
so -> so_iptos = ip -> ip_tos; 132
so -> so_faddr = ip -> ip_dst; 140
so -> so_fport = uh -> uh_dport; 141
if ( so -> so_emu )  150
udp_emu ( so , m ); 151
if ( sosendto ( so , m ) == - 1 )  153
* ip = save_ip; 156
m_free ( so -> so_m ); 161
* ip = save_ip; 166
so -> so_m = m; 167
------------------------------
621 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c * out_len = op - out 201
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
ip = ie; 52
op = oe; 53
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
op += 8; 133
op += 8; 136
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
op += next; 143
ip += next; 144
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
op += t; 172
ip += t; 173
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
622 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c * out_len = op - out 197
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
ip = ie; 52
op = oe; 53
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
op += 8; 133
op += 8; 136
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
op += next; 143
ip += next; 144
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
op += t; 172
ip += t; 173
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
623 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c * out_len = op - out 193
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
ip = ie; 52
op = oe; 53
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
op += 8; 133
op += 8; 136
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
op += next; 143
ip += next; 144
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
op += t; 172
ip += t; 173
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
624 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c * out_len = op - out 187
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
ip = ie; 52
op = oe; 53
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
op += 8; 133
op += 8; 136
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
op += next; 143
ip += next; 144
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
op += t; 172
ip += t; 173
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
625 /home/SySeVR/data/CVE_2014_4654_VULN_snd_ctl_elem_add.c ue -> elem_data = ( char * ) ue + sizeof ( * ue ) 87
static int CVE_2014_4654_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
long private_size ; 7
struct user_element * ue ; 8
int idx , err ; 9
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
info -> id . numid = 0; 19
_kctl = snd_ctl_find_id ( card , & info -> id ); 22
err = 0; 23
if ( _kctl )  24
if ( replace )  25
err = snd_ctl_remove ( card , _kctl ); 26
err = - EBUSY; 28
if ( replace )  30
err = - ENOENT; 31
if ( err < 0 )  34
switch ( info -> type )  51
private_size = sizeof ( long ); 54
if ( info -> count > 128 )  55
private_size = sizeof ( long long ); 59
if ( info -> count > 64 )  60
private_size = sizeof ( unsigned int ); 64
if ( info -> count > 128 || info -> value . enumerated . items == 0 )  65
private_size = sizeof ( unsigned char ); 69
if ( info -> count > 512 )  70
private_size = sizeof ( struct snd_aes_iec958 ); 74
if ( info -> count != 1 )  75
private_size *= info -> count; 81
ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ); 82
if ( ue == NULL )  83
ue -> info = * info; 85
ue -> info . access = 0; 86
ue -> elem_data = ( char * ) ue + sizeof ( * ue ); 87
ue -> elem_data_size = private_size; 88
if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED )  89
err = snd_ctl_elem_init_enum_names ( ue ); 90
if ( err < 0 )  91
kfree ( ue ); 92
return err ; 93
kfree ( ue -> priv_data ); 99
kfree ( ue ); 100
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
------------------------------
626 /home/SySeVR/data/CVE_2014_4655_PATCHED_snd_ctl_elem_add.c ue -> elem_data = ( char * ) ue + sizeof ( * ue ) 80
static int CVE_2014_4655_PATCHED_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
long private_size ; 7
struct user_element * ue ; 8
int idx , err ; 9
if ( info -> count < 1 )  11
info -> id . numid = 0; 17
if ( replace )  20
err = snd_ctl_remove_user_ctl ( file , & info -> id ); 21
if ( err )  22
if ( card -> user_ctl_count >= MAX_USER_CONTROLS )  26
switch ( info -> type )  44
private_size = sizeof ( long ); 47
if ( info -> count > 128 )  48
private_size = sizeof ( long long ); 52
if ( info -> count > 64 )  53
private_size = sizeof ( unsigned int ); 57
if ( info -> count > 128 || info -> value . enumerated . items == 0 )  58
private_size = sizeof ( unsigned char ); 62
if ( info -> count > 512 )  63
private_size = sizeof ( struct snd_aes_iec958 ); 67
if ( info -> count != 1 )  68
private_size *= info -> count; 74
ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ); 75
if ( ue == NULL )  76
ue -> info = * info; 78
ue -> info . access = 0; 79
ue -> elem_data = ( char * ) ue + sizeof ( * ue ); 80
ue -> elem_data_size = private_size; 81
if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED )  82
err = snd_ctl_elem_init_enum_names ( ue ); 83
if ( err < 0 )  84
kfree ( ue ); 85
return err ; 86
kfree ( ue -> priv_data ); 92
kfree ( ue ); 93
_kctl -> private_data = ue; 96
for (idx = 0; idx < _kctl->count; idx++) 97
_kctl -> vd [ idx ] . owner = file; 98
err = snd_ctl_add ( card , _kctl ); 99
if ( err < 0 )  100
return err ; 101
------------------------------
627 /home/SySeVR/data/CVE_2014_4655_VULN_snd_ctl_elem_add.c ue -> elem_data = ( char * ) ue + sizeof ( * ue ) 87
static int CVE_2014_4655_VULN_snd_ctl_elem_add(struct snd_ctl_file *file,
struct snd_ctl_elem_info *info, int replace) 2
struct snd_card * card = file -> card ; 4
struct snd_kcontrol kctl , * _kctl ; 5
long private_size ; 7
struct user_element * ue ; 8
int idx , err ; 9
if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  11
if ( info -> count < 1 )  13
info -> id . numid = 0; 19
_kctl = snd_ctl_find_id ( card , & info -> id ); 22
err = 0; 23
if ( _kctl )  24
if ( replace )  25
err = snd_ctl_remove ( card , _kctl ); 26
err = - EBUSY; 28
if ( replace )  30
err = - ENOENT; 31
if ( err < 0 )  34
switch ( info -> type )  51
private_size = sizeof ( long ); 54
if ( info -> count > 128 )  55
private_size = sizeof ( long long ); 59
if ( info -> count > 64 )  60
private_size = sizeof ( unsigned int ); 64
if ( info -> count > 128 || info -> value . enumerated . items == 0 )  65
private_size = sizeof ( unsigned char ); 69
if ( info -> count > 512 )  70
private_size = sizeof ( struct snd_aes_iec958 ); 74
if ( info -> count != 1 )  75
private_size *= info -> count; 81
ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ); 82
if ( ue == NULL )  83
ue -> info = * info; 85
ue -> info . access = 0; 86
ue -> elem_data = ( char * ) ue + sizeof ( * ue ); 87
ue -> elem_data_size = private_size; 88
if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED )  89
err = snd_ctl_elem_init_enum_names ( ue ); 90
if ( err < 0 )  91
kfree ( ue ); 92
return err ; 93
kfree ( ue -> priv_data ); 99
kfree ( ue ); 100
_kctl -> private_data = ue; 103
for (idx = 0; idx < _kctl->count; idx++) 104
_kctl -> vd [ idx ] . owner = file; 105
err = snd_ctl_add ( card , _kctl ); 106
if ( err < 0 )  107
return err ; 108
------------------------------
628 /home/SySeVR/data/CVE_2014_5472_PATCHED_isofs_read_inode.c de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) 23
static int CVE_2014_5472_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
tmpde = kmalloc ( de_len , GFP_KERNEL ); 29
if ( tmpde == NULL )  30
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
de = tmpde; 41
if ( de -> flags [ - high_sierra ] & 2 )  51
ei -> i_section_size = isonum_733 ( de -> size ); 84
if ( de -> flags [ - high_sierra ] & 0x80 )  85
ei -> i_next_section_block = 0; 91
ei -> i_next_section_offset = 0; 92
inode -> i_size = isonum_733 ( de -> size ); 93
inode -> i_size &= 0x00ffffff; 103
if ( de -> interleave [ 0 ] )  105
inode -> i_size = 0; 107
if ( de -> file_unit_size [ 0 ] != 0 )  112
printk ( KERN_DEBUG "ISOFS: File unit size != 0 for ISO file (%ld).\n" ,
inode -> i_ino ) 114
if ( ( de -> flags [ - high_sierra ] & ~2 ) != 0 )  120
printk ( KERN_DEBUG "ISOFS: Unusual flag settings for ISO file "
"(%ld %x).\n" ,
inode -> i_ino , de -> flags [ - high_sierra ] ) 123
inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ); 127
inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0; 130
ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ); 134
inode -> i_blocks = ( inode -> i_size + 511 ) >> 9; 138
parse_rock_ridge_inode ( de , inode , relocated ); 146
inode -> i_uid = sbi -> s_uid; 149
inode -> i_gid = sbi -> s_gid; 151
if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE )  154
inode -> i_mode = S_IFDIR | sbi -> s_dmode; 156
if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE )  157
inode -> i_mode = S_IFREG | sbi -> s_fmode; 159
if ( S_ISREG ( inode -> i_mode ) )  162
inode -> i_fop = & generic_ro_fops; 163
switch ( ei -> i_file_format )  164
inode -> i_data . a_ops = & zisofs_aops; 167
inode -> i_data . a_ops = & isofs_aops; 171
if ( S_ISDIR ( inode -> i_mode ) )  174
if ( S_ISLNK ( inode -> i_mode ) )  177
init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ); 182
kfree ( tmpde ); 186
------------------------------
629 /home/SySeVR/data/CVE_2014_6427_PATCHED_is_rtsp_request_or_reply.c tokenlen = get_token_len ( token , line + linelen , & next_token ) 19
static gboolean
CVE_2014_6427_PATCHED_is_rtsp_request_or_reply(const guchar *line, size_t linelen, rtsp_type_t *type) 2
const guchar * token , * next_token ; 5
int tokenlen ; 6
if ( linelen >= 5 && g_ascii_strncasecmp ( "RTSP/" , line , 5 ) == 0 )  10
tokenlen = get_token_len ( line , line + 5 , & token ); 16
if ( tokenlen != 0 )  17
tokenlen = get_token_len ( token , line + linelen , & next_token ); 19
if ( tokenlen >= 3 )  20
------------------------------
630 /home/SySeVR/data/CVE_2014_7825_PATCHED_perf_syscall_enter.c size = ALIGN ( size + sizeof ( u32 ) , sizeof ( u64 ) ) 26
static void CVE_2014_7825_PATCHED_perf_syscall_enter(void *ignore, struct pt_regs *regs, long id) 1
struct syscall_metadata * sys_data ; 3
struct syscall_trace_enter * rec ; 4
struct hlist_head * head ; 5
int syscall_nr ; 6
int size ; 8
syscall_nr = trace_get_syscall_nr ( current , regs ); 10
if ( syscall_nr < 0 || syscall_nr >= NR_syscalls )  11
if ( ! test_bit ( syscall_nr , enabled_perf_enter_syscalls ) )  13
sys_data = syscall_nr_to_meta ( syscall_nr ); 16
if ( ! sys_data )  17
head = this_cpu_ptr ( sys_data -> enter_event -> perf_events ); 20
if ( hlist_empty ( head ) )  21
size = sizeof ( unsigned long ) * sys_data -> nb_args + sizeof ( * rec ); 25
size = ALIGN ( size + sizeof ( u32 ) , sizeof ( u64 ) ); 26
size -= sizeof ( u32 ); 27
rec = ( struct syscall_trace_enter * ) perf_trace_buf_prepare ( size , sys_data -> enter_event -> event . type , regs , & rctx ); 29
if ( ! rec )  31
rec -> nr = syscall_nr; 34
syscall_get_arguments ( current , regs , 0 , sys_data -> nb_args , ( unsigned long * ) & rec -> args ); 35
perf_trace_buf_submit ( rec , size , rctx , 0 , 1 , regs , head , NULL ); 37
------------------------------
631 /home/SySeVR/data/CVE_2014_7825_PATCHED_perf_syscall_enter.c size = sizeof ( unsigned long ) * sys_data -> nb_args + sizeof ( * rec ) 25
static void CVE_2014_7825_PATCHED_perf_syscall_enter(void *ignore, struct pt_regs *regs, long id) 1
struct syscall_metadata * sys_data ; 3
struct syscall_trace_enter * rec ; 4
struct hlist_head * head ; 5
int syscall_nr ; 6
int size ; 8
syscall_nr = trace_get_syscall_nr ( current , regs ); 10
if ( syscall_nr < 0 || syscall_nr >= NR_syscalls )  11
if ( ! test_bit ( syscall_nr , enabled_perf_enter_syscalls ) )  13
sys_data = syscall_nr_to_meta ( syscall_nr ); 16
if ( ! sys_data )  17
head = this_cpu_ptr ( sys_data -> enter_event -> perf_events ); 20
if ( hlist_empty ( head ) )  21
size = sizeof ( unsigned long ) * sys_data -> nb_args + sizeof ( * rec ); 25
size = ALIGN ( size + sizeof ( u32 ) , sizeof ( u64 ) ); 26
size -= sizeof ( u32 ); 27
rec = ( struct syscall_trace_enter * ) perf_trace_buf_prepare ( size , sys_data -> enter_event -> event . type , regs , & rctx ); 29
if ( ! rec )  31
rec -> nr = syscall_nr; 34
syscall_get_arguments ( current , regs , 0 , sys_data -> nb_args , ( unsigned long * ) & rec -> args ); 35
perf_trace_buf_submit ( rec , size , rctx , 0 , 1 , regs , head , NULL ); 37
------------------------------
632 /home/SySeVR/data/CVE_2014_7937_PATCHED_vorbis_residue_decode_internal.c av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffset / ch + ( voffs % ch ) * vlen , vec [ voffset / ch + ( voffs % ch ) * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ) 109
static av_always_inline int CVE_2014_7937_PATCHED_vorbis_residue_decode_internal(vorbis_context *vc,
vorbis_residue *vr,
unsigned ch,
uint8_t *do_not_decode,
float *vec,
unsigned vlen,
unsigned ch_left,
int vr_type) 8
GetBitContext * gb = & vc -> gb ; 10
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; 11
uint8_t * classifs = vr -> classifs ; 12
unsigned pass , ch_used , i , j , k , l ; 13
unsigned max_output = ( ch - 1 ) * vlen ; 14
int ptns_to_read = vr -> ptns_to_read ; 15
if ( vr_type == 2 )  18
for (j = 1; j < ch; ++j) 19
do_not_decode [ 0 ] &= do_not_decode [ j ]; 20
if ( do_not_decode [ 0 ] )  21
ch_used = 1; 23
max_output += vr -> end / ch; 24
ch_used = ch; 26
max_output += vr -> end; 27
if ( max_output > ch_left * vlen )  30
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )  31
ptns_to_read --; 32
for (pass = 0; pass <= vr->maxpass; ++pass) 42
int voffset , partition_count , j_times_ptns_to_read ; 43
voffset = vr -> begin; 45
for (partition_count = 0; partition_count < ptns_to_read;) 46
if ( ! pass )  47
int ret ; 48
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count , ptns_to_read ) ) < 0 )  49
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) 52
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) 53
unsigned voffs ; 54
if ( ! do_not_decode [ j ] )  56
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
int vqbook = vr -> books [ vqclass ] [ pass ] ; 58
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )  60
unsigned coffs ; 61
unsigned dim = vc -> codebooks [ vqbook ] . dimensions ; 62
unsigned step = FASTDIV ( vr -> partition_size << 1 , dim << 1 ) ; 63
vorbis_codebook codebook = vc -> codebooks [ vqbook ] ; 64
if ( vr_type == 0 )  66
voffs = voffset + j * vlen; 68
for (k = 0; k < step; ++k) 69
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 70
for (l = 0; l < dim; ++l) 71
vec [ voffs + k + l * step ] += codebook . codevectors [ coffs + l ]; 72
if ( vr_type == 1 )  74
voffs = voffset + j * vlen; 75
for (k = 0; k < step; ++k) 76
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 77
for (l = 0; l < dim; ++l, ++voffs) 78
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 79
if ( vr_type == 2 && ch == 2 && ( voffset & 1 ) == 0 && ( dim & 1 ) == 0 )  85
voffs = voffset >> 1; 86
if ( dim == 2 )  88
for (k = 0; k < step; ++k) 89
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * 2; 90
vec [ voffs + k ] += codebook . codevectors [ coffs ]; 91
vec [ voffs + k + vlen ] += codebook . codevectors [ coffs + 1 ]; 92
if ( dim == 4 )  94
for (k = 0; k < step; ++k, voffs += 2) 95
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * 4; 96
vec [ voffs ] += codebook . codevectors [ coffs ]; 97
vec [ voffs + 1 ] += codebook . codevectors [ coffs + 2 ]; 98
vec [ voffs + vlen ] += codebook . codevectors [ coffs + 1 ]; 99
vec [ voffs + vlen + 1 ] += codebook . codevectors [ coffs + 3 ]; 100
for (k = 0; k < step; ++k) 103
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 104
for (l = 0; l < dim; l += 2, voffs++) 105
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 106
vec [ voffs + vlen ] += codebook . codevectors [ coffs + l + 1 ]; 107
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffset / ch + ( voffs % ch ) * vlen , vec [ voffset / ch + ( voffs % ch ) * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 109
if ( vr_type == 2 )  116
unsigned voffs_div = FASTDIV ( voffset << 1 , ch << 1 ) ; 117
unsigned voffs_mod = voffset - voffs_div * ch ; 118
for (k = 0; k < step; ++k) 120
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 121
for (l = 0; l < dim; ++l) 122
vec [ voffs_div + voffs_mod * vlen ] += codebook . codevectors [ coffs + l ]; 123
if ( ++ voffs_mod == ch )  131
voffs_div ++; 132
voffs_mod = 0; 133
j_times_ptns_to_read += ptns_to_read; 140
voffset += vr -> partition_size; 143
------------------------------
633 /home/SySeVR/data/CVE_2014_7937_PATCHED_vorbis_residue_decode_internal.c voffs = voffset + j * vlen 75
static av_always_inline int CVE_2014_7937_PATCHED_vorbis_residue_decode_internal(vorbis_context *vc,
vorbis_residue *vr,
unsigned ch,
uint8_t *do_not_decode,
float *vec,
unsigned vlen,
unsigned ch_left,
int vr_type) 8
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; 11
uint8_t * classifs = vr -> classifs ; 12
unsigned pass , ch_used , i , j , k , l ; 13
unsigned max_output = ( ch - 1 ) * vlen ; 14
int ptns_to_read = vr -> ptns_to_read ; 15
if ( vr_type == 2 )  18
for (j = 1; j < ch; ++j) 19
do_not_decode [ 0 ] &= do_not_decode [ j ]; 20
if ( do_not_decode [ 0 ] )  21
ch_used = 1; 23
max_output += vr -> end / ch; 24
ch_used = ch; 26
max_output += vr -> end; 27
if ( max_output > ch_left * vlen )  30
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )  31
ptns_to_read --; 32
for (pass = 0; pass <= vr->maxpass; ++pass) 42
int voffset , partition_count , j_times_ptns_to_read ; 43
voffset = vr -> begin; 45
for (partition_count = 0; partition_count < ptns_to_read;) 46
if ( ! pass )  47
int ret ; 48
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count , ptns_to_read ) ) < 0 )  49
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) 52
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) 53
unsigned voffs ; 54
if ( ! do_not_decode [ j ] )  56
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
int vqbook = vr -> books [ vqclass ] [ pass ] ; 58
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )  60
if ( vr_type == 0 )  66
vec [ voffs + k + l * step ] += codebook . codevectors [ coffs + l ]; 72
if ( vr_type == 1 )  74
voffs = voffset + j * vlen; 75
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 79
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d  \n" , pass , voffs , vec [ voffs ] , codebook . codevectors [ coffs + l ] , coffs ); 81
vec [ voffs + k ] += codebook . codevectors [ coffs ]; 91
vec [ voffs + k + vlen ] += codebook . codevectors [ coffs + 1 ]; 92
vec [ voffs ] += codebook . codevectors [ coffs ]; 97
vec [ voffs + 1 ] += codebook . codevectors [ coffs + 2 ]; 98
vec [ voffs + vlen ] += codebook . codevectors [ coffs + 1 ]; 99
vec [ voffs + vlen + 1 ] += codebook . codevectors [ coffs + 3 ]; 100
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 106
vec [ voffs + vlen ] += codebook . codevectors [ coffs + l + 1 ]; 107
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffset / ch + ( voffs % ch ) * vlen , vec [ voffset / ch + ( voffs % ch ) * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 109
vec [ voffs_div + voffs_mod * vlen ] += codebook . codevectors [ coffs + l ]; 123
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffs_div + voffs_mod * vlen , vec [ voffs_div + voffs_mod * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 126
if ( ++ voffs_mod == ch )  131
voffs_div ++; 132
j_times_ptns_to_read += ptns_to_read; 140
voffset += vr -> partition_size; 143
------------------------------
634 /home/SySeVR/data/CVE_2014_7937_PATCHED_vorbis_residue_decode_internal.c voffs = voffset + j * vlen 68
static av_always_inline int CVE_2014_7937_PATCHED_vorbis_residue_decode_internal(vorbis_context *vc,
vorbis_residue *vr,
unsigned ch,
uint8_t *do_not_decode,
float *vec,
unsigned vlen,
unsigned ch_left,
int vr_type) 8
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; 11
uint8_t * classifs = vr -> classifs ; 12
unsigned pass , ch_used , i , j , k , l ; 13
unsigned max_output = ( ch - 1 ) * vlen ; 14
int ptns_to_read = vr -> ptns_to_read ; 15
if ( vr_type == 2 )  18
for (j = 1; j < ch; ++j) 19
do_not_decode [ 0 ] &= do_not_decode [ j ]; 20
if ( do_not_decode [ 0 ] )  21
ch_used = 1; 23
max_output += vr -> end / ch; 24
ch_used = ch; 26
max_output += vr -> end; 27
if ( max_output > ch_left * vlen )  30
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )  31
ptns_to_read --; 32
for (pass = 0; pass <= vr->maxpass; ++pass) 42
int voffset , partition_count , j_times_ptns_to_read ; 43
voffset = vr -> begin; 45
for (partition_count = 0; partition_count < ptns_to_read;) 46
if ( ! pass )  47
int ret ; 48
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count , ptns_to_read ) ) < 0 )  49
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) 52
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) 53
unsigned voffs ; 54
if ( ! do_not_decode [ j ] )  56
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
int vqbook = vr -> books [ vqclass ] [ pass ] ; 58
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )  60
if ( vr_type == 0 )  66
voffs = voffset + j * vlen; 68
vec [ voffs + k + l * step ] += codebook . codevectors [ coffs + l ]; 72
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 79
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d  \n" , pass , voffs , vec [ voffs ] , codebook . codevectors [ coffs + l ] , coffs ); 81
vec [ voffs + k ] += codebook . codevectors [ coffs ]; 91
vec [ voffs + k + vlen ] += codebook . codevectors [ coffs + 1 ]; 92
vec [ voffs ] += codebook . codevectors [ coffs ]; 97
vec [ voffs + 1 ] += codebook . codevectors [ coffs + 2 ]; 98
vec [ voffs + vlen ] += codebook . codevectors [ coffs + 1 ]; 99
vec [ voffs + vlen + 1 ] += codebook . codevectors [ coffs + 3 ]; 100
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 106
vec [ voffs + vlen ] += codebook . codevectors [ coffs + l + 1 ]; 107
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffset / ch + ( voffs % ch ) * vlen , vec [ voffset / ch + ( voffs % ch ) * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 109
vec [ voffs_div + voffs_mod * vlen ] += codebook . codevectors [ coffs + l ]; 123
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffs_div + voffs_mod * vlen , vec [ voffs_div + voffs_mod * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 126
if ( ++ voffs_mod == ch )  131
voffs_div ++; 132
j_times_ptns_to_read += ptns_to_read; 140
voffset += vr -> partition_size; 143
------------------------------
635 /home/SySeVR/data/CVE_2014_8369_PATCHED_kvm_pin_pages.c end_gfn = gfn + npages 8
static pfn_t CVE_2014_8369_PATCHED_kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
unsigned long npages) 2
gfn_t end_gfn ; 4
end_gfn = gfn + npages; 8
while ( gfn < end_gfn )  14
------------------------------
636 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c s -> block_stride [ i ] = bw * s -> h_count [ i ] 344
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
height *= 2; 114
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
s -> first_picture = 0; 121
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
s -> rgb = 1; 131
if ( ! s -> lossless )  132
s -> rgb = 0; 133
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
for (i = 0; i < 4; i++) 316
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
------------------------------
637 /home/SySeVR/data/CVE_2014_8545_VULN_decode_frame.c s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3 109
static int CVE_2014_8545_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
PNGDecContext * const s = avctx -> priv_data 5
AVFrame * p ; 8
uint32_t tag , length ; 10
int64_t sig ; 11
int ret ; 12
p = s -> picture . f; 16
sig = bytestream2_get_be64 ( & s -> gb ); 21
if ( sig != PNGSIG && sig != MNGSIG )  22
s -> y = s -> state = 0; 28
s -> zstream . zalloc = ff_png_zalloc; 31
s -> zstream . zfree = ff_png_zfree; 32
s -> zstream . opaque = NULL; 33
ret = inflateInit ( & s -> zstream ); 34
if ( ret != Z_OK )  35
if ( bytestream2_get_bytes_left ( & s -> gb ) <= 0 )  40
if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL )  42
length = bytestream2_get_be32 ( & s -> gb ); 48
if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) )  49
if ( length != 13 )  62
s -> width = bytestream2_get_be32 ( & s -> gb ); 64
s -> height = bytestream2_get_be32 ( & s -> gb ); 65
if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) )  66
s -> bit_depth = bytestream2_get_byte ( & s -> gb ); 71
s -> color_type = bytestream2_get_byte ( & s -> gb ); 72
s -> compression_type = bytestream2_get_byte ( & s -> gb ); 73
s -> filter_type = bytestream2_get_byte ( & s -> gb ); 74
s -> interlace_type = bytestream2_get_byte ( & s -> gb ); 75
s -> state |= PNG_IHDR; 77
if ( s -> state & PNG_IDAT )  85
avctx -> sample_aspect_ratio . num = bytestream2_get_be32 ( & s -> gb ); 89
avctx -> sample_aspect_ratio . den = bytestream2_get_be32 ( & s -> gb ); 90
if ( avctx -> sample_aspect_ratio . num < 0 || avctx -> sample_aspect_ratio . den < 0 )  91
avctx -> sample_aspect_ratio = ( AVRational ) 0 , 1 92
if ( ! ( s -> state & PNG_IHDR ) )  97
if ( ! ( s -> state & PNG_IDAT ) )  101
avctx -> width = s -> width; 103
avctx -> height = s -> height; 104
s -> channels = ff_png_get_nb_channels ( s -> color_type ); 106
s -> bits_per_pixel = s -> bit_depth * s -> channels; 107
s -> bpp = ( s -> bits_per_pixel + 7 ) >> 3; 108
s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3; 109
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB )  111
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  114
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_GRAY )  117
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY )  120
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB )  123
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  126
if ( ( s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && s -> color_type == PNG_COLOR_TYPE_PALETTE )  129
if ( s -> bit_depth == 1 )  132
if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )  134
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )  137
avctx -> pix_fmt = AV_PIX_FMT_YA16BE; 139
av_log ( avctx , AV_LOG_ERROR , "unsupported bit depth %d "
"and color type %d\n" ,
s -> bit_depth , s -> color_type ) 143
if ( ff_thread_get_buffer ( avctx , & s -> picture , AV_GET_BUFFER_FLAG_REF ) < 0 )  147
p -> pict_type = AV_PICTURE_TYPE_I; 151
p -> key_frame = 1; 152
p -> interlaced_frame = ! ! s -> interlace_type; 153
if ( ! s -> interlace_type )  156
s -> crow_size = s -> row_size + 1; 157
s -> pass = 0; 159
s -> pass_row_size = ff_png_pass_row_size ( s -> pass , s -> bits_per_pixel , s -> width ); 160
s -> crow_size = s -> pass_row_size + 1; 163
av_dlog ( avctx , "row_size=%d crow_size =%d\n" , s -> row_size , s -> crow_size ); 165
s -> image_buf = p -> data [ 0 ]; 167
s -> image_linesize = p -> linesize [ 0 ]; 168
memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ); 171
av_fast_padded_mallocz ( & s -> last_row , & s -> last_row_size , s -> row_size ); 173
if ( ! s -> last_row )  174
if ( s -> interlace_type || s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  176
av_fast_padded_malloc ( & s -> tmp_row , & s -> tmp_row_size , s -> row_size ); 178
if ( ! s -> tmp_row )  179
av_fast_padded_malloc ( & s -> buffer , & s -> buffer_size , s -> row_size + 16 ); 183
if ( ! s -> buffer )  184
s -> crow_buf = s -> buffer + 15; 188
s -> zstream . avail_out = s -> crow_size; 189
s -> zstream . next_out = s -> crow_buf; 190
s -> state |= PNG_IDAT; 192
if ( png_decode_idat ( s , length ) < 0 )  193
bytestream2_skip ( & s -> gb , 4 ); 195
r = bytestream2_get_byte ( & s -> gb ); 206
g = bytestream2_get_byte ( & s -> gb ); 207
b = bytestream2_get_byte ( & s -> gb ); 208
s -> palette [ i ] = ( 0xFFU << 24 ) | ( r << 16 ) | ( g << 8 ) | b; 209
for (; i < 256; i++) 211
s -> palette [ i ] = ( 0xFFU << 24 ); 212
s -> state |= PNG_PLTE; 213
bytestream2_skip ( & s -> gb , 4 ); 214
if ( s -> color_type != PNG_COLOR_TYPE_PALETTE || length > 256 || ! ( s -> state & PNG_PLTE ) )  222
for (i = 0; i < length; i++) 226
v = bytestream2_get_byte ( & s -> gb ); 227
s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ); 228
bytestream2_skip ( & s -> gb , 4 ); 230
if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 )  234
if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 )  239
if ( ! ( s -> state & PNG_ALLIMAGE ) )  244
if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) )  246
bytestream2_skip ( & s -> gb , 4 ); 249
bytestream2_skip ( & s -> gb , length + 4 ); 254
if ( s -> bits_per_pixel == 1 && s -> color_type == PNG_COLOR_TYPE_PALETTE )  260
uint8_t * pd = p -> data [ 0 ] ; 262
for (j = 0; j < s->height; j++) 263
i = s -> width / 8; 264
if ( ( s -> width & 7 ) >= k )  266
pd [ 8 * i + k - 1 ] = ( pd [ i ] >> 8 - k ) & 1; 267
for (i--; i >= 0; i--) 268
pd [ 8 * i + 7 ] = pd [ i ] & 1; 269
pd [ 8 * i + 6 ] = ( pd [ i ] >> 1 ) & 1; 270
pd [ 8 * i + 5 ] = ( pd [ i ] >> 2 ) & 1; 271
pd [ 8 * i + 4 ] = ( pd [ i ] >> 3 ) & 1; 272
pd [ 8 * i + 3 ] = ( pd [ i ] >> 4 ) & 1; 273
pd [ 8 * i + 2 ] = ( pd [ i ] >> 5 ) & 1; 274
pd [ 8 * i + 1 ] = ( pd [ i ] >> 6 ) & 1; 275
pd [ 8 * i + 0 ] = pd [ i ] >> 7; 276
pd += s -> image_linesize; 278
if ( s -> bits_per_pixel == 2 )  281
uint8_t * pd = p -> data [ 0 ] ; 283
for (j = 0; j < s->height; j++) 284
i = s -> width / 4; 285
if ( s -> color_type == PNG_COLOR_TYPE_PALETTE )  286
if ( ( s -> width & 3 ) >= 3 )  287
pd [ 4 * i + 2 ] = ( pd [ i ] >> 2 ) & 3; 287
if ( ( s -> width & 3 ) >= 2 )  288
pd [ 4 * i + 1 ] = ( pd [ i ] >> 4 ) & 3; 288
if ( ( s -> width & 3 ) >= 1 )  289
pd [ 4 * i + 0 ] = pd [ i ] >> 6; 289
for (i--; i >= 0; i--) 290
pd [ 4 * i + 3 ] = pd [ i ] & 3; 291
pd [ 4 * i + 2 ] = ( pd [ i ] >> 2 ) & 3; 292
pd [ 4 * i + 1 ] = ( pd [ i ] >> 4 ) & 3; 293
pd [ 4 * i + 0 ] = pd [ i ] >> 6; 294
if ( ( s -> width & 3 ) >= 3 )  297
pd [ 4 * i + 2 ] = ( ( pd [ i ] >> 2 ) & 3 ) * 0x55; 297
if ( ( s -> width & 3 ) >= 2 )  298
pd [ 4 * i + 1 ] = ( ( pd [ i ] >> 4 ) & 3 ) * 0x55; 298
if ( ( s -> width & 3 ) >= 1 )  299
pd [ 4 * i + 0 ] = ( pd [ i ] >> 6 ) * 0x55; 299
for (i--; i >= 0; i--) 300
pd [ 4 * i + 3 ] = ( pd [ i ] & 3 ) * 0x55; 301
pd [ 4 * i + 2 ] = ( ( pd [ i ] >> 2 ) & 3 ) * 0x55; 302
pd [ 4 * i + 1 ] = ( ( pd [ i ] >> 4 ) & 3 ) * 0x55; 303
pd [ 4 * i + 0 ] = ( pd [ i ] >> 6 ) * 0x55; 304
pd += s -> image_linesize; 307
if ( s -> bits_per_pixel == 4 )  310
uint8_t * pd = p -> data [ 0 ] ; 312
for (j = 0; j < s->height; j++) 313
i = s -> width / 2; 314
if ( s -> color_type == PNG_COLOR_TYPE_PALETTE )  315
if ( s -> width & 1 )  316
pd [ 2 * i + 0 ] = pd [ i ] >> 4; 316
for (i--; i >= 0; i--) 317
pd [ 2 * i + 1 ] = pd [ i ] & 15; 318
pd [ 2 * i + 0 ] = pd [ i ] >> 4; 319
if ( s -> width & 1 )  322
pd [ 2 * i + 0 ] = ( pd [ i ] >> 4 ) * 0x11; 322
for (i--; i >= 0; i--) 323
pd [ 2 * i + 1 ] = ( pd [ i ] & 15 ) * 0x11; 324
pd [ 2 * i + 0 ] = ( pd [ i ] >> 4 ) * 0x11; 325
pd += s -> image_linesize; 328
if ( s -> last_picture . f -> data [ 0 ] )  333
if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( "MPNG" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format )  334
uint8_t * pd = p -> data [ 0 ] ; 340
uint8_t * pd_last = s -> last_picture . f -> data [ 0 ] ; 341
ff_thread_await_progress ( & s -> last_picture , INT_MAX , 0 ); 343
for (j = 0; j < s->height; j++) 344
for (i = 0; i < s->width * s->bpp; i++) 345
pd [ i ] += pd_last [ i ]; 346
pd += s -> image_linesize; 347
pd_last += s -> image_linesize; 348
ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ); 352
if ( ( ret = av_frame_ref ( data , s -> picture . f ) ) < 0 )  357
return ret ; 358
ret = bytestream2_tell ( & s -> gb ); 362
inflateEnd ( & s -> zstream ); 364
s -> crow_buf = NULL; 365
return ret ; 366
ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ); 369
------------------------------
638 /home/SySeVR/data/CVE_2014_8545_VULN_decode_frame.c s -> bits_per_pixel = s -> bit_depth * s -> channels 107
static int CVE_2014_8545_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
PNGDecContext * const s = avctx -> priv_data 5
AVFrame * p ; 8
uint32_t tag , length ; 10
int64_t sig ; 11
int ret ; 12
p = s -> picture . f; 16
sig = bytestream2_get_be64 ( & s -> gb ); 21
if ( sig != PNGSIG && sig != MNGSIG )  22
s -> y = s -> state = 0; 28
s -> zstream . zalloc = ff_png_zalloc; 31
s -> zstream . zfree = ff_png_zfree; 32
s -> zstream . opaque = NULL; 33
ret = inflateInit ( & s -> zstream ); 34
if ( ret != Z_OK )  35
if ( bytestream2_get_bytes_left ( & s -> gb ) <= 0 )  40
if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL )  42
length = bytestream2_get_be32 ( & s -> gb ); 48
if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) )  49
if ( length != 13 )  62
s -> width = bytestream2_get_be32 ( & s -> gb ); 64
s -> height = bytestream2_get_be32 ( & s -> gb ); 65
if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) )  66
s -> bit_depth = bytestream2_get_byte ( & s -> gb ); 71
s -> color_type = bytestream2_get_byte ( & s -> gb ); 72
s -> compression_type = bytestream2_get_byte ( & s -> gb ); 73
s -> filter_type = bytestream2_get_byte ( & s -> gb ); 74
s -> interlace_type = bytestream2_get_byte ( & s -> gb ); 75
s -> state |= PNG_IHDR; 77
if ( s -> state & PNG_IDAT )  85
avctx -> sample_aspect_ratio . num = bytestream2_get_be32 ( & s -> gb ); 89
avctx -> sample_aspect_ratio . den = bytestream2_get_be32 ( & s -> gb ); 90
if ( avctx -> sample_aspect_ratio . num < 0 || avctx -> sample_aspect_ratio . den < 0 )  91
avctx -> sample_aspect_ratio = ( AVRational ) 0 , 1 92
if ( ! ( s -> state & PNG_IHDR ) )  97
if ( ! ( s -> state & PNG_IDAT ) )  101
avctx -> width = s -> width; 103
avctx -> height = s -> height; 104
s -> channels = ff_png_get_nb_channels ( s -> color_type ); 106
s -> bits_per_pixel = s -> bit_depth * s -> channels; 107
s -> bpp = ( s -> bits_per_pixel + 7 ) >> 3; 108
s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3; 109
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB )  111
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  114
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_GRAY )  117
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY )  120
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB )  123
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  126
if ( ( s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && s -> color_type == PNG_COLOR_TYPE_PALETTE )  129
if ( s -> bit_depth == 1 )  132
if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )  134
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )  137
avctx -> pix_fmt = AV_PIX_FMT_YA16BE; 139
av_log ( avctx , AV_LOG_ERROR , "unsupported bit depth %d "
"and color type %d\n" ,
s -> bit_depth , s -> color_type ) 143
if ( ff_thread_get_buffer ( avctx , & s -> picture , AV_GET_BUFFER_FLAG_REF ) < 0 )  147
p -> pict_type = AV_PICTURE_TYPE_I; 151
p -> key_frame = 1; 152
p -> interlaced_frame = ! ! s -> interlace_type; 153
if ( ! s -> interlace_type )  156
s -> crow_size = s -> row_size + 1; 157
s -> pass = 0; 159
s -> pass_row_size = ff_png_pass_row_size ( s -> pass , s -> bits_per_pixel , s -> width ); 160
s -> crow_size = s -> pass_row_size + 1; 163
av_dlog ( avctx , "row_size=%d crow_size =%d\n" , s -> row_size , s -> crow_size ); 165
s -> image_buf = p -> data [ 0 ]; 167
s -> image_linesize = p -> linesize [ 0 ]; 168
memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ); 171
av_fast_padded_mallocz ( & s -> last_row , & s -> last_row_size , s -> row_size ); 173
if ( ! s -> last_row )  174
if ( s -> interlace_type || s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )  176
av_fast_padded_malloc ( & s -> tmp_row , & s -> tmp_row_size , s -> row_size ); 178
if ( ! s -> tmp_row )  179
av_fast_padded_malloc ( & s -> buffer , & s -> buffer_size , s -> row_size + 16 ); 183
if ( ! s -> buffer )  184
s -> crow_buf = s -> buffer + 15; 188
s -> zstream . avail_out = s -> crow_size; 189
s -> zstream . next_out = s -> crow_buf; 190
s -> state |= PNG_IDAT; 192
if ( png_decode_idat ( s , length ) < 0 )  193
bytestream2_skip ( & s -> gb , 4 ); 195
r = bytestream2_get_byte ( & s -> gb ); 206
g = bytestream2_get_byte ( & s -> gb ); 207
b = bytestream2_get_byte ( & s -> gb ); 208
s -> palette [ i ] = ( 0xFFU << 24 ) | ( r << 16 ) | ( g << 8 ) | b; 209
for (; i < 256; i++) 211
s -> palette [ i ] = ( 0xFFU << 24 ); 212
s -> state |= PNG_PLTE; 213
bytestream2_skip ( & s -> gb , 4 ); 214
if ( s -> color_type != PNG_COLOR_TYPE_PALETTE || length > 256 || ! ( s -> state & PNG_PLTE ) )  222
for (i = 0; i < length; i++) 226
v = bytestream2_get_byte ( & s -> gb ); 227
s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ); 228
bytestream2_skip ( & s -> gb , 4 ); 230
if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 )  234
if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 )  239
if ( ! ( s -> state & PNG_ALLIMAGE ) )  244
if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) )  246
bytestream2_skip ( & s -> gb , 4 ); 249
bytestream2_skip ( & s -> gb , length + 4 ); 254
if ( s -> bits_per_pixel == 1 && s -> color_type == PNG_COLOR_TYPE_PALETTE )  260
uint8_t * pd = p -> data [ 0 ] ; 262
for (j = 0; j < s->height; j++) 263
i = s -> width / 8; 264
if ( ( s -> width & 7 ) >= k )  266
pd [ 8 * i + k - 1 ] = ( pd [ i ] >> 8 - k ) & 1; 267
for (i--; i >= 0; i--) 268
pd [ 8 * i + 7 ] = pd [ i ] & 1; 269
pd [ 8 * i + 6 ] = ( pd [ i ] >> 1 ) & 1; 270
pd [ 8 * i + 5 ] = ( pd [ i ] >> 2 ) & 1; 271
pd [ 8 * i + 4 ] = ( pd [ i ] >> 3 ) & 1; 272
pd [ 8 * i + 3 ] = ( pd [ i ] >> 4 ) & 1; 273
pd [ 8 * i + 2 ] = ( pd [ i ] >> 5 ) & 1; 274
pd [ 8 * i + 1 ] = ( pd [ i ] >> 6 ) & 1; 275
pd [ 8 * i + 0 ] = pd [ i ] >> 7; 276
pd += s -> image_linesize; 278
if ( s -> bits_per_pixel == 2 )  281
uint8_t * pd = p -> data [ 0 ] ; 283
for (j = 0; j < s->height; j++) 284
i = s -> width / 4; 285
if ( s -> color_type == PNG_COLOR_TYPE_PALETTE )  286
if ( ( s -> width & 3 ) >= 3 )  287
pd [ 4 * i + 2 ] = ( pd [ i ] >> 2 ) & 3; 287
if ( ( s -> width & 3 ) >= 2 )  288
pd [ 4 * i + 1 ] = ( pd [ i ] >> 4 ) & 3; 288
if ( ( s -> width & 3 ) >= 1 )  289
pd [ 4 * i + 0 ] = pd [ i ] >> 6; 289
for (i--; i >= 0; i--) 290
pd [ 4 * i + 3 ] = pd [ i ] & 3; 291
pd [ 4 * i + 2 ] = ( pd [ i ] >> 2 ) & 3; 292
pd [ 4 * i + 1 ] = ( pd [ i ] >> 4 ) & 3; 293
pd [ 4 * i + 0 ] = pd [ i ] >> 6; 294
if ( ( s -> width & 3 ) >= 3 )  297
pd [ 4 * i + 2 ] = ( ( pd [ i ] >> 2 ) & 3 ) * 0x55; 297
if ( ( s -> width & 3 ) >= 2 )  298
pd [ 4 * i + 1 ] = ( ( pd [ i ] >> 4 ) & 3 ) * 0x55; 298
if ( ( s -> width & 3 ) >= 1 )  299
pd [ 4 * i + 0 ] = ( pd [ i ] >> 6 ) * 0x55; 299
for (i--; i >= 0; i--) 300
pd [ 4 * i + 3 ] = ( pd [ i ] & 3 ) * 0x55; 301
pd [ 4 * i + 2 ] = ( ( pd [ i ] >> 2 ) & 3 ) * 0x55; 302
pd [ 4 * i + 1 ] = ( ( pd [ i ] >> 4 ) & 3 ) * 0x55; 303
pd [ 4 * i + 0 ] = ( pd [ i ] >> 6 ) * 0x55; 304
pd += s -> image_linesize; 307
if ( s -> bits_per_pixel == 4 )  310
uint8_t * pd = p -> data [ 0 ] ; 312
for (j = 0; j < s->height; j++) 313
i = s -> width / 2; 314
if ( s -> color_type == PNG_COLOR_TYPE_PALETTE )  315
if ( s -> width & 1 )  316
pd [ 2 * i + 0 ] = pd [ i ] >> 4; 316
for (i--; i >= 0; i--) 317
pd [ 2 * i + 1 ] = pd [ i ] & 15; 318
pd [ 2 * i + 0 ] = pd [ i ] >> 4; 319
if ( s -> width & 1 )  322
pd [ 2 * i + 0 ] = ( pd [ i ] >> 4 ) * 0x11; 322
for (i--; i >= 0; i--) 323
pd [ 2 * i + 1 ] = ( pd [ i ] & 15 ) * 0x11; 324
pd [ 2 * i + 0 ] = ( pd [ i ] >> 4 ) * 0x11; 325
pd += s -> image_linesize; 328
if ( s -> last_picture . f -> data [ 0 ] )  333
if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( "MPNG" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format )  334
uint8_t * pd = p -> data [ 0 ] ; 340
uint8_t * pd_last = s -> last_picture . f -> data [ 0 ] ; 341
ff_thread_await_progress ( & s -> last_picture , INT_MAX , 0 ); 343
for (j = 0; j < s->height; j++) 344
for (i = 0; i < s->width * s->bpp; i++) 345
pd [ i ] += pd_last [ i ]; 346
pd += s -> image_linesize; 347
pd_last += s -> image_linesize; 348
ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ); 352
if ( ( ret = av_frame_ref ( data , s -> picture . f ) ) < 0 )  357
return ret ; 358
ret = bytestream2_tell ( & s -> gb ); 362
inflateEnd ( & s -> zstream ); 364
s -> crow_buf = NULL; 365
return ret ; 366
ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ); 369
------------------------------
639 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c ip3 = ip2 + s -> frame -> linesize [ 0 ] 23
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
if ( s -> avctx -> height - y > 3 )  22
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
p = ip3; 88
* p ++ = cb2 [ 6 ]; 89
* p ++ = cb2 [ 9 ]; 90
* p ++ = cb3 [ 6 ]; 91
* p = cb3 [ 9 ]; 92
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
ip3 += 4; 124
ip3 += 12; 127
------------------------------
640 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c ip2 = ip1 + s -> frame -> linesize [ 0 ] 21
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
if ( s -> avctx -> height - y > 2 )  20
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
p = ip3; 88
* p ++ = cb2 [ 6 ]; 89
* p ++ = cb2 [ 9 ]; 90
* p ++ = cb3 [ 6 ]; 91
* p = cb3 [ 9 ]; 92
p = ip2; 93
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
ip2 += 4; 124
ip3 += 4; 124
ip2 += 12; 127
ip3 += 12; 127
------------------------------
641 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c ip1 = ip0 + s -> frame -> linesize [ 0 ] 19
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
if ( s -> avctx -> height - y > 1 )  18
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
p = ip3; 88
* p ++ = cb2 [ 6 ]; 89
* p ++ = cb2 [ 9 ]; 90
* p ++ = cb3 [ 6 ]; 91
* p = cb3 [ 9 ]; 92
p = ip2; 93
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
p = ip1; 98
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
ip1 += 4; 123
ip2 += 4; 124
ip3 += 4; 124
ip1 += 12; 126
ip2 += 12; 127
ip3 += 12; 127
------------------------------
642 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ) 16
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
uint32_t flag , mask ; 5
uint8_t * cb0 , * cb1 , * cb2 , * cb3 ; 6
unsigned int x , y ; 7
char * ip0 , * ip1 , * ip2 , * ip3 ; 8
flag = 0; 10
mask = 0; 11
for (y=strip->y1; y < strip->y2; y+=4) 13
ip0 = ip1 = ip2 = ip3 = s -> frame -> data [ 0 ] + ( s -> palette_video ? strip -> x1 : strip -> x1 * 3 ) + ( y * s -> frame -> linesize [ 0 ] ); 16
ip1 = ip0 + s -> frame -> linesize [ 0 ]; 19
ip2 = ip1 + s -> frame -> linesize [ 0 ]; 21
ip3 = ip2 + s -> frame -> linesize [ 0 ]; 23
for (x=strip->x1; x < strip->x2; x+=4) 32
if ( ( chunk_id & 0x01 ) && ! ( mask >>= 1 ) )  33
if ( ( data + 4 ) > eod )  34
flag = AV_RB32 ( data ); 37
data += 4; 38
mask = 0x80000000; 39
if ( ! ( chunk_id & 0x01 ) || ( flag & mask ) )  42
if ( ! ( chunk_id & 0x02 ) && ! ( mask >>= 1 ) )  43
if ( ( data + 4 ) > eod )  44
flag = AV_RB32 ( data ); 47
data += 4; 48
mask = 0x80000000; 49
if ( ( chunk_id & 0x02 ) || ( ~flag & mask ) )  52
uint8_t * p ; 53
if ( data >= eod )  54
p = strip -> v1_codebook [ * data ++ ]; 57
ip3 [ 0 ] = ip3 [ 1 ] = ip2 [ 0 ] = ip2 [ 1 ] = p [ 6 ]; 59
ip3 [ 2 ] = ip3 [ 3 ] = ip2 [ 2 ] = ip2 [ 3 ] = p [ 9 ]; 60
ip1 [ 0 ] = ip1 [ 1 ] = ip0 [ 0 ] = ip0 [ 1 ] = p [ 0 ]; 61
ip1 [ 2 ] = ip1 [ 3 ] = ip0 [ 2 ] = ip0 [ 3 ] = p [ 3 ]; 62
memcpy ( ip3 + 0 , p , 3 ); 65
memcpy ( ip3 + 3 , p , 3 ); 65
memcpy ( ip2 + 0 , p , 3 ); 66
memcpy ( ip2 + 3 , p , 3 ); 66
memcpy ( ip3 + 6 , p , 3 ); 68
memcpy ( ip3 + 9 , p , 3 ); 68
memcpy ( ip2 + 6 , p , 3 ); 69
memcpy ( ip2 + 9 , p , 3 ); 69
memcpy ( ip1 + 0 , p , 3 ); 71
memcpy ( ip1 + 3 , p , 3 ); 71
memcpy ( ip0 + 0 , p , 3 ); 72
memcpy ( ip0 + 3 , p , 3 ); 72
memcpy ( ip1 + 6 , p , 3 ); 74
memcpy ( ip1 + 9 , p , 3 ); 74
memcpy ( ip0 + 6 , p , 3 ); 75
memcpy ( ip0 + 9 , p , 3 ); 75
if ( flag & mask )  78
if ( ( data + 4 ) > eod )  79
cb0 = strip -> v4_codebook [ * data ++ ]; 82
cb1 = strip -> v4_codebook [ * data ++ ]; 83
cb2 = strip -> v4_codebook [ * data ++ ]; 84
cb3 = strip -> v4_codebook [ * data ++ ]; 85
p = ip3; 88
* p ++ = cb2 [ 6 ]; 89
* p ++ = cb2 [ 9 ]; 90
* p ++ = cb3 [ 6 ]; 91
* p = cb3 [ 9 ]; 92
p = ip2; 93
* p ++ = cb2 [ 0 ]; 94
* p ++ = cb2 [ 3 ]; 95
* p ++ = cb3 [ 0 ]; 96
* p = cb3 [ 3 ]; 97
p = ip1; 98
* p ++ = cb0 [ 6 ]; 99
* p ++ = cb0 [ 9 ]; 100
* p ++ = cb1 [ 6 ]; 101
* p = cb1 [ 9 ]; 102
p = ip0; 103
* p ++ = cb0 [ 0 ]; 104
* p ++ = cb0 [ 3 ]; 105
* p ++ = cb1 [ 0 ]; 106
* p = cb1 [ 3 ]; 107
memcpy ( ip3 + 0 , cb2 + 6 , 6 ); 109
memcpy ( ip3 + 6 , cb3 + 6 , 6 ); 110
memcpy ( ip2 + 0 , cb2 + 0 , 6 ); 111
memcpy ( ip2 + 6 , cb3 + 0 , 6 ); 112
memcpy ( ip1 + 0 , cb0 + 6 , 6 ); 113
memcpy ( ip1 + 6 , cb1 + 6 , 6 ); 114
memcpy ( ip0 + 0 , cb0 + 0 , 6 ); 115
memcpy ( ip0 + 6 , cb1 + 0 , 6 ); 116
ip0 += 4; 123
ip1 += 4; 123
ip2 += 4; 124
ip3 += 4; 124
ip0 += 12; 126
ip1 += 12; 126
ip2 += 12; 127
ip3 += 12; 127
------------------------------
643 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c ptr = ptr1 + linesize 156
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
uint32_t * ptr , * pal , * px , * pr , * ptr1 ; 5
int ret ; 6
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
is_interleaved = flags & 0x40; 18
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( left + width > s -> screen_width )  61
pw = s -> screen_width - left; 63
pw = width; 67
if ( top + height > s -> screen_height )  69
height = s -> screen_height - top; 73
s -> gce_prev_disposal = s -> gce_disposal; 84
if ( s -> gce_disposal != GCE_DISPOSAL_NONE )  86
s -> gce_l = left; 87
s -> gce_t = top; 87
s -> gce_w = pw; 88
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> transparent_color_index >= 0 )  91
s -> stored_bg_color = s -> trans_color; 92
s -> stored_bg_color = s -> bg_color; 94
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )  106
code_size = bytestream2_get_byteu ( & s -> gb ); 110
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )  111
linesize = frame -> linesize [ 0 ] / sizeof ( uint32_t ); 118
ptr1 = ( uint32_t * ) frame -> data [ 0 ] + top * linesize + left; 119
pass = 0; 121
y1 = 0; 122
for (y = 0; y < height; y++) 123
int count = ff_lzw_decode ( s -> lzw , s -> idx_line , width ) ; 124
if ( count != width )  125
pr = ptr + pw; 131
for (px = ptr, idx = s->idx_line; px < pr; px++, idx++) 133
if ( * idx != s -> transparent_color_index )  134
* px = pal [ * idx ]; 135
if ( is_interleaved )  138
switch ( pass )  139
y1 += 8; 143
ptr += linesize * 8; 144
if ( y1 >= height )  145
y1 = pass ? 2 : 4; 146
pass ++; 148
y1 += 4; 152
ptr += linesize * 4; 153
if ( y1 >= height )  154
y1 = 1; 155
ptr = ptr1 + linesize; 156
pass ++; 157
y1 += 2; 161
ptr += linesize * 2; 162
ptr += linesize; 166
------------------------------
644 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c ptr = ptr1 + linesize * y1 147
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
uint32_t * ptr , * pal , * px , * pr , * ptr1 ; 5
int ret ; 6
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
is_interleaved = flags & 0x40; 18
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( left + width > s -> screen_width )  61
pw = s -> screen_width - left; 63
pw = width; 67
if ( top + height > s -> screen_height )  69
height = s -> screen_height - top; 73
s -> gce_prev_disposal = s -> gce_disposal; 84
if ( s -> gce_disposal != GCE_DISPOSAL_NONE )  86
s -> gce_l = left; 87
s -> gce_t = top; 87
s -> gce_w = pw; 88
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> transparent_color_index >= 0 )  91
s -> stored_bg_color = s -> trans_color; 92
s -> stored_bg_color = s -> bg_color; 94
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )  106
code_size = bytestream2_get_byteu ( & s -> gb ); 110
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )  111
linesize = frame -> linesize [ 0 ] / sizeof ( uint32_t ); 118
ptr1 = ( uint32_t * ) frame -> data [ 0 ] + top * linesize + left; 119
pass = 0; 121
y1 = 0; 122
for (y = 0; y < height; y++) 123
int count = ff_lzw_decode ( s -> lzw , s -> idx_line , width ) ; 124
if ( count != width )  125
pr = ptr + pw; 131
for (px = ptr, idx = s->idx_line; px < pr; px++, idx++) 133
if ( * idx != s -> transparent_color_index )  134
* px = pal [ * idx ]; 135
if ( is_interleaved )  138
switch ( pass )  139
y1 += 8; 143
ptr += linesize * 8; 144
if ( y1 >= height )  145
y1 = pass ? 2 : 4; 146
ptr = ptr1 + linesize * y1; 147
pass ++; 148
y1 += 4; 152
ptr += linesize * 4; 153
if ( y1 >= height )  154
y1 = 1; 155
pass ++; 157
y1 += 2; 161
ptr += linesize * 2; 162
ptr += linesize; 166
------------------------------
645 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c pr = ptr + pw 131
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
uint32_t * ptr , * pal , * px , * pr , * ptr1 ; 5
int ret ; 6
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
is_interleaved = flags & 0x40; 18
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( left + width > s -> screen_width )  61
pw = s -> screen_width - left; 63
pw = width; 67
if ( top + height > s -> screen_height )  69
height = s -> screen_height - top; 73
s -> gce_prev_disposal = s -> gce_disposal; 84
if ( s -> gce_disposal != GCE_DISPOSAL_NONE )  86
s -> gce_l = left; 87
s -> gce_t = top; 87
s -> gce_w = pw; 88
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> transparent_color_index >= 0 )  91
s -> stored_bg_color = s -> trans_color; 92
s -> stored_bg_color = s -> bg_color; 94
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )  106
code_size = bytestream2_get_byteu ( & s -> gb ); 110
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )  111
linesize = frame -> linesize [ 0 ] / sizeof ( uint32_t ); 118
ptr1 = ( uint32_t * ) frame -> data [ 0 ] + top * linesize + left; 119
ptr = ptr1; 120
pass = 0; 121
y1 = 0; 122
for (y = 0; y < height; y++) 123
int count = ff_lzw_decode ( s -> lzw , s -> idx_line , width ) ; 124
if ( count != width )  125
pr = ptr + pw; 131
for (px = ptr, idx = s->idx_line; px < pr; px++, idx++) 133
if ( is_interleaved )  138
switch ( pass )  139
y1 += 8; 143
ptr += linesize * 8; 144
if ( y1 >= height )  145
y1 = pass ? 2 : 4; 146
ptr = ptr1 + linesize * y1; 147
pass ++; 148
y1 += 4; 152
ptr += linesize * 4; 153
if ( y1 >= height )  154
y1 = 1; 155
ptr = ptr1 + linesize; 156
pass ++; 157
y1 += 2; 161
ptr += linesize * 2; 162
ptr += linesize; 166
------------------------------
646 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c ptr1 = ( uint32_t * ) frame -> data [ 0 ] + top * linesize + left 119
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
uint32_t * ptr , * pal , * px , * pr , * ptr1 ; 5
int ret ; 6
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( left + width > s -> screen_width )  61
pw = s -> screen_width - left; 63
pw = width; 67
if ( top + height > s -> screen_height )  69
height = s -> screen_height - top; 73
s -> gce_prev_disposal = s -> gce_disposal; 84
if ( s -> gce_disposal != GCE_DISPOSAL_NONE )  86
s -> gce_l = left; 87
s -> gce_t = top; 87
s -> gce_w = pw; 88
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> transparent_color_index >= 0 )  91
s -> stored_bg_color = s -> trans_color; 92
s -> stored_bg_color = s -> bg_color; 94
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )  106
code_size = bytestream2_get_byteu ( & s -> gb ); 110
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )  111
linesize = frame -> linesize [ 0 ] / sizeof ( uint32_t ); 118
ptr1 = ( uint32_t * ) frame -> data [ 0 ] + top * linesize + left; 119
ptr = ptr1; 120
pr = ptr + pw; 131
for (px = ptr, idx = s->idx_line; px < pr; px++, idx++) 133
if ( * idx != s -> transparent_color_index )  134
* px = pal [ * idx ]; 135
ptr += linesize * 8; 144
ptr = ptr1 + linesize * y1; 147
ptr += linesize * 4; 153
ptr = ptr1 + linesize; 156
ptr += linesize * 2; 162
ptr += linesize; 166
------------------------------
647 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c gif_copy_img_rect ( ( uint32_t * ) frame -> data [ 0 ] , s -> stored_img , frame -> linesize [ 0 ] / sizeof ( uint32_t ) , left , top , pw , height ) 100
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( left + width > s -> screen_width )  61
pw = s -> screen_width - left; 63
pw = width; 67
if ( top + height > s -> screen_height )  69
height = s -> screen_height - top; 73
s -> gce_prev_disposal = s -> gce_disposal; 84
if ( s -> gce_disposal != GCE_DISPOSAL_NONE )  86
s -> gce_l = left; 87
s -> gce_t = top; 87
s -> gce_w = pw; 88
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
gif_copy_img_rect ( ( uint32_t * ) frame -> data [ 0 ] , s -> stored_img , frame -> linesize [ 0 ] / sizeof ( uint32_t ) , left , top , pw , height ); 100
------------------------------
648 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c gif_copy_img_rect ( s -> stored_img , ( uint32_t * ) frame -> data [ 0 ] , frame -> linesize [ 0 ] / sizeof ( uint32_t ) , s -> gce_l , s -> gce_t , s -> gce_w , s -> gce_h ) 80
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( s -> gce_prev_disposal == GCE_DISPOSAL_BACKGROUND )  77
if ( s -> gce_prev_disposal == GCE_DISPOSAL_RESTORE )  79
gif_copy_img_rect ( s -> stored_img , ( uint32_t * ) frame -> data [ 0 ] , frame -> linesize [ 0 ] / sizeof ( uint32_t ) , s -> gce_l , s -> gce_t , s -> gce_w , s -> gce_h ); 80
------------------------------
649 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c height = s -> screen_height - top 73
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( top + height > s -> screen_height )  69
height = s -> screen_height - top; 73
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> transparent_color_index >= 0 )  91
s -> stored_bg_color = s -> trans_color; 92
s -> stored_bg_color = s -> bg_color; 94
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
gif_copy_img_rect ( ( uint32_t * ) frame -> data [ 0 ] , s -> stored_img , frame -> linesize [ 0 ] / sizeof ( uint32_t ) , left , top , pw , height ); 100
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )  106
code_size = bytestream2_get_byteu ( & s -> gb ); 110
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )  111
av_log ( s -> avctx , AV_LOG_ERROR , "LZW init failed\n" ); 113
return ret ; 114
for (y = 0; y < height; y++) 123
int count = ff_lzw_decode ( s -> lzw , s -> idx_line , width ) ; 124
if ( count != width )  125
if ( count )  126
av_log ( s -> avctx , AV_LOG_ERROR , "LZW decode failed\n" ); 127
for (px = ptr, idx = s->idx_line; px < pr; px++, idx++) 133
if ( * idx != s -> transparent_color_index )  134
* px = pal [ * idx ]; 135
if ( y1 >= height )  145
if ( y1 >= height )  154
ff_lzw_decode_tail ( s -> lzw ); 172
s -> transparent_color_index = - 1; 176
s -> gce_disposal = GCE_DISPOSAL_NONE; 177
------------------------------
650 /home/SySeVR/data/CVE_2014_8547_VULN_gif_read_image.c pw = s -> screen_width - left 63
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame) 1
int left , top , width , height , bits_per_pixel , code_size , flags , pw ; 3
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ; 4
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )  10
left = bytestream2_get_le16u ( & s -> gb ); 13
top = bytestream2_get_le16u ( & s -> gb ); 14
width = bytestream2_get_le16u ( & s -> gb ); 15
height = bytestream2_get_le16u ( & s -> gb ); 16
flags = bytestream2_get_byteu ( & s -> gb ); 17
has_local_palette = flags & 0x80; 19
bits_per_pixel = ( flags & 0x07 ) + 1; 20
if ( has_local_palette )  24
pal_size = 1 << bits_per_pixel; 25
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )  27
if ( ! s -> has_global_palette )  33
if ( ! width || width > s -> screen_width || left >= s -> screen_width )  53
if ( ! height || height > s -> screen_height || top >= s -> screen_height )  57
if ( left + width > s -> screen_width )  61
pw = s -> screen_width - left; 63
s -> gce_w = pw; 88
s -> gce_h = height; 88
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )  90
if ( s -> transparent_color_index >= 0 )  91
s -> stored_bg_color = s -> trans_color; 92
s -> stored_bg_color = s -> bg_color; 94
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )  95
if ( ! s -> stored_img )  97
gif_copy_img_rect ( ( uint32_t * ) frame -> data [ 0 ] , s -> stored_img , frame -> linesize [ 0 ] / sizeof ( uint32_t ) , left , top , pw , height ); 100
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )  106
code_size = bytestream2_get_byteu ( & s -> gb ); 110
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )  111
av_log ( s -> avctx , AV_LOG_ERROR , "LZW init failed\n" ); 113
return ret ; 114
int count = ff_lzw_decode ( s -> lzw , s -> idx_line , width ) ; 124
if ( count != width )  125
if ( count )  126
av_log ( s -> avctx , AV_LOG_ERROR , "LZW decode failed\n" ); 127
pr = ptr + pw; 131
for (px = ptr, idx = s->idx_line; px < pr; px++, idx++) 133
if ( * idx != s -> transparent_color_index )  134
* px = pal [ * idx ]; 135
ff_lzw_decode_tail ( s -> lzw ); 172
s -> transparent_color_index = - 1; 176
s -> gce_disposal = GCE_DISPOSAL_NONE; 177
------------------------------
651 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ) 23
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
__skb_queue_tail ( & tx -> skbs , tmp ); 30
skb_reserve ( tmp , local -> tx_headroom + IEEE80211_ENCRYPT_HEADROOM ); 32
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
info = IEEE80211_SKB_CB ( tmp ); 37
info -> flags &= ~ ( IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT ); 38
info -> flags |= IEEE80211_TX_CTL_MORE_FRAMES; 42
skb_copy_queue_mapping ( tmp , skb ); 44
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
------------------------------
652 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c skb -> len = hdrlen + per_fragm 56
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
skb -> len = hdrlen + per_fragm; 56
------------------------------
653 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ) 23
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
struct ieee80211_local * local = tx -> local ; 5
struct sk_buff * tmp ; 7
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
tmp = dev_alloc_skb ( local -> tx_headroom + frag_threshold + IEEE80211_ENCRYPT_HEADROOM + IEEE80211_ENCRYPT_TAILROOM ); 23
if ( ! tmp )  27
__skb_queue_tail ( & tx -> skbs , tmp ); 30
skb_reserve ( tmp , local -> tx_headroom + IEEE80211_ENCRYPT_HEADROOM ); 32
memcpy ( tmp -> cb , skb -> cb , sizeof ( tmp -> cb ) ); 35
info = IEEE80211_SKB_CB ( tmp ); 37
info -> flags &= ~ ( IEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT ); 38
info -> flags |= IEEE80211_TX_CTL_MORE_FRAMES; 42
skb_copy_queue_mapping ( tmp , skb ); 44
tmp -> priority = skb -> priority; 45
tmp -> dev = skb -> dev; 46
memcpy ( skb_put ( tmp , hdrlen ) , skb -> data , hdrlen ); 49
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
------------------------------
654 /home/SySeVR/data/CVE_2014_9428_VULN_batadv_frag_merge_packets.c size = entry -> skb -> len - hdr_size 41
static struct sk_buff *
CVE_2014_9428_VULN_batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb) 2
struct batadv_frag_packet * packet ; 4
struct batadv_frag_list_entry * entry ; 5
int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; 7
packet = ( struct batadv_frag_packet * ) skb -> data; 10
size = ntohs ( packet -> total_size ); 11
if ( size > batadv_frag_size_limit ( ) )  12
entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) 18
skb_out = entry -> skb; 20
if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 )  24
size = entry -> skb -> len - hdr_size; 41
memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ); 42
------------------------------
655 /home/SySeVR/data/CVE_2014_9657_PATCHED_tt_face_load_hdmx.c limit = p + table_size 21
CVE_2014_9657_PATCHED_tt_face_load_hdmx( TT_Face    face,
FT_Stream  stream ) 2
FT_Error error ; 4
FT_ULong table_size , record_size ; 7
FT_Byte * p ; 8
FT_Byte * limit ; 9
error = face -> goto_table ( face , TTAG_hdmx , stream , & table_size ); 13
if ( error || table_size < 8 )  14
if ( FT_FRAME_EXTRACT ( table_size , face -> hdmx_table ) )  17
p = face -> hdmx_table; 20
limit = p + table_size; 21
if ( p + record_size > limit )  56
------------------------------
656 /home/SySeVR/data/CVE_2014_9657_VULN_tt_face_load_hdmx.c limit = p + table_size 21
CVE_2014_9657_VULN_tt_face_load_hdmx( TT_Face    face,
FT_Stream  stream ) 2
FT_Error error ; 4
FT_ULong table_size , record_size ; 7
FT_Byte * p ; 8
FT_Byte * limit ; 9
error = face -> goto_table ( face , TTAG_hdmx , stream , & table_size ); 13
if ( error || table_size < 8 )  14
if ( FT_FRAME_EXTRACT ( table_size , face -> hdmx_table ) )  17
p = face -> hdmx_table; 20
limit = p + table_size; 21
if ( p + record_size > limit )  54
------------------------------
657 /home/SySeVR/data/CVE_2014_9658_VULN_tt_face_load_kern.c num_pairs = ( FT_UInt ) ( ( p_next - p ) / 6 ) 76
CVE_2014_9658_VULN_tt_face_load_kern( TT_Face    face,
FT_Stream  stream ) 2
FT_Error error ; 4
FT_ULong table_size ; 5
FT_Byte * p ; 6
FT_Byte * p_limit ; 7
FT_UInt nn , num_tables ; 8
error = face -> goto_table ( face , TTAG_kern , stream , & table_size ); 13
if ( error )  14
if ( table_size < 4 )  17
if ( FT_FRAME_EXTRACT ( table_size , face -> kern_table ) )  25
face -> kern_table_size = table_size; 32
p = face -> kern_table; 34
p_limit = p + table_size; 35
p += 2; 37
num_tables = FT_NEXT_USHORT ( p ); 38
if ( num_tables > 32 )  40
num_tables = 32; 41
for ( nn = 0; nn < num_tables; nn++ ) 43
FT_UInt num_pairs , length , coverage ; 45
FT_Byte * p_next ; 46
if ( p + 6 > p_limit )  50
p_next = p; 53
p += 2; 55
length = FT_NEXT_USHORT ( p ); 56
coverage = FT_NEXT_USHORT ( p ); 57
if ( length <= 6 )  59
p_next += length; 62
if ( p_next > p_limit )  64
p_next = p_limit; 65
if ( ( coverage & ~8 ) != 0x0001 || p + 8 > p_limit )  68
num_pairs = FT_NEXT_USHORT ( p ); 72
p += 6; 73
if ( ( p_next - p ) < 6 * ( int ) num_pairs )  75
num_pairs = ( FT_UInt ) ( ( p_next - p ) / 6 ); 76
if ( num_pairs > 0 )  84
for ( count = num_pairs - 1; count > 0; count-- ) 93
if ( count == 0 )  106
p = p_next; 111
------------------------------
658 /home/SySeVR/data/CVE_2014_9658_VULN_tt_face_load_kern.c p_limit = p + table_size 35
CVE_2014_9658_VULN_tt_face_load_kern( TT_Face    face,
FT_Stream  stream ) 2
FT_Error error ; 4
FT_ULong table_size ; 5
FT_Byte * p ; 6
FT_Byte * p_limit ; 7
error = face -> goto_table ( face , TTAG_kern , stream , & table_size ); 13
if ( error )  14
if ( table_size < 4 )  17
if ( FT_FRAME_EXTRACT ( table_size , face -> kern_table ) )  25
face -> kern_table_size = table_size; 32
p = face -> kern_table; 34
p_limit = p + table_size; 35
if ( p + 6 > p_limit )  50
p_next = p; 53
p += 2; 55
length = FT_NEXT_USHORT ( p ); 56
coverage = FT_NEXT_USHORT ( p ); 57
if ( length <= 6 )  59
p_next += length; 62
if ( p_next > p_limit )  64
p_next = p_limit; 65
if ( ( coverage & ~8 ) != 0x0001 || p + 8 > p_limit )  68
num_pairs = FT_NEXT_USHORT ( p ); 72
p += 6; 73
if ( ( p_next - p ) < 6 * ( int ) num_pairs )  75
num_pairs = ( FT_UInt ) ( ( p_next - p ) / 6 ); 76
if ( num_pairs > 0 )  84
old_pair = FT_NEXT_ULONG ( p ); 90
p += 2; 91
for ( count = num_pairs - 1; count > 0; count-- ) 93
cur_pair = FT_NEXT_ULONG ( p ); 98
if ( cur_pair <= old_pair )  99
p += 2; 102
old_pair = cur_pair; 103
if ( count == 0 )  106
p = p_next; 111
------------------------------
659 /home/SySeVR/data/CVE_2014_9676_PATCHED_seg_write_packet.c seg -> cur_entry . end_time = FFMAX ( seg -> cur_entry . end_time , ( double ) ( pkt -> pts + pkt -> duration ) * av_q2d ( st -> time_base ) ) 43
static int CVE_2014_9676_PATCHED_seg_write_packet(AVFormatContext *s, AVPacket *pkt) 1
SegmentContext * seg = s -> priv_data ; 3
AVStream * st = s -> streams [ pkt -> stream_index ] ; 5
int64_t end_pts = INT64_MAX , offset ; 6
int start_frame = INT_MAX ; 7
if ( seg -> times )  10
end_pts = seg -> segment_count < seg -> nb_times ? seg -> times [ seg -> segment_count ] : INT64_MAX; 11
if ( seg -> frames )  13
start_frame = seg -> segment_count <= seg -> nb_frames ? seg -> frames [ seg -> segment_count ] : INT_MAX; 14
end_pts = seg -> time * ( seg -> segment_count + 1 ); 17
if ( pkt -> stream_index == seg -> reference_stream_index && pkt -> flags & AV_PKT_FLAG_KEY && ( seg -> frame_count >= start_frame || ( pkt -> pts != AV_NOPTS_VALUE && av_compare_ts ( pkt -> pts , st -> time_base , end_pts - seg -> time_delta , AV_TIME_BASE_Q ) >= 0 ) ) )  25
if ( pkt -> pts != AV_NOPTS_VALUE )  42
seg -> cur_entry . end_time = FFMAX ( seg -> cur_entry . end_time , ( double ) ( pkt -> pts + pkt -> duration ) * av_q2d ( st -> time_base ) ); 43
if ( seg -> is_first_pkt )  47
av_log ( s , AV_LOG_DEBUG , "segment:'%s' starts with packet stream:%d pts:%s pts_time:%s frame:%d\n" , seg -> avf -> filename , pkt -> stream_index , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & st -> time_base ) , seg -> frame_count ); 48
seg -> is_first_pkt = 0; 51
av_log ( s , AV_LOG_DEBUG , "stream:%d start_pts_time:%s pts:%s pts_time:%s dts:%s dts_time:%s" , pkt -> stream_index , av_ts2timestr ( seg -> cur_entry . start_pts , & AV_TIME_BASE_Q ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & st -> time_base ) ); 54
offset = av_rescale_q ( seg -> initial_offset - ( seg -> reset_timestamps ? seg -> cur_entry . start_pts : 0 ) , AV_TIME_BASE_Q , st -> time_base ); 61
pkt -> pts += offset; 64
if ( pkt -> dts != AV_NOPTS_VALUE )  65
pkt -> dts += offset; 66
av_log ( s , AV_LOG_DEBUG , " -> pts:%s pts_time:%s dts:%s dts_time:%s\n" , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & st -> time_base ) ); 68
ret = ff_write_chained ( oc , pkt -> stream_index , pkt , s ); 72
if ( pkt -> stream_index == seg -> reference_stream_index )  75
seg -> frame_count ++; 76
if ( ret < 0 )  78
if ( seg -> list )  79
avio_close ( seg -> list_pb ); 80
avformat_free_context ( seg -> avf ); 81
return ret ; 84
------------------------------
660 /home/SySeVR/data/CVE_2014_9676_PATCHED_seg_write_packet.c seg -> cur_entry . start_time = ( double ) pkt -> pts * av_q2d ( st -> time_base ) 40
static int CVE_2014_9676_PATCHED_seg_write_packet(AVFormatContext *s, AVPacket *pkt) 1
SegmentContext * seg = s -> priv_data ; 3
AVStream * st = s -> streams [ pkt -> stream_index ] ; 5
int64_t end_pts = INT64_MAX , offset ; 6
int start_frame = INT_MAX ; 7
int ret ; 8
if ( seg -> times )  10
end_pts = seg -> segment_count < seg -> nb_times ? seg -> times [ seg -> segment_count ] : INT64_MAX; 11
if ( seg -> frames )  13
start_frame = seg -> segment_count <= seg -> nb_frames ? seg -> frames [ seg -> segment_count ] : INT_MAX; 14
end_pts = seg -> time * ( seg -> segment_count + 1 ); 17
if ( pkt -> stream_index == seg -> reference_stream_index && pkt -> flags & AV_PKT_FLAG_KEY && ( seg -> frame_count >= start_frame || ( pkt -> pts != AV_NOPTS_VALUE && av_compare_ts ( pkt -> pts , st -> time_base , end_pts - seg -> time_delta , AV_TIME_BASE_Q ) >= 0 ) ) )  25
if ( ( ret = segment_end ( s , seg -> individual_header_trailer , 0 ) ) < 0 )  31
if ( ( ret = segment_start ( s , seg -> individual_header_trailer ) ) < 0 )  34
seg -> cur_entry . index = seg -> segment_idx; 39
seg -> cur_entry . start_time = ( double ) pkt -> pts * av_q2d ( st -> time_base ); 40
seg -> cur_entry . start_pts = av_rescale_q ( pkt -> pts , st -> time_base , AV_TIME_BASE_Q ); 41
if ( seg -> is_first_pkt )  47
av_log ( s , AV_LOG_DEBUG , "segment:'%s' starts with packet stream:%d pts:%s pts_time:%s frame:%d\n" , seg -> avf -> filename , pkt -> stream_index , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & st -> time_base ) , seg -> frame_count ); 48
av_log ( s , AV_LOG_DEBUG , "stream:%d start_pts_time:%s pts:%s pts_time:%s dts:%s dts_time:%s" , pkt -> stream_index , av_ts2timestr ( seg -> cur_entry . start_pts , & AV_TIME_BASE_Q ) , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & st -> time_base ) ); 54
offset = av_rescale_q ( seg -> initial_offset - ( seg -> reset_timestamps ? seg -> cur_entry . start_pts : 0 ) , AV_TIME_BASE_Q , st -> time_base ); 61
pkt -> pts += offset; 64
if ( pkt -> dts != AV_NOPTS_VALUE )  65
pkt -> dts += offset; 66
av_log ( s , AV_LOG_DEBUG , " -> pts:%s pts_time:%s dts:%s dts_time:%s\n" , av_ts2str ( pkt -> pts ) , av_ts2timestr ( pkt -> pts , & st -> time_base ) , av_ts2str ( pkt -> dts ) , av_ts2timestr ( pkt -> dts , & st -> time_base ) ); 68
ret = ff_write_chained ( oc , pkt -> stream_index , pkt , s ); 72
if ( pkt -> stream_index == seg -> reference_stream_index )  75
seg -> frame_count ++; 76
if ( ret < 0 )  78
if ( seg -> list )  79
avio_close ( seg -> list_pb ); 80
avformat_free_context ( seg -> avf ); 81
return ret ; 84
------------------------------
661 /home/SySeVR/data/CVE_2014_9679_PATCHED_cupsRasterReadPixels.c r -> pcurrent = r -> pixels + bytes 163
unsigned				/* O - Number of bytes read */
CVE_2014_9679_PATCHED_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
* temp = * ( temp - r -> bpp ); 132
temp += 1; 133
count -= 1; 134
cups_swap ( ptr , bytes ); 147
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ptr != p )  170
memcpy ( p , ptr , bytes ); 171
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
------------------------------
662 /home/SySeVR/data/CVE_2014_9679_PATCHED_cupsRasterReadPixels.c * temp = * ( temp - r -> bpp ) 132
unsigned				/* O - Number of bytes read */
CVE_2014_9679_PATCHED_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
* temp = * ( temp - r -> bpp ); 132
temp += 1; 133
count -= 1; 134
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
------------------------------
663 /home/SySeVR/data/CVE_2014_9679_PATCHED_cupsRasterReadPixels.c r -> remaining -= len / r -> header . cupsBytesPerLine 26
unsigned				/* O - Number of bytes read */
CVE_2014_9679_PATCHED_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
r -> remaining -= len / r -> header . cupsBytesPerLine; 26
if ( ! cups_read ( r -> fd , p , len ) )  28
if ( ( r -> header . cupsBitsPerColor == 16 || r -> header . cupsBitsPerPixel == 12 || r -> header . cupsBitsPerPixel == 16 ) && r -> swapped )  35
------------------------------
664 /home/SySeVR/data/CVE_2014_9679_VULN_cupsRasterReadPixels.c r -> pcurrent = r -> pixels + bytes 163
unsigned				/* O - Number of bytes read */
CVE_2014_9679_VULN_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
int bytes ; 8
unsigned cupsBytesPerLine ; 9
unsigned remaining ; 10
unsigned char * ptr , byte , * temp ; 11
int count ; 14
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
remaining = len; 52
cupsBytesPerLine = r -> header . cupsBytesPerLine; 53
while ( remaining > 0 && r -> remaining > 0 )  55
if ( r -> count == 0 )  57
if ( remaining == cupsBytesPerLine )  63
ptr = p; 64
ptr = r -> pixels; 66
if ( ! cups_raster_read ( r , & byte , 1 ) )  72
r -> count = byte + 1; 75
if ( r -> count > 1 )  77
ptr = r -> pixels; 78
temp = ptr; 80
bytes = cupsBytesPerLine; 81
while ( bytes > 0 )  83
if ( ! cups_raster_read ( r , & byte , 1 ) )  89
if ( byte & 128 )  92
count = ( 257 - byte ) * r -> bpp; 98
if ( count > bytes )  100
count = bytes; 101
if ( ! cups_raster_read ( r , temp , count ) )  103
temp += count; 106
bytes -= count; 107
count = ( byte + 1 ) * r -> bpp; 115
if ( count > bytes )  116
count = bytes; 117
if ( count < r -> bpp )  119
bytes -= count; 122
if ( ! cups_raster_read ( r , temp , r -> bpp ) )  124
temp += r -> bpp; 127
count -= r -> bpp; 128
while ( count > 0 )  130
memcpy ( temp , temp - r -> bpp , r -> bpp ); 132
temp += r -> bpp; 133
count -= r -> bpp; 134
cups_swap ( ptr , bytes ); 147
if ( remaining >= cupsBytesPerLine )  153
bytes = cupsBytesPerLine; 155
r -> pcurrent = r -> pixels; 156
r -> count --; 157
r -> remaining --; 158
bytes = remaining; 162
r -> pcurrent = r -> pixels + bytes; 163
if ( ptr != p )  170
memcpy ( p , ptr , bytes ); 171
if ( ( bytes = r -> pend - r -> pcurrent ) > remaining )  179
bytes = remaining; 180
memcpy ( p , r -> pcurrent , bytes ); 182
r -> pcurrent += bytes; 183
if ( r -> pcurrent >= r -> pend )  185
r -> pcurrent = r -> pixels; 187
r -> count --; 188
r -> remaining --; 189
remaining -= bytes; 193
p += bytes; 194
------------------------------
665 /home/SySeVR/data/CVE_2014_9679_VULN_cupsRasterReadPixels.c r -> remaining -= len / r -> header . cupsBytesPerLine 26
unsigned				/* O - Number of bytes read */
CVE_2014_9679_VULN_cupsRasterReadPixels(cups_raster_t *r,	/* I - Raster stream */
unsigned char *p,	/* I - Pointer to pixel buffer */
unsigned      len)	/* I - Number of bytes to read */ 7
if ( r == NULL || r -> mode != CUPS_RASTER_READ || r -> remaining == 0 )  17
if ( ! r -> compressed )  20
r -> remaining -= len / r -> header . cupsBytesPerLine; 26
if ( ! cups_read ( r -> fd , p , len ) )  28
if ( ( r -> header . cupsBitsPerColor == 16 || r -> header . cupsBitsPerPixel == 12 || r -> header . cupsBitsPerPixel == 16 ) && r -> swapped )  35
------------------------------
666 /home/SySeVR/data/CVE_2015_0228_VULN_lua_websocket_read.c rv = apr_socket_recv ( sock , buffer + at , & received ) 111
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
apr_size_t remaining = plen ; 102
apr_size_t received ; 103
apr_off_t at = 0 ; 104
char * buffer = apr_palloc ( r -> pool , plen + 1 ) ; 105
buffer [ plen ] = 0; 106
if ( plaintext )  108
while ( remaining > 0 )  109
received = remaining; 110
rv = apr_socket_recv ( sock , buffer + at , & received ); 111
if ( received > 0 )  112
remaining -= received; 113
at += received; 114
------------------------------
667 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( newDistDir , sizeof ( newDistDir ) / sizeof ( newDistDir [ 0 ] ) , NS_T ( "%s/Contents/Resources/distribution" ) , gInstallDirPath ) 826
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
NS_tchar newDistDir [ MAXPATHLEN ] ; 825
NS_tsnprintf ( newDistDir , sizeof ( newDistDir ) / sizeof ( newDistDir [ 0 ] ) , NS_T ( "%s/Contents/Resources/distribution" ) , gInstallDirPath ); 826
------------------------------
668 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( oldDistDir , sizeof ( oldDistDir ) / sizeof ( oldDistDir [ 0 ] ) , NS_T ( "%s/Contents/MacOS/distribution" ) , gInstallDirPath ) 821
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
NS_tsnprintf ( oldDistDir , sizeof ( oldDistDir ) / sizeof ( oldDistDir [ 0 ] ) , NS_T ( "%s/Contents/MacOS/distribution" ) , gInstallDirPath ); 821
------------------------------
669 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath ) 816
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldPrecomplete [ MAXPATHLEN ] ; 815
NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath ); 816
------------------------------
670 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath ) 298
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gPatchDirPath = argv [ 1 ]; 42
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath ); 298
------------------------------
671 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ) 269
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( sStagedUpdate )  250
if ( sReplaceRequest )  256
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 269
------------------------------
672 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ) 263
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( sStagedUpdate )  250
if ( sReplaceRequest )  256
NS_tchar installDir [ MAXPATHLEN ] ; 259
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
------------------------------
673 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s/updated.update_in_progress.lock" ) , gInstallDirPath ) 253
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( sStagedUpdate )  250
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s/updated.update_in_progress.lock" ) , gInstallDirPath ); 253
------------------------------
674 /home/SySeVR/data/CVE_2015_0833_VULN_UpdateThreadFunc.c NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath ) 47
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
MARChannelStringTable MARStrings ; 26
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
MARStrings . MARChannelID [ 0 ] = '\0'; 30
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 33
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
rv = CopyInstallDirToDestDir ( ); 40
if ( rv == OK )  43
NS_tchar updatingDir [ MAXPATHLEN ] ; 46
NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath ); 47
------------------------------
675 /home/SySeVR/data/CVE_2015_0833_VULN_UpdateThreadFunc.c NS_tsnprintf ( updateSettingsPath , sizeof ( updateSettingsPath ) / sizeof ( updateSettingsPath [ 0 ] ) , NS_T ( "%s/update-settings.ini" ) , gWorkingDirPath ) 23
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
NS_tsnprintf ( updateSettingsPath , sizeof ( updateSettingsPath ) / sizeof ( updateSettingsPath [ 0 ] ) , NS_T ( "%s/update-settings.ini" ) , gWorkingDirPath ); 23
------------------------------
676 /home/SySeVR/data/CVE_2015_2922_PATCHED_ndisc_router_discovery.c rtime = ( rtime * HZ ) / 1000 169
static void CVE_2015_2922_PATCHED_ndisc_router_discovery(struct sk_buff *skb) 1
struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; 3
struct inet6_dev * in6_dev ; 5
int lifetime ; 7
struct ndisc_options ndopts ; 8
int optlen ; 9
__u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; 12
optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ); 14
if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) )  16
if ( optlen < 0 )  20
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST )  26
in6_dev = __in6_dev_get ( skb -> dev ); 36
if ( in6_dev == NULL )  37
if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) )  43
if ( ! accept_ra ( in6_dev ) )  48
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  53
if ( in6_dev -> if_flags & IF_RS_SENT )  57
in6_dev -> if_flags |= IF_RA_RCVD; 62
in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ); 69
if ( ! in6_dev -> cnf . accept_ra_defrtr )  76
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  79
lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ); 82
pref = ra_msg -> icmph . icmp6_router_pref; 85
if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref )  87
pref = ICMPV6_ROUTER_PREF_MEDIUM; 89
rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ); 92
if ( rt )  94
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 95
if ( ! neigh )  96
if ( rt && lifetime == 0 )  104
rt = NULL; 106
if ( rt == NULL && lifetime )  109
rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ); 112
if ( rt == NULL )  113
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 120
if ( neigh == NULL )  121
if ( ra_msg -> icmph . icmp6_hop_limit )  135
if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit )  139
in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit; 140
if ( in6_dev -> nd_parms )  155
unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; 156
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ )  158
rtime = ( rtime * HZ ) / 1000; 159
if ( rtime < HZ / 10 )  160
rtime = HZ / 10; 161
rtime = ntohl ( ra_msg -> reachable_time ); 167
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) )  168
rtime = ( rtime * HZ ) / 1000; 169
if ( rtime < HZ / 10 )  171
if ( rtime != in6_dev -> nd_parms -> base_reachable_time )  174
in6_dev -> nd_parms -> base_reachable_time = rtime; 175
in6_dev -> nd_parms -> gc_staletime = 3 * rtime; 176
in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ); 177
in6_dev -> tstamp = jiffies; 178
inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ); 179
if ( ! accept_ra ( in6_dev ) )  211
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  215
if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri )  218
if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen )  229
if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi )  245
if ( in6_dev -> cnf . mtu6 != mtu )  265
in6_dev -> cnf . mtu6 = mtu; 266
------------------------------
677 /home/SySeVR/data/CVE_2015_2922_PATCHED_ndisc_router_discovery.c rtime = ( rtime * HZ ) / 1000 159
static void CVE_2015_2922_PATCHED_ndisc_router_discovery(struct sk_buff *skb) 1
struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; 3
struct inet6_dev * in6_dev ; 5
int lifetime ; 7
struct ndisc_options ndopts ; 8
int optlen ; 9
__u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; 12
optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ); 14
if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) )  16
if ( optlen < 0 )  20
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST )  26
in6_dev = __in6_dev_get ( skb -> dev ); 36
if ( in6_dev == NULL )  37
if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) )  43
if ( ! accept_ra ( in6_dev ) )  48
if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT )  53
if ( in6_dev -> if_flags & IF_RS_SENT )  57
in6_dev -> if_flags |= IF_RA_RCVD; 62
in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | IF_RA_OTHERCONF ) ) | ( ra_msg -> icmph . icmp6_addrconf_managed ? IF_RA_MANAGED : 0 ) | ( ra_msg -> icmph . icmp6_addrconf_other ? IF_RA_OTHERCONF : 0 ); 69
if ( ! in6_dev -> cnf . accept_ra_defrtr )  76
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  79
lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ); 82
pref = ra_msg -> icmph . icmp6_router_pref; 85
if ( pref == ICMPV6_ROUTER_PREF_INVALID || ! in6_dev -> cnf . accept_ra_rtr_pref )  87
pref = ICMPV6_ROUTER_PREF_MEDIUM; 89
rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ); 92
if ( rt )  94
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 95
if ( ! neigh )  96
if ( rt && lifetime == 0 )  104
rt = NULL; 106
if ( rt == NULL && lifetime )  109
rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ); 112
if ( rt == NULL )  113
neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ); 120
if ( neigh == NULL )  121
if ( ra_msg -> icmph . icmp6_hop_limit )  135
if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit )  139
in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit; 140
if ( in6_dev -> nd_parms )  155
unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; 156
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ )  158
rtime = ( rtime * HZ ) / 1000; 159
if ( rtime < HZ / 10 )  160
in6_dev -> nd_parms -> retrans_time = rtime; 162
in6_dev -> tstamp = jiffies; 163
inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ); 164
if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) )  168
rtime = ( rtime * HZ ) / 1000; 169
if ( rtime < HZ / 10 )  171
if ( rtime != in6_dev -> nd_parms -> base_reachable_time )  174
in6_dev -> nd_parms -> base_reachable_time = rtime; 175
in6_dev -> nd_parms -> gc_staletime = 3 * rtime; 176
in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ); 177
in6_dev -> tstamp = jiffies; 178
inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ); 179
if ( ! accept_ra ( in6_dev ) )  211
if ( ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) )  215
if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri )  218
if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen )  229
if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi )  245
if ( in6_dev -> cnf . mtu6 != mtu )  265
in6_dev -> cnf . mtu6 = mtu; 266
------------------------------
678 /home/SySeVR/data/CVE_2015_2922_PATCHED_ndisc_router_discovery.c optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ) 14
static void CVE_2015_2922_PATCHED_ndisc_router_discovery(struct sk_buff *skb) 1
int optlen ; 9
optlen = ( skb -> tail - skb -> transport_header ) - sizeof ( struct ra_msg ); 14
if ( optlen < 0 )  20
if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) )  43
------------------------------
679 /home/SySeVR/data/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0 64
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = scatterwalk_map ( & src_sg_walk ); 39
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
680 /home/SySeVR/data/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c assoc = ( src + req -> cryptlen ) 52
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
assoc = ( src + req -> cryptlen ); 52
scatterwalk_map_and_copy ( assoc , req -> assoc , 0 , req -> assoclen , 0 ); 54
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
scatterwalk_unmap ( assoc ); 73
------------------------------
681 /home/SySeVR/data/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ) 49
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
assoc = ( src + req -> cryptlen ); 52
scatterwalk_map_and_copy ( src , req -> src , 0 , req -> cryptlen , 0 ); 53
scatterwalk_map_and_copy ( assoc , req -> assoc , 0 , req -> assoclen , 0 ); 54
dst = src; 56
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
scatterwalk_unmap ( dst ); 69
scatterwalk_unmap ( src ); 72
scatterwalk_unmap ( assoc ); 73
scatterwalk_map_and_copy ( dst , req -> dst , 0 , tempCipherLen , 1 ); 77
kfree ( src ); 78
return retval ; 80
------------------------------
682 /home/SySeVR/data/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ) 27
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
scatterwalk_map_and_copy ( dst , req -> dst , 0 , tempCipherLen , 1 ); 77
return retval ; 80
------------------------------
683 /home/SySeVR/data/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0 64
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = scatterwalk_map ( & src_sg_walk ); 39
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
684 /home/SySeVR/data/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c assoc = ( src + req -> cryptlen + auth_tag_len ) 52
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
assoc = ( src + req -> cryptlen + auth_tag_len ); 52
scatterwalk_map_and_copy ( assoc , req -> assoc , 0 , req -> assoclen , 0 ); 54
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
scatterwalk_unmap ( assoc ); 73
------------------------------
685 /home/SySeVR/data/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ) 49
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 * src , * dst , * assoc ; 4
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )  35
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ); 49
if ( ! src )  50
assoc = ( src + req -> cryptlen + auth_tag_len ); 52
scatterwalk_map_and_copy ( src , req -> src , 0 , req -> cryptlen , 0 ); 53
scatterwalk_map_and_copy ( assoc , req -> assoc , 0 , req -> assoclen , 0 ); 54
dst = src; 56
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
scatterwalk_unmap ( dst ); 69
scatterwalk_unmap ( src ); 72
scatterwalk_unmap ( assoc ); 73
scatterwalk_map_and_copy ( dst , req -> dst , 0 , req -> cryptlen , 1 ); 77
kfree ( src ); 78
return retval ; 80
------------------------------
686 /home/SySeVR/data/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ) 27
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ; 8
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ; 11
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )  20
tempCipherLen = ( unsigned long ) ( req -> cryptlen - auth_tag_len ); 27
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
687 /home/SySeVR/data/CVE_2015_3808_VULN_dissect_lbmr_pser.c opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ) 36
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
curr_offset += hdr_len; 26
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
proto_item_set_len ( opts_item , opt_len ); 43
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
opt_len -= option_len; 70
------------------------------
688 /home/SySeVR/data/CVE_2015_3808_VULN_dissect_lbmr_pser.c flags_item = proto_tree_add_none_format ( tree , hf_lbmr_pser_flags , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , "Flags (0x%04x)" , flags ) 16
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
flags_item = proto_tree_add_none_format ( tree , hf_lbmr_pser_flags , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , "Flags (0x%04x)" , flags ); 16
flags_tree = proto_item_add_subtree ( flags_item , ett_lbmr_pser_flags ); 17
proto_tree_add_item ( flags_tree , hf_lbmr_pser_flags_option , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , ENC_BIG_ENDIAN ); 18
------------------------------
689 /home/SySeVR/data/CVE_2015_3808_VULN_dissect_lbmr_pser.c topic_len = hdr_len - L_LBMR_PSER_T 13
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
topic_len = hdr_len - L_LBMR_PSER_T; 13
proto_tree_add_item ( tree , hf_lbmr_pser_topic , tvb , offset + O_LBMR_PSER_T_TOPIC , topic_len , ENC_ASCII | ENC_NA ); 25
------------------------------
690 /home/SySeVR/data/CVE_2015_3808_VULN_dissect_lbmr_pser.c flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ) 12
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
flags_item = proto_tree_add_none_format ( tree , hf_lbmr_pser_flags , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , "Flags (0x%04x)" , flags ); 16
flags_tree = proto_item_add_subtree ( flags_item , ett_lbmr_pser_flags ); 17
proto_tree_add_item ( flags_tree , hf_lbmr_pser_flags_option , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , ENC_BIG_ENDIAN ); 18
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
------------------------------
691 /home/SySeVR/data/CVE_2015_3808_VULN_dissect_lbmr_pser.c hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ) 11
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
topic_len = hdr_len - L_LBMR_PSER_T; 13
proto_tree_add_item ( tree , hf_lbmr_pser_topic , tvb , offset + O_LBMR_PSER_T_TOPIC , topic_len , ENC_ASCII | ENC_NA ); 25
curr_offset += hdr_len; 26
len = hdr_len; 27
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
opts_item = proto_tree_add_item ( tree , hf_lbmr_pser_opts , tvb , curr_offset , - 1 , ENC_NA ); 37
opts_tree = proto_item_add_subtree ( opts_item , ett_lbmr_pser_opts ); 38
optlen_item = proto_tree_add_item ( opts_tree , hf_lbmr_pser_optlen , tvb , curr_offset , L_LBMR_PSER_OPTLEN_T , ENC_NA ); 39
optlen_tree = proto_item_add_subtree ( optlen_item , ett_lbmr_pser_opt_len ); 40
proto_tree_add_item ( optlen_tree , hf_lbmr_pser_optlen_type , tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_TYPE , L_LBMR_PSER_OPTLEN_T_TYPE , ENC_BIG_ENDIAN ); 41
proto_tree_add_item ( optlen_tree , hf_lbmr_pser_optlen_optlen , tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN , L_LBMR_PSER_OPTLEN_T_OPTLEN , ENC_BIG_ENDIAN ); 42
proto_item_set_len ( opts_item , opt_len ); 43
len += L_LBMR_PSER_OPTLEN_T; 44
curr_offset += L_LBMR_PSER_OPTLEN_T; 45
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
switch ( opt_type )  54
ctxinst_item = proto_tree_add_item ( opts_tree , hf_lbmr_pser_opt_ctxinst , tvb , offset , L_LBMR_PSER_OPT_CTXINST_T , ENC_NA ); 58
ctxinst_tree = proto_item_add_subtree ( ctxinst_item , ett_lbmr_pser_opt_ctxinst ); 59
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_len , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_LEN , L_LBMR_PSER_OPT_CTXINST_T_LEN , ENC_BIG_ENDIAN ); 60
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_type , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_TYPE , L_LBMR_PSER_OPT_CTXINST_T_TYPE , ENC_BIG_ENDIAN ); 61
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_ctxinst , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_CTXINST , L_LBMR_PSER_OPT_CTXINST_T_CTXINST , ENC_NA ); 62
len += L_LBMR_PSER_OPT_CTXINST_T; 63
curr_offset += L_LBMR_PSER_OPT_CTXINST_T; 64
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
len += option_len; 68
curr_offset += option_len; 69
opt_len -= option_len; 70
expert_add_info_format ( pinfo , NULL , & ei_lbmr_analysis_invalid_value , "Unknown LBMR PSER option 0x%02x" , opt_type ); 71
return ( len ) ; 76
------------------------------
692 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ) 36
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
curr_offset += hdr_len; 26
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
proto_item_set_len ( opts_item , opt_len ); 43
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
opt_len -= option_len; 70
------------------------------
693 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c flags_item = proto_tree_add_none_format ( tree , hf_lbmr_pser_flags , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , "Flags (0x%04x)" , flags ) 16
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
flags_item = proto_tree_add_none_format ( tree , hf_lbmr_pser_flags , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , "Flags (0x%04x)" , flags ); 16
flags_tree = proto_item_add_subtree ( flags_item , ett_lbmr_pser_flags ); 17
proto_tree_add_item ( flags_tree , hf_lbmr_pser_flags_option , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , ENC_BIG_ENDIAN ); 18
------------------------------
694 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c topic_len = hdr_len - L_LBMR_PSER_T 13
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
topic_len = hdr_len - L_LBMR_PSER_T; 13
proto_tree_add_item ( tree , hf_lbmr_pser_topic , tvb , offset + O_LBMR_PSER_T_TOPIC , topic_len , ENC_ASCII | ENC_NA ); 25
------------------------------
695 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ) 12
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
flags_item = proto_tree_add_none_format ( tree , hf_lbmr_pser_flags , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , "Flags (0x%04x)" , flags ); 16
flags_tree = proto_item_add_subtree ( flags_item , ett_lbmr_pser_flags ); 17
proto_tree_add_item ( flags_tree , hf_lbmr_pser_flags_option , tvb , offset + O_LBMR_PSER_T_FLAGS , L_LBMR_PSER_T_FLAGS , ENC_BIG_ENDIAN ); 18
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
------------------------------
696 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ) 11
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
topic_len = hdr_len - L_LBMR_PSER_T; 13
proto_tree_add_item ( tree , hf_lbmr_pser_topic , tvb , offset + O_LBMR_PSER_T_TOPIC , topic_len , ENC_ASCII | ENC_NA ); 25
curr_offset += hdr_len; 26
len = hdr_len; 27
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
opts_item = proto_tree_add_item ( tree , hf_lbmr_pser_opts , tvb , curr_offset , - 1 , ENC_NA ); 37
opts_tree = proto_item_add_subtree ( opts_item , ett_lbmr_pser_opts ); 38
optlen_item = proto_tree_add_item ( opts_tree , hf_lbmr_pser_optlen , tvb , curr_offset , L_LBMR_PSER_OPTLEN_T , ENC_NA ); 39
optlen_tree = proto_item_add_subtree ( optlen_item , ett_lbmr_pser_opt_len ); 40
proto_tree_add_item ( optlen_tree , hf_lbmr_pser_optlen_type , tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_TYPE , L_LBMR_PSER_OPTLEN_T_TYPE , ENC_BIG_ENDIAN ); 41
proto_tree_add_item ( optlen_tree , hf_lbmr_pser_optlen_optlen , tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN , L_LBMR_PSER_OPTLEN_T_OPTLEN , ENC_BIG_ENDIAN ); 42
proto_item_set_len ( opts_item , opt_len ); 43
len += L_LBMR_PSER_OPTLEN_T; 44
curr_offset += L_LBMR_PSER_OPTLEN_T; 45
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
guint8 option_len = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN ) ; 52
switch ( opt_type )  54
ctxinst_item = proto_tree_add_item ( opts_tree , hf_lbmr_pser_opt_ctxinst , tvb , curr_offset , L_LBMR_PSER_OPT_CTXINST_T , ENC_NA ); 58
ctxinst_tree = proto_item_add_subtree ( ctxinst_item , ett_lbmr_pser_opt_ctxinst ); 59
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_len , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_LEN , L_LBMR_PSER_OPT_CTXINST_T_LEN , ENC_BIG_ENDIAN ); 60
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_type , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_TYPE , L_LBMR_PSER_OPT_CTXINST_T_TYPE , ENC_BIG_ENDIAN ); 61
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_ctxinst , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_CTXINST , L_LBMR_PSER_OPT_CTXINST_T_CTXINST , ENC_NA ); 62
len += L_LBMR_PSER_OPT_CTXINST_T; 63
curr_offset += L_LBMR_PSER_OPT_CTXINST_T; 64
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
len += option_len; 68
curr_offset += option_len; 69
opt_len -= option_len; 70
expert_add_info_format ( pinfo , NULL , & ei_lbmr_analysis_invalid_value , "Unknown LBMR PSER option 0x%02x" , opt_type ); 71
if ( option_len == 0 )  72
return ( len ) ; 73
return ( len ) ; 79
------------------------------
697 /home/SySeVR/data/CVE_2015_3811_PATCHED_wcp_uncompress.c src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ) 40
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
if ( cnt - offset > MAX_WCP_BUF_LEN )  26
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
src += 3; 87
data_cnt = ( * src >> 4 ) + 1; 96
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
src += 2; 106
if ( data_offset + 1 > buf_ptr -> initialized )  109
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data offset exceeds valid window size (%d > %d)" , data_offset + 1 , buf_ptr -> initialized ); 110
if ( data_offset + 1 < data_cnt )  116
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data count exceeds offset (%d > %d)" , data_cnt , data_offset + 1 ); 117
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_ptr ); 123
if ( dst == NULL )  126
* dst = * src; 153
if ( dst ++ == buf_end )  154
comp_flag_bits <<= 1; 164
comp_flag_bits = * src ++; 172
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 174
buf_ptr -> buf_cur = dst; 200
------------------------------
698 /home/SySeVR/data/CVE_2015_3811_PATCHED_wcp_uncompress.c cd_item = proto_tree_add_item ( tree , hf_wcp_compressed_data , src_tvb , offset , cnt - offset , ENC_NA ) 23
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
proto_item * cd_item , * ti ; 6
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
cd_item = proto_tree_add_item ( tree , hf_wcp_compressed_data , src_tvb , offset , cnt - offset , ENC_NA ); 23
cd_tree = proto_item_add_subtree ( cd_item , ett_wcp_comp_data ); 25
expert_add_info_format ( pinfo , cd_item , & ei_wcp_compressed_data_exceeds , "Compressed data exceeds maximum buffer length (%d > %d)" , cnt - offset , MAX_WCP_BUF_LEN ); 27
ti = proto_tree_add_item ( cd_tree , hf_wcp_long_run , src_tvb , offset , 3 , ENC_NA ); 78
sub_tree = proto_item_add_subtree ( ti , ett_wcp_field ); 80
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
proto_tree_add_item ( sub_tree , hf_wcp_long_len , src_tvb , offset + 2 , 1 , ENC_BIG_ENDIAN ); 84
ti = proto_tree_add_item ( cd_tree , hf_wcp_short_run , src_tvb , offset , 2 , ENC_NA ); 98
sub_tree = proto_item_add_subtree ( ti , ett_wcp_field ); 100
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data offset exceeds valid window size (%d > %d)" , data_offset + 1 , buf_ptr -> initialized ); 110
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data count exceeds offset (%d > %d)" , data_cnt , data_offset + 1 ); 117
expert_add_info_format ( pinfo , cd_item , & ei_wcp_uncompressed_data_exceeds , "Uncompressed data exceeds maximum buffer length (%d > %d)" , len , MAX_WCP_BUF_LEN ); 127
expert_add_info_format ( pinfo , cd_item , & ei_wcp_uncompressed_data_exceeds , "Uncompressed data exceeds maximum buffer length (%d > %d)" , len , MAX_WCP_BUF_LEN ); 141
if ( cd_tree )  173
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 174
------------------------------
699 /home/SySeVR/data/CVE_2015_3811_PATCHED_wcp_uncompress.c buf_end = buf_start + MAX_WIN_BUF_LEN 21
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
buf_ptr = get_wcp_window_ptr ( pinfo ); 18
buf_start = buf_ptr -> buffer; 20
buf_end = buf_start + MAX_WIN_BUF_LEN; 21
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_ptr ); 123
if ( dst == NULL )  126
* dst = * src; 153
if ( dst ++ == buf_end )  154
buf_ptr -> buf_cur = dst; 200
------------------------------
700 /home/SySeVR/data/CVE_2015_3811_VULN_wcp_uncompress.c src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ) 40
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
if ( cnt - offset > MAX_WCP_BUF_LEN )  26
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
src += 3; 87
data_cnt = ( * src >> 4 ) + 1; 96
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
src += 2; 106
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_start , buf_end ); 110
if ( dst == NULL )  113
* dst = * src; 140
if ( dst ++ == buf_end )  141
comp_flag_bits <<= 1; 149
comp_flag_bits = * src ++; 157
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 159
buf_ptr -> buf_cur = dst; 185
------------------------------
701 /home/SySeVR/data/CVE_2015_3811_VULN_wcp_uncompress.c cd_item = proto_tree_add_item ( tree , hf_wcp_compressed_data , src_tvb , offset , cnt - offset , ENC_NA ) 23
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
proto_item * cd_item , * ti ; 6
int cnt = tvb_reported_length ( src_tvb ) - 1 ; 9
cd_item = proto_tree_add_item ( tree , hf_wcp_compressed_data , src_tvb , offset , cnt - offset , ENC_NA ); 23
cd_tree = proto_item_add_subtree ( cd_item , ett_wcp_comp_data ); 25
expert_add_info_format ( pinfo , cd_item , & ei_wcp_compressed_data_exceeds , "Compressed data exceeds maximum buffer length (%d > %d)" , cnt - offset , MAX_WCP_BUF_LEN ); 27
ti = proto_tree_add_item ( cd_tree , hf_wcp_long_run , src_tvb , offset , 3 , ENC_NA ); 78
sub_tree = proto_item_add_subtree ( ti , ett_wcp_field ); 80
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
proto_tree_add_item ( sub_tree , hf_wcp_long_len , src_tvb , offset + 2 , 1 , ENC_BIG_ENDIAN ); 84
ti = proto_tree_add_item ( cd_tree , hf_wcp_short_run , src_tvb , offset , 2 , ENC_NA ); 98
sub_tree = proto_item_add_subtree ( ti , ett_wcp_field ); 100
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
expert_add_info_format ( pinfo , cd_item , & ei_wcp_uncompressed_data_exceeds , "Uncompressed data exceeds maximum buffer length (%d > %d)" , len , MAX_WCP_BUF_LEN ); 114
expert_add_info_format ( pinfo , cd_item , & ei_wcp_uncompressed_data_exceeds , "Uncompressed data exceeds maximum buffer length (%d > %d)" , len , MAX_WCP_BUF_LEN ); 128
if ( cd_tree )  158
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 159
------------------------------
702 /home/SySeVR/data/CVE_2015_3811_VULN_wcp_uncompress.c buf_end = buf_start + MAX_WIN_BUF_LEN 21
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
buf_ptr = get_wcp_window_ptr ( pinfo ); 18
buf_start = buf_ptr -> buffer; 20
buf_end = buf_start + MAX_WIN_BUF_LEN; 21
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_start , buf_end ); 110
if ( dst == NULL )  113
* dst = * src; 140
if ( dst ++ == buf_end )  141
buf_ptr -> buf_cur = dst; 185
------------------------------
703 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c fd_head -> error = "offset + len < offset" 315
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
fd_head -> flags |= FD_DEFRAGMENTED; 332
fd_head -> reassembled_in = pinfo -> fd -> num; 333
if ( fd_head -> error )  336
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 337
------------------------------
704 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ) 309
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
------------------------------
705 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c fd_head -> error = "fraglen < dfpos - offset" 304
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
fd_head -> flags |= FD_DEFRAGMENTED; 332
fd_head -> reassembled_in = pinfo -> fd -> num; 333
if ( fd_head -> error )  336
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 337
------------------------------
706 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c fraglen = fd_head -> datalen - fd_i -> offset 285
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
------------------------------
707 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c fd_head -> error = "dfpos - offset > len" 263
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
fd_head -> flags |= FD_DEFRAGMENTED; 332
fd_head -> reassembled_in = pinfo -> fd -> num; 333
if ( fd_head -> error )  336
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 337
------------------------------
708 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c max = fd_i -> offset + fd_i -> len 188
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
------------------------------
709 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c fd_head -> datalen = fd -> offset + fd -> len 121
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
fd_head -> flags |= FD_OVERLAP; 136
if ( end_offset > fd_head -> datalen || end_offset < fd -> offset || end_offset < fd -> len )  138
fd_head -> flags |= FD_TOOLONGFRAGMENT; 140
if ( tvb_memeql ( fd_head -> tvb_data , fd -> offset , tvb_get_ptr ( tvb , offset , fd -> len ) , fd -> len ) )  143
fd_head -> flags |= FD_OVERLAPCONFLICT; 146
LINK_FRAG ( fd_head , fd ); 149
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
old_tvb_data = fd_head -> tvb_data; 205
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
tvb_set_free_cb ( fd_head -> tvb_data , g_free ); 208
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
if ( dfpos - fd_i -> offset > fd_i -> len )  262
if ( ! fd_head -> tvb_data )  264
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 306
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
if ( fd_i -> tvb_data )  321
tvb_free ( fd_i -> tvb_data ); 322
fd_i -> tvb_data = NULL; 324
if ( old_tvb_data )  328
tvb_add_to_chain ( tvb , old_tvb_data ); 329
fd_head -> flags |= FD_DEFRAGMENTED; 332
fd_head -> reassembled_in = pinfo -> fd -> num; 333
if ( fd_head -> error )  336
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 337
------------------------------
710 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c fd_head -> error = "offset + len < offset" 313
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
fd_head -> flags |= FD_DEFRAGMENTED; 330
fd_head -> reassembled_in = pinfo -> fd -> num; 331
if ( fd_head -> error )  334
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 335
------------------------------
711 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ) 307
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
------------------------------
712 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c fd_head -> error = "fraglen < dfpos - offset" 302
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
fd_head -> flags |= FD_DEFRAGMENTED; 330
fd_head -> reassembled_in = pinfo -> fd -> num; 331
if ( fd_head -> error )  334
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 335
------------------------------
713 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c fraglen = fd_head -> datalen - fd_i -> offset 283
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
------------------------------
714 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c fd_head -> error = "dfpos - offset > len" 261
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
fd_head -> flags |= FD_DEFRAGMENTED; 330
fd_head -> reassembled_in = pinfo -> fd -> num; 331
if ( fd_head -> error )  334
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 335
------------------------------
715 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c max = fd_i -> offset + fd_i -> len 186
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
------------------------------
716 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c fd_head -> datalen = fd -> offset + fd -> len 121
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
fd_head -> flags |= FD_OVERLAP; 136
if ( end_offset > fd_head -> datalen || end_offset < fd -> offset || end_offset < fd -> len )  138
fd_head -> flags |= FD_TOOLONGFRAGMENT; 140
if ( tvb_memeql ( fd_head -> tvb_data , fd -> offset , tvb_get_ptr ( tvb , offset , fd -> len ) , fd -> len ) )  143
fd_head -> flags |= FD_OVERLAPCONFLICT; 146
LINK_FRAG ( fd_head , fd ); 149
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
old_tvb_data = fd_head -> tvb_data; 203
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
tvb_set_free_cb ( fd_head -> tvb_data , g_free ); 206
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
if ( dfpos - fd_i -> offset > fd_i -> len )  260
if ( ! fd_head -> tvb_data )  262
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
memcpy ( data + dfpos , tvb_get_ptr ( fd_i -> tvb_data , ( dfpos - fd_i -> offset ) , fraglen - ( dfpos - fd_i -> offset ) ) , fraglen - ( dfpos - fd_i -> offset ) ); 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
if ( fd_i -> tvb_data )  319
tvb_free ( fd_i -> tvb_data ); 320
fd_i -> tvb_data = NULL; 322
if ( old_tvb_data )  326
tvb_add_to_chain ( tvb , old_tvb_data ); 327
fd_head -> flags |= FD_DEFRAGMENTED; 330
fd_head -> reassembled_in = pinfo -> fd -> num; 331
if ( fd_head -> error )  334
THROW_MESSAGE ( ReassemblyError , fd_head -> error ); 335
------------------------------
717 /home/SySeVR/data/CVE_2015_4652_VULN_de_bcd_num.c num_string_len = len - ( curr_offset - offset ) 30
static guint16
CVE_2015_4652_VULN_de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, int header_field, gboolean *address_extracted) 2
guint8 extension , oct ; 5
guint32 curr_offset , i , num_string_len ; 6
curr_offset = offset; 11
extension = tvb_get_guint8 ( tvb , curr_offset ) & 0x80; 13
curr_offset ++; 17
if ( ! extension )  19
curr_offset ++; 25
num_string_len = len - ( curr_offset - offset ); 30
poctets = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , curr_offset , num_string_len ); 31
my_dgt_tbcd_unpack ( a_bigbuf , poctets , num_string_len , & Dgt_mbcd ); 34
item = proto_tree_add_string_format ( tree , header_field , tvb , curr_offset , num_string_len , a_bigbuf , "BCD Digits: %s" , a_bigbuf ); 37
for(i = 0; i < num_string_len - 1; i++) 44
oct = poctets [ i ]; 46
if ( ( ( oct & 0xf0 ) == 0xf0 ) || ( ( oct & 0x0f ) == 0x0f ) )  47
oct = poctets [ num_string_len - 1 ]; 54
if ( ( oct & 0x0f ) == 0x0f )  55
expert_add_info ( pinfo , item , & ei_gsm_a_dtap_end_mark_unexpected ); 59
------------------------------
718 /home/SySeVR/data/CVE_2015_6242_VULN_wmem_block_split_free_chunk.c available = chunk -> len - aligned_size 29
static void
CVE_2015_6242_VULN_wmem_block_split_free_chunk(wmem_block_allocator_t *allocator,
wmem_block_chunk_t *chunk,
const size_t size) 4
size_t aligned_size , available ; 8
aligned_size = WMEM_ALIGN_SIZE ( size ) + WMEM_CHUNK_HEADER_SIZE; 11
if ( WMEM_CHUNK_DATA_LEN ( chunk ) < aligned_size + sizeof ( wmem_block_free_t ) )  13
available = chunk -> len - aligned_size; 29
extra -> len = ( guint32 ) available; 78
extra -> last = last; 79
extra -> prev = chunk -> len; 80
extra -> used = FALSE; 81
extra -> jumbo = FALSE; 82
WMEM_CHUNK_NEXT ( extra ) -> prev = extra -> len; 86
------------------------------
719 /home/SySeVR/data/CVE_2015_6246_PATCHED_dissect_wa_payload.c current_offset = offset + iLoop * delta 494
static void CVE_2015_6246_PATCHED_dissect_wa_payload(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint32 control_word, guint8 version) 1
switch ( control_word )  3
guint32 offset ; 115
guint32 delta ; 117
guint32 iLoop ; 118
offset = starting_offset + 8; 128
delta = 156; 129
for (iLoop = 0; iLoop < NUM_STATE_CHANGES; iLoop++) 131
guint32 if_status ; 134
int current_offset ; 135
current_offset = offset + iLoop * delta; 137
if_status = tvb_get_ntohl ( tvb , current_offset ); 140
if ( if_status == 0 )  141
guint32 offset ; 201
guint32 num_bss_entries ; 203
guint32 delta ; 205
guint32 iLoop ; 206
num_bss_entries = tvb_get_ntohl ( tvb , starting_offset + 8 ); 219
if ( num_bss_entries > NUM_BSS )  221
num_bss_entries = NUM_BSS; 223
offset = starting_offset + 16; 227
delta = 148; 228
for (iLoop = 0; iLoop < num_bss_entries; iLoop++) 232
int current_offset ; 236
if ( version < 3 )  303
starting_offset += 4; 314
guint32 offset ; 470
guint32 delta ; 471
guint32 iLoop ; 472
guint32 num_bss_entries ; 473
num_bss_entries = tvb_get_ntohl ( tvb , starting_offset + 142 ); 487
offset = starting_offset + 46; 489
delta = 6; 490
for (iLoop = 0; iLoop < num_bss_entries; iLoop++) 491
int current_offset ; 493
current_offset = offset + iLoop * delta; 494
proto_tree_add_item ( parent_tree , hf_waveagent_scanbssid , tvb , current_offset , 6 , ENC_NA ); 496
------------------------------
720 /home/SySeVR/data/CVE_2015_6246_PATCHED_dissect_wa_payload.c current_offset = offset + iLoop * delta 240
static void CVE_2015_6246_PATCHED_dissect_wa_payload(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint32 control_word, guint8 version) 1
switch ( control_word )  3
guint32 offset ; 115
guint32 delta ; 117
guint32 iLoop ; 118
offset = starting_offset + 8; 128
delta = 156; 129
for (iLoop = 0; iLoop < NUM_STATE_CHANGES; iLoop++) 131
guint32 if_status ; 134
int current_offset ; 135
current_offset = offset + iLoop * delta; 137
if_status = tvb_get_ntohl ( tvb , current_offset ); 140
if ( if_status == 0 )  141
guint32 offset ; 201
guint32 num_bss_entries ; 203
guint32 delta ; 205
guint32 iLoop ; 206
num_bss_entries = tvb_get_ntohl ( tvb , starting_offset + 8 ); 219
if ( num_bss_entries > NUM_BSS )  221
num_bss_entries = NUM_BSS; 223
offset = starting_offset + 16; 227
delta = 148; 228
for (iLoop = 0; iLoop < num_bss_entries; iLoop++) 232
int current_offset ; 236
current_offset = offset + iLoop * delta; 240
bssIndex = proto_tree_add_item ( parent_tree , hf_waveagent_scanssid , tvb , current_offset , 32 , ENC_ASCII | ENC_NA ); 242
bss_tree = proto_item_add_subtree ( bssIndex , ett_bss [ iLoop ] ); 245
tag_len = tvb_get_ntohl ( tvb , current_offset + 52 ); 247
if ( tag_len != 0 )  249
for (isr = 0; isr < tag_len; isr++) 253
proto_tree_add_string ( bss_tree , hf_waveagent_ifwlansupprates , tvb , offset + 36 + isr ,
1 ,
"BSS requires support for mandatory features of HT PHY (IEEE 802.11"
" - Clause 20)" ) 259
proto_tree_add_string ( bss_tree , hf_waveagent_ifwlansupprates , tvb , offset + 36 , tag_len , wmem_strbuf_get_str ( sb ) ); 273
proto_tree_add_item ( bss_tree , hf_waveagent_scanbssid , tvb , current_offset + 56 , 6 , ENC_NA ); 276
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlancapabilities , tvb , current_offset + 62 , 2 , ENC_BIG_ENDIAN ); 279
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanrssi , tvb , current_offset + 64 , 4 , ENC_BIG_ENDIAN ); 282
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlansigquality , tvb , current_offset + 68 , 4 , ENC_BIG_ENDIAN ); 287
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanchannel , tvb , current_offset + 72 , 4 , ENC_BIG_ENDIAN ); 290
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanprivacy , tvb , current_offset + 76 , 4 , ENC_BIG_ENDIAN ); 293
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanbssmode , tvb , current_offset + 80 , 4 , ENC_BIG_ENDIAN ); 296
proto_tree_add_item ( parent_tree , hf_waveagent_scanbssid , tvb , current_offset , 6 , ENC_NA ); 496
------------------------------
721 /home/SySeVR/data/CVE_2015_6246_PATCHED_dissect_wa_payload.c current_offset = offset + iLoop * delta 137
static void CVE_2015_6246_PATCHED_dissect_wa_payload(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint32 control_word, guint8 version) 1
switch ( control_word )  3
guint32 offset ; 115
guint32 delta ; 117
guint32 iLoop ; 118
offset = starting_offset + 8; 128
delta = 156; 129
for (iLoop = 0; iLoop < NUM_STATE_CHANGES; iLoop++) 131
guint32 if_status ; 134
int current_offset ; 135
current_offset = offset + iLoop * delta; 137
if_status = tvb_get_ntohl ( tvb , current_offset ); 140
if ( if_status == 0 )  141
stIndex = proto_tree_add_uint_format_value ( parent_tree , hf_waveagent_ifwlanl2status , tvb , current_offset , 4 , if_status , "Interface state change %d" , iLoop ); 144
st_change_index_tree = proto_item_add_subtree ( stIndex , ett_scindex [ iLoop ] ); 147
proto_tree_add_item ( st_change_index_tree , hf_waveagent_ifwlanl2status , tvb , current_offset , 4 , ENC_BIG_ENDIAN ); 150
proto_tree_add_item ( st_change_index_tree , hf_waveagent_ifethl2status , tvb , current_offset , 4 , ENC_BIG_ENDIAN ); 153
proto_tree_add_item ( st_change_index_tree , hf_waveagent_ifl3status , tvb , current_offset + 4 , 4 , ENC_BIG_ENDIAN ); 157
proto_tree_add_item ( st_change_index_tree , hf_waveagent_iflinkspeed , tvb , current_offset + 8 , 4 , ENC_BIG_ENDIAN ); 160
dissect_wlan_if_stats ( current_offset + 12 , st_change_index_tree , tvb ); 164
proto_tree_add_item ( st_change_index_tree , hf_waveagent_snap , tvb , current_offset + 108 , 8 , ENC_BIG_ENDIAN ); 167
proto_tree_add_item ( st_change_index_tree , hf_waveagent_ifiptype , tvb , current_offset + 116 , 2 , ENC_BIG_ENDIAN ); 170
if ( tvb_get_ntohs ( tvb , current_offset + 116 ) == IPV4_TYPE )  173
proto_tree_add_item ( st_change_index_tree , hf_waveagent_ifipv4 , tvb , current_offset + 124 , 4 , ENC_BIG_ENDIAN ); 174
proto_tree_add_item ( st_change_index_tree , hf_waveagent_ifipv6 , tvb , current_offset + 124 , 16 , ENC_NA ); 178
bssIndex = proto_tree_add_item ( parent_tree , hf_waveagent_scanssid , tvb , current_offset , 32 , ENC_ASCII | ENC_NA ); 242
bss_tree = proto_item_add_subtree ( bssIndex , ett_bss [ iLoop ] ); 245
tag_len = tvb_get_ntohl ( tvb , current_offset + 52 ); 247
if ( tag_len != 0 )  249
for (isr = 0; isr < tag_len; isr++) 253
proto_tree_add_string ( bss_tree , hf_waveagent_ifwlansupprates , tvb , offset + 36 + isr ,
1 ,
"BSS requires support for mandatory features of HT PHY (IEEE 802.11"
" - Clause 20)" ) 259
proto_tree_add_string ( bss_tree , hf_waveagent_ifwlansupprates , tvb , offset + 36 , tag_len , wmem_strbuf_get_str ( sb ) ); 273
proto_tree_add_item ( bss_tree , hf_waveagent_scanbssid , tvb , current_offset + 56 , 6 , ENC_NA ); 276
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlancapabilities , tvb , current_offset + 62 , 2 , ENC_BIG_ENDIAN ); 279
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanrssi , tvb , current_offset + 64 , 4 , ENC_BIG_ENDIAN ); 282
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlansigquality , tvb , current_offset + 68 , 4 , ENC_BIG_ENDIAN ); 287
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanchannel , tvb , current_offset + 72 , 4 , ENC_BIG_ENDIAN ); 290
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanprivacy , tvb , current_offset + 76 , 4 , ENC_BIG_ENDIAN ); 293
proto_tree_add_item ( bss_tree , hf_waveagent_ifwlanbssmode , tvb , current_offset + 80 , 4 , ENC_BIG_ENDIAN ); 296
proto_tree_add_item ( parent_tree , hf_waveagent_scanbssid , tvb , current_offset , 6 , ENC_NA ); 496
------------------------------
722 /home/SySeVR/data/CVE_2015_6249_PATCHED_dissect_wccp2r1_address_table_info.c wccp_wccp_address_table . table_ipv6 = ( struct e_in6_addr * ) wmem_alloc0 ( pinfo -> pool , wccp_wccp_address_table . table_length * sizeof ( struct e_in6_addr ) ) 50
static gint
CVE_2015_6249_PATCHED_dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset, int length,
packet_info *pinfo, proto_tree *info_tree) 3
gint16 family ; 7
guint16 table_length ; 8
if ( length < 2 * 4 )  15
family = tvb_get_ntohs ( tvb , offset ); 18
table_length = tvb_get_ntohl ( tvb , offset ); 26
if ( wccp_wccp_address_table . in_use == FALSE )  31
wccp_wccp_address_table . family = family; 32
wccp_wccp_address_table . table_length = table_length; 33
switch ( wccp_wccp_address_table . family )  36
if ( wccp_wccp_address_table . table_ipv6 == NULL )  49
wccp_wccp_address_table . table_ipv6 = ( struct e_in6_addr * ) wmem_alloc0 ( pinfo -> pool , wccp_wccp_address_table . table_length * sizeof ( struct e_in6_addr ) ); 50
expert_add_info_format ( pinfo , tf , & ei_wccp_address_table_family_unknown , "Unknown address family: %d" , wccp_wccp_address_table . family ); 60
if ( ( wccp_wccp_address_table . in_use == FALSE ) && ( wccp_wccp_address_table . table_ipv4 != NULL ) && ( ( address_length * i ) < wccp_wccp_address_table . table_length ) )  74
wccp_wccp_address_table . table_ipv4 [ i ] = tvb_get_ntohl ( tvb , offset ); 77
if ( ( wccp_wccp_address_table . in_use == FALSE ) && ( wccp_wccp_address_table . table_ipv6 != NULL ) && ( i < wccp_wccp_address_table . table_length ) )  82
tvb_get_ipv6 ( tvb , offset , & ( wccp_wccp_address_table . table_ipv6 [ i ] ) ); 85
addr = wmem_strdup_printf ( wmem_packet_scope ( ) , "unknown family %d" , wccp_wccp_address_table . family ); 88
pi = proto_tree_add_string_format_value ( element_tree , hf_address_table_element , tvb , offset , address_length , addr , "%d: %s" , i + 1 , addr ); 94
if ( i > wccp_wccp_address_table . table_length )  97
expert_add_info_format ( pinfo , pi , & ei_wccp_length_bad , "Ran out of space to store address" ); 98
wccp_wccp_address_table . in_use = TRUE; 103
------------------------------
723 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
unsigned pix_fmt_id ; 4
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
height *= 2; 122
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
s -> rgb = 0; 141
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
s -> upscale_v = 6; 299
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
for (i = 0; i < 4; i++) 343
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
724 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
unsigned pix_fmt_id ; 4
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
height *= 2; 122
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
s -> rgb = 0; 141
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
s -> upscale_v = 6; 299
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
for (i = 0; i < 4; i++) 343
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
if ( s -> progressive )  360
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
725 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , bits , ret ; 3
unsigned pix_fmt_id ; 4
int h_count [ MAX_COMPONENTS ] ; 5
int v_count [ MAX_COMPONENTS ] ; 6
s -> cur_scan = 0; 8
s -> upscale_h = s -> upscale_v = 0; 9
s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); 13
if ( bits > 16 || bits < 1 )  16
if ( s -> pegasus_rct )  21
bits = 9; 22
if ( bits == 9 && ! s -> pegasus_rct )  23
s -> rct = 1; 24
if ( s -> lossless && s -> avctx -> lowres )  26
height = get_bits ( & s -> gb , 16 ); 31
width = get_bits ( & s -> gb , 16 ); 32
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  38
height = s -> height; 39
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  42
nb_components = get_bits ( & s -> gb , 8 ); 45
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  46
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  49
if ( nb_components != s -> nb_components )  50
if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  56
s -> nb_components = nb_components; 62
s -> h_max = 1; 63
s -> v_max = 1; 64
memset ( h_count , 0 , sizeof ( h_count ) ); 65
memset ( v_count , 0 , sizeof ( v_count ) ); 66
for (i = 0; i < nb_components; i++) 67
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
if ( ! h_count [ i ] || ! v_count [ i ] )  82
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
height *= 2; 122
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
s -> rgb = 0; 141
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
s -> upscale_v = 6; 299
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
for (i = 0; i < 4; i++) 343
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
726 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 130
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 128
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 130
if ( codsty -> transform == FF_DWT97 )  148
------------------------------
727 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 129
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 128
Jpeg2000Component * comp = tile -> comp + compno ; 129
float * datap = comp -> f_data ; 131
int32_t * i_datap = comp -> i_data ; 132
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
datap ++; 155
dst += pixelsize; 156
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
i_datap ++; 165
dst += pixelsize; 166
------------------------------
728 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 81
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 81
if ( codsty -> transform == FF_DWT97 )  100
------------------------------
729 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 80
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
int x , y ; 6
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
int x , y ; 42
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
if ( s -> cdef [ 0 ] < 0 )  71
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
Jpeg2000Component * comp = tile -> comp + compno ; 80
float * datap = comp -> f_data ; 82
int32_t * i_datap = comp -> i_data ; 83
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 102
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 104
* dst = val << ( 8 - cbps ); 105
datap ++; 106
dst += pixelsize; 107
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 111
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 113
* dst = val << ( 8 - cbps ); 114
i_datap ++; 115
dst += pixelsize; 116
------------------------------
730 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 44
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
dequantization_float ( x , y , cblk , comp , & t1 , band ); 53
dequantization_int_97 ( x , y , cblk , comp , & t1 , band ); 55
dequantization_int ( x , y , cblk , comp , & t1 , band ); 57
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int cbps = s -> cbps [ compno ] ; 84
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 85
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
for (; x < w; x ++) 101
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 102
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 104
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
for (; x < w; x ++) 110
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 111
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 113
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
for (; x < w; x ++) 149
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
for (; x < w; x ++) 159
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
731 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000Prec * prec = band -> prec + precno ; 38
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
int nb_precincts , precno ; 25
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 44
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
dequantization_float ( x , y , cblk , comp , & t1 , band ); 53
dequantization_int_97 ( x , y , cblk , comp , & t1 , band ); 55
dequantization_int ( x , y , cblk , comp , & t1 , band ); 57
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int cbps = s -> cbps [ compno ] ; 84
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 85
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
for (; x < w; x ++) 101
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 102
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 104
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
for (; x < w; x ++) 110
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 111
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 113
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
for (; x < w; x ++) 149
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
for (; x < w; x ++) 159
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
732 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000Band * band = rlevel -> band + bandno ; 26
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 44
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
dequantization_float ( x , y , cblk , comp , & t1 , band ); 53
dequantization_int_97 ( x , y , cblk , comp , & t1 , band ); 55
dequantization_int ( x , y , cblk , comp , & t1 , band ); 57
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int cbps = s -> cbps [ compno ] ; 84
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 85
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
for (; x < w; x ++) 101
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 102
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 104
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
for (; x < w; x ++) 110
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 111
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 113
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
for (; x < w; x ++) 149
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
for (; x < w; x ++) 159
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
733 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 44
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
dequantization_float ( x , y , cblk , comp , & t1 , band ); 53
dequantization_int_97 ( x , y , cblk , comp , & t1 , band ); 55
dequantization_int ( x , y , cblk , comp , & t1 , band ); 57
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int cbps = s -> cbps [ compno ] ; 84
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 85
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
for (; x < w; x ++) 101
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 102
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 104
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
for (; x < w; x ++) 110
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 111
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 113
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
for (; x < w; x ++) 149
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
for (; x < w; x ++) 159
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
734 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 16
t1 . stride = ( 1 << codsty -> log2_cblk_width ) + 2; 18
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 21
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 44
if ( codsty -> transform == FF_DWT97 )  52
dequantization_float ( x , y , cblk , comp , & t1 , band ); 53
if ( codsty -> transform == FF_DWT97_INT )  54
dequantization_int_97 ( x , y , cblk , comp , & t1 , band ); 55
dequantization_int ( x , y , cblk , comp , & t1 , band ); 57
ff_dwt_decode ( & comp -> dwt , codsty -> transform == FF_DWT97 ? ( void * ) comp -> f_data : ( void * ) comp -> i_data ); 64
------------------------------
735 /home/SySeVR/data/CVE-2016-2213_VULN_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 15
static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 5
for (compno = 0; compno < s->ncomponents; compno++) 14
Jpeg2000Component * comp = tile -> comp + compno ; 15
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 22
for (bandno = 0; bandno < rlevel->nbands; bandno++) 24
Jpeg2000Band * band = rlevel -> band + bandno ; 26
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  31
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 35
for (precno = 0; precno < nb_precincts; precno++) 37
Jpeg2000Prec * prec = band -> prec + precno ; 38
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 41
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 43
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 44
x = cblk -> coord [ 0 ] [ 0 ] - band -> coord [ 0 ] [ 0 ]; 49
y = cblk -> coord [ 1 ] [ 0 ] - band -> coord [ 1 ] [ 0 ]; 50
dequantization_float ( x , y , cblk , comp , & t1 , band ); 53
dequantization_int_97 ( x , y , cblk , comp , & t1 , band ); 55
dequantization_int ( x , y , cblk , comp , & t1 , band ); 57
ff_dwt_decode ( & comp -> dwt , codsty -> transform == FF_DWT97 ? ( void * ) comp -> f_data : ( void * ) comp -> i_data ); 64
for (x = 0; x < s->ncomponents; x++) 72
s -> cdef [ x ] = x + 1; 73
if ( ( s -> ncomponents & 1 ) == 0 )  74
s -> cdef [ s -> ncomponents - 1 ] = 0; 75
if ( s -> precision <= 8 )  78
for (compno = 0; compno < s->ncomponents; compno++) 79
int cbps = s -> cbps [ compno ] ; 84
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 85
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 89
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 92
line = picture -> data [ plane ] + y * picture -> linesize [ plane ]; 93
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 94
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 97
dst = line + x * pixelsize + compno * ! planar; 98
for (; x < w; x ++) 101
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 102
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 104
* dst = val << ( 8 - cbps ); 105
dst += pixelsize; 107
for (; x < w; x ++) 110
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 111
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 113
* dst = val << ( 8 - cbps ); 114
dst += pixelsize; 116
line += picture -> linesize [ plane ]; 119
int precision = picture -> format == AV_PIX_FMT_XYZ12 || picture -> format == AV_PIX_FMT_RGB48 || picture -> format == AV_PIX_FMT_RGBA64 || picture -> format == AV_PIX_FMT_GRAY16 ? 16 : s -> precision ; 123
for (compno = 0; compno < s->ncomponents; compno++) 128
int cbps = s -> cbps [ compno ] ; 134
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 135
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 139
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y / s -> cdy [ compno ]; 141
linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ); 142
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y ++) 143
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x / s -> cdx [ compno ]; 146
dst = linel + ( x * pixelsize + compno * ! planar ); 147
for (; x < w; x ++) 149
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 150
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 152
* dst = val << ( precision - cbps ); 154
dst += pixelsize; 156
for (; x < w; x ++) 159
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 160
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 162
* dst = val << ( precision - cbps ); 164
dst += pixelsize; 166
linel += picture -> linesize [ plane ] >> 1; 169
------------------------------
736 /home/SySeVR/data/CVE-2016-2327_VULN_apng_encode_frame.c size_t row_start = s -> last_frame -> linesize [ 0 ] * y + bpp * last_fctl_chunk . x_offset ; 66
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) 2
PNGEncContext * s = avctx -> priv_data ; 4
int ret ; 5
unsigned int y ; 6
AVFrame * diffFrame ; 7
uint8_t bpp = ( s -> bits_per_pixel + 7 ) >> 3 ; 8
uint8_t * original_bytestream , * original_bytestream_end ; 9
uint8_t * best_bytestream ; 12
size_t best_bytestream_size = SIZE_MAX ; 13
APNGFctlChunk last_fctl_chunk = * best_last_fctl_chunk ; 14
APNGFctlChunk fctl_chunk = * best_fctl_chunk ; 15
if ( avctx -> frame_number == 0 )  17
diffFrame = av_frame_alloc ( ); 26
if ( ! diffFrame )  27
diffFrame -> format = pict -> format; 30
diffFrame -> width = pict -> width; 31
diffFrame -> height = pict -> height; 32
if ( ( ret = av_frame_get_buffer ( diffFrame , 32 ) ) < 0 )  33
original_bytestream = s -> bytestream; 36
original_bytestream_end = s -> bytestream_end; 37
temp_bytestream = av_malloc ( original_bytestream_end - original_bytestream ); 39
temp_bytestream_end = temp_bytestream + ( original_bytestream_end - original_bytestream ); 40
if ( ! temp_bytestream )  41
for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) 46
for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) 51
uint32_t original_sequence_number = s -> sequence_number , sequence_number ; 55
uint8_t * bytestream_start = s -> bytestream ; 56
size_t bytestream_size ; 57
if ( last_fctl_chunk . dispose_op != APNG_DISPOSE_OP_PREVIOUS )  60
if ( last_fctl_chunk . dispose_op == APNG_DISPOSE_OP_BACKGROUND )  64
for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) 65
size_t row_start = s -> last_frame -> linesize [ 0 ] * y + bpp * last_fctl_chunk . x_offset ; 66
memset ( diffFrame -> data [ 0 ] + row_start , 0 , bpp * last_fctl_chunk . width ); 67
if ( ! s -> prev_frame )  71
memcpy ( diffFrame -> data [ 0 ] , s -> prev_frame -> data [ 0 ] , s -> prev_frame -> linesize [ 0 ] * s -> prev_frame -> height ); 74
if ( apng_do_inverse_blend ( diffFrame , pict , & fctl_chunk , bpp ) < 0 )  79
ret = encode_frame ( avctx , diffFrame ); 83
s -> sequence_number = original_sequence_number; 85
bytestream_size = s -> bytestream - bytestream_start; 86
s -> bytestream = bytestream_start; 87
if ( ret < 0 )  88
if ( bytestream_size < best_bytestream_size )  91
best_bytestream = s -> bytestream; 96
best_bytestream_size = bytestream_size; 97
if ( best_bytestream == original_bytestream )  99
s -> bytestream = temp_bytestream; 100
s -> bytestream_end = temp_bytestream_end; 101
s -> bytestream = original_bytestream; 103
s -> bytestream_end = original_bytestream_end; 104
------------------------------
737 /home/SySeVR/data/CVE-2016-2522_VULN_dissect_ber_constrained_bitstring.c guint8 bits_in_pad = tvb_get_guint8 ( tvb , offset + len - 1 ) & ( 0xFF >> ( 8 - pad ) ) ; 139
dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb) 1
gint8 ber_class ; 3
gboolean pc , ind ; 4
gint32 tag ; 5
guint32 len , byteno ; 6
guint8 pad = 0 , b0 , b1 , val , * bitstring ; 7
if ( ! implicit_tag )  17
offset = dissect_ber_identifier ( actx -> pinfo , parent_tree , tvb , offset , & ber_class , & pc , & tag ); 20
offset = dissect_ber_length ( actx -> pinfo , parent_tree , tvb , offset , & len , & ind ); 21
if ( ! implicit_tag && ( ber_class != BER_CLASS_APP ) )  32
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_BITSTRING ) )  33
pc = 0; 51
len = tvb_reported_length_remaining ( tvb , offset ); 52
if ( pc )  58
pad = tvb_get_guint8 ( tvb , offset ); 63
offset ++; 76
len --; 77
if ( ( pad > 0 ) && ( pad < 8 ) && ( len > 0 ) )  138
guint8 bits_in_pad = tvb_get_guint8 ( tvb , offset + len - 1 ) & ( 0xFF >> ( 8 - pad ) ) ; 139
if ( bits_in_pad )  140
expert_add_info_format ( actx -> pinfo , item , & ei_ber_bits_set_padded , "Bits set in padded area: 0x%02x" , bits_in_pad ); 141
------------------------------
738 /home/SySeVR/data/CVE_2006_5751_VULN_get_fdb_entries.c size_t size = maxnum * sizeof ( struct __fdb_entry ) ; 6
static int CVE_2006_5751_VULN_get_fdb_entries(struct net_bridge *br, void __user *userbuf,
unsigned long maxnum, unsigned long offset) 2
size_t size = maxnum * sizeof ( struct __fdb_entry ) ; 6
if ( size > PAGE_SIZE )  8
buf = kmalloc ( size , GFP_USER ); 13
if ( ! buf )  14
num = br_fdb_fillbuf ( br , buf , maxnum , offset ); 17
if ( num > 0 )  18
if ( copy_to_user ( userbuf , buf , num * sizeof ( struct __fdb_entry ) ) )  19
kfree ( buf ); 22
return num ; 24
------------------------------
739 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
mPos ++; 118
aCount --; 118
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
mPos += toCopy; 129
aCount -= toCopy; 131
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )  145
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 146
if ( rowSize % 4 )  147
rowSize += ( 4 - ( rowSize % 4 ) ); 148
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
while ( aCount > 0 )  231
------------------------------
740 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
aCount -= toCopy; 32
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
if ( mBIH . compression == BI_BITFIELDS && mPos == WIN_HEADER_LENGTH + BITFIELD_LENGTH )  133
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
while ( aCount > 0 )  231
while ( aCount > 0 )  258
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
while ( mStateData > 0 )  284
SetPixel ( mDecoding , byte , mColors ); 285
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
switch ( byte )  298
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mDecoding += byte * GFXBYTESPERPIXEL; 356
byte = * aBuffer ++; 363
aCount --; 364
if ( byte == 0 )  366
rv = WriteRLERows ( PR_MIN ( byte , mCurLine ) ); 369
NS_ENSURE_SUCCESS ( rv , rv ); 370
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
SetPixel ( mDecoding , byte , mColors ); 383
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
------------------------------
741 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint8 colorNum = colorBytes / bpc ; 100
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
PRUint32 colorBytes = mPos - mLOH ; 99
PRUint8 colorNum = colorBytes / bpc ; 100
mColors [ colorNum ] . blue = * aBuffer; 105
mColors [ colorNum ] . green = * aBuffer; 108
mColors [ colorNum ] . red = * aBuffer; 111
colorNum ++; 112
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
SetPixel ( mDecoding , byte , mColors ); 285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
SetPixel ( mDecoding , byte , mColors ); 383
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
------------------------------
742 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint32 colorBytes = mPos - mLOH ; 99
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
aCount -= toCopy; 14
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
mPos += toCopy; 31
if ( mPos == mLOH )  35
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )  40
if ( mBIH . bpp <= 8 )  44
mNumColors = 1 << mBIH . bpp; 45
if ( mBIH . colors && mBIH . colors < mNumColors )  46
mNumColors = mBIH . colors; 47
mColors = new colorTable [ 256 ]; 51
if ( ! mColors )  52
memset ( mColors , 0 , 256 * sizeof ( colorTable ) ); 55
if ( mBIH . width < 0 )  65
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ]; 75
if ( ! mRow )  79
PRUint8 bpc ; 95
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4; 96
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
PRUint32 colorBytes = mPos - mLOH ; 99
PRUint8 colorNum = colorBytes / bpc ; 100
PRUint8 at = colorBytes % bpc ; 101
switch ( at )  103
mColors [ colorNum ] . blue = * aBuffer; 105
mColors [ colorNum ] . green = * aBuffer; 108
mColors [ colorNum ] . red = * aBuffer; 111
colorNum ++; 112
at = ( at + 1 ) % bpc; 119
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
SetPixel ( mDecoding , byte , mColors ); 285
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
SetPixel ( mDecoding , byte , mColors ); 383
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
------------------------------
743 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint32 toCopy = mLOH - mPos ; 27
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
toCopy = aCount; 11
mPos += toCopy; 13
if ( mPos == BFH_LENGTH )  17
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )  21
if ( mBFH . bihsize == OS2_BIH_LENGTH )  23
mLOH = OS2_HEADER_LENGTH; 24
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
PRUint32 colorBytes = mPos - mLOH ; 99
PRUint8 colorNum = colorBytes / bpc ; 100
PRUint8 at = colorBytes % bpc ; 101
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
switch ( at )  103
mColors [ colorNum ] . blue = * aBuffer; 105
mColors [ colorNum ] . green = * aBuffer; 108
mColors [ colorNum ] . red = * aBuffer; 111
colorNum ++; 112
mPos ++; 118
aBuffer ++; 118
aCount --; 118
at = ( at + 1 ) % bpc; 119
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
if ( mBIH . compression == BI_BITFIELDS && mPos == WIN_HEADER_LENGTH + BITFIELD_LENGTH )  133
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
while ( aCount > 0 )  231
while ( aCount > 0 )  258
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
while ( mStateData > 0 )  284
SetPixel ( mDecoding , byte , mColors ); 285
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
switch ( byte )  298
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mDecoding += byte * GFXBYTESPERPIXEL; 356
byte = * aBuffer ++; 363
aCount --; 364
if ( byte == 0 )  366
rv = WriteRLERows ( PR_MIN ( byte , mCurLine ) ); 369
NS_ENSURE_SUCCESS ( rv , rv ); 370
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
SetPixel ( mDecoding , byte , mColors ); 383
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
------------------------------
744 /home/SySeVR/data/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint32 toCopy = BFH_LENGTH - mPos ; 9
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount) 1
if ( ! aCount || ! mCurLine )  4
if ( mPos < BFH_LENGTH )  8
PRUint32 toCopy = BFH_LENGTH - mPos ; 9
if ( toCopy > aCount )  10
memcpy ( mRawBuf + mPos , aBuffer , toCopy ); 12
mPos += toCopy; 13
aCount -= toCopy; 14
aBuffer += toCopy; 15
if ( mPos == BFH_LENGTH )  17
if ( mPos >= BFH_LENGTH && mPos < mLOH )  26
PRUint32 toCopy = mLOH - mPos ; 27
if ( toCopy > aCount )  28
toCopy = aCount; 29
memcpy ( mRawBuf + ( mPos - BFH_LENGTH ) , aBuffer , toCopy ); 30
mPos += toCopy; 31
aCount -= toCopy; 32
aBuffer += toCopy; 33
if ( mPos == mLOH )  35
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )  97
PRUint32 colorBytes = mPos - mLOH ; 99
PRUint8 colorNum = colorBytes / bpc ; 100
PRUint8 at = colorBytes % bpc ; 101
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )  102
switch ( at )  103
mColors [ colorNum ] . blue = * aBuffer; 105
mColors [ colorNum ] . green = * aBuffer; 108
mColors [ colorNum ] . red = * aBuffer; 111
colorNum ++; 112
mPos ++; 118
aBuffer ++; 118
aCount --; 118
at = ( at + 1 ) % bpc; 119
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )  122
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ; 125
if ( toCopy > aCount )  126
toCopy = aCount; 127
memcpy ( mRawBuf + ( mPos - WIN_HEADER_LENGTH ) , aBuffer , toCopy ); 128
mPos += toCopy; 129
aBuffer += toCopy; 130
aCount -= toCopy; 131
if ( mBIH . compression == BI_BITFIELDS && mPos == WIN_HEADER_LENGTH + BITFIELD_LENGTH )  133
mBitFields . red = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) mRawBuf ); 134
mBitFields . green = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 4 ) ); 135
mBitFields . blue = LITTLE_TO_NATIVE32 ( * ( PRUint32 * ) ( mRawBuf + 8 ) ); 136
while ( aCount && ( mPos < mBFH . dataoffset ) )  139
mPos ++; 140
aBuffer ++; 140
aCount --; 140
if ( aCount && ++ mPos >= mBFH . dataoffset )  142
toCopy = rowSize - mRowBytes; 151
if ( toCopy )  152
if ( toCopy > aCount )  153
toCopy = aCount; 154
memcpy ( mRow + mRowBytes , aBuffer , toCopy ); 155
aCount -= toCopy; 156
aBuffer += toCopy; 157
mRowBytes += toCopy; 158
if ( ( rowSize - mRowBytes ) == 0 )  160
PRUint8 * p = mRow ; 167
idx = ( * p >> bit ) & 1; 176
SetPixel ( d , idx , mColors ); 177
Set4BitPixel ( d , * p , lpos , mColors ); 185
SetPixel ( d , * p , mColors ); 191
PRUint16 val = LITTLE_TO_NATIVE16 ( * ( PRUint16 * ) p ) ; 198
SetPixel ( d , ( val & mBitFields . red ) >> mBitFields . redRightShift << mBitFields . redLeftShift , ( val & mBitFields . green ) >> mBitFields . greenRightShift << mBitFields . greenLeftShift , ( val & mBitFields . blue ) >> mBitFields . blueRightShift << mBitFields . blueLeftShift ); 199
p += 2; 204
SetPixel ( d , p [ 2 ] , p [ 1 ] , p [ 0 ] ); 210
p += 2; 211
p ++; 214
while ( aCount > 0 )  231
while ( aCount > 0 )  258
mStateData = ( PRUint8 ) * aBuffer ++; 263
aCount --; 264
byte = * aBuffer ++; 270
aCount --; 271
if ( mStateData != RLE_ESCAPE )  272
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  279
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr ); 280
memset ( mAlphaPtr , 0xFF , mStateData ); 281
mAlphaPtr += mStateData; 282
while ( mStateData > 0 )  284
SetPixel ( mDecoding , byte , mColors ); 285
mStateData --; 286
while ( mStateData > 0 )  289
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 290
switch ( byte )  298
mStateData = byte; 321
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  322
mStateData -= mBIH . width & 1; 325
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )  326
memset ( mAlphaPtr , 0xFF , mStateData ); 329
mAlphaPtr += mStateData; 330
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )  341
byte = * aBuffer ++; 351
aCount --; 352
mAlphaPtr += byte; 353
if ( mAlphaPtr > mAlpha + mBIH . width )  354
mDecoding += byte * GFXBYTESPERPIXEL; 356
byte = * aBuffer ++; 363
aCount --; 364
if ( byte == 0 )  366
rv = WriteRLERows ( PR_MIN ( byte , mCurLine ) ); 369
NS_ENSURE_SUCCESS ( rv , rv ); 370
while ( aCount > 0 && mStateData > 0 )  380
byte = * aBuffer ++; 381
aCount --; 382
SetPixel ( mDecoding , byte , mColors ); 383
mStateData --; 384
while ( aCount > 0 && mStateData > 0 )  387
byte = * aBuffer ++; 388
aCount --; 389
Set4BitPixel ( mDecoding , byte , mStateData , mColors ); 390
if ( mStateData == 0 )  394
if ( aCount > 0 )  400
aBuffer ++; 403
aCount --; 404
------------------------------
745 /home/SySeVR/data/CVE_2009_0946_VULN_ft_smooth_render_generic.c FT_Vector * points_end = points + outline -> n_points ; 145
static FT_Error
CVE_2009_0946_VULN_ft_smooth_render_generic( FT_Renderer       render,
FT_GlyphSlot      slot,
FT_Render_Mode    mode,
const FT_Vector*  origin,
FT_Render_Mode    required_mode ) 6
FT_BBox cbox ; 10
FT_UInt width , height , height_org , width_org , pitch ; 11
FT_Bitmap * bitmap ; 12
FT_Int hmul = mode == FT_RENDER_MODE_LCD ; 14
FT_Int vmul = mode == FT_RENDER_MODE_LCD_V ; 15
if ( slot -> format != render -> glyph_format )  22
if ( mode != required_mode )  29
outline = & slot -> outline; 32
cbox . xMin = FT_PIX_FLOOR ( cbox . xMin ); 41
cbox . yMin = FT_PIX_FLOOR ( cbox . yMin ); 42
cbox . xMax = FT_PIX_CEIL ( cbox . xMax ); 43
cbox . yMax = FT_PIX_CEIL ( cbox . yMax ); 44
width = ( FT_UInt ) ( ( cbox . xMax - cbox . xMin ) >> 6 ); 46
height = ( FT_UInt ) ( ( cbox . yMax - cbox . yMin ) >> 6 ); 47
bitmap = & slot -> bitmap; 48
if ( slot -> internal -> flags & FT_GLYPH_OWN_BITMAP )  55
slot -> internal -> flags &= ~FT_GLYPH_OWN_BITMAP; 58
pitch = width; 62
if ( hmul )  63
width = width * 3; 65
pitch = FT_PAD_CEIL ( width , 4 ); 66
if ( vmul )  69
height *= 3; 70
if ( slot -> library -> lcd_filter_func )  79
FT_Int extra = slot -> library -> lcd_extra ; 81
if ( hmul )  84
width += 3 * extra; 87
pitch = FT_PAD_CEIL ( width , 4 ); 88
if ( vmul )  92
height += 3 * extra; 95
bitmap -> pixel_mode = FT_PIXEL_MODE_GRAY; 102
bitmap -> num_grays = 256; 103
bitmap -> width = width; 104
bitmap -> rows = height; 105
bitmap -> pitch = pitch; 106
if ( FT_ALLOC ( bitmap -> buffer , ( FT_ULong ) pitch * height ) )  111
FT_Vector * points = outline -> points ; 144
FT_Vector * points_end = points + outline -> n_points ; 145
for ( vec = points; vec < points_end; vec++ ) 150
for ( vec = points; vec < points_end; vec++ ) 154
------------------------------
746 /home/SySeVR/data/CVE_2009_0946_VULN_ft_smooth_render_generic.c FT_Vector * points_end = points + outline -> n_points ; 126
static FT_Error
CVE_2009_0946_VULN_ft_smooth_render_generic( FT_Renderer       render,
FT_GlyphSlot      slot,
FT_Render_Mode    mode,
const FT_Vector*  origin,
FT_Render_Mode    required_mode ) 6
FT_BBox cbox ; 10
FT_UInt width , height , height_org , width_org , pitch ; 11
FT_Bitmap * bitmap ; 12
FT_Int hmul = mode == FT_RENDER_MODE_LCD ; 14
FT_Int vmul = mode == FT_RENDER_MODE_LCD_V ; 15
if ( slot -> format != render -> glyph_format )  22
if ( mode != required_mode )  29
outline = & slot -> outline; 32
cbox . xMin = FT_PIX_FLOOR ( cbox . xMin ); 41
cbox . yMin = FT_PIX_FLOOR ( cbox . yMin ); 42
cbox . xMax = FT_PIX_CEIL ( cbox . xMax ); 43
cbox . yMax = FT_PIX_CEIL ( cbox . yMax ); 44
width = ( FT_UInt ) ( ( cbox . xMax - cbox . xMin ) >> 6 ); 46
height = ( FT_UInt ) ( ( cbox . yMax - cbox . yMin ) >> 6 ); 47
bitmap = & slot -> bitmap; 48
if ( slot -> internal -> flags & FT_GLYPH_OWN_BITMAP )  55
slot -> internal -> flags &= ~FT_GLYPH_OWN_BITMAP; 58
pitch = width; 62
if ( hmul )  63
width = width * 3; 65
pitch = FT_PAD_CEIL ( width , 4 ); 66
if ( vmul )  69
height *= 3; 70
if ( slot -> library -> lcd_filter_func )  79
FT_Int extra = slot -> library -> lcd_extra ; 81
if ( hmul )  84
width += 3 * extra; 87
pitch = FT_PAD_CEIL ( width , 4 ); 88
if ( vmul )  92
height += 3 * extra; 95
bitmap -> pixel_mode = FT_PIXEL_MODE_GRAY; 102
bitmap -> num_grays = 256; 103
bitmap -> width = width; 104
bitmap -> rows = height; 105
bitmap -> pitch = pitch; 106
if ( FT_ALLOC ( bitmap -> buffer , ( FT_ULong ) pitch * height ) )  111
FT_Vector * points = outline -> points ; 125
FT_Vector * points_end = points + outline -> n_points ; 126
for ( vec = points; vec < points_end; vec++ ) 131
for ( vec = points; vec < points_end; vec++ ) 135
------------------------------
747 /home/SySeVR/data/CVE_2009_1385_PATCHED_e1000_clean_rx_irq.c struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 90
static bool CVE_2009_1385_PATCHED_e1000_clean_rx_irq(struct e1000_adapter *adapter,
struct e1000_rx_ring *rx_ring,
int *work_done, int work_to_do) 3
struct e1000_hw * hw = & adapter -> hw ; 5
struct net_device * netdev = adapter -> netdev ; 6
struct e1000_rx_desc * rx_desc , * next_rxd ; 8
struct e1000_buffer * buffer_info , * next_buffer ; 9
u32 length ; 11
u8 last_byte ; 12
unsigned int i ; 13
i = rx_ring -> next_to_clean; 18
rx_desc = E1000_RX_DESC ( * rx_ring , i ); 19
buffer_info = & rx_ring -> buffer_info [ i ]; 20
while ( rx_desc -> status & E1000_RXD_STAT_DD )  22
struct sk_buff * skb ; 23
u8 status ; 24
if ( * work_done >= work_to_do )  26
( * work_done ) ++; 28
status = rx_desc -> status; 30
skb = buffer_info -> skb; 31
buffer_info -> skb = NULL; 32
prefetch ( skb -> data - NET_IP_ALIGN ); 34
if ( ++ i == rx_ring -> count )  36
i = 0; 36
next_rxd = E1000_RX_DESC ( * rx_ring , i ); 37
next_buffer = & rx_ring -> buffer_info [ i ]; 40
length = le16_to_cpu ( rx_desc -> length ); 49
if ( unlikely ( ! ( status & E1000_RXD_STAT_EOP ) || ( length <= 4 ) ) )  52
buffer_info -> skb = skb; 57
if ( unlikely ( rx_desc -> errors & E1000_RXD_ERR_FRAME_ERR_MASK ) )  61
last_byte = * ( skb -> data + length - 1 ); 62
if ( TBI_ACCEPT ( hw , status , rx_desc -> errors , length , last_byte ) )  63
e1000_tbi_adjust_stats ( hw , & adapter -> stats , length , skb -> data ); 66
length --; 70
buffer_info -> skb = skb; 73
length -= 4; 80
if ( length < copybreak )  89
struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 90
if ( new_skb )  92
skb_reserve ( new_skb , NET_IP_ALIGN ); 93
skb_copy_to_linear_data_offset ( new_skb , - NET_IP_ALIGN , ( skb -> data - NET_IP_ALIGN ) , ( length + NET_IP_ALIGN ) ); 94
buffer_info -> skb = skb; 101
skb = new_skb; 102
skb_put ( skb , length ); 107
e1000_rx_checksum ( adapter , ( u32 ) ( status ) | ( ( u32 ) ( rx_desc -> errors ) << 24 ) , le16_to_cpu ( rx_desc -> csum ) , skb ); 110
skb -> protocol = eth_type_trans ( skb , netdev ); 115
vlan_hwaccel_receive_skb ( skb , adapter -> vlgrp , le16_to_cpu ( rx_desc -> special ) ); 119
netif_receive_skb ( skb ); 122
rx_desc -> status = 0; 126
rx_desc = next_rxd; 135
buffer_info = next_buffer; 136
------------------------------
748 /home/SySeVR/data/CVE_2009_1385_VULN_e1000_clean_rx_irq.c struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 89
static bool CVE_2009_1385_VULN_e1000_clean_rx_irq(struct e1000_adapter *adapter,
struct e1000_rx_ring *rx_ring,
int *work_done, int work_to_do) 3
struct e1000_hw * hw = & adapter -> hw ; 5
struct net_device * netdev = adapter -> netdev ; 6
struct e1000_rx_desc * rx_desc , * next_rxd ; 8
struct e1000_buffer * buffer_info , * next_buffer ; 9
u32 length ; 11
u8 last_byte ; 12
unsigned int i ; 13
i = rx_ring -> next_to_clean; 18
rx_desc = E1000_RX_DESC ( * rx_ring , i ); 19
buffer_info = & rx_ring -> buffer_info [ i ]; 20
while ( rx_desc -> status & E1000_RXD_STAT_DD )  22
struct sk_buff * skb ; 23
u8 status ; 24
if ( * work_done >= work_to_do )  26
( * work_done ) ++; 28
status = rx_desc -> status; 30
skb = buffer_info -> skb; 31
buffer_info -> skb = NULL; 32
prefetch ( skb -> data - NET_IP_ALIGN ); 34
if ( ++ i == rx_ring -> count )  36
i = 0; 36
next_rxd = E1000_RX_DESC ( * rx_ring , i ); 37
next_buffer = & rx_ring -> buffer_info [ i ]; 40
length = le16_to_cpu ( rx_desc -> length ); 49
if ( unlikely ( ! ( status & E1000_RXD_STAT_EOP ) ) )  51
buffer_info -> skb = skb; 56
if ( unlikely ( rx_desc -> errors & E1000_RXD_ERR_FRAME_ERR_MASK ) )  60
last_byte = * ( skb -> data + length - 1 ); 61
if ( TBI_ACCEPT ( hw , status , rx_desc -> errors , length , last_byte ) )  62
e1000_tbi_adjust_stats ( hw , & adapter -> stats , length , skb -> data ); 65
length --; 69
buffer_info -> skb = skb; 72
length -= 4; 79
if ( length < copybreak )  88
struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 89
if ( new_skb )  91
skb_reserve ( new_skb , NET_IP_ALIGN ); 92
skb_copy_to_linear_data_offset ( new_skb , - NET_IP_ALIGN , ( skb -> data - NET_IP_ALIGN ) , ( length + NET_IP_ALIGN ) ); 93
buffer_info -> skb = skb; 100
skb = new_skb; 101
skb_put ( skb , length ); 106
e1000_rx_checksum ( adapter , ( u32 ) ( status ) | ( ( u32 ) ( rx_desc -> errors ) << 24 ) , le16_to_cpu ( rx_desc -> csum ) , skb ); 109
skb -> protocol = eth_type_trans ( skb , netdev ); 114
vlan_hwaccel_receive_skb ( skb , adapter -> vlgrp , le16_to_cpu ( rx_desc -> special ) ); 118
netif_receive_skb ( skb ); 121
rx_desc -> status = 0; 125
rx_desc = next_rxd; 134
buffer_info = next_buffer; 135
------------------------------
749 /home/SySeVR/data/CVE_2009_4410_PATCHED_fuse_ioctl_copy_user.c size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; 21
static int CVE_2009_4410_PATCHED_fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,
unsigned int nr_segs, size_t bytes, bool to_user) 2
struct iov_iter ii ; 4
int page_idx = 0 ; 5
if ( ! bytes )  7
while ( iov_iter_count ( & ii ) )  12
struct page * page = pages [ page_idx ++ ] ; 13
size_t todo = min_t ( size_t , PAGE_SIZE , iov_iter_count ( & ii ) ) ; 14
void * kaddr , * map ; 15
kaddr = map = kmap ( page ); 17
while ( todo )  19
char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; 20
size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; 21
size_t copy = min ( todo , iov_len ) ; 22
size_t left ; 23
if ( ! to_user )  25
left = copy_from_user ( kaddr , uaddr , copy ); 26
left = copy_to_user ( uaddr , kaddr , copy ); 28
if ( unlikely ( left ) )  30
iov_iter_advance ( & ii , copy ); 33
todo -= copy; 34
kaddr += copy; 35
------------------------------
750 /home/SySeVR/data/CVE_2009_4410_PATCHED_fuse_ioctl_copy_user.c char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; 20
static int CVE_2009_4410_PATCHED_fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,
unsigned int nr_segs, size_t bytes, bool to_user) 2
struct iov_iter ii ; 4
int page_idx = 0 ; 5
if ( ! bytes )  7
while ( iov_iter_count ( & ii ) )  12
struct page * page = pages [ page_idx ++ ] ; 13
size_t todo = min_t ( size_t , PAGE_SIZE , iov_iter_count ( & ii ) ) ; 14
void * kaddr , * map ; 15
kaddr = map = kmap ( page ); 17
while ( todo )  19
char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; 20
size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; 21
size_t copy = min ( todo , iov_len ) ; 22
size_t left ; 23
if ( ! to_user )  25
left = copy_from_user ( kaddr , uaddr , copy ); 26
left = copy_to_user ( uaddr , kaddr , copy ); 28
if ( unlikely ( left ) )  30
todo -= copy; 34
kaddr += copy; 35
------------------------------
751 /home/SySeVR/data/CVE_2009_4410_VULN_fuse_ioctl_copy_user.c size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; 21
static int CVE_2009_4410_VULN_fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,
unsigned int nr_segs, size_t bytes, bool to_user) 2
struct iov_iter ii ; 4
int page_idx = 0 ; 5
if ( ! bytes )  7
while ( iov_iter_count ( & ii ) )  12
struct page * page = pages [ page_idx ++ ] ; 13
size_t todo = min_t ( size_t , PAGE_SIZE , iov_iter_count ( & ii ) ) ; 14
void * kaddr , * map ; 15
kaddr = map = kmap ( page ); 17
while ( todo )  19
char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; 20
size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; 21
size_t copy = min ( todo , iov_len ) ; 22
size_t left ; 23
if ( ! to_user )  25
left = copy_from_user ( kaddr , uaddr , copy ); 26
left = copy_to_user ( uaddr , kaddr , copy ); 28
if ( unlikely ( left ) )  30
iov_iter_advance ( & ii , copy ); 33
todo -= copy; 34
kaddr += copy; 35
------------------------------
752 /home/SySeVR/data/CVE_2009_4410_VULN_fuse_ioctl_copy_user.c char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; 20
static int CVE_2009_4410_VULN_fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,
unsigned int nr_segs, size_t bytes, bool to_user) 2
struct iov_iter ii ; 4
int page_idx = 0 ; 5
if ( ! bytes )  7
while ( iov_iter_count ( & ii ) )  12
struct page * page = pages [ page_idx ++ ] ; 13
size_t todo = min_t ( size_t , PAGE_SIZE , iov_iter_count ( & ii ) ) ; 14
void * kaddr , * map ; 15
kaddr = map = kmap ( page ); 17
while ( todo )  19
char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; 20
size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; 21
size_t copy = min ( todo , iov_len ) ; 22
size_t left ; 23
if ( ! to_user )  25
left = copy_from_user ( kaddr , uaddr , copy ); 26
left = copy_to_user ( uaddr , kaddr , copy ); 28
if ( unlikely ( left ) )  30
todo -= copy; 34
kaddr += copy; 35
------------------------------
753 /home/SySeVR/data/CVE_2010_2498_PATCHED_psh_glyph_find_strong_points.c PSH_Point point = glyph -> points + first ; 44
static void
CVE_2010_2498_PATCHED_psh_glyph_find_strong_points( PSH_Glyph  glyph,
FT_Int     dimension ) 4
PSH_Hint_Table table = & glyph -> hint_tables [ dimension ] ; 9
PS_Mask mask = table -> hint_masks -> masks ; 10
FT_UInt num_masks = table -> hint_masks -> num_masks ; 11
if ( num_masks > 1 && glyph -> num_points > 0 )  25
first = mask -> end_point > glyph -> num_points ? glyph -> num_points : mask -> end_point; 28
mask ++; 31
for ( ; num_masks > 1; num_masks--, mask++ ) 32
FT_UInt next ; 34
FT_Int count ; 35
next = mask -> end_point > glyph -> num_points ? glyph -> num_points : mask -> end_point; 38
count = next - first; 41
if ( count > 0 )  42
PSH_Point point = glyph -> points + first ; 44
psh_hint_table_find_strong_points ( table , point , count , threshold , major_dir ); 49
first = next; 52
------------------------------
754 /home/SySeVR/data/CVE_2010_2500_PATCHED_gray_render_span.c unsigned char * q = p + spans -> x ; 31
static void
CVE_2010_2500_PATCHED_gray_render_span( int             y,
int             count,
const FT_Span*  spans,
PWorker         worker ) 5
unsigned char * p ; 7
FT_Bitmap * map = & worker -> target ; 8
p = ( unsigned char * ) map -> buffer - y * map -> pitch; 12
if ( map -> pitch >= 0 )  13
p += ( unsigned ) ( ( map -> rows - 1 ) * map -> pitch ); 14
for ( ; count > 0; count--, spans++ ) 16
unsigned char coverage = spans -> coverage ; 18
if ( coverage )  21
if ( spans -> len >= 8 )  27
unsigned char * q = p + spans -> x ; 31
* q ++ = ( unsigned char ) coverage; 36
* q ++ = ( unsigned char ) coverage; 37
* q ++ = ( unsigned char ) coverage; 38
* q ++ = ( unsigned char ) coverage; 39
* q ++ = ( unsigned char ) coverage; 40
* q ++ = ( unsigned char ) coverage; 41
* q = ( unsigned char ) coverage; 42
------------------------------
755 /home/SySeVR/data/CVE_2010_2500_VULN_gray_render_span.c unsigned char * q = p + spans -> x ; 31
static void
CVE_2010_2500_VULN_gray_render_span( int             y,
int             count,
const FT_Span*  spans,
PWorker         worker ) 5
unsigned char * p ; 7
FT_Bitmap * map = & worker -> target ; 8
p = ( unsigned char * ) map -> buffer - y * map -> pitch; 12
if ( map -> pitch >= 0 )  13
p += ( map -> rows - 1 ) * map -> pitch; 14
for ( ; count > 0; count--, spans++ ) 16
unsigned char coverage = spans -> coverage ; 18
if ( coverage )  21
if ( spans -> len >= 8 )  27
unsigned char * q = p + spans -> x ; 31
* q ++ = ( unsigned char ) coverage; 36
* q ++ = ( unsigned char ) coverage; 37
* q ++ = ( unsigned char ) coverage; 38
* q ++ = ( unsigned char ) coverage; 39
* q ++ = ( unsigned char ) coverage; 40
* q ++ = ( unsigned char ) coverage; 41
* q = ( unsigned char ) coverage; 42
------------------------------
756 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeScroll.c int dx = i_shifth + x ; 52
static int CVE_2011_0021_PATCHED_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
for( x = 0; x < CDG_SCREEN_WIDTH; x++ ) 50
int dx = i_shifth + x ; 52
if ( b_copy )  54
dy %= CDG_SCREEN_HEIGHT; 56
dx %= CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
757 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeScroll.c int dy = i_shiftv + y ; 49
static int CVE_2011_0021_PATCHED_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
dy %= CDG_SCREEN_HEIGHT; 56
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
758 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeTileBlock.c int index = ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ; 19
static int CVE_2011_0021_PATCHED_DecodeTileBlock( decoder_sys_t *p_cdg, const uint8_t *p_data, int doXor ) 1
int sx , sy ; 4
int x , y ; 5
sy = ( p_data [ 2 ] & 0x1f ) * 12; 10
sx = ( p_data [ 3 ] & 0x3f ) * 6; 11
for( y = 0; y < 12; y++ ) 13
for( x = 0; x < 6; x++ ) 15
int index = ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ; 19
if ( index >= CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT )  20
uint8_t * p = & p_cdg -> p_screen [ index ] ; 23
* p ^= p_color [ idx ]; 26
* p = p_color [ idx ]; 28
------------------------------
759 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c int dx = i_shifth + x ; 52
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
for( x = 0; x < CDG_SCREEN_WIDTH; x++ ) 50
int dx = i_shifth + x ; 52
if ( b_copy )  54
dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT; 56
dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
760 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c int dy = i_shiftv + y ; 49
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
int i_shifth ; 6
int i_shiftv ; 7
int x , y ; 8
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )  20
i_shifth = 6; 22
i_shifth = - 6; 23
i_shifth = 0; 25
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )  28
i_shiftv = 12; 30
i_shiftv = - 12; 31
i_shiftv = 0; 33
if ( i_shifth == 0 && i_shiftv == 0 )  37
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ ) 47
int dy = i_shiftv + y ; 49
dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT; 56
dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH; 57
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )  61
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
761 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeTileBlock.c uint8_t * p = & p_cdg -> p_screen [ ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ] ; 18
static int CVE_2011_0021_VULN_DecodeTileBlock( decoder_sys_t *p_cdg, const uint8_t *p_data, int doXor ) 1
int sx , sy ; 4
int x , y ; 5
sy = ( p_data [ 2 ] & 0x1f ) * 12; 10
sx = ( p_data [ 3 ] & 0x3f ) * 6; 11
for( y = 0; y < 12; y++ ) 13
for( x = 0; x < 6; x++ ) 15
uint8_t * p = & p_cdg -> p_screen [ ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ] ; 18
* p ^= p_color [ idx ]; 20
* p = p_color [ idx ]; 22
------------------------------
762 /home/SySeVR/data/CVE_2011_1010_VULN_mac_partition.c int pos = blk * secsize ; 36
int CVE_2011_1010_VULN_mac_partition(struct parsed_partitions *state) 1
unsigned char * data ; 5
int blk , blocks_in_map ; 6
unsigned secsize ; 7
struct CVE_2011_1010_VULN_mac_partition * part ; 12
struct mac_driver_desc * md ; 13
md = read_part_sector ( state , 0 , & sect ); 16
if ( ! md )  17
if ( be16_to_cpu ( md -> signature ) != MAC_DRIVER_MAGIC )  19
secsize = be16_to_cpu ( md -> block_size ); 23
data = read_part_sector ( state , secsize / 512 , & sect ); 25
if ( ! data )  26
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + secsize % 512 ); 28
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  29
blocks_in_map = be32_to_cpu ( part -> map_count ); 34
for (blk = 1; blk <= blocks_in_map; ++blk) 35
int pos = blk * secsize ; 36
data = read_part_sector ( state , pos / 512 , & sect ); 38
if ( ! data )  39
part = ( struct CVE_2011_1010_VULN_mac_partition * ) ( data + pos % 512 ); 41
if ( be16_to_cpu ( part -> signature ) != MAC_PARTITION_MAGIC )  42
put_partition ( state , slot , be32_to_cpu ( part -> start_block ) * ( secsize / 512 ) , be32_to_cpu ( part -> block_count ) * ( secsize / 512 ) ); 44
if ( ! strnicmp ( part -> type , "Linux_RAID" , 10 ) )  48
mac_fix_string ( part -> processor , 16 ); 58
mac_fix_string ( part -> name , 32 ); 59
mac_fix_string ( part -> type , 32 ); 60
if ( ( be32_to_cpu ( part -> status ) & MAC_STATUS_BOOTABLE ) && strcasecmp ( part -> processor , "powerpc" ) == 0 )  62
if ( strcasecmp ( part -> type , "Apple_UNIX_SVR2" ) == 0 || ( strnicmp ( part -> type , "Linux" , 5 ) == 0 && strcasecmp ( part -> type , "Linux_swap" ) != 0 ) )  66
l = strlen ( part -> name ); 72
if ( strcmp ( part -> name , "/" ) == 0 )  73
for (i = 0; i <= l - 4; ++i) 75
if ( strnicmp ( part -> name + i , "root" , 4 ) == 0 )  76
if ( strnicmp ( part -> name , "swap" , 4 ) == 0 )  82
------------------------------
763 /home/SySeVR/data/CVE_2011_1746_PATCHED_agp_create_user_memory.c unsigned long alloc_size = num_agp_pages * sizeof ( struct page * ) ; 4
static struct agp_memory *CVE_2011_1746_PATCHED_agp_create_user_memory(unsigned long num_agp_pages) 1
unsigned long alloc_size = num_agp_pages * sizeof ( struct page * ) ; 4
------------------------------
764 /home/SySeVR/data/CVE_2011_1747_PATCHED_agp_create_user_memory.c unsigned long alloc_size = num_agp_pages * sizeof ( struct page * ) ; 4
static struct agp_memory *CVE_2011_1747_PATCHED_agp_create_user_memory(unsigned long num_agp_pages) 1
unsigned long alloc_size = num_agp_pages * sizeof ( struct page * ) ; 4
------------------------------
765 /home/SySeVR/data/CVE_2011_2174_PATCHED_tvb_uncompress.c guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ; 77
tvbuff_t *
CVE_2011_2174_PATCHED_tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen) 2
guint bytes_out = 0 ; 5
guint8 * uncompr = NULL ; 7
gint wbits = MAX_WBITS ; 12
if ( tvb == NULL )  20
compr = tvb_memdup ( tvb , offset , comprlen ); 24
if ( ! compr )  26
bufsiz = tvb_length_remaining ( tvb , offset ) * 2; 33
bufsiz = CLAMP ( bufsiz , TVB_Z_MIN_BUFSIZ , TVB_Z_MAX_BUFSIZ ); 34
next = compr; 40
strm = g_new0 ( z_stream , 1 ); 42
strm -> next_in = next; 43
strm -> avail_in = comprlen; 44
strmbuf = g_malloc0 ( bufsiz ); 46
strm -> next_out = strmbuf; 47
strm -> avail_out = bufsiz; 48
err = inflateInit2 ( strm , wbits ); 50
inits_done = 1; 51
if ( err != Z_OK )  52
while ( 1 )  60
memset ( strmbuf , '\0' , bufsiz ); 61
strm -> next_out = strmbuf; 62
strm -> avail_out = bufsiz; 63
err = inflate ( strm , Z_SYNC_FLUSH ); 65
if ( err == Z_OK || err == Z_STREAM_END )  67
guint bytes_pass = bufsiz - strm -> avail_out ; 68
if ( uncompr == NULL )  74
uncompr = g_memdup ( strmbuf , bytes_pass ); 75
guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ; 77
g_memmove ( new_data , uncompr , bytes_out ); 79
g_memmove ( ( new_data + bytes_out ) , strmbuf , bytes_pass ); 80
g_free ( uncompr ); 83
uncompr = new_data; 84
bytes_out += bytes_pass; 87
if ( err == Z_STREAM_END )  89
if ( err == Z_BUF_ERROR )  95
if ( uncompr != NULL )  105
if ( err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && ( * compr == 0x1f ) && ( * ( compr + 1 ) == 0x8b ) )  112
Bytef * c = compr + 2 ; 129
if ( * c == Z_DEFLATED )  132
c ++; 133
flags = * c; 142
c += 7; 145
if ( flags & ( 1 << 2 ) )  147
gint xsize = ( gint ) ( * c | ( * ( c + 1 ) << 8 ) ) ; 149
c += xsize; 152
if ( flags & ( 1 << 3 ) )  155
while ( ( c - compr ) < comprlen && * c != '\0' )  158
c ++; 159
c ++; 162
if ( flags & ( 1 << 4 ) )  165
while ( ( c - compr ) < comprlen && * c != '\0' )  168
c ++; 169
c ++; 172
next = c; 177
if ( c - compr > comprlen )  179
comprlen -= ( int ) ( c - compr ); 186
inits_done ++; 190
if ( err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3 )  191
wbits = - MAX_WBITS; 201
strm -> next_in = next; 205
strm -> avail_in = comprlen; 206
memset ( strmbuf , '\0' , bufsiz ); 209
strm -> next_out = strmbuf; 210
strm -> avail_out = bufsiz; 211
err = inflateInit2 ( strm , wbits ); 213
inits_done ++; 215
if ( err != Z_OK )  217
g_free ( uncompr ); 221
if ( uncompr == NULL )  230
if ( uncompr != NULL )  244
uncompr_tvb = tvb_new_real_data ( ( guint8 * ) uncompr , bytes_out , bytes_out ); 245
tvb_set_free_cb ( uncompr_tvb , g_free ); 247
return uncompr_tvb ; 250
------------------------------
766 /home/SySeVR/data/CVE_2011_2174_PATCHED_tvb_uncompress.c guint bytes_pass = bufsiz - strm -> avail_out ; 68
tvbuff_t *
CVE_2011_2174_PATCHED_tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen) 2
guint bytes_out = 0 ; 5
guint8 * uncompr = NULL ; 7
gint wbits = MAX_WBITS ; 12
if ( tvb == NULL )  20
compr = tvb_memdup ( tvb , offset , comprlen ); 24
if ( ! compr )  26
bufsiz = tvb_length_remaining ( tvb , offset ) * 2; 33
bufsiz = CLAMP ( bufsiz , TVB_Z_MIN_BUFSIZ , TVB_Z_MAX_BUFSIZ ); 34
next = compr; 40
strm = g_new0 ( z_stream , 1 ); 42
strm -> next_in = next; 43
strm -> avail_in = comprlen; 44
strmbuf = g_malloc0 ( bufsiz ); 46
strm -> next_out = strmbuf; 47
strm -> avail_out = bufsiz; 48
err = inflateInit2 ( strm , wbits ); 50
inits_done = 1; 51
if ( err != Z_OK )  52
while ( 1 )  60
memset ( strmbuf , '\0' , bufsiz ); 61
strm -> next_out = strmbuf; 62
strm -> avail_out = bufsiz; 63
err = inflate ( strm , Z_SYNC_FLUSH ); 65
if ( err == Z_OK || err == Z_STREAM_END )  67
guint bytes_pass = bufsiz - strm -> avail_out ; 68
if ( uncompr == NULL )  74
uncompr = g_memdup ( strmbuf , bytes_pass ); 75
guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ; 77
g_memmove ( new_data , uncompr , bytes_out ); 79
g_memmove ( ( new_data + bytes_out ) , strmbuf , bytes_pass ); 80
g_free ( uncompr ); 83
uncompr = new_data; 84
bytes_out += bytes_pass; 87
if ( err == Z_STREAM_END )  89
if ( err == Z_BUF_ERROR )  95
if ( uncompr != NULL )  105
if ( err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && ( * compr == 0x1f ) && ( * ( compr + 1 ) == 0x8b ) )  112
Bytef * c = compr + 2 ; 129
if ( * c == Z_DEFLATED )  132
c ++; 133
flags = * c; 142
c += 7; 145
if ( flags & ( 1 << 2 ) )  147
gint xsize = ( gint ) ( * c | ( * ( c + 1 ) << 8 ) ) ; 149
c += xsize; 152
if ( flags & ( 1 << 3 ) )  155
while ( ( c - compr ) < comprlen && * c != '\0' )  158
c ++; 159
c ++; 162
if ( flags & ( 1 << 4 ) )  165
while ( ( c - compr ) < comprlen && * c != '\0' )  168
c ++; 169
c ++; 172
next = c; 177
if ( c - compr > comprlen )  179
comprlen -= ( int ) ( c - compr ); 186
inits_done ++; 190
if ( err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3 )  191
wbits = - MAX_WBITS; 201
strm -> next_in = next; 205
strm -> avail_in = comprlen; 206
memset ( strmbuf , '\0' , bufsiz ); 209
strm -> next_out = strmbuf; 210
strm -> avail_out = bufsiz; 211
err = inflateInit2 ( strm , wbits ); 213
inits_done ++; 215
if ( err != Z_OK )  217
g_free ( uncompr ); 221
if ( uncompr == NULL )  230
printf ( "bytes  in: %u\nbytes out: %u\n\n" , bytes_in , bytes_out ); 241
if ( uncompr != NULL )  244
uncompr_tvb = tvb_new_real_data ( ( guint8 * ) uncompr , bytes_out , bytes_out ); 245
tvb_set_free_cb ( uncompr_tvb , g_free ); 247
return uncompr_tvb ; 250
------------------------------
767 /home/SySeVR/data/CVE_2011_2689_PATCHED_gfs2_fallocate.c loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 12
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 13
len = next - offset; 21
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  34
while ( len > 0 )  37
if ( len < bytes )  38
bytes = len; 39
gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ); 51
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  56
bytes >>= 1; 57
bytes &= bsize_mask; 58
if ( bytes == 0 )  59
max_bytes = bytes; 65
calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ); 66
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 79
if ( error )  82
len -= max_bytes; 85
offset += max_bytes; 86
return error ; 103
------------------------------
768 /home/SySeVR/data/CVE_2011_2689_VULN_gfs2_fallocate.c loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t offset,
loff_t len) 2
struct inode * inode = file -> f_path . dentry -> d_inode ; 4
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; 5
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; 11
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift; 12
len = next - offset; 21
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )  31
while ( len > 0 )  34
if ( len < bytes )  35
bytes = len; 36
gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ); 48
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )  53
bytes >>= 1; 54
max_bytes = bytes; 59
calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ); 60
error = fallocate_chunk ( inode , offset , max_bytes , mode ); 73
if ( error )  76
len -= max_bytes; 79
offset += max_bytes; 80
return error ; 97
------------------------------
769 /home/SySeVR/data/CVE_2011_3648_VULN_nsShiftJISToUnicode__Convert.c PRUnichar ch = gJapaneseMap [ mData + off ] ; 115
NS_IMETHODIMP CVE_2011_3648_VULN_nsShiftJISToUnicode::Convert(
const char * aSrc, PRInt32 * aSrcLen,
PRUnichar * aDest, PRInt32 * aDestLen) 3
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 41
const unsigned char * src = ( unsigned char * ) aSrc ; 42
PRUnichar * destEnd = aDest + * aDestLen ; 43
PRUnichar * dest = aDest ; 44
while ( src < srcEnd )  45
switch ( mState )  47
if ( * src & 0x80 )  51
mData = SJIS_INDEX [ * src & 0x7F ]; 53
if ( mData < 0xE000 )  54
mState = 1; 56
if ( mData > 0xFF00 )  58
if ( 0xFFFD == mData )  60
switch ( * src )  67
* dest ++ = ( PRUnichar ) * src; 69
* dest ++ = ( PRUnichar ) 0xf8f0; 73
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) ); 79
if ( mErrBehavior == kOnError_Signal )  84
* dest ++ = SJIS_UNMAPPED; 86
if ( dest >= destEnd )  88
* dest ++ = mData; 91
if ( dest >= destEnd )  92
mState = 2; 96
* dest ++ = ( PRUnichar ) * src; 101
if ( dest >= destEnd )  102
PRUint8 off = sbIdx [ * src ] ; 109
if ( 0xFF == off )  110
if ( mErrBehavior == kOnError_Signal )  111
* dest ++ = SJIS_UNMAPPED; 113
PRUnichar ch = gJapaneseMap [ mData + off ] ; 115
if ( ch == 0xfffd )  116
if ( mErrBehavior == kOnError_Signal )  117
ch = SJIS_UNMAPPED; 119
* dest ++ = ch; 121
mState = 0; 123
if ( dest >= destEnd )  124
PRUint8 off = sbIdx [ * src ] ; 131
if ( 0xFF == off )  132
if ( mErrBehavior == kOnError_Signal )  133
* dest ++ = SJIS_UNMAPPED; 136
* dest ++ = mData + off; 138
mState = 0; 140
if ( dest >= destEnd )  141
src ++; 147
* aDestLen = dest - aDest; 149
* aDestLen = dest - aDest; 152
* aDestLen = dest - aDest; 156
------------------------------
770 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c const uint8_t * buf_end = buf + avpkt -> size ; 4
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
if ( buf_end - 3 < buf )  57
if ( buf_end - 1 < buf )  78
------------------------------
771 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c const uint8_t * buf_end = buf + avpkt -> size ; 4
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
const uint8_t * buf = avpkt -> data ; 3
const uint8_t * buf_end = buf + avpkt -> size ; 4
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
if ( buf_end - 3 < buf )  57
if ( buf_end - 1 < buf )  78
------------------------------
772 /home/SySeVR/data/CVE_2012_0464_VULN_array_toString_sub.c const Value * end = beg + Min ( length , obj -> getDenseArrayInitializedLength ( ) ) ; 36
static JSBool
CVE_2012_0464_VULN_array_toString_sub(JSContext *cx, JSObject *obj, JSBool locale,
JSString *sepstr, Value *rval) 3
const jschar * sep ; 6
size_t seplen ; 7
if ( sepstr )  8
seplen = sepstr -> length ( ); 9
sep = sepstr -> getChars ( cx ); 10
if ( ! sep )  11
seplen = 1; 15
AutoArrayCycleDetector detector ( cx , obj ) ; 18
if ( ! detector . init ( ) )  19
if ( detector . foundCycle ( ) )  22
jsuint length ; 27
if ( ! js_GetLengthProperty ( cx , obj , & length ) )  28
if ( ! locale && ! seplen && obj -> isDenseArray ( ) && ! js_PrototypeHasIndexedProperties ( cx , obj ) )  33
const Value * beg = obj -> getDenseArrayElements ( ) ; 35
const Value * end = beg + Min ( length , obj -> getDenseArrayInitializedLength ( ) ) ; 36
for (const Value *vp = beg; vp != end; ++vp) 37
------------------------------
773 /home/SySeVR/data/CVE_2012_1097_PATCHED_fill_thread_core_info.c size_t size = regset -> n * regset -> size ; 35
static int CVE_2012_1097_PATCHED_fill_thread_core_info(struct elf_thread_core_info *t,
const struct user_regset_view *view,
long signr, size_t *total) 3
unsigned int i ; 5
for (i = 1; i < view->n; ++i) 29
const struct user_regset * regset = & view -> regsets [ i ] ; 30
if ( regset -> core_note_type && regset -> get && ( ! regset -> active || regset -> active ( t -> task , regset ) ) )  32
int ret ; 34
size_t size = regset -> n * regset -> size ; 35
void * data = kmalloc ( size , GFP_KERNEL ) ; 36
if ( unlikely ( ! data ) )  37
ret = regset -> get ( t -> task , regset , 0 , size , data , NULL ); 39
if ( unlikely ( ret ) )  41
kfree ( data ); 42
if ( regset -> core_note_type != NT_PRFPREG )  44
fill_note ( & t -> notes [ i ] , "LINUX" , regset -> core_note_type , size , data ); 45
t -> prstatus . pr_fpvalid = 1; 49
fill_note ( & t -> notes [ i ] , "CORE" , NT_PRFPREG , size , data ); 50
------------------------------
774 /home/SySeVR/data/CVE_2012_1183_PATCHED_milliwatt_generate.c const int maxsamples = ARRAY_LEN ( buf ) - ( AST_FRIENDLY_OFFSET / sizeof ( buf [ 0 ] ) ) ; 4
static int CVE_2012_1183_PATCHED_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) - ( AST_FRIENDLY_OFFSET / sizeof ( buf [ 0 ] ) ) ; 4
if ( samples > maxsamples )  19
ast_log ( LOG_WARNING , "Only doing %d samples (%d requested)\n" , maxsamples , samples ); 20
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
for (i = 0; i < len; i++) 29
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
775 /home/SySeVR/data/CVE_2012_1594_PATCHED_dissect_rsn_ie.c int tag_end = offset + tag_len ; 10
static int
CVE_2012_1594_PATCHED_dissect_rsn_ie(proto_tree * tree, tvbuff_t * tvb, int offset, guint32 tag_len) 2
int tag_end = offset + tag_len ; 10
if ( offset >= tag_end )  86
if ( offset >= tag_end )  103
------------------------------
776 /home/SySeVR/data/CVE_2012_1594_VULN_dissect_rsn_ie.c int tag_end = offset + tag_len ; 9
static int
CVE_2012_1594_VULN_dissect_rsn_ie(proto_tree * tree, tvbuff_t * tvb, int offset, guint32 tag_len) 2
int tag_end = offset + tag_len ; 9
if ( offset >= tag_end )  85
if ( offset >= tag_end )  102
------------------------------
777 /home/SySeVR/data/CVE_2012_3377_VULN_Ogg_DecodePacket.c uint64_t u_pnum = dts + delay ; 242
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t *p_demux,
logical_stream_t *p_stream,
ogg_packet *p_oggpacket ) 4
block_t * p_block ; 6
bool b_selected ; 7
if ( ! p_oggpacket -> bytes )  13
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )  19
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )  25
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )  32
if ( p_stream -> b_force_backup )  39
bool b_xiph ; 41
p_stream -> i_packets_backup ++; 42
switch ( p_stream -> fmt . i_codec )  43
if ( p_stream -> i_packets_backup == 3 )  48
p_stream -> b_force_backup = 0; 48
b_xiph = true; 49
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )  53
p_stream -> b_force_backup = 0; 56
if ( p_stream -> fmt . audio . i_rate )  58
p_stream -> b_force_backup = 0; 60
if ( p_oggpacket -> bytes >= 9 )  61
p_oggpacket -> packet += 9; 63
p_oggpacket -> bytes -= 9; 64
b_xiph = false; 67
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )  71
p_stream -> b_force_backup = 0; 71
b_xiph = true; 72
p_stream -> b_force_backup = 0; 76
b_xiph = false; 77
if ( ! b_xiph )  82
p_stream -> i_headers += p_oggpacket -> bytes; 85
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers ); 86
if ( p_stream -> p_headers )  87
p_stream -> i_headers = 0; 95
p_stream -> p_headers = NULL; 96
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )  100
p_stream -> i_headers = 0; 103
p_stream -> p_headers = NULL; 104
if ( p_stream -> i_headers > 0 )  106
if ( ! p_stream -> b_force_backup )  108
p_stream -> fmt . i_extra = p_stream -> i_headers; 113
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers ); 114
if ( p_stream -> fmt . p_extra )  115
p_stream -> fmt . i_extra = 0; 119
b_selected = false; 134
if ( p_stream -> fmt . i_codec == VLC_CODEC_VORBIS || p_stream -> fmt . i_codec == VLC_CODEC_SPEEX || p_stream -> fmt . i_codec == VLC_CODEC_FLAC )  138
if ( p_stream -> i_pcr >= 0 )  142
p_stream -> i_previous_pcr = p_stream -> i_pcr; 156
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> i_pcr >= 0 )  185
p_stream -> i_previous_pcr = p_stream -> i_pcr; 190
if ( ! b_selected )  196
if ( p_oggpacket -> bytes <= 0 )  203
if ( ! ( p_block = block_New ( p_demux , p_oggpacket -> bytes ) ) )  206
if ( p_stream -> i_skip_frames > 0 )  210
p_stream -> i_skip_frames --; 213
if ( p_stream -> fmt . i_cat == AUDIO_ES )  222
if ( p_stream -> fmt . i_cat == SPU_ES )  224
if ( p_stream -> fmt . i_codec == VLC_CODEC_THEORA )  229
if ( p_stream -> fmt . i_codec == VLC_CODEC_DIRAC )  237
ogg_int64_t dts = p_oggpacket -> granulepos >> 31 ; 239
ogg_int64_t delay = ( p_oggpacket -> granulepos >> 9 ) & 0x1fff ; 240
uint64_t u_pnum = dts + delay ; 242
p_block -> i_pts = u_pnum * INT64_C ( 1000000 ) / p_stream -> f_rate / 2; 250
if ( p_block -> i_buffer >= ( unsigned int ) i_header_len )  295
p_block -> i_buffer -= i_header_len; 296
memcpy ( p_block -> p_buffer , p_oggpacket -> packet + i_header_len , p_oggpacket -> bytes - i_header_len ); 309
es_out_Send ( p_demux -> out , p_stream -> p_es , p_block ); 312
------------------------------
778 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRInt32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint8 extrema [ 4 ] ; 21
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 22
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRInt32 startY = NS_MAX ( 0 , y - ry ) ; 26
PRInt32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRInt32 startX = NS_MAX ( 0 , x - rx ) ; 32
PRInt32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
PRInt32 targIndex = y * stride + 4 * x ; 34
for (PRInt32 i = 0; i < 4; i++) 36
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRInt32 y1 = startY; y1 <= endY; y1++) 39
for (PRInt32 x1 = startX; x1 <= endX; x1++) 40
for (PRInt32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
779 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c PRInt32 targIndex = y * stride + 4 * x ; 34
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRInt32 stride = aTarget -> mImage -> Stride ( ) ; 20
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRInt32 targIndex = y * stride + 4 * x ; 34
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRInt32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
780 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c PRInt32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRInt32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
for (PRInt32 x1 = startX; x1 <= endX; x1++) 40
------------------------------
781 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c PRInt32 startX = NS_MAX ( 0 , x - rx ) ; 32
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRInt32 startX = NS_MAX ( 0 , x - rx ) ; 32
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRInt32 x1 = startX; x1 <= endX; x1++) 40
for (PRInt32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
782 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c PRInt32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRInt32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
for (PRInt32 y1 = startY; y1 <= endY; y1++) 39
------------------------------
783 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c PRInt32 startY = NS_MAX ( 0 , y - ry ) ; 26
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRInt32 startY = NS_MAX ( 0 , y - ry ) ; 26
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRInt32 y1 = startY; y1 <= endY; y1++) 39
for (PRInt32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
784 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint8 extrema [ 4 ] ; 21
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 22
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 26
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 32
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
PRUint32 targIndex = y * stride + 4 * x ; 34
for (PRUint32 i = 0; i < 4; i++) 36
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRUint32 y1 = startY; y1 <= endY; y1++) 39
for (PRUint32 x1 = startX; x1 <= endX; x1++) 40
for (PRUint32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
785 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 targIndex = y * stride + 4 * x ; 34
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRUint32 targIndex = y * stride + 4 * x ; 34
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRUint32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
786 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 33
for (PRUint32 x1 = startX; x1 <= endX; x1++) 40
------------------------------
787 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 32
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 31
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 32
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRUint32 x1 = startX; x1 <= endX; x1++) 40
for (PRUint32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
788 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30
for (PRUint32 y1 = startY; y1 <= endY; y1++) 39
------------------------------
789 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 26
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 25
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 26
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRUint32 y1 = startY; y1 <= endY; y1++) 39
for (PRUint32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
790 /home/SySeVR/data/CVE_2012_4190_VULN_ft_module_get_service.c FT_Module * limit = cur + library -> num_modules ; 21
CVE_2012_4190_VULN_ft_module_get_service( FT_Module    module,
const char*  service_id ) 2
FT_Pointer result = NULL ; 4
if ( module )  6
if ( module -> clazz -> get_interface )  12
result = module -> clazz -> get_interface ( module , service_id ); 13
if ( result == NULL )  15
FT_Library library = module -> library ; 19
FT_Module * cur = library -> modules ; 20
FT_Module * limit = cur + library -> num_modules ; 21
for ( ; cur < limit; cur++ ) 23
------------------------------
791 /home/SySeVR/data/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c unsigned short sw = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) ) ; 414
static FT_Error
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*          line,
unsigned long  linelen,
unsigned long  lineno,
void*          call_data,
void*          client_data ) 6
_bdf_parse_t * p ; 13
bdf_glyph_t * glyph ; 14
bdf_font_t * font ; 15
p = ( _bdf_parse_t * ) client_data; 24
font = p -> font; 26
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )  30
if ( ! ( p -> flags & _BDF_GLYPHS ) )  45
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )  81
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )  95
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )  105
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )  111
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )  145
if ( p -> glyph_enc == - 1 )  261
glyph = font -> unencoded + ( font -> unencoded_used - 1 ); 262
glyph = font -> glyphs + ( font -> glyphs_used - 1 ); 264
if ( p -> flags & _BDF_BITMAP )  267
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )  328
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )  344
if ( ft_memcmp ( line , "BBX" , 3 ) == 0 )  372
if ( ! ( p -> flags & _BDF_ENCODING ) )  374
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen ); 377
if ( error )  378
glyph -> bbx . width = _bdf_atos ( p -> list . field [ 1 ] , 0 , 10 ); 381
glyph -> bbx . height = _bdf_atos ( p -> list . field [ 2 ] , 0 , 10 ); 382
glyph -> bbx . x_offset = _bdf_atos ( p -> list . field [ 3 ] , 0 , 10 ); 383
glyph -> bbx . y_offset = _bdf_atos ( p -> list . field [ 4 ] , 0 , 10 ); 384
glyph -> bbx . ascent = ( short ) ( glyph -> bbx . height + glyph -> bbx . y_offset ); 387
glyph -> bbx . descent = ( short ) ( - glyph -> bbx . y_offset ); 388
p -> maxas = ( short ) FT_MAX ( glyph -> bbx . ascent , p -> maxas ); 392
p -> maxds = ( short ) FT_MAX ( glyph -> bbx . descent , p -> maxds ); 393
p -> rbearing = ( short ) ( glyph -> bbx . width + glyph -> bbx . x_offset ); 395
p -> maxrb = ( short ) FT_MAX ( p -> rbearing , p -> maxrb ); 397
p -> minlb = ( short ) FT_MIN ( glyph -> bbx . x_offset , p -> minlb ); 398
p -> maxlb = ( short ) FT_MAX ( glyph -> bbx . x_offset , p -> maxlb ); 399
if ( ! ( p -> flags & _BDF_DWIDTH ) )  401
glyph -> dwidth = glyph -> bbx . width; 406
if ( p -> opts -> correct_metrics != 0 )  411
unsigned short sw = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) ) ; 414
if ( sw != glyph -> swidth )  420
glyph -> swidth = sw; 422
_bdf_set_glyph_modified ( font -> nmod , glyph -> encoding ); 428
------------------------------
792 /home/SySeVR/data/CVE_2013_0750_VULN_ReplaceRegExpCallback.c size_t growth = leftlen + replen ; 15
static bool
CVE_2013_0750_VULN_ReplaceRegExpCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p) 2
ReplaceData & rdata = * static_cast < ReplaceData * > p 4
rdata . calledBack = true; 6
size_t leftoff = rdata . leftIndex ; 7
size_t leftlen = res -> matchStart ( ) - leftoff ; 8
rdata . leftIndex = res -> matchLimit ( ); 9
size_t replen = 0 ; 11
if ( ! FindReplaceLength ( cx , res , rdata , & replen ) )  12
size_t growth = leftlen + replen ; 15
if ( ! rdata . sb . reserve ( rdata . sb . length ( ) + growth ) )  16
------------------------------
793 /home/SySeVR/data/CVE_2013_0756_PATCHED_obj_toSource.c const jschar * end = vchars + vlength ; 122
static JSBool
CVE_2013_0756_PATCHED_obj_toSource(JSContext *cx, unsigned argc, Value *vp) 2
CallArgs args = CallArgsFromVp ( argc , vp ) ; 4
RootedObject obj ( cx , ToObject ( cx , args . thisv ( ) ) ) ; 7
if ( ! obj )  8
bool outermost = ( cx -> cycleDetectorSet . count ( ) == 0 ) ; 12
AutoCycleDetector detector ( cx , obj ) ; 14
if ( ! detector . init ( ) )  15
if ( detector . foundCycle ( ) )  17
StringBuffer buf ( cx ) ; 25
if ( outermost && ! buf . append ( '(' ) )  26
if ( ! buf . append ( '{' ) )  28
Value val [ 2 ] ; 31
JSString * gsop [ 2 ] ; 35
AutoIdVector idv ( cx ) ; 38
if ( ! GetPropertyNames ( cx , obj , JSITER_OWNONLY , & idv ) )  39
bool comma = false ; 42
for (size_t i = 0; i < idv.length(); ++i) 43
RootedId id ( cx , idv [ i ] ) ; 44
RootedObject obj2 ( cx ) ; 45
RootedShape shape ( cx ) ; 46
if ( ! JSObject :: lookupGeneric ( cx , obj , id , & obj2 , & shape ) )  47
int valcnt = 0 ; 51
if ( shape )  52
bool doGet = true ; 53
if ( obj2 -> isNative ( ) )  54
unsigned attrs = shape -> attributes ( ) ; 55
if ( attrs & JSPROP_GETTER )  56
doGet = false; 57
val [ valcnt ] = shape -> getterValue ( ); 58
gsop [ valcnt ] = cx -> runtime -> atomState . getAtom; 59
valcnt ++; 60
if ( attrs & JSPROP_SETTER )  62
doGet = false; 63
val [ valcnt ] = shape -> setterValue ( ); 64
gsop [ valcnt ] = cx -> runtime -> atomState . setAtom; 65
valcnt ++; 66
if ( doGet )  69
valcnt = 1; 70
gsop [ 0 ] = NULL; 71
MutableHandleValue vp = MutableHandleValue :: fromMarkedLocation ( & val [ 0 ] ) ; 72
if ( ! JSObject :: getGeneric ( cx , obj , obj , id , vp ) )  73
RawString s = ToString ( cx , IdToValue ( id ) ) ; 79
if ( ! s )  80
Rooted < JSLinearString * > idstr ( cx , s -> ensureLinear ( cx ) ) ; 82
if ( ! idstr )  83
if ( JSID_IS_ATOM ( id ) ? ! IsIdentifier ( idstr ) : ( ! JSID_IS_INT ( id ) || JSID_TO_INT ( id ) < 0 ) )  90
s = js_QuoteString ( cx , idstr , jschar ( '\'' ) ); 94
if ( ! s || ! ( idstr = s -> ensureLinear ( cx ) ) )  95
for (int j = 0; j < valcnt; j++) 99
if ( gsop [ j ] && val [ j ] . isUndefined ( ) )  104
RootedString valstr ( cx , js_ValueToSource ( cx , val [ j ] ) ) ; 108
if ( ! valstr )  109
const jschar * vchars = valstr -> getChars ( cx ) ; 111
if ( ! vchars )  112
size_t vlength = valstr -> length ( ) ; 114
if ( gsop [ j ] && IsFunctionObject ( val [ j ] ) )  120
const jschar * start = vchars ; 121
const jschar * end = vchars + vlength ; 122
uint8_t parenChomp = 0 ; 124
if ( vchars [ 0 ] == '(' )  125
vchars ++; 126
parenChomp = 1; 127
if ( vchars )  131
vchars = js_strchr_limit ( vchars , ' ' , end ); 132
if ( vchars )  138
vchars = js_strchr_limit ( vchars , '(' , end ); 139
if ( vchars )  141
if ( * vchars == ' ' )  142
vchars ++; 143
vlength = end - vchars - parenChomp; 144
gsop [ j ] = NULL; 146
vchars = start; 147
if ( comma && ! buf . append ( ", " ) )  151
comma = true; 153
if ( gsop [ j ] )  155
if ( ! buf . append ( gsop [ j ] ) || ! buf . append ( ' ' ) )  156
if ( ! buf . append ( idstr ) )  159
if ( ! buf . append ( gsop [ j ] ? ' ' : ':' ) )  161
if ( ! buf . append ( vchars , vlength ) )  164
------------------------------
794 /home/SySeVR/data/CVE_2013_0761_PATCHED_CopyTrackData.c TrackTicks inputStartTicks = inputEndTicks - ticks ; 58
void CVE_2013_0761_PATCHED_CopyTrackData(StreamBuffer::Track* aInputTrack,
uint32_t aMapIndex, GraphTime aFrom, GraphTime aTo,
bool* aOutputTrackFinished) 3
TrackMapEntry * map = & mTrackMap [ aMapIndex ] ; 5
StreamBuffer :: Track * outputTrack = mBuffer . FindTrack ( map -> mOutputTrackID ) ; 6
TrackRate rate = outputTrack -> GetRate ( ) ; 9
MediaStream * source = map -> mInputPort -> GetSource ( ) ; 11
GraphTime next ; 13
for (GraphTime t = aFrom; t < aTo; t = next) 15
MediaInputPort :: InputInterval interval = map -> mInputPort -> GetNextInputInterval ( t ) ; 16
interval . mEnd = NS_MIN ( interval . mEnd , aTo ); 17
if ( interval . mStart >= interval . mEnd )  18
next = interval . mEnd; 20
StreamTime outputEnd = GraphTimeToStreamTime ( interval . mEnd ) ; 23
TrackTicks startTicks = outputTrack -> GetEnd ( ) ; 24
TrackTicks endTicks = TimeToTicksRoundUp ( rate , outputEnd ) ; 30
TrackTicks ticks = endTicks - startTicks ; 31
StreamTime inputEnd = source -> GraphTimeToStreamTime ( interval . mEnd ) ; 33
if ( interval . mInputIsBlocked )  44
TrackTicks inputEndTicks = TimeToTicksRoundUp ( rate , inputEnd ) ; 57
TrackTicks inputStartTicks = inputEndTicks - ticks ; 58
segment -> AppendSlice ( * aInputTrack -> GetSegment ( ) , NS_MIN ( inputTrackEndPoint , inputStartTicks ) , NS_MIN ( inputTrackEndPoint , inputEndTicks ) ); 59
LOG ( PR_LOG_DEBUG , ( "TrackUnionStream %p appending %lld ticks of input data to track %d" , this , ( long long ) ( NS_MIN ( inputTrackEndPoint , inputEndTicks ) - NS_MIN ( inputTrackEndPoint , inputStartTicks ) ) , outputTrack -> GetID ( ) ) ); 62
------------------------------
795 /home/SySeVR/data/CVE_2013_0761_PATCHED_CopyTrackData.c TrackTicks ticks = endTicks - startTicks ; 31
void CVE_2013_0761_PATCHED_CopyTrackData(StreamBuffer::Track* aInputTrack,
uint32_t aMapIndex, GraphTime aFrom, GraphTime aTo,
bool* aOutputTrackFinished) 3
TrackMapEntry * map = & mTrackMap [ aMapIndex ] ; 5
StreamBuffer :: Track * outputTrack = mBuffer . FindTrack ( map -> mOutputTrackID ) ; 6
TrackRate rate = outputTrack -> GetRate ( ) ; 9
GraphTime next ; 13
for (GraphTime t = aFrom; t < aTo; t = next) 15
MediaInputPort :: InputInterval interval = map -> mInputPort -> GetNextInputInterval ( t ) ; 16
interval . mEnd = NS_MIN ( interval . mEnd , aTo ); 17
if ( interval . mStart >= interval . mEnd )  18
next = interval . mEnd; 20
StreamTime outputEnd = GraphTimeToStreamTime ( interval . mEnd ) ; 23
TrackTicks startTicks = outputTrack -> GetEnd ( ) ; 24
TrackTicks endTicks = TimeToTicksRoundUp ( rate , outputEnd ) ; 30
TrackTicks ticks = endTicks - startTicks ; 31
segment -> AppendNullData ( ticks ); 46
LOG ( PR_LOG_DEBUG , ( "TrackUnionStream %p appending %lld ticks of null data to track %d" , this , ( long long ) ticks , outputTrack -> GetID ( ) ) ); 47
TrackTicks inputStartTicks = inputEndTicks - ticks ; 58
segment -> AppendSlice ( * aInputTrack -> GetSegment ( ) , NS_MIN ( inputTrackEndPoint , inputStartTicks ) , NS_MIN ( inputTrackEndPoint , inputEndTicks ) ); 59
LOG ( PR_LOG_DEBUG , ( "TrackUnionStream %p appending %lld ticks of input data to track %d" , this , ( long long ) ( NS_MIN ( inputTrackEndPoint , inputEndTicks ) - NS_MIN ( inputTrackEndPoint , inputStartTicks ) ) , outputTrack -> GetID ( ) ) ); 62
------------------------------
796 /home/SySeVR/data/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
void
CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
nsRenderingContext* aRenderingContext,
bool aShouldBlink,
nsHTMLReflowMetrics& aMetrics,
nsReflowStatus& aStatus) 6
int32_t maxContentLength = GetInFlowContentLength ( ) ; 33
if ( ! maxContentLength )  36
const nsStyleText * textStyle = GetStyleText ( ) ; 59
bool atStartOfLine = aLineLayout . LineAtStart ( ) ; 61
const nsTextFragment * frag = mContent -> GetText ( ) ; 69
int32_t length = maxContentLength ; 74
int32_t offset = GetContentOffset ( ) ; 75
int32_t newLineOffset = - 1 ; 78
int32_t contentNewLineOffset = - 1 ; 79
NewlineProperty * cachedNewlineOffset = nullptr ; 81
if ( textStyle -> NewlineIsSignificant ( ) )  82
cachedNewlineOffset =
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline ) 84
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )  85
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset; 88
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' ); 90
if ( contentNewLineOffset < offset + length )  93
newLineOffset = contentNewLineOffset; 99
if ( newLineOffset >= 0 )  101
length = newLineOffset + 1 - offset; 102
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )  105
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ; 109
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ; 110
offset += whitespaceCount; 112
length -= whitespaceCount; 113
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )  119
if ( aLineLayout . GetInFirstLetter ( ) )  123
if ( mTextRun )  135
int32_t firstLetterLength = length ; 136
if ( aLineLayout . GetFirstLetterStyleOK ( ) )  137
if ( newLineOffset >= 0 )  140
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 ); 142
firstLetterLength = 0; 156
length = firstLetterLength; 159
if ( ! mTextRun )  200
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ; 219
int32_t limitLength = length ; 232
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ; 233
if ( forceBreak >= offset + length )  235
forceBreak = - 1; 238
if ( forceBreak >= 0 )  240
limitLength = forceBreak - offset; 241
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ; 290
int32_t charsFit = end . GetOriginalOffset ( ) - offset ; 292
if ( charsFit >= limitLength )  304
charsFit = limitLength; 305
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ; 362
aStatus = contentLength == maxContentLength ? NS_FRAME_COMPLETE : NS_FRAME_NOT_COMPLETE; 458
if ( contentLength > 0 && mContentOffset + contentLength - 1 == newLineOffset )  464
aStatus = NS_INLINE_LINE_BREAK_AFTER ( aStatus ); 466
aStatus = NS_INLINE_LINE_BREAK_AFTER ( aStatus ); 469
aStatus |= NS_INLINE_BREAK_FIRST_LETTER_COMPLETE; 473
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )  477
if ( ! cachedNewlineOffset )  481
cachedNewlineOffset = new NewlineProperty 482
SetLength ( contentLength , & aLineLayout , ALLOW_FRAME_CREATION_AND_DESTRUCTION ); 513
printf ( ": desiredSize=%d,%d(b=%d) status=%x\n" , aMetrics . width , aMetrics . height , aMetrics . ascent , aStatus ); 519
------------------------------
797 /home/SySeVR/data/CVE_2013_0772_PATCHED_nsGIFDecoder2__DoLzw.c uint8_t * rowend = mImageData + ( bpr * mGIFStruct . irow ) + mGIFStruct . width ; 29
bool
CVE_2013_0772_PATCHED_nsGIFDecoder2::DoLzw(const uint8_t *q) 2
if ( ! mGIFStruct . rows_remaining )  4
uint32_t bpr = mGIFStruct . width ; 26
if ( ! mGIFStruct . images_decoded )  27
bpr *= sizeof ( uint32_t ); 28
uint8_t * rowend = mImageData + ( bpr * mGIFStruct . irow ) + mGIFStruct . width ; 29
------------------------------
798 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__DoLzw.c uint8_t * rowend = mImageData + ( bpr * mGIFStruct . irow ) + mGIFStruct . width ; 29
bool
CVE_2013_0772_VULN_nsGIFDecoder2::DoLzw(const uint8_t *q) 2
if ( ! mGIFStruct . rows_remaining )  4
uint32_t bpr = mGIFStruct . width ; 26
if ( ! mGIFStruct . images_decoded )  27
bpr *= sizeof ( uint32_t ); 28
uint8_t * rowend = mImageData + ( bpr * mGIFStruct . irow ) + mGIFStruct . width ; 29
------------------------------
799 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c uint8_t * from = rowp + mGIFStruct . width ; 43
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
uint8_t * from = rowp + mGIFStruct . width ; 43
* -- to = cmap [ * -- from ]; 48
* -- to = cmap [ ( * -- from ) & mask ]; 54
------------------------------
800 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . images_decoded )  12
const uint32_t bpr = sizeof ( uint32_t ) * mGIFStruct . width ; 39
uint8_t * rowp = mImageData + ( mGIFStruct . irow * bpr ) ; 40
uint8_t * from = rowp + mGIFStruct . width ; 43
uint32_t * to = ( ( uint32_t * ) rowp ) + mGIFStruct . width ; 44
* -- to = cmap [ * -- from ]; 48
* -- to = cmap [ ( * -- from ) & mask ]; 54
const uint32_t * rgb = ( uint32_t * ) rowp ; 60
if ( * rgb ++ == 0 )  62
memcpy ( mImageData + ( r * bpr ) , rowp , bpr ); 74
------------------------------
801 /home/SySeVR/data/CVE_2013_0777_PATCHED_nsCSSRendering__PaintBoxShadowOuter.c gfxFloat spreadDistance = shadowItem -> mSpread / twipsPerPixel ; 157
void
CVE_2013_0777_PATCHED_nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
nsRenderingContext& aRenderingContext,
nsIFrame* aForFrame,
const nsRect& aFrameArea,
const nsRect& aDirtyRect) 6
const nsStyleBorder * styleBorder = aForFrame -> GetStyleBorder ( ) ; 8
nsCSSShadowArray * shadows = styleBorder -> mBoxShadow ; 9
if ( ! shadows )  10
nscoord twipsPerPixel = aPresContext -> DevPixelsToAppUnits ( 1 ) ; 12
bool hasBorderRadius ; 14
bool nativeTheme ; 15
const nsStyleDisplay * styleDisplay = aForFrame -> GetStyleDisplay ( ) ; 19
nsITheme :: Transparency transparency ; 20
if ( aForFrame -> IsThemed ( styleDisplay , & transparency ) )  21
hasBorderRadius = false; 23
nativeTheme = transparency != nsITheme :: eOpaque; 26
nativeTheme = false; 28
nscoord twipsRadii [ 8 ] ; 29
hasBorderRadius = aForFrame -> GetBorderRadii ( twipsRadii ); 31
nsRect frameRect = nativeTheme ? aForFrame -> GetVisualOverflowRectRelativeToSelf ( ) + aFrameArea . TopLeft ( ) : aFrameArea ; 37
bool useSkipGfxRect = true ; 45
if ( nativeTheme )  46
useSkipGfxRect = ! aForFrame -> IsLeaf ( ); 52
nsRect paddingRect = aForFrame -> GetPaddingRect ( ) - aForFrame -> GetPosition ( ) + aFrameArea . TopLeft ( ) ; 53
skipGfxRect = nsLayoutUtils :: RectToGfxRect ( paddingRect , twipsPerPixel ); 55
for (uint32_t i = shadows->Length(); i > 0; --i) 62
nsCSSShadowItem * shadowItem = shadows -> ShadowAt ( i - 1 ) ; 63
if ( shadowItem -> mInset )  64
nsRect shadowRect = frameRect ; 67
nscoord pixelSpreadRadius ; 69
if ( nativeTheme )  70
pixelSpreadRadius = shadowItem -> mSpread; 71
pixelSpreadRadius = 0; 74
nscoord blurRadius = shadowItem -> mRadius ; 80
gfxContext * renderContext = aRenderingContext . ThebesContext ( ) ; 91
nsContextBoxBlur blurringArea ; 92
gfxContext * shadowContext = blurringArea . Init ( shadowRect , pixelSpreadRadius , blurRadius , twipsPerPixel , renderContext , aDirtyRect , useSkipGfxRect ? & skipGfxRect : nullptr , nativeTheme ? nsContextBoxBlur :: FORCE_MASK : 0 ) ; 98
if ( ! shadowContext )  103
if ( nativeTheme )  125
if ( hasBorderRadius )  155
gfxFloat spreadDistance = shadowItem -> mSpread / twipsPerPixel ; 157
borderSizes [ NS_SIDE_LEFT ] = spreadDistance; 161
borderSizes [ NS_SIDE_TOP ] = spreadDistance; 162
borderSizes [ NS_SIDE_RIGHT ] = spreadDistance; 163
borderSizes [ NS_SIDE_BOTTOM ] = spreadDistance; 164
nsCSSBorderRenderer :: ComputeOuterRadii ( borderRadii , borderSizes , & clipRectRadii ); 166
------------------------------
802 /home/SySeVR/data/CVE_2013_0777_VULN_nsCSSRendering__PaintBoxShadowOuter.c gfxFloat spreadDistance = shadowItem -> mSpread / twipsPerPixel ; 154
void
CVE_2013_0777_VULN_nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
nsRenderingContext& aRenderingContext,
nsIFrame* aForFrame,
const nsRect& aFrameArea,
const nsRect& aDirtyRect) 6
const nsStyleBorder * styleBorder = aForFrame -> GetStyleBorder ( ) ; 8
nsCSSShadowArray * shadows = styleBorder -> mBoxShadow ; 9
if ( ! shadows )  10
nscoord twipsPerPixel = aPresContext -> DevPixelsToAppUnits ( 1 ) ; 12
bool hasBorderRadius ; 14
bool nativeTheme ; 15
const nsStyleDisplay * styleDisplay = aForFrame -> GetStyleDisplay ( ) ; 19
nsITheme :: Transparency transparency ; 20
if ( aForFrame -> IsThemed ( styleDisplay , & transparency ) )  21
hasBorderRadius = false; 23
nativeTheme = transparency != nsITheme :: eOpaque; 26
nativeTheme = false; 28
nscoord twipsRadii [ 8 ] ; 29
hasBorderRadius = aForFrame -> GetBorderRadii ( twipsRadii ); 31
nsRect frameRect = nativeTheme ? aForFrame -> GetVisualOverflowRectRelativeToSelf ( ) + aFrameArea . TopLeft ( ) : aFrameArea ; 37
bool useSkipGfxRect = true ; 45
if ( nativeTheme )  46
useSkipGfxRect = ! aForFrame -> IsLeaf ( ); 52
nsRect paddingRect = aForFrame -> GetPaddingRect ( ) - aForFrame -> GetPosition ( ) + aFrameArea . TopLeft ( ) ; 53
skipGfxRect = nsLayoutUtils :: RectToGfxRect ( paddingRect , twipsPerPixel ); 55
for (uint32_t i = shadows->Length(); i > 0; --i) 62
nsCSSShadowItem * shadowItem = shadows -> ShadowAt ( i - 1 ) ; 63
if ( shadowItem -> mInset )  64
nsRect shadowRect = frameRect ; 67
nscoord pixelSpreadRadius ; 69
if ( nativeTheme )  70
pixelSpreadRadius = shadowItem -> mSpread; 71
pixelSpreadRadius = 0; 74
nscoord blurRadius = shadowItem -> mRadius ; 80
gfxContext * renderContext = aRenderingContext . ThebesContext ( ) ; 91
nsRefPtr < gfxContext > shadowContext ; 92
nsContextBoxBlur blurringArea ; 93
shadowContext = blurringArea . Init ( shadowRect , pixelSpreadRadius , blurRadius , twipsPerPixel , renderContext , aDirtyRect , useSkipGfxRect ? & skipGfxRect : nullptr , nativeTheme ? nsContextBoxBlur :: FORCE_MASK : 0 ); 99
if ( ! shadowContext )  104
if ( nativeTheme )  122
if ( hasBorderRadius )  152
gfxFloat spreadDistance = shadowItem -> mSpread / twipsPerPixel ; 154
borderSizes [ NS_SIDE_LEFT ] = spreadDistance; 158
borderSizes [ NS_SIDE_TOP ] = spreadDistance; 159
borderSizes [ NS_SIDE_RIGHT ] = spreadDistance; 160
borderSizes [ NS_SIDE_BOTTOM ] = spreadDistance; 161
nsCSSBorderRenderer :: ComputeOuterRadii ( borderRadii , borderSizes , & clipRectRadii ); 163
------------------------------
803 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* outString = temp; 22
* outString = nullptr; 24
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
------------------------------
804 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* bufferLength += addLength; 21
* outString = temp; 22
* outString = nullptr; 24
* bufferLength = 0; 25
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
------------------------------
805 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c int16_t * smp = samples + channel ; 295
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
GetByteContext gb ; 13
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 206
c -> status [ 1 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 207
c -> status [ 0 ] . step_index = bytestream2_get_byteu ( & gb ); 208
c -> status [ 1 ] . step_index = bytestream2_get_byteu ( & gb ); 209
if ( c -> status [ 0 ] . step_index > 88u || c -> status [ 1 ] . step_index > 88u )  210
while ( samples < samples_end )  229
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 244
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 245
* samples ++ = c -> status [ 0 ] . predictor + c -> status [ 1 ] . predictor; 253
* samples ++ = c -> status [ 0 ] . predictor - c -> status [ 1 ] . predictor; 254
for (channel = 0; channel < avctx->channels; channel++) 259
cs = & c -> status [ channel ]; 260
cs -> predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 261
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 262
if ( cs -> step_index > 88u )  263
for (n = nb_samples >> (1 - st); n > 0; n--) 270
int v1 , v2 ; 271
int v = bytestream2_get_byteu ( & gb ) ; 272
if ( st )  274
v1 = v >> 4; 275
v2 = v & 0x0F; 276
v2 = v >> 4; 278
v1 = v & 0x0F; 279
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v1 , 3 ); 281
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v2 , 3 ); 282
while ( bytestream2_get_bytes_left ( & gb ) > 0 )  286
int v = bytestream2_get_byteu ( & gb ) ; 287
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 288
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 289
if ( c -> vqa_version == 3 )  293
for (channel = 0; channel < avctx->channels; channel++) 294
int16_t * smp = samples + channel ; 295
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v >> 4 , 3 ); 299
smp += avctx -> channels; 300
* smp = adpcm_ima_expand_nibble ( & c -> status [ channel ] , v & 0x0F , 3 ); 301
smp += avctx -> channels; 302
------------------------------
806 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
short * samples ; 9
int st ; 10
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
samples = ( short * ) c -> frame . data [ 0 ]; 28
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
st = avctx -> channels == 2 ? 1 : 0; 38
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
samples = ( short * ) c -> frame . data [ 0 ] + channel; 73
for (m = 0; m < 32; m++) 75
int byte = bytestream2_get_byteu ( & gb ) ; 76
* samples = adpcm_ima_qt_expand_nibble ( cs , byte & 0x0F , 3 ); 77
samples += avctx -> channels; 78
* samples = adpcm_ima_qt_expand_nibble ( cs , byte >> 4 , 3 ); 79
samples += avctx -> channels; 80
for(i=0; i<avctx->channels; i++) 85
cs = & ( c -> status [ i ] ); 86
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 87
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 89
if ( cs -> step_index > 88u )  90
for (n = (nb_samples - 1) / 8; n > 0; n--) 97
for (i = 0; i < avctx->channels; i++) 98
cs = & c -> status [ i ]; 99
for (m = 0; m < 4; m++) 100
int v = bytestream2_get_byteu ( & gb ) ; 101
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 3 ); 102
samples += avctx -> channels; 103
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 3 ); 104
samples += avctx -> channels; 105
samples -= 8 * avctx -> channels - 1; 107
samples += 7 * avctx -> channels; 109
for (i = 0; i < avctx->channels; i++) 113
c -> status [ i ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 114
for (i = 0; i < avctx->channels; i++) 116
c -> status [ i ] . step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 117
if ( c -> status [ i ] . step_index > 88u )  118
for (i = 0; i < avctx->channels; i++) 125
samples = ( short * ) c -> frame . data [ 0 ] + i; 126
cs = & c -> status [ i ]; 127
for (n = nb_samples >> 1; n > 0; n--) 128
int v = bytestream2_get_byteu ( & gb ) ; 129
* samples = adpcm_ima_expand_nibble ( cs , v & 0x0F , 4 ); 130
samples += avctx -> channels; 131
* samples = adpcm_ima_expand_nibble ( cs , v >> 4 , 4 ); 132
samples += avctx -> channels; 133
int block_predictor ; 139
block_predictor = bytestream2_get_byteu ( & gb ); 141
if ( block_predictor > 6 )  142
c -> status [ 0 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 147
c -> status [ 0 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 148
if ( st )  149
block_predictor = bytestream2_get_byteu ( & gb ); 150
if ( block_predictor > 6 )  151
c -> status [ 1 ] . coeff1 = ff_adpcm_AdaptCoeff1 [ block_predictor ]; 156
c -> status [ 1 ] . coeff2 = ff_adpcm_AdaptCoeff2 [ block_predictor ]; 157
c -> status [ 0 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 159
if ( st )  160
c -> status [ 1 ] . idelta = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 161
c -> status [ 0 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 164
if ( st )  165
c -> status [ 1 ] . sample1 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 165
c -> status [ 0 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 166
if ( st )  167
c -> status [ 1 ] . sample2 = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 167
* samples ++ = c -> status [ 0 ] . sample2; 169
if ( st )  170
* samples ++ = c -> status [ 1 ] . sample2; 170
* samples ++ = c -> status [ 0 ] . sample1; 171
if ( st )  172
* samples ++ = c -> status [ 1 ] . sample1; 172
for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) 173
int byte = bytestream2_get_byteu ( & gb ) ; 174
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ 0 ] , byte >> 4 ); 175
* samples ++ = adpcm_ms_expand_nibble ( & c -> status [ st ] , byte & 0x0F ); 176
for (channel = 0; channel < avctx->channels; channel++) 181
cs = & c -> status [ channel ]; 182
cs -> predictor = * samples ++ = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 183
cs -> step_index = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 184
if ( cs -> step_index > 88u )  185
for (n = nb_samples >> (1 - st); n > 0; n--) 191
int v = bytestream2_get_byteu ( & gb ) ; 192
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , v >> 4 , 3 ); 193
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ st ] , v & 0x0F , 3 ); 194
const int16_t * samples_end = samples + avctx -> channels * nb_samples ; 203
while ( samples < samples_end )  229
------------------------------
807 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c int diff = predictor - cs -> predictor ; 56
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
ADPCMChannelStatus * cs ; 7
int n , m , channel , i ; 8
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
switch ( avctx -> codec -> id )  40
for (channel = 0; channel < avctx->channels; channel++) 44
int predictor ; 45
int step_index ; 46
cs = & ( c -> status [ channel ] ); 47
predictor = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 51
step_index = predictor & 0x7F; 52
predictor &= ~0x7F; 53
if ( cs -> step_index == step_index )  55
int diff = predictor - cs -> predictor ; 56
if ( diff < 0 )  57
diff = - diff; 58
if ( diff > 0x7f )  59
cs -> step_index = step_index; 63
cs -> predictor = predictor; 64
if ( cs -> step_index > 88u )  67
------------------------------
808 /home/SySeVR/data/CVE_2013_0851_PATCHED_decode_frame.c const uint8_t * buf_end = buf + buf_size ; 7
static int CVE_2013_0851_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
av_fast_malloc ( & s -> bitstream_buf , & s -> bitstream_buf_size , ( buf_end - buf ) + FF_INPUT_BUFFER_PADDING_SIZE ); 51
s -> dsp . bswap16_buf ( s -> bitstream_buf , ( const uint16_t * ) buf , ( buf_end - buf ) / 2 ); 54
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
init_get_bits ( & s -> gb , s -> bitstream_buf , 8 * ( buf_end - buf ) ); 56
------------------------------
809 /home/SySeVR/data/CVE_2013_0851_VULN_decode_frame.c const uint8_t * buf_end = buf + buf_size ; 7
static int CVE_2013_0851_VULN_decode_frame(AVCodecContext *avctx,
void *data, int *data_size,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> data ; 5
int buf_size = avpkt -> size ; 6
const uint8_t * buf_end = buf + buf_size ; 7
if ( ( width * height ) / 2048 * 7 > buf_end - buf )  32
av_fast_malloc ( & s -> bitstream_buf , & s -> bitstream_buf_size , ( buf_end - buf ) + FF_INPUT_BUFFER_PADDING_SIZE ); 51
s -> dsp . bswap16_buf ( s -> bitstream_buf , ( const uint16_t * ) buf , ( buf_end - buf ) / 2 ); 54
memset ( ( uint8_t * ) s -> bitstream_buf + ( buf_end - buf ) , 0 , FF_INPUT_BUFFER_PADDING_SIZE ); 55
init_get_bits ( & s -> gb , s -> bitstream_buf , 8 * ( buf_end - buf ) ); 56
------------------------------
810 /home/SySeVR/data/CVE_2013_0864_PATCHED_gif_copy_img_rect.c const uint32_t * src_pb = src_py + h * linesize ; 8
static void CVE_2013_0864_PATCHED_gif_copy_img_rect(const uint32_t *src, uint32_t *dst,
int linesize, int l, int t, int w, int h) 2
const int y_start = t * linesize ; 4
const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
const uint32_t * src_pb = src_py + h * linesize ; 8
for (; src_py < src_pb; src_py += linesize, dst_py += linesize) 11
------------------------------
811 /home/SySeVR/data/CVE_2013_0864_PATCHED_gif_copy_img_rect.c const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
static void CVE_2013_0864_PATCHED_gif_copy_img_rect(const uint32_t *src, uint32_t *dst,
int linesize, int l, int t, int w, int h) 2
const int y_start = t * linesize ; 4
const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
const uint32_t * src_pb = src_py + h * linesize ; 8
for (; src_py < src_pb; src_py += linesize, dst_py += linesize) 11
src_px = src_py + l; 12
dst_px = ( uint32_t * ) dst_py + l; 13
src_pr = src_px + w; 14
for (; src_px < src_pr; src_px++, dst_px++) 16
* dst_px = * src_px; 17
------------------------------
812 /home/SySeVR/data/CVE_2013_0864_PATCHED_gif_copy_img_rect.c const int y_start = t * linesize ; 4
static void CVE_2013_0864_PATCHED_gif_copy_img_rect(const uint32_t *src, uint32_t *dst,
int linesize, int l, int t, int w, int h) 2
const int y_start = t * linesize ; 4
const uint32_t * src_px , * src_pr , * src_py = src + y_start , * dst_py = dst + y_start ; 5
const uint32_t * src_pb = src_py + h * linesize ; 8
for (; src_py < src_pb; src_py += linesize, dst_py += linesize) 11
src_px = src_py + l; 12
dst_px = ( uint32_t * ) dst_py + l; 13
src_pr = src_px + w; 14
for (; src_px < src_pr; src_px++, dst_px++) 16
* dst_px = * src_px; 17
------------------------------
813 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c int limit1 = limit0 - len1 ; 45
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
int i , b , g , r , code ; 32
int p0 = s -> decorrelate ; 33
int p1 = ! s -> decorrelate ; 34
for (i = 0, g = -16; g < 16; g++) 38
int len0 = s -> len [ p0 ] [ g & 255 ] ; 39
int limit0 = VLC_BITS - len0 ; 40
if ( limit0 < 2 || ! len0 )  41
for (b = -16; b < 16; b++) 43
int len1 = s -> len [ p1 ] [ b & 255 ] ; 44
int limit1 = limit0 - len1 ; 45
if ( limit1 < 1 || ! len1 )  46
if ( len2 > limit1 || ! len2 )  51
------------------------------
814 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c int limit0 = VLC_BITS - len0 ; 40
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
int i , b , g , r , code ; 32
int p0 = s -> decorrelate ; 33
for (i = 0, g = -16; g < 16; g++) 38
int len0 = s -> len [ p0 ] [ g & 255 ] ; 39
int limit0 = VLC_BITS - len0 ; 40
if ( limit0 < 2 || ! len0 )  41
int limit1 = limit0 - len1 ; 45
if ( limit1 < 1 || ! len1 )  46
if ( len2 > limit1 || ! len2 )  51
------------------------------
815 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c int limit = VLC_BITS - len0 ; 11
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 || ! len0 )  12
if ( len1 > limit || ! len1 )  16
------------------------------
816 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c int limit1 = limit0 - len1 ; 44
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
int i , b , g , r , code ; 31
int p0 = s -> decorrelate ; 32
int p1 = ! s -> decorrelate ; 33
for (i = 0, g = -16; g < 16; g++) 37
int len0 = s -> len [ p0 ] [ g & 255 ] ; 38
int limit0 = VLC_BITS - len0 ; 39
if ( limit0 < 2 )  40
for (b = -16; b < 16; b++) 42
int len1 = s -> len [ p1 ] [ b & 255 ] ; 43
int limit1 = limit0 - len1 ; 44
if ( limit1 < 1 )  45
if ( len2 > limit1 )  50
------------------------------
817 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c int limit0 = VLC_BITS - len0 ; 39
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
int i , b , g , r , code ; 31
int p0 = s -> decorrelate ; 32
for (i = 0, g = -16; g < 16; g++) 37
int len0 = s -> len [ p0 ] [ g & 255 ] ; 38
int limit0 = VLC_BITS - len0 ; 39
if ( limit0 < 2 )  40
int limit1 = limit0 - len1 ; 44
if ( limit1 < 1 )  45
if ( len2 > limit1 )  50
------------------------------
818 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c int limit = VLC_BITS - len0 ; 11
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
if ( s -> bitstream_bpp < 24 )  6
int p , i , y , u ; 7
for (p = 0; p < 3; p++) 8
for (i = y = 0; y < 256; y++) 9
int len0 = s -> len [ 0 ] [ y ] ; 10
int limit = VLC_BITS - len0 ; 11
if ( limit <= 0 )  12
if ( len1 > limit )  16
------------------------------
819 /home/SySeVR/data/CVE_2013_1676_VULN_nsBidiPresUtils__ResolveParagraph.c int32_t runEnd = contentOffset + runLength ; 134
nsresult
CVE_2013_1676_VULN_nsBidiPresUtils::ResolveParagraph(nsBlockFrame* aBlockFrame,
BidiParagraphData* aBpd) 3
if ( aBpd -> BufferLength ( ) < 1 )  7
int32_t runCount ; 12
rv = aBpd -> CountRuns ( & runCount ); 19
int32_t runLength = 0 ; 22
int32_t logicalLimit = 0 ; 24
int32_t numRun = - 1 ; 25
int32_t fragmentLength = 0 ; 26
int32_t frameIndex = - 1 ; 27
int32_t frameCount = aBpd -> FrameCount ( ) ; 28
int32_t contentOffset = 0 ; 29
bool isTextFrame = false ; 30
nsIFrame * frame = nullptr ; 31
nsIContent * content = nullptr ; 32
int32_t contentTextLength = 0 ; 33
if ( fragmentLength <= 0 )  53
if ( ++ frameIndex >= frameCount )  55
frame = aBpd -> FrameAt ( frameIndex ); 58
if ( frame == NS_BIDI_CONTROL_FRAME || nsGkAtoms :: textFrame != frame -> GetType ( ) )  59
isTextFrame = false; 65
fragmentLength = 1; 66
content = frame -> GetContent ( ); 74
if ( ! content )  75
contentTextLength = content -> TextLength ( ); 79
if ( contentTextLength == 0 )  80
int32_t start , end ; 92
fragmentLength = NS_MIN ( contentTextLength , end - start ); 96
contentOffset = start; 97
isTextFrame = true; 98
if ( runLength <= 0 )  102
if ( ++ numRun >= runCount )  104
lineOffset = logicalLimit; 107
if ( NS_FAILED ( aBpd -> GetLogicalRun ( lineOffset , & logicalLimit , & embeddingLevel ) ) )  108
runLength = logicalLimit - lineOffset; 112
if ( frame == NS_BIDI_CONTROL_FRAME )  115
frame = nullptr; 116
if ( isTextFrame )  126
if ( ( runLength > 0 ) && ( runLength < fragmentLength ) )  127
nsIFrame * nextBidi ; 133
int32_t runEnd = contentOffset + runLength ; 134
rv = EnsureBidiContinuation ( frame , & nextBidi , frameIndex , contentOffset , runEnd ); 135
if ( NS_FAILED ( rv ) )  138
nextBidi -> AdjustOffsetsForBidi ( runEnd , contentOffset + fragmentLength ); 141
lastFrame = frame = nextBidi; 143
contentOffset = runEnd; 144
if ( contentOffset + fragmentLength == contentTextLength )  147
int32_t newIndex = aBpd -> GetLastFrameForContent ( content ) ; 153
if ( newIndex > frameIndex )  154
frameIndex = newIndex; 157
lastFrame = frame = aBpd -> FrameAt ( frameIndex ); 158
frame -> AdjustOffsetsForBidi ( contentOffset , contentOffset + fragmentLength ); 186
int32_t temp = runLength ; 194
runLength -= fragmentLength; 195
fragmentLength -= temp; 196
return rv ; 274
------------------------------
820 /home/SySeVR/data/CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph.c unsigned int c = glyph_surface -> stride * glyph_surface -> height / 4 ; 148
static cairo_status_t
CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
scaled_glyph = * pscaled_glyph; 33
glyph_surface = scaled_glyph -> surface; 34
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format ); 46
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ; 51
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )  64
cairo_surface_t * tmp_surface ; 65
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 ); 67
status = tmp_surface -> status; 68
if ( unlikely ( status ) )  69
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 72
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 73
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 75
if ( glyph_surface -> format != glyphset_info -> format )  82
cairo_surface_pattern_t pattern ; 83
cairo_surface_t * tmp_surface ; 84
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height ); 86
status = tmp_surface -> status; 89
if ( unlikely ( status ) )  90
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 93
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 94
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL ); 97
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 102
if ( unlikely ( status ) )  104
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )  119
if ( _native_byte_order_lsb ( ) != ( ImageByteOrder ( display -> display ) == LSBFirst ) )  147
unsigned int c = glyph_surface -> stride * glyph_surface -> height / 4 ; 148
------------------------------
821 /home/SySeVR/data/CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph.c int c = glyph_surface -> stride * glyph_surface -> height ; 123
static cairo_status_t
CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
scaled_glyph = * pscaled_glyph; 33
glyph_surface = scaled_glyph -> surface; 34
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format ); 46
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ; 51
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )  64
cairo_surface_t * tmp_surface ; 65
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 ); 67
status = tmp_surface -> status; 68
if ( unlikely ( status ) )  69
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 72
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 73
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 75
if ( glyph_surface -> format != glyphset_info -> format )  82
cairo_surface_pattern_t pattern ; 83
cairo_surface_t * tmp_surface ; 84
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height ); 86
status = tmp_surface -> status; 89
if ( unlikely ( status ) )  90
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 93
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 94
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL ); 97
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 102
if ( unlikely ( status ) )  104
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )  119
if ( _native_byte_order_lsb ( ) != ( BitmapBitOrder ( display -> display ) == LSBFirst ) )  122
int c = glyph_surface -> stride * glyph_surface -> height ; 123
------------------------------
822 /home/SySeVR/data/CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph.c int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
static cairo_status_t
CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
------------------------------
823 /home/SySeVR/data/CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph.c unsigned int c = glyph_surface -> stride * glyph_surface -> height / 4 ; 148
static cairo_status_t
CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
scaled_glyph = * pscaled_glyph; 33
glyph_surface = scaled_glyph -> surface; 34
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format ); 46
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ; 51
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )  64
cairo_surface_t * tmp_surface ; 65
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 ); 67
status = tmp_surface -> status; 68
if ( unlikely ( status ) )  69
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 72
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 73
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 75
if ( glyph_surface -> format != glyphset_info -> format )  82
cairo_surface_pattern_t pattern ; 83
cairo_surface_t * tmp_surface ; 84
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height ); 86
status = tmp_surface -> status; 89
if ( unlikely ( status ) )  90
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 93
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 94
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL ); 97
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 102
if ( unlikely ( status ) )  104
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )  119
if ( _native_byte_order_lsb ( ) != ( ImageByteOrder ( display -> display ) == LSBFirst ) )  147
unsigned int c = glyph_surface -> stride * glyph_surface -> height / 4 ; 148
------------------------------
824 /home/SySeVR/data/CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph.c int c = glyph_surface -> stride * glyph_surface -> height ; 123
static cairo_status_t
CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
scaled_glyph = * pscaled_glyph; 33
glyph_surface = scaled_glyph -> surface; 34
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format ); 46
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ; 51
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )  64
cairo_surface_t * tmp_surface ; 65
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 ); 67
status = tmp_surface -> status; 68
if ( unlikely ( status ) )  69
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 72
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 73
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 75
if ( glyph_surface -> format != glyphset_info -> format )  82
cairo_surface_pattern_t pattern ; 83
cairo_surface_t * tmp_surface ; 84
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height ); 86
status = tmp_surface -> status; 89
if ( unlikely ( status ) )  90
tmp_surface -> device_transform = glyph_surface -> base . device_transform; 93
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse; 94
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL ); 97
glyph_surface = ( cairo_image_surface_t * ) tmp_surface; 102
if ( unlikely ( status ) )  104
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )  119
if ( _native_byte_order_lsb ( ) != ( BitmapBitOrder ( display -> display ) == LSBFirst ) )  122
int c = glyph_surface -> stride * glyph_surface -> height ; 123
------------------------------
825 /home/SySeVR/data/CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph.c int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
static cairo_status_t
CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
cairo_scaled_font_t   *scaled_font,
cairo_scaled_glyph_t **pscaled_glyph) 4
unsigned long glyph_index ; 7
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ; 10
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ; 11
cairo_xlib_font_glyphset_info_t * glyphset_info ; 13
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph ); 15
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface ); 18
if ( glyphset_info != NULL )  19
if ( ! glyph_surface )  24
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph ); 25
if ( unlikely ( status ) )  30
if ( scaled_font -> surface_private == NULL )  40
status = _cairo_xlib_surface_font_init ( display , scaled_font ); 41
if ( unlikely ( status ) )  42
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ; 52
if ( len >= max_request_size )  57
------------------------------
826 /home/SySeVR/data/CVE_2013_1681_PATCHED_nsContentUtils__RemoveScriptBlocker.c uint32_t blockersCount = lastBlocker - firstBlocker ; 14
void
CVE_2013_1681_PATCHED_nsContentUtils::RemoveScriptBlocker() 2
if ( sScriptBlockerCount )  7
uint32_t firstBlocker = sRunnersCountAtFirstBlocker ; 11
uint32_t lastBlocker = sBlockedScriptRunners -> Length ( ) ; 12
uint32_t blockersCount = lastBlocker - firstBlocker ; 14
sBlockedScriptRunners -> RemoveElementsAt ( originalFirstBlocker , blockersCount ); 37
------------------------------
827 /home/SySeVR/data/CVE_2013_1681_VULN_nsContentUtils__RemoveScriptBlocker.c uint32_t blockersCount = lastBlocker - firstBlocker ; 13
void
CVE_2013_1681_VULN_nsContentUtils::RemoveScriptBlocker() 2
if ( sScriptBlockerCount )  6
uint32_t firstBlocker = sRunnersCountAtFirstBlocker ; 10
uint32_t lastBlocker = sBlockedScriptRunners -> Length ( ) ; 11
uint32_t blockersCount = lastBlocker - firstBlocker ; 13
sBlockedScriptRunners -> RemoveElementsAt ( originalFirstBlocker , blockersCount ); 27
------------------------------
828 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint32 xExt [ 4 ] , yExt [ 4 ] ; 21
PRUint8 extrema [ 4 ] ; 22
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 23
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 33
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 37
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 38
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 39
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 40
PRUint32 targIndex = y * stride + 4 * x ; 41
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
PRUint32 i ; 46
for (i = 0; i < 4; i++) 47
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (PRUint32 y1 = startY; y1 <= endY; y1++) 50
for (PRUint32 x1 = startX; x1 <= endX; x1++) 51
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
for (PRUint32 y1 = startY; y1 <= endY; y1++) 66
for (PRUint32 i = 0; i < 4; i++) 67
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
829 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ; 18
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ; 19
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
PRUint32 xExt [ 4 ] , yExt [ 4 ] ; 21
PRUint8 extrema [ 4 ] ; 22
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ; 23
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 33
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 37
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 38
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 39
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 40
PRUint32 targIndex = y * stride + 4 * x ; 41
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
PRUint32 i ; 46
for (i = 0; i < 4; i++) 47
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (PRUint32 y1 = startY; y1 <= endY; y1++) 50
for (PRUint32 x1 = startX; x1 <= endX; x1++) 51
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
for (PRUint32 y1 = startY; y1 <= endY; y1++) 66
for (PRUint32 i = 0; i < 4; i++) 67
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
830 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 targIndex = y * stride + 4 * x ; 41
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint32 stride = aTarget -> mImage -> Stride ( ) ; 20
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 38
PRUint32 targIndex = y * stride + 4 * x ; 41
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
831 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 40
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 38
PRUint32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ; 40
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (PRUint32 x1 = startX; x1 <= endX; x1++) 51
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
832 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 39
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
for (PRInt32 x = rect.x; x < rect.XMost(); x++) 38
PRUint32 startX = NS_MAX ( 0 , x - rx ) ; 39
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (PRUint32 x1 = startX; x1 <= endX; x1++) 51
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
833 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 37
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 37
for (PRUint32 y1 = startY; y1 <= endY; y1++) 50
for (PRUint32 y1 = startY; y1 <= endY; y1++) 66
------------------------------
834 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 33
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
for (PRInt32 y = rect.y; y < rect.YMost(); y++) 32
PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 33
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (PRUint32 y1 = startY; y1 <= endY; y1++) 50
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
for (PRUint32 y1 = startY; y1 <= endY; y1++) 66
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
835 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c size_t len = NS_tstrlen ( gDestinationPath + commonPrefixLength ) ; 590
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
if ( sReplaceRequest )  580
size_t commonPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , gDestinationPath , NULL ) ; 583
size_t len = NS_tstrlen ( gDestinationPath + commonPrefixLength ) ; 590
p += len; 591
bufferLeft -= len; 592
* p = NS_T ( '\\' ); 593
bufferLeft --; 595
* p = NS_T ( '\0' ); 596
NS_tstrncpy ( p , argv [ callbackIndex ] + max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 601
------------------------------
836 /home/SySeVR/data/CVE_2013_2486_PATCHED_dissect_diagnosticrequest.c int local_increment = dissect_diagnosticextension ( tvb , pinfo , extensions_tree , offset + 4 + local_offset + extensions_offset , extensions_length - extensions_offset ) ; 46
static int CVE_2013_2486_PATCHED_dissect_diagnosticrequest(int anchor, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length) 1
proto_item * ti_local ; 2
proto_tree * local_tree ; 3
guint16 local_offset = 0 ; 4
int hf = hf_reload_diagnosticrequest ; 6
if ( anchor >= 0 )  8
hf = anchor; 9
ti_local = proto_tree_add_item ( tree , hf , tvb , offset , length , ENC_NA ); 12
local_tree = proto_item_add_subtree ( ti_local , ett_reload_diagnosticrequest ); 13
local_offset += 8; 16
local_offset += 8; 19
local_length = tvb_get_ntohl ( tvb , offset + local_offset ); 20
local_offset += 4; 22
local_offset += dissect_dmflag ( tvb , local_tree , offset + local_offset ); 24
if ( local_offset + local_length > length )  25
local_length = length - local_offset; 27
if ( local_length > 0 )  29
proto_item * ti_extensions ; 30
proto_tree * extensions_tree ; 31
guint32 extensions_offset = 0 ; 32
ti_extensions = proto_tree_add_item ( local_tree , hf_reload_diagnosticrequest_extensions , tvb , offset + local_offset , local_length , ENC_NA ); 36
extensions_tree = proto_item_add_subtree ( ti_extensions , ett_reload_diagnosticrequest_extensions ); 37
extensions_length = tvb_get_ntohl ( tvb , offset + local_offset ); 38
if ( extensions_length + 4 > local_length )  39
extensions_length = local_length - 4; 41
while ( extensions_offset < extensions_length )  45
int local_increment = dissect_diagnosticextension ( tvb , pinfo , extensions_tree , offset + 4 + local_offset + extensions_offset , extensions_length - extensions_offset ) ; 46
if ( local_increment <= 0 )  47
extensions_offset += local_increment; 48
------------------------------
837 /home/SySeVR/data/CVE_2013_2850_VULN_iscsi_decode_text_input.c char * tmpptr = key + strlen ( key ) ; 35
int CVE_2013_2850_VULN_iscsi_decode_text_input(
u8 phase,
u8 sender,
char *textbuf,
u32 length,
struct iscsi_conn *conn) 6
struct iscsi_param_list * param_list = conn -> param_list ; 8
tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ); 11
if ( ! tmpbuf )  12
memcpy ( tmpbuf , textbuf , length ); 17
tmpbuf [ length ] = '\0'; 18
start = tmpbuf; 19
end = ( start + length ); 20
while ( start < end )  22
char * key , * value ; 23
struct iscsi_param * param ; 24
if ( iscsi_extract_key_value ( start , & key , & value ) < 0 )  26
if ( phase & PHASE_SECURITY )  33
if ( iscsi_check_for_auth_key ( key ) > 0 )  34
char * tmpptr = key + strlen ( key ) ; 35
* tmpptr = '='; 36
param = iscsi_check_key ( key , phase , sender , param_list ); 42
if ( ! param )  43
if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 )  44
start += strlen ( key ) + strlen ( value ) + 2; 49
if ( iscsi_check_value ( param , value ) < 0 )  52
start += strlen ( key ) + strlen ( value ) + 2; 57
if ( IS_PSTATE_PROPOSER ( param ) )  59
if ( iscsi_check_proposer_state ( param , value ) < 0 )  60
if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 )  66
------------------------------
838 /home/SySeVR/data/CVE_2013_3670_PATCHED_rle_unpack.c unsigned char * dest_end = dest + dest_len ; 8
static int CVE_2013_3670_PATCHED_rle_unpack(const unsigned char *src, int src_len, int src_count,
unsigned char *dest, int dest_len) 2
unsigned char * dest_end = dest + dest_len ; 8
if ( dest_end - pd < l || ps_end - ps < l )  27
if ( dest_end - pd < 2 * l || ps_end - ps < 2 )  33
------------------------------
839 /home/SySeVR/data/CVE_2013_3670_VULN_rle_unpack.c unsigned char * dest_end = dest + dest_len ; 8
static int CVE_2013_3670_VULN_rle_unpack(const unsigned char *src, int src_len, int src_count,
unsigned char *dest, int dest_len) 2
unsigned char * dest_end = dest + dest_len ; 8
if ( dest_end - pd < l || ps_end - ps < l )  27
if ( dest_end - pd < i || ps_end - ps < 2 )  33
------------------------------
840 /home/SySeVR/data/CVE_2013_4153_PATCHED_qemuAgentGetVCPUs.c qemuAgentCPUInfoPtr in = * info + i ; 41
int
CVE_2013_4153_PATCHED_qemuAgentGetVCPUs(qemuAgentPtr mon,
qemuAgentCPUInfoPtr *info) 3
int i ; 6
virJSONValuePtr cmd ; 7
virJSONValuePtr reply = NULL ; 8
int ndata ; 10
if ( ! ( cmd = qemuAgentMakeCommand ( "guest-get-vcpus" , NULL ) ) )  12
if ( qemuAgentCommand ( mon , cmd , & reply , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) < 0 || qemuAgentCheckError ( cmd , reply ) < 0 )  15
if ( ! ( data = virJSONValueObjectGet ( reply , "return" ) ) )  20
if ( data -> type != VIR_JSON_TYPE_ARRAY )  26
ndata = virJSONValueArraySize ( data ); 32
if ( VIR_ALLOC_N ( * info , ndata ) < 0 )  34
for (i = 0; i < ndata; i++) 39
virJSONValuePtr entry = virJSONValueArrayGet ( data , i ) ; 40
qemuAgentCPUInfoPtr in = * info + i ; 41
if ( ! entry )  43
if ( virJSONValueObjectGetNumberUint ( entry , "logical-id" , & in -> id ) < 0 )  50
if ( virJSONValueObjectGetBoolean ( entry , "online" , & in -> online ) < 0 )  56
if ( virJSONValueObjectGetBoolean ( entry , "can-offline" , & in -> offlinable ) < 0 )  62
------------------------------
841 /home/SySeVR/data/CVE_2013_4921_PATCHED_dissect_radiotap.c guint n_bitmaps = ( guint ) ( iter . this_arg - bmap_start ) / 4 ; 85
static void
CVE_2013_4921_PATCHED_dissect_radiotap(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree) 2
guint length ; 12
void * data ; 23
struct ieee80211_radiotap_iterator iter ; 26
static struct radiotap_override overrides [ ] =
IEEE80211_RADIOTAP_XCHANNEL , 4 , 8 , 30
guint n_overrides = array_length ( overrides ) ; 35
if ( ! radiotap_bit14_fcs )  37
n_overrides --; 38
length = tvb_get_letohs ( tvb , 2 ); 46
data = ep_tvb_memdup ( tvb , 0 , length ); 68
if ( ! data )  69
if ( ieee80211_radiotap_iterator_init ( & iter , ( struct ieee80211_radiotap_header * ) data , length , NULL ) )  72
iter . overrides = overrides; 79
iter . n_overrides = n_overrides; 80
if ( tree )  83
guchar * bmap_start = ( guchar * ) data + 4 ; 84
guint n_bitmaps = ( guint ) ( iter . this_arg - bmap_start ) / 4 ; 85
pt = proto_tree_add_item ( radiotap_tree , hf_radiotap_present , tvb , 4 , n_bitmaps * 4 , ENC_NA ); 92
for (i = 0; i < n_bitmaps; i++) 96
present_tree = proto_item_add_subtree ( pt , ett_radiotap_present ); 102
proto_tree_add_item ( present_tree , hf_radiotap_present_tsft , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 129
proto_tree_add_item ( present_tree , hf_radiotap_present_flags , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 132
proto_tree_add_item ( present_tree , hf_radiotap_present_rate , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 135
proto_tree_add_item ( present_tree , hf_radiotap_present_channel , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 138
proto_tree_add_item ( present_tree , hf_radiotap_present_fhss , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 141
proto_tree_add_item ( present_tree , hf_radiotap_present_dbm_antsignal , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 144
proto_tree_add_item ( present_tree , hf_radiotap_present_dbm_antnoise , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 147
proto_tree_add_item ( present_tree , hf_radiotap_present_lock_quality , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 150
proto_tree_add_item ( present_tree , hf_radiotap_present_tx_attenuation , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 153
proto_tree_add_item ( present_tree , hf_radiotap_present_db_tx_attenuation , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 156
proto_tree_add_item ( present_tree , hf_radiotap_present_dbm_tx_power , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 159
proto_tree_add_item ( present_tree , hf_radiotap_present_antenna , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 162
proto_tree_add_item ( present_tree , hf_radiotap_present_db_antsignal , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 165
proto_tree_add_item ( present_tree , hf_radiotap_present_db_antnoise , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 168
proto_tree_add_item ( present_tree , hf_radiotap_present_hdrfcs , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 172
proto_tree_add_item ( present_tree , hf_radiotap_present_rxflags , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 176
proto_tree_add_item ( present_tree , hf_radiotap_present_xchannel , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 180
proto_tree_add_item ( present_tree , hf_radiotap_present_mcs , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 184
proto_tree_add_item ( present_tree , hf_radiotap_present_ampdu , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 187
proto_tree_add_item ( present_tree , hf_radiotap_present_vht , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 190
ti = proto_tree_add_item ( present_tree , hf_radiotap_present_reserved , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 193
expert_add_info_format ( pinfo , ti , PI_UNDECODED , PI_NOTE ,
"Unknown Radiotap fields, code not implemented, "
"Please check radiotap documentation, "
"Contact Wireshark developers if you want this supported" ) 202
proto_tree_add_item ( present_tree , hf_radiotap_present_rtap_ns , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 205
proto_tree_add_item ( present_tree , hf_radiotap_present_vendor_ns , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 208
proto_tree_add_item ( present_tree , hf_radiotap_present_ext , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ); 211
proto_item_append_text ( ti , " (malformed)" ); 951
------------------------------
842 /home/SySeVR/data/CVE_2013_5593_PATCHED_nsComboboxControlFrame__AbsolutelyPositionDropDown.c const nsPoint newPos = dropdownPosition + translation ; 51
nsComboboxControlFrame::DropDownPositionState
CVE_2013_5593_PATCHED_nsComboboxControlFrame::AbsolutelyPositionDropDown() 2
nsPoint translation ; 4
nscoord above , below ; 5
if ( above <= 0 && below <= 0 )  8
nsSize dropdownSize = mDropdownFrame -> GetSize ( ) ; 18
nscoord height = std :: max ( above , below ) ; 19
nsListControlFrame * lcf = static_cast < nsListControlFrame * > mDropdownFrame 20
if ( height < dropdownSize . height )  21
if ( lcf -> GetNumDisplayRows ( ) > 1 )  22
if ( height > ( dropdownSize . height + lcf -> GetHeightOfARow ( ) * 1.5 ) && lcf -> GetDropdownCanGrow ( ) )  28
bool b = dropdownSize . height <= below || dropdownSize . height > above ; 41
nsPoint dropdownPosition ( 0 , b ? GetRect ( ) . height : - dropdownSize . height ) ; 42
if ( StyleVisibility ( ) -> mDirection == NS_STYLE_DIRECTION_RTL )  43
dropdownPosition . x = GetRect ( ) . width - dropdownSize . width; 45
const nsPoint newPos = dropdownPosition + translation ; 51
if ( currentPos != newPos )  52
mDropdownFrame -> SetPosition ( newPos ); 53
------------------------------
843 /home/SySeVR/data/CVE_2013_5593_VULN_nsComboboxControlFrame__AbsolutelyPositionDropDown.c const nsPoint newPos = dropdownPosition + translation ; 50
nsComboboxControlFrame::DropDownPositionState
CVE_2013_5593_VULN_nsComboboxControlFrame::AbsolutelyPositionDropDown() 2
nsPoint translation ; 4
nscoord above , below ; 5
if ( above <= 0 && below <= 0 )  8
nsSize dropdownSize = mDropdownFrame -> GetSize ( ) ; 18
nscoord height = std :: max ( above , below ) ; 19
nsListControlFrame * lcf = static_cast < nsListControlFrame * > mDropdownFrame 20
if ( height < dropdownSize . height )  21
if ( lcf -> GetNumDisplayRows ( ) > 1 )  22
if ( height > ( dropdownSize . height + lcf -> GetHeightOfARow ( ) * 1.5 ) && lcf -> GetDropdownCanGrow ( ) )  28
bool b = dropdownSize . height <= below || below >= above ; 40
nsPoint dropdownPosition ( 0 , b ? GetRect ( ) . height : - dropdownSize . height ) ; 41
if ( StyleVisibility ( ) -> mDirection == NS_STYLE_DIRECTION_RTL )  42
dropdownPosition . x = GetRect ( ) . width - dropdownSize . width; 44
const nsPoint newPos = dropdownPosition + translation ; 50
if ( currentPos != newPos )  51
mDropdownFrame -> SetPosition ( newPos ); 52
------------------------------
844 /home/SySeVR/data/CVE_2013_7010_PATCHED_add_bytes_c.c long b = * ( long * ) ( dst + i ) ; 5
static void CVE_2013_7010_PATCHED_add_bytes_c(uint8_t *dst, uint8_t *src, int w) 1
long i ; 2
for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)) 3
long a = * ( long * ) ( src + i ) ; 4
long b = * ( long * ) ( dst + i ) ; 5
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ); 6
for(; i<w; i++) 8
dst [ i + 0 ] += src [ i + 0 ]; 9
------------------------------
845 /home/SySeVR/data/CVE_2013_7010_PATCHED_add_bytes_c.c long a = * ( long * ) ( src + i ) ; 4
static void CVE_2013_7010_PATCHED_add_bytes_c(uint8_t *dst, uint8_t *src, int w) 1
long i ; 2
for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)) 3
long a = * ( long * ) ( src + i ) ; 4
long b = * ( long * ) ( dst + i ) ; 5
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ); 6
for(; i<w; i++) 8
dst [ i + 0 ] += src [ i + 0 ]; 9
------------------------------
846 /home/SySeVR/data/CVE_2013_7010_PATCHED_diff_bytes_c.c long b = * ( long * ) ( src2 + i ) ; 19
static void CVE_2013_7010_PATCHED_diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w) 1
long i ; 2
if ( ( long ) src2 & ( sizeof ( long ) - 1 ) )  4
for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)) 17
long a = * ( long * ) ( src1 + i ) ; 18
long b = * ( long * ) ( src2 + i ) ; 19
* ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ); 20
for(; i<w; i++) 22
dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ]; 23
------------------------------
847 /home/SySeVR/data/CVE_2013_7010_PATCHED_diff_bytes_c.c long a = * ( long * ) ( src1 + i ) ; 18
static void CVE_2013_7010_PATCHED_diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w) 1
long i ; 2
if ( ( long ) src2 & ( sizeof ( long ) - 1 ) )  4
for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)) 17
long a = * ( long * ) ( src1 + i ) ; 18
long b = * ( long * ) ( src2 + i ) ; 19
* ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ); 20
for(; i<w; i++) 22
dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ]; 23
------------------------------
848 /home/SySeVR/data/CVE_2013_7010_VULN_add_bytes_c.c long b = * ( long * ) ( dst + i ) ; 5
static void CVE_2013_7010_VULN_add_bytes_c(uint8_t *dst, uint8_t *src, int w) 1
long i ; 2
for(i=0; i<=w-sizeof(long); i+=sizeof(long)) 3
long a = * ( long * ) ( src + i ) ; 4
long b = * ( long * ) ( dst + i ) ; 5
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ); 6
for(; i<w; i++) 8
dst [ i + 0 ] += src [ i + 0 ]; 9
------------------------------
849 /home/SySeVR/data/CVE_2013_7010_VULN_add_bytes_c.c long a = * ( long * ) ( src + i ) ; 4
static void CVE_2013_7010_VULN_add_bytes_c(uint8_t *dst, uint8_t *src, int w) 1
long i ; 2
for(i=0; i<=w-sizeof(long); i+=sizeof(long)) 3
long a = * ( long * ) ( src + i ) ; 4
long b = * ( long * ) ( dst + i ) ; 5
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ); 6
for(; i<w; i++) 8
dst [ i + 0 ] += src [ i + 0 ]; 9
------------------------------
850 /home/SySeVR/data/CVE_2013_7010_VULN_diff_bytes_c.c long b = * ( long * ) ( src2 + i ) ; 19
static void CVE_2013_7010_VULN_diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w) 1
long i ; 2
if ( ( long ) src2 & ( sizeof ( long ) - 1 ) )  4
for(i=0; i<=w-sizeof(long); i+=sizeof(long)) 17
long a = * ( long * ) ( src1 + i ) ; 18
long b = * ( long * ) ( src2 + i ) ; 19
* ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ); 20
for(; i<w; i++) 22
dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ]; 23
------------------------------
851 /home/SySeVR/data/CVE_2013_7010_VULN_diff_bytes_c.c long a = * ( long * ) ( src1 + i ) ; 18
static void CVE_2013_7010_VULN_diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w) 1
long i ; 2
if ( ( long ) src2 & ( sizeof ( long ) - 1 ) )  4
for(i=0; i<=w-sizeof(long); i+=sizeof(long)) 17
long a = * ( long * ) ( src1 + i ) ; 18
long b = * ( long * ) ( src2 + i ) ; 19
* ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ); 20
for(; i<w; i++) 22
dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ]; 23
------------------------------
852 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c int size = AV_RB24 ( p - trailer ) ; 129
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
RangeCoder * const c = & f -> slice_context [ 0 ] -> c 5
memset ( state , 128 , sizeof ( state ) ); 7
if ( f -> version < 2 )  9
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
for (i = 1; i < 256; i++) 18
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
f -> packed_at_lsb = 1; 62
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
f -> packed_at_lsb = 1; 72
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
if ( f -> version < 2 )  115
if ( f -> version < 3 )  121
const uint8_t * p = c -> bytestream_end ; 124
for (f->slice_count = 0;
f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
f->slice_count++) 127
int trailer = 3 + 5 * ! ! f -> ec ; 128
int size = AV_RB24 ( p - trailer ) ; 129
if ( size + trailer > p - c -> bytestream_start )  130
p -= size + trailer; 132
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
853 /home/SySeVR/data/CVE_2013_7014_PATCHED_add_bytes_l2_c.c long b = * ( long * ) ( src2 + i ) ; 6
static void CVE_2013_7014_PATCHED_add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w) 1
long i ; 3
for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) 4
long a = * ( long * ) ( src1 + i ) ; 5
long b = * ( long * ) ( src2 + i ) ; 6
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ); 7
for (; i < w; i++) 9
dst [ i ] = src1 [ i ] + src2 [ i ]; 10
------------------------------
854 /home/SySeVR/data/CVE_2013_7014_PATCHED_add_bytes_l2_c.c long a = * ( long * ) ( src1 + i ) ; 5
static void CVE_2013_7014_PATCHED_add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w) 1
long i ; 3
for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) 4
long a = * ( long * ) ( src1 + i ) ; 5
long b = * ( long * ) ( src2 + i ) ; 6
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ); 7
for (; i < w; i++) 9
dst [ i ] = src1 [ i ] + src2 [ i ]; 10
------------------------------
855 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_cleanup.c Jpeg2000Prec * prec = band -> prec + precno ; 13
void CVE_2013_7017_PATCHED_ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty) 1
int reslevelno , bandno , precno ; 3
for (reslevelno = 0;
comp->reslevel && reslevelno < codsty->nreslevels;
reslevelno++) 6
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
for (bandno = 0; bandno < reslevel->nbands; bandno++) 9
Jpeg2000Band * band = reslevel -> band + bandno ; 10
for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) 11
if ( band -> prec )  12
Jpeg2000Prec * prec = band -> prec + precno ; 13
av_freep ( & prec -> zerobits ); 14
av_freep ( & prec -> cblkincl ); 15
av_freep ( & prec -> cblk ); 16
------------------------------
856 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_cleanup.c Jpeg2000Band * band = reslevel -> band + bandno ; 10
void CVE_2013_7017_PATCHED_ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty) 1
int reslevelno , bandno , precno ; 3
for (reslevelno = 0;
comp->reslevel && reslevelno < codsty->nreslevels;
reslevelno++) 6
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
for (bandno = 0; bandno < reslevel->nbands; bandno++) 9
Jpeg2000Band * band = reslevel -> band + bandno ; 10
if ( band -> prec )  12
Jpeg2000Prec * prec = band -> prec + precno ; 13
av_freep ( & prec -> zerobits ); 14
av_freep ( & prec -> cblkincl ); 15
av_freep ( & prec -> cblk ); 16
av_freep ( & band -> prec ); 20
------------------------------
857 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_cleanup.c Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
void CVE_2013_7017_PATCHED_ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty) 1
int reslevelno , bandno , precno ; 3
for (reslevelno = 0;
comp->reslevel && reslevelno < codsty->nreslevels;
reslevelno++) 6
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
for (bandno = 0; bandno < reslevel->nbands; bandno++) 9
Jpeg2000Band * band = reslevel -> band + bandno ; 10
for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) 11
if ( band -> prec )  12
Jpeg2000Prec * prec = band -> prec + precno ; 13
av_freep ( & prec -> zerobits ); 14
av_freep ( & prec -> cblkincl ); 15
av_freep ( & prec -> cblk ); 16
av_freep ( & band -> prec ); 20
av_freep ( & reslevel -> band ); 22
------------------------------
858 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
859 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c Jpeg2000Prec * prec = band -> prec + precno ; 188
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
860 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c Jpeg2000Band * band = reslevel -> band + bandno ; 88
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
861 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
862 /home/SySeVR/data/CVE_2013_7017_PATCHED_ff_jpeg2000_init_component.c int declvl = codsty -> nreslevels - reslevelno ; 40
int CVE_2013_7017_PATCHED_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
863 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_cleanup.c Jpeg2000Prec * prec = band -> prec + precno ; 12
void CVE_2013_7017_VULN_ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty) 1
int reslevelno , bandno , precno ; 3
for (reslevelno = 0;
comp->reslevel && reslevelno < codsty->nreslevels;
reslevelno++) 6
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
for (bandno = 0; bandno < reslevel->nbands; bandno++) 9
Jpeg2000Band * band = reslevel -> band + bandno ; 10
for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) 11
Jpeg2000Prec * prec = band -> prec + precno ; 12
av_freep ( & prec -> zerobits ); 13
av_freep ( & prec -> cblkincl ); 14
av_freep ( & prec -> cblk ); 15
------------------------------
864 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_cleanup.c Jpeg2000Band * band = reslevel -> band + bandno ; 10
void CVE_2013_7017_VULN_ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty) 1
int reslevelno , bandno , precno ; 3
for (reslevelno = 0;
comp->reslevel && reslevelno < codsty->nreslevels;
reslevelno++) 6
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
for (bandno = 0; bandno < reslevel->nbands; bandno++) 9
Jpeg2000Band * band = reslevel -> band + bandno ; 10
Jpeg2000Prec * prec = band -> prec + precno ; 12
av_freep ( & prec -> zerobits ); 13
av_freep ( & prec -> cblkincl ); 14
av_freep ( & prec -> cblk ); 15
av_freep ( & band -> prec ); 18
------------------------------
865 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_cleanup.c Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
void CVE_2013_7017_VULN_ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty) 1
int reslevelno , bandno , precno ; 3
for (reslevelno = 0;
comp->reslevel && reslevelno < codsty->nreslevels;
reslevelno++) 6
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 7
for (bandno = 0; bandno < reslevel->nbands; bandno++) 9
Jpeg2000Band * band = reslevel -> band + bandno ; 10
for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) 11
Jpeg2000Prec * prec = band -> prec + precno ; 12
av_freep ( & prec -> zerobits ); 13
av_freep ( & prec -> cblkincl ); 14
av_freep ( & prec -> cblk ); 15
av_freep ( & band -> prec ); 18
av_freep ( & reslevel -> band ); 20
------------------------------
866 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
867 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c Jpeg2000Prec * prec = band -> prec + precno ; 188
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
868 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c Jpeg2000Band * band = reslevel -> band + bandno ; 88
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
869 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
870 /home/SySeVR/data/CVE_2013_7017_VULN_ff_jpeg2000_init_component.c int declvl = codsty -> nreslevels - reslevelno ; 40
int CVE_2013_7017_VULN_ff_jpeg2000_init_component(Jpeg2000Component *comp,
Jpeg2000CodingStyle *codsty,
Jpeg2000QuantStyle *qntsty,
int cbps, int dx, int dy,
AVCodecContext *avctx) 5
uint8_t log2_band_prec_width , log2_band_prec_height ; 7
int reslevelno , bandno , gbandno = 0 , ret , i , j ; 8
uint32_t csize ; 9
if ( codsty -> nreslevels2decode <= 0 )  11
if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) )  16
csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ); 21
if ( codsty -> transform == FF_DWT97 )  24
comp -> i_data = NULL; 25
comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ); 26
if ( ! comp -> f_data )  27
comp -> f_data = NULL; 30
comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ); 31
if ( ! comp -> i_data )  32
comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ); 35
if ( ! comp -> reslevel )  36
for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) 39
int declvl = codsty -> nreslevels - reslevelno ; 40
Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; 41
for (i = 0; i < 2; i++) 46
for (j = 0; j < 2; j++) 47
reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ); 48
reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ]; 51
reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ]; 52
if ( reslevelno == 0 )  55
reslevel -> nbands = 1; 56
reslevel -> nbands = 3; 58
if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] )  67
reslevel -> num_precincts_x = 0; 68
reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ); 70
if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] )  75
reslevel -> num_precincts_y = 0; 76
reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ); 78
reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ); 83
if ( ! reslevel -> band )  84
for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) 87
Jpeg2000Band * band = reslevel -> band + bandno ; 88
int cblkno , precno ; 89
int nb_precincts ; 90
switch ( qntsty -> quantsty )  94
band -> f_stepsize = 1; 99
numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ]; 103
band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ); 105
gain = cbps; 117
band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ); 118
band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0; 119
band -> f_stepsize = 0; 122
if ( ! av_codec_is_encoder ( avctx -> codec ) )  128
band -> f_stepsize *= 0.5; 129
band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ); 131
if ( reslevelno == 0 )  137
for (i = 0; i < 2; i++) 139
for (j = 0; j < 2; j++) 140
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ); 141
log2_band_prec_width = reslevel -> log2_prec_width; 144
log2_band_prec_height = reslevel -> log2_prec_height; 145
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ); 147
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ); 149
for (i = 0; i < 2; i++) 154
for (j = 0; j < 2; j++) 155
band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ); 157
band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ); 165
band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ); 167
log2_band_prec_width = reslevel -> log2_prec_width - 1; 170
log2_band_prec_height = reslevel -> log2_prec_height - 1; 171
for (j = 0; j < 2; j++) 174
band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ); 175
for (j = 0; j < 2; j++) 176
band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ); 177
band -> prec = av_malloc_array ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ); 179
if ( ! band -> prec )  182
nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y; 185
for (precno = 0; precno < nb_precincts; precno++) 187
Jpeg2000Prec * prec = band -> prec + precno ; 188
prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ); 194
prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ); 196
prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ); 199
prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ); 201
prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ); 204
prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ); 206
prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ); 209
prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ); 211
prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ); 213
prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ); 217
prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 223
if ( ! prec -> cblkincl )  226
prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ); 229
if ( ! prec -> zerobits )  232
prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ); 235
if ( ! prec -> cblk )  238
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 240
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 241
Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width; 246
Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ); 247
cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ); 248
Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height; 251
Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ); 252
cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ); 253
cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ); 256
cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ); 260
cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 264
cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ]; 266
cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 270
cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ]; 272
cblk -> zero = 0; 276
cblk -> lblock = 3; 277
cblk -> length = 0; 278
cblk -> lengthinc = 0; 279
cblk -> npasses = 0; 280
------------------------------
871 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
* buf = pc -> buffer; 47
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 60
------------------------------
872 /home/SySeVR/data/CVE_2013_7023_VULN_ff_combine_frame.c void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
int CVE_2013_7023_VULN_ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) 1
for(; pc->overread>0; pc->overread--) 10
pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ]; 11
if ( ! * buf_size && next == END_NOT_FOUND )  15
next = 0; 16
pc -> last_index = pc -> index; 19
if ( next == END_NOT_FOUND )  22
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 23
if ( ! new_buffer )  25
pc -> buffer = new_buffer; 27
memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ); 28
pc -> index += * buf_size; 29
* buf_size = pc -> overread_index = pc -> index + next; 33
if ( pc -> index )  37
void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; 38
if ( ! new_buffer )  40
pc -> buffer = new_buffer; 42
memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ); 44
pc -> index = 0; 46
* buf = pc -> buffer; 47
pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ]; 52
pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ]; 53
pc -> overread ++; 54
if ( pc -> overread )  57
av_dlog ( NULL , "overread %d, state:%X next:%d index:%d o_index:%d\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ); 58
av_dlog ( NULL , "%X %X %X %X\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ); 60
------------------------------
873 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 120
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 118
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 120
if ( codsty -> transform == FF_DWT97 )  140
------------------------------
874 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 119
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 118
Jpeg2000Component * comp = tile -> comp + compno ; 119
float * datap = comp -> f_data ; 121
int32_t * i_datap = comp -> i_data ; 122
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 142
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 144
* dst = val << ( 16 - cbps ); 146
datap ++; 147
dst += pixelsize; 148
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 152
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 154
* dst = val << ( 16 - cbps ); 156
i_datap ++; 157
dst += pixelsize; 158
------------------------------
875 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 74
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 74
if ( codsty -> transform == FF_DWT97 )  95
------------------------------
876 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 73
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
int x , y ; 5
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
int x , y ; 37
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
x = cblk -> coord [ 0 ] [ 0 ]; 44
if ( s -> cdef [ 0 ] < 0 )  64
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
Jpeg2000Component * comp = tile -> comp + compno ; 73
float * datap = comp -> f_data ; 75
int32_t * i_datap = comp -> i_data ; 76
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 97
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 99
* dst = val << ( 8 - cbps ); 100
datap ++; 101
dst += pixelsize; 102
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 106
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 108
* dst = val << ( 8 - cbps ); 109
i_datap ++; 110
dst += pixelsize; 111
------------------------------
877 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 39
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
dequantization_float ( x , y , cblk , comp , & t1 , band ); 48
dequantization_int ( x , y , cblk , comp , & t1 , band ); 50
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int cbps = s -> cbps [ compno ] ; 77
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 78
int pixelsize = planar ? 1 : s -> ncomponents ; 80
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 89
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 92
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
for (; x < w; x += s->cdx[compno]) 96
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 97
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 99
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
for (; x < w; x += s->cdx[compno]) 105
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 106
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 108
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
for (compno = 0; compno < s->ncomponents; compno++) 118
int cbps = s -> cbps [ compno ] ; 124
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 125
int pixelsize = planar ? 1 : s -> ncomponents ; 127
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 135
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 138
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
for (; x < w; x += s-> cdx[compno]) 141
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 142
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 144
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
for (; x < w; x += s-> cdx[compno]) 151
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 152
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 154
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
878 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000Prec * prec = band -> prec + precno ; 33
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
int nb_precincts , precno ; 20
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 39
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
dequantization_float ( x , y , cblk , comp , & t1 , band ); 48
dequantization_int ( x , y , cblk , comp , & t1 , band ); 50
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int cbps = s -> cbps [ compno ] ; 77
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 78
int pixelsize = planar ? 1 : s -> ncomponents ; 80
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 89
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 92
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
for (; x < w; x += s->cdx[compno]) 96
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 97
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 99
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
for (; x < w; x += s->cdx[compno]) 105
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 106
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 108
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
for (compno = 0; compno < s->ncomponents; compno++) 118
int cbps = s -> cbps [ compno ] ; 124
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 125
int pixelsize = planar ? 1 : s -> ncomponents ; 127
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 135
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 138
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
for (; x < w; x += s-> cdx[compno]) 141
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 142
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 144
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
for (; x < w; x += s-> cdx[compno]) 151
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 152
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 154
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
879 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000Band * band = rlevel -> band + bandno ; 21
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 39
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
dequantization_float ( x , y , cblk , comp , & t1 , band ); 48
dequantization_int ( x , y , cblk , comp , & t1 , band ); 50
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int cbps = s -> cbps [ compno ] ; 77
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 78
int pixelsize = planar ? 1 : s -> ncomponents ; 80
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 89
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 92
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
for (; x < w; x += s->cdx[compno]) 96
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 97
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 99
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
for (; x < w; x += s->cdx[compno]) 105
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 106
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 108
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
for (compno = 0; compno < s->ncomponents; compno++) 118
int cbps = s -> cbps [ compno ] ; 124
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 125
int pixelsize = planar ? 1 : s -> ncomponents ; 127
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 135
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 138
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
for (; x < w; x += s-> cdx[compno]) 141
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 142
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 144
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
for (; x < w; x += s-> cdx[compno]) 151
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 152
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 154
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
880 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 39
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
dequantization_float ( x , y , cblk , comp , & t1 , band ); 48
dequantization_int ( x , y , cblk , comp , & t1 , band ); 50
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int cbps = s -> cbps [ compno ] ; 77
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 78
int pixelsize = planar ? 1 : s -> ncomponents ; 80
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 89
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 92
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
for (; x < w; x += s->cdx[compno]) 96
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 97
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 99
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
for (; x < w; x += s->cdx[compno]) 105
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 106
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 108
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
for (compno = 0; compno < s->ncomponents; compno++) 118
int cbps = s -> cbps [ compno ] ; 124
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 125
int pixelsize = planar ? 1 : s -> ncomponents ; 127
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 135
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 138
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
for (; x < w; x += s-> cdx[compno]) 141
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 142
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 144
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
for (; x < w; x += s-> cdx[compno]) 151
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 152
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 154
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
881 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; 13
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) 16
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 39
if ( codsty -> transform == FF_DWT97 )  47
ff_dwt_decode ( & comp -> dwt , codsty -> transform == FF_DWT97 ? ( void * ) comp -> f_data : ( void * ) comp -> i_data ); 57
------------------------------
882 /home/SySeVR/data/CVE_2013_7024_PATCHED_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 12
static int CVE_2013_7024_PATCHED_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
AVFrame *picture) 2
int compno , reslevelno , bandno ; 4
for (compno = 0; compno < s->ncomponents; compno++) 11
Jpeg2000Component * comp = tile -> comp + compno ; 12
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; 17
for (bandno = 0; bandno < rlevel->nbands; bandno++) 19
Jpeg2000Band * band = rlevel -> band + bandno ; 21
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )  26
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y; 30
for (precno = 0; precno < nb_precincts; precno++) 32
Jpeg2000Prec * prec = band -> prec + precno ; 33
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) 36
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; 38
decode_cblk ( s , codsty , & t1 , cblk , cblk -> coord [ 0 ] [ 1 ] - cblk -> coord [ 0 ] [ 0 ] , cblk -> coord [ 1 ] [ 1 ] - cblk -> coord [ 1 ] [ 0 ] , bandpos ); 39
x = cblk -> coord [ 0 ] [ 0 ]; 44
y = cblk -> coord [ 1 ] [ 0 ]; 45
dequantization_float ( x , y , cblk , comp , & t1 , band ); 48
dequantization_int ( x , y , cblk , comp , & t1 , band ); 50
ff_dwt_decode ( & comp -> dwt , codsty -> transform == FF_DWT97 ? ( void * ) comp -> f_data : ( void * ) comp -> i_data ); 57
for (x = 0; x < s->ncomponents; x++) 65
s -> cdef [ x ] = x + 1; 66
if ( ( s -> ncomponents & 1 ) == 0 )  67
s -> cdef [ s -> ncomponents - 1 ] = 0; 68
if ( s -> precision <= 8 )  71
for (compno = 0; compno < s->ncomponents; compno++) 72
int cbps = s -> cbps [ compno ] ; 77
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 78
int pixelsize = planar ? 1 : s -> ncomponents ; 80
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 84
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 87
line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ]; 88
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 89
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 92
dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar; 93
for (; x < w; x += s->cdx[compno]) 96
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 97
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 99
* dst = val << ( 8 - cbps ); 100
dst += pixelsize; 102
for (; x < w; x += s->cdx[compno]) 105
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 106
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 108
* dst = val << ( 8 - cbps ); 109
dst += pixelsize; 111
line += picture -> linesize [ plane ]; 114
for (compno = 0; compno < s->ncomponents; compno++) 118
int cbps = s -> cbps [ compno ] ; 124
int w = tile -> comp [ compno ] . coord [ 0 ] [ 1 ] - s -> image_offset_x ; 125
int pixelsize = planar ? 1 : s -> ncomponents ; 127
plane = s -> cdef [ compno ] ? s -> cdef [ compno ] - 1 : ( s -> ncomponents - 1 ); 131
y = tile -> comp [ compno ] . coord [ 1 ] [ 0 ] - s -> image_offset_y; 133
linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ); 134
for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) 135
x = tile -> comp [ compno ] . coord [ 0 ] [ 0 ] - s -> image_offset_x; 138
dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ); 139
for (; x < w; x += s-> cdx[compno]) 141
int val = lrintf ( * datap ) + ( 1 << ( cbps - 1 ) ) ; 142
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 144
* dst = val << ( 16 - cbps ); 146
dst += pixelsize; 148
for (; x < w; x += s-> cdx[compno]) 151
int val = * i_datap + ( 1 << ( cbps - 1 ) ) ; 152
val = av_clip ( val , 0 , ( 1 << cbps ) - 1 ); 154
* dst = val << ( 16 - cbps ); 156
dst += pixelsize; 158
linel += picture -> linesize [ plane ] >> 1; 161
------------------------------
883 /home/SySeVR/data/CVE_2014_0221_PATCHED_dtls1_get_message_fragment.c unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ; 86
static long
CVE_2014_0221_PATCHED_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
unsigned long len , frag_off , frag_len ; 5
int i , al ; 6
struct hm_header_st msg_hdr ; 7
if ( ( frag_len = dtls1_retrieve_buffered_fragment ( s , max , ok ) ) || * ok )  11
if ( * ok )  13
s -> init_num = frag_len; 13
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 18
if ( i <= 0 )  20
s -> rwstate = SSL_READING; 22
if ( i != DTLS1_HM_HEADER_LENGTH )  27
if ( msg_hdr . seq != s -> d1 -> handshake_read_seq && ! ( s -> d1 -> listen && msg_hdr . seq == 1 ) )  43
len = msg_hdr . msg_len; 46
frag_len = msg_hdr . frag_len; 48
if ( frag_len && frag_len < len )  50
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  53
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  60
s -> init_num = 0; 67
if ( al = dtls1_preprocess_fragment ( s , & msg_hdr , max ) )  78
s -> state = stn; 82
if ( frag_len > 0 )  84
unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ; 86
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , & p [ frag_off ] , frag_len , 0 ); 88
if ( i <= 0 )  91
return i ; 95
if ( i != ( int ) frag_len )  103
------------------------------
884 /home/SySeVR/data/CVE_2014_0221_VULN_dtls1_get_message_fragment.c unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ; 86
static long
CVE_2014_0221_VULN_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
unsigned long len , frag_off , frag_len ; 5
int i , al ; 6
struct hm_header_st msg_hdr ; 7
if ( ( frag_len = dtls1_retrieve_buffered_fragment ( s , max , ok ) ) || * ok )  10
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 17
if ( i <= 0 )  19
if ( i != DTLS1_HM_HEADER_LENGTH )  26
if ( msg_hdr . seq != s -> d1 -> handshake_read_seq && ! ( s -> d1 -> listen && msg_hdr . seq == 1 ) )  42
len = msg_hdr . msg_len; 45
frag_len = msg_hdr . frag_len; 47
if ( frag_len && frag_len < len )  49
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  52
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  59
return CVE_2014_0221_VULN_dtls1_get_message_fragment ( s , st1 , stn , max , ok ) ; 67
static long
CVE_2014_0221_VULN_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
unsigned long len , frag_off , frag_len ; 5
int i , al ; 6
struct hm_header_st msg_hdr ; 7
if ( ( frag_len = dtls1_retrieve_buffered_fragment ( s , max , ok ) ) || * ok )  10
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 17
if ( i <= 0 )  19
if ( i != DTLS1_HM_HEADER_LENGTH )  26
if ( msg_hdr . seq != s -> d1 -> handshake_read_seq && ! ( s -> d1 -> listen && msg_hdr . seq == 1 ) )  42
len = msg_hdr . msg_len; 45
frag_len = msg_hdr . frag_len; 47
if ( frag_len && frag_len < len )  49
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  52
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  59
return CVE_2014_0221_VULN_dtls1_get_message_fragment ( s , st1 , stn , max , ok ) ; 67
static long
CVE_2014_0221_VULN_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
unsigned long len , frag_off , frag_len ; 5
int i , al ; 6
struct hm_header_st msg_hdr ; 7
if ( ( frag_len = dtls1_retrieve_buffered_fragment ( s , max , ok ) ) || * ok )  10
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 17
if ( i <= 0 )  19
if ( i != DTLS1_HM_HEADER_LENGTH )  26
if ( msg_hdr . seq != s -> d1 -> handshake_read_seq && ! ( s -> d1 -> listen && msg_hdr . seq == 1 ) )  42
len = msg_hdr . msg_len; 45
frag_len = msg_hdr . frag_len; 47
if ( frag_len && frag_len < len )  49
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  52
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  59
return CVE_2014_0221_VULN_dtls1_get_message_fragment ( s , st1 , stn , max , ok ) ; 67
static long
CVE_2014_0221_VULN_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
unsigned long len , frag_off , frag_len ; 5
int i , al ; 6
struct hm_header_st msg_hdr ; 7
if ( ( frag_len = dtls1_retrieve_buffered_fragment ( s , max , ok ) ) || * ok )  10
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 17
if ( i <= 0 )  19
if ( i != DTLS1_HM_HEADER_LENGTH )  26
if ( msg_hdr . seq != s -> d1 -> handshake_read_seq && ! ( s -> d1 -> listen && msg_hdr . seq == 1 ) )  42
len = msg_hdr . msg_len; 45
frag_len = msg_hdr . frag_len; 47
if ( frag_len && frag_len < len )  49
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  52
if ( al = dtls1_preprocess_fragment ( s , & msg_hdr , max ) )  78
s -> state = stn; 82
if ( frag_len > 0 )  84
unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ; 86
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , & p [ frag_off ] , frag_len , 0 ); 88
if ( i <= 0 )  91
return i ; 95
if ( i != ( int ) frag_len )  103
------------------------------
885 /home/SySeVR/data/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c gfxFloat h = H * f ; 51
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ; 13
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat h = H * f ; 51
gfxCtx -> Line ( rect . BottomLeft ( ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) ); 55
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
------------------------------
886 /home/SySeVR/data/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c gfxFloat w = W * f ; 51
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ; 13
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxCtx -> Line ( rect . BottomLeft ( ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) ); 55
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
------------------------------
887 /home/SySeVR/data/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ; 13
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxFloat h = H * f ; 51
gfxCtx -> Line ( rect . BottomLeft ( ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) ); 55
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
------------------------------
888 /home/SySeVR/data/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c gfxFloat l = sqrt ( W * W + H * H ) ; 49
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxFloat h = H * f ; 51
gfxCtx -> Line ( rect . BottomLeft ( ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) ); 55
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
------------------------------
889 /home/SySeVR/data/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
rect . Deflate ( e / 2.0 ); 17
gfxCtx -> Ellipse ( rect . Center ( ) , rect . Size ( ) ); 23
gfxCtx -> RoundedRectangle ( rect , gfxCornerSizes ( 3 * e ) , true ); 29
gfxCtx -> Line ( rect . BottomLeft ( ) , rect . TopRight ( ) ); 35
gfxCtx -> Line ( rect . TopLeft ( ) , rect . BottomRight ( ) ); 41
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxFloat h = H * f ; 51
gfxCtx -> Line ( rect . BottomLeft ( ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) ); 55
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
------------------------------
890 /home/SySeVR/data/CVE_2014_1522_VULN_ComputeCustom.c float higher = sampleInterpolationFactor * higherWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * higherWaveData [ j2 ] ; 34
void CVE_2014_1522_VULN_ComputeCustom(float* aOutput,
TrackTicks ticks,
uint32_t aStart,
uint32_t aEnd) 4
uint32_t periodicWaveSize = mPeriodicWave -> periodicWaveSize ( ) ; 8
float * higherWaveData = nullptr ; 9
float rate = 1.0 / mSource -> SampleRate ( ) ; 12
for (uint32_t i = aStart; i < aEnd; ++i) 14
mPhase += periodicWaveSize * mFinalFrequency * rate; 21
if ( mPhase >= periodicWaveSize )  22
mPhase -= periodicWaveSize; 23
uint32_t j1 = floor ( mPhase ) ; 26
uint32_t j2 = j1 + 1 ; 27
if ( j2 >= periodicWaveSize )  28
j2 -= periodicWaveSize; 29
float sampleInterpolationFactor = mPhase - j1 ; 31
float higher = sampleInterpolationFactor * higherWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * higherWaveData [ j2 ] ; 34
aOutput [ i ] = tableInterpolationFactor * lower + ( 1 - tableInterpolationFactor ) * higher; 36
------------------------------
891 /home/SySeVR/data/CVE_2014_1522_VULN_ComputeCustom.c float lower = sampleInterpolationFactor * lowerWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * lowerWaveData [ j2 ] ; 32
void CVE_2014_1522_VULN_ComputeCustom(float* aOutput,
TrackTicks ticks,
uint32_t aStart,
uint32_t aEnd) 4
uint32_t periodicWaveSize = mPeriodicWave -> periodicWaveSize ( ) ; 8
float * lowerWaveData = nullptr ; 10
float rate = 1.0 / mSource -> SampleRate ( ) ; 12
for (uint32_t i = aStart; i < aEnd; ++i) 14
mPhase += periodicWaveSize * mFinalFrequency * rate; 21
if ( mPhase >= periodicWaveSize )  22
mPhase -= periodicWaveSize; 23
uint32_t j1 = floor ( mPhase ) ; 26
uint32_t j2 = j1 + 1 ; 27
if ( j2 >= periodicWaveSize )  28
j2 -= periodicWaveSize; 29
float sampleInterpolationFactor = mPhase - j1 ; 31
float lower = sampleInterpolationFactor * lowerWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * lowerWaveData [ j2 ] ; 32
aOutput [ i ] = tableInterpolationFactor * lower + ( 1 - tableInterpolationFactor ) * higher; 36
------------------------------
892 /home/SySeVR/data/CVE_2014_1522_VULN_ComputeCustom.c float sampleInterpolationFactor = mPhase - j1 ; 31
void CVE_2014_1522_VULN_ComputeCustom(float* aOutput,
TrackTicks ticks,
uint32_t aStart,
uint32_t aEnd) 4
uint32_t periodicWaveSize = mPeriodicWave -> periodicWaveSize ( ) ; 8
float rate = 1.0 / mSource -> SampleRate ( ) ; 12
for (uint32_t i = aStart; i < aEnd; ++i) 14
mPhase += periodicWaveSize * mFinalFrequency * rate; 21
if ( mPhase >= periodicWaveSize )  22
mPhase -= periodicWaveSize; 23
uint32_t j1 = floor ( mPhase ) ; 26
float sampleInterpolationFactor = mPhase - j1 ; 31
float lower = sampleInterpolationFactor * lowerWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * lowerWaveData [ j2 ] ; 32
float higher = sampleInterpolationFactor * higherWaveData [ j1 ] + ( 1 - sampleInterpolationFactor ) * higherWaveData [ j2 ] ; 34
aOutput [ i ] = tableInterpolationFactor * lower + ( 1 - tableInterpolationFactor ) * higher; 36
------------------------------
893 /home/SySeVR/data/CVE_2014_2523_VULN_dccp_error.c unsigned int dccp_len = skb -> len - dataoff ; 7
static int CVE_2014_2523_VULN_dccp_error(struct net *net, struct nf_conn *tmpl,
struct sk_buff *skb, unsigned int dataoff,
enum ip_conntrack_info *ctinfo,
u_int8_t pf, unsigned int hooknum) 4
unsigned int dccp_len = skb -> len - dataoff ; 7
if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len )  17
cscov = dccp_len; 23
if ( cscov > dccp_len )  26
if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) )  32
------------------------------
894 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c unsigned char * oe = op + t ; 156
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
ip = ie; 52
op = oe; 53
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
op += 8; 133
op += 8; 136
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
op += next; 143
ip += next; 144
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
op += t; 172
ip += t; 173
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
------------------------------
895 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c unsigned char * oe = op + t ; 129
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
COPY8 ( op , ip ); 45
op += 8; 46
ip += 8; 47
COPY8 ( op , ip ); 48
op += 8; 49
ip += 8; 50
while ( ip < ie )  51
ip = ie; 52
op = oe; 53
NEED_OP ( t ); 57
NEED_IP ( t + 3 ); 58
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
TEST_LB ( m_pos ); 70
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
TEST_LB ( m_pos ); 126
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
COPY8 ( op , m_pos ); 132
op += 8; 133
m_pos += 8; 134
COPY8 ( op , m_pos ); 135
op += 8; 136
m_pos += 8; 137
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
COPY4 ( op , ip ); 142
op += next; 143
ip += next; 144
NEED_OP ( t ); 148
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
NEED_OP ( t ); 157
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
COPY4 ( op , ip ); 171
op += t; 172
ip += t; 173
NEED_IP ( t + 3 ); 177
NEED_OP ( t ); 178
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; 188
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
896 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c unsigned char * oe = op + t ; 43
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
COPY8 ( op , ip ); 45
op += 8; 46
ip += 8; 47
COPY8 ( op , ip ); 48
op += 8; 49
ip += 8; 50
while ( ip < ie )  51
ip = ie; 52
op = oe; 53
NEED_OP ( t ); 57
NEED_IP ( t + 3 ); 58
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
TEST_LB ( m_pos ); 70
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
TEST_LB ( m_pos ); 126
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
COPY8 ( op , m_pos ); 132
op += 8; 133
m_pos += 8; 134
COPY8 ( op , m_pos ); 135
op += 8; 136
m_pos += 8; 137
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
COPY4 ( op , ip ); 142
op += next; 143
ip += next; 144
NEED_OP ( t ); 148
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
NEED_OP ( t ); 157
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
COPY4 ( op , ip ); 171
op += t; 172
ip += t; 173
NEED_IP ( t + 3 ); 177
NEED_OP ( t ); 178
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; 188
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
897 /home/SySeVR/data/CVE_2014_4608_VULN_lzo1x_decompress_safe.c const unsigned char * ie = ip + t ; 42
int CVE_2014_4608_VULN_lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
unsigned char *out, size_t *out_len) 2
unsigned char * op ; 4
const unsigned char * ip ; 5
size_t t , next ; 6
size_t state = 0 ; 7
const unsigned char * m_pos ; 8
op = out; 12
ip = in; 13
if ( unlikely ( in_len < 3 ) )  15
if ( * ip > 17 )  17
t = * ip ++ - 17; 18
if ( t < 4 )  19
next = t; 20
t = * ip ++; 27
if ( t < 16 )  28
if ( likely ( state == 0 ) )  29
if ( unlikely ( t == 0 ) )  30
while ( unlikely ( * ip == 0 ) )  31
t += 255; 32
ip ++; 33
t += 15 + * ip ++; 36
t += 3; 38
if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) )  41
const unsigned char * ie = ip + t ; 42
unsigned char * oe = op + t ; 43
COPY8 ( op , ip ); 45
op += 8; 46
ip += 8; 47
COPY8 ( op , ip ); 48
op += 8; 49
ip += 8; 50
while ( ip < ie )  51
ip = ie; 52
op = oe; 53
NEED_OP ( t ); 57
NEED_IP ( t + 3 ); 58
* op ++ = * ip ++; 60
while ( -- t > 0 )  61
state = 4; 63
if ( state != 4 )  65
next = t & 3; 66
m_pos = op - 1; 67
m_pos -= t >> 2; 68
m_pos -= * ip ++ << 2; 69
TEST_LB ( m_pos ); 70
op [ 0 ] = m_pos [ 0 ]; 72
op [ 1 ] = m_pos [ 1 ]; 73
op += 2; 74
next = t & 3; 77
m_pos = op - ( 1 + M2_MAX_OFFSET ); 78
m_pos -= t >> 2; 79
m_pos -= * ip ++ << 2; 80
t = 3; 81
if ( t >= 64 )  83
next = t & 3; 84
m_pos = op - 1; 85
m_pos -= ( t >> 2 ) & 7; 86
m_pos -= * ip ++ << 3; 87
t = ( t >> 5 ) - 1 + ( 3 - 1 ); 88
if ( t >= 32 )  89
t = ( t & 31 ) + ( 3 - 1 ); 90
if ( unlikely ( t == 2 ) )  91
while ( unlikely ( * ip == 0 ) )  92
t += 255; 93
ip ++; 94
t += 31 + * ip ++; 97
m_pos = op - 1; 100
next = get_unaligned_le16 ( ip ); 101
ip += 2; 102
m_pos -= next >> 2; 103
next &= 3; 104
m_pos = op; 106
m_pos -= ( t & 8 ) << 11; 107
t = ( t & 7 ) + ( 3 - 1 ); 108
if ( unlikely ( t == 2 ) )  109
while ( unlikely ( * ip == 0 ) )  110
t += 255; 111
ip ++; 112
t += 7 + * ip ++; 115
next = get_unaligned_le16 ( ip ); 118
ip += 2; 119
m_pos -= next >> 2; 120
next &= 3; 121
if ( m_pos == op )  122
m_pos -= 0x4000; 124
TEST_LB ( m_pos ); 126
if ( op - m_pos >= 8 )  128
unsigned char * oe = op + t ; 129
if ( likely ( HAVE_OP ( t + 15 ) ) )  130
COPY8 ( op , m_pos ); 132
op += 8; 133
m_pos += 8; 134
COPY8 ( op , m_pos ); 135
op += 8; 136
m_pos += 8; 137
while ( op < oe )  138
op = oe; 139
if ( HAVE_IP ( 6 ) )  140
state = next; 141
COPY4 ( op , ip ); 142
op += next; 143
ip += next; 144
NEED_OP ( t ); 148
* op ++ = * m_pos ++; 150
while ( op < oe )  151
unsigned char * oe = op + t ; 156
NEED_OP ( t ); 157
op [ 0 ] = m_pos [ 0 ]; 158
op [ 1 ] = m_pos [ 1 ]; 159
op += 2; 160
m_pos += 2; 161
* op ++ = * m_pos ++; 163
while ( op < oe )  164
state = next; 167
t = next; 168
if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) )  170
COPY4 ( op , ip ); 171
op += t; 172
ip += t; 173
NEED_IP ( t + 3 ); 177
NEED_OP ( t ); 178
while ( t > 0 )  179
* op ++ = * ip ++; 180
t --; 181
* out_len = op - out; 187
return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; 188
* out_len = op - out; 193
* out_len = op - out; 197
* out_len = op - out; 201
------------------------------
898 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 168
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  160
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  161
if ( s -> ham )  166
for (y = 0; y < avctx->height ; y++) 167
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 168
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 170
------------------------------
899 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 163
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  160
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  161
for(y = 0; y < avctx->height ; y++ ) 162
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 163
buf += decode_byterun ( row , avctx -> width , buf , buf_end ); 164
------------------------------
900 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 152
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for(y = 0; y < avctx->height ; y++ ) 151
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 152
memset ( row , 0 , avctx -> width << 2 ); 153
decodeplane32 ( ( uint32_t * ) row , s -> planebuf , s -> planesize , plane ); 156
------------------------------
901 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 142
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
if ( s -> ham )  140
for (y = 0; y < avctx->height ; y++) 141
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 142
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 148
------------------------------
902 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 132
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
if ( avctx -> bits_per_coded_sample <= 8 )  130
for (y = 0; y < avctx->height ; y++ ) 131
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 132
lookup_pal_indicies ( ( uint32_t * ) row , s -> mask_buf , s -> mask_palbuf , avctx -> width ); 138
------------------------------
903 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 123
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  120
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  121
for(y = 0; y < avctx->height ; y++ ) 122
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 123
memset ( row , 0 , avctx -> width ); 124
decodeplane8 ( row , s -> planebuf , s -> planesize , plane ); 127
------------------------------
904 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 110
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
if ( s -> ham )  108
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 110
buf += avctx -> width + ( avctx -> width & 1 ); 112
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
------------------------------
905 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 104
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> codec_tag == MKTAG ( 'P' , 'B' , 'M' , ' ' ) )  101
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  102
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 104
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
buf += avctx -> width + ( avctx -> width % 2 ); 106
------------------------------
906 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 93
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for(y = 0; y < avctx->height; y++ ) 92
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 93
memset ( row , 0 , avctx -> width << 2 ); 94
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
------------------------------
907 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 83
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
if ( s -> ham )  81
for (y = 0; y < avctx->height; y++) 82
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 83
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 89
------------------------------
908 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 74
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
if ( avctx -> codec_tag == MKTAG ( 'I' , 'L' , 'B' , 'M' ) )  71
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  72
for(y = 0; y < avctx->height; y++ ) 73
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 74
memset ( row , 0 , avctx -> width ); 75
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
------------------------------
909 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 63
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> codec_tag == MKTAG ( 'D' , 'E' , 'E' , 'P' ) )  58
const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; 59
int raw_width = avctx -> width * ( av_get_bits_per_pixel ( desc ) >> 3 ) ; 60
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 63
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
buf += raw_width; 65
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
------------------------------
910 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c const uint8_t * start = buf + ( plane * avctx -> height + y ) * s -> planesize ; 49
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
for(y = 0; y < avctx->height; y++) 45
memset ( s -> ham_buf , 0 , s -> planesize * 8 ); 47
for (plane = 0; plane < s->bpp; plane++) 48
const uint8_t * start = buf + ( plane * avctx -> height + y ) * s -> planesize ; 49
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
------------------------------
911 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 46
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
if ( s -> ham )  43
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 44
for(y = 0; y < avctx->height; y++) 45
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 46
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 54
------------------------------
912 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 38
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
IffContext * s = avctx -> priv_data ; 5
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
int y , plane , res ; 9
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )  12
if ( s -> init )  14
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )  15
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )  19
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  22
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )  23
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )  25
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )  26
s -> init = 1; 29
switch ( s -> compression )  31
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )  33
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )  34
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] ); 35
for (plane = 0; plane < s->bpp; plane++) 36
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 37
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 38
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
buf += s -> planesize; 40
------------------------------
913 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c const uint8_t * buf_end = buf + buf_size ; 8
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 37
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 76
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 85
decodeplane8 ( s -> ham_buf , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 86
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 95
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
memcpy ( s -> ham_buf , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 111
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 126
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 135
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 145
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 155
buf += decode_byterun ( row , avctx -> width , buf , buf_end ); 164
buf += decode_byterun ( s -> ham_buf , avctx -> width , buf , buf_end ); 169
------------------------------
914 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ; 7
const uint8_t * buf_end = buf + buf_size ; 8
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 37
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 76
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 85
decodeplane8 ( s -> ham_buf , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 86
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 95
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
memcpy ( s -> ham_buf , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 111
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 126
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 135
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 145
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 155
buf += decode_byterun ( row , avctx -> width , buf , buf_end ); 164
buf += decode_byterun ( s -> ham_buf , avctx -> width , buf , buf_end ); 169
decode_deep_rle32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 177
bytestream2_init ( & gb , buf , buf_size ); 183
decode_deep_tvdc32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] , s -> tvdc ); 195
return buf_size ; 207
------------------------------
915 /home/SySeVR/data/CVE_2014_5272_PATCHED_decode_frame.c const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
static int CVE_2014_5272_PATCHED_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt) 3
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ; 6
const uint8_t * buf_end = buf + buf_size ; 8
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 37
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 39
buf += s -> planesize; 40
const uint8_t * start = buf + ( plane * avctx -> height + y ) * s -> planesize ; 49
if ( start >= buf_end )  50
decodeplane8 ( s -> ham_buf , start , FFMIN ( s -> planesize , buf_end - start ) , plane ); 52
for(y = 0; y < avctx->height && buf < buf_end; y++ ) 62
memcpy ( row , buf , FFMIN ( raw_width , buf_end - buf ) ); 64
buf += raw_width; 65
row [ 4 * x + 3 ] = row [ 4 * x + 3 ] & 0xF0 | ( row [ 4 * x + 3 ] >> 4 ); 68
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 76
decodeplane8 ( row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 77
buf += s -> planesize; 78
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 85
decodeplane8 ( s -> ham_buf , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 86
buf += s -> planesize; 87
for (plane = 0; plane < s->bpp && buf < buf_end; plane++) 95
decodeplane32 ( ( uint32_t * ) row , buf , FFMIN ( s -> planesize , buf_end - buf ) , plane ); 96
buf += s -> planesize; 97
for(y = 0; y < avctx->height && buf_end > buf; y++ ) 103
memcpy ( row , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 105
buf += avctx -> width + ( avctx -> width % 2 ); 106
for (y = 0; y < avctx->height && buf_end > buf; y++) 109
memcpy ( s -> ham_buf , buf , FFMIN ( avctx -> width , buf_end - buf ) ); 111
buf += avctx -> width + ( avctx -> width & 1 ); 112
decode_ham_plane32 ( ( uint32_t * ) row , s -> ham_buf , s -> ham_palbuf , s -> planesize ); 113
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 126
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 135
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 145
buf += decode_byterun ( s -> planebuf , s -> planesize , buf , buf_end ); 155
buf += decode_byterun ( row , avctx -> width , buf , buf_end ); 164
buf += decode_byterun ( s -> ham_buf , avctx -> width , buf , buf_end ); 169
decode_deep_rle32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] ); 177
bytestream2_init ( & gb , buf , buf_size ); 183
decode_deep_tvdc32 ( s -> frame . data [ 0 ] , buf , buf_size , avctx -> width , avctx -> height , s -> frame . linesize [ 0 ] , s -> tvdc ); 195
------------------------------
916 /home/SySeVR/data/CVE_2014_5472_PATCHED_isofs_read_inode.c int frag1 = bufsize - offset ; 27
static int CVE_2014_5472_PATCHED_isofs_read_inode(struct inode *inode, int relocated) 1
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; 5
unsigned long block ; 6
struct iso_directory_record * de ; 9
unsigned int de_len ; 11
unsigned long offset ; 12
struct iso_inode_info * ei = ISOFS_I ( inode ) ; 13
block = ei -> i_iget5_block; 16
bh = sb_bread ( inode -> i_sb , block ); 17
if ( ! bh )  18
offset = ei -> i_iget5_offset; 21
de = ( struct iso_directory_record * ) ( bh -> b_data + offset ); 23
de_len = * ( unsigned char * ) de; 24
if ( offset + de_len > bufsize )  26
int frag1 = bufsize - offset ; 27
memcpy ( tmpde , bh -> b_data + offset , frag1 ); 35
memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ); 40
------------------------------
917 /home/SySeVR/data/CVE_2014_6429_VULN_SnifferDecompress.c unsigned char * pout_end = pout + outlen ; 8
static int
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pout = outbuf ; 6
unsigned char * pout_end = pout + outlen ; 8
if ( pout + length > pout_end )  70
if ( pout + length > pout_end )  97
if ( pout + length > pout_end )  132
if ( pout + length > pout_end )  161
------------------------------
918 /home/SySeVR/data/CVE_2014_6429_VULN_SnifferDecompress.c unsigned char * pin_end = pin + inlen ; 7
static int
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pin_end = pin + inlen ; 7
if ( pin >= pin_end )  32
if ( pin >= pin_end )  53
if ( pin >= pin_end )  91
if ( pin >= pin_end )  118
if ( pin >= pin_end )  176
------------------------------
919 /home/SySeVR/data/CVE_2014_6431_VULN_SnifferDecompress.c unsigned char * pout_end = pout + outlen ; 8
static int
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pout = outbuf ; 6
unsigned char * pout_end = pout + outlen ; 8
if ( pout + length > pout_end )  70
if ( pout + length > pout_end )  97
if ( pout + length > pout_end )  132
if ( pout + length > pout_end )  161
------------------------------
920 /home/SySeVR/data/CVE_2014_6431_VULN_SnifferDecompress.c unsigned char * pin_end = pin + inlen ; 7
static int
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pin_end = pin + inlen ; 7
if ( pin >= pin_end )  32
if ( pin >= pin_end )  53
if ( pin >= pin_end )  91
if ( pin >= pin_end )  118
if ( pin >= pin_end )  176
------------------------------
921 /home/SySeVR/data/CVE_2014_6432_PATCHED_SnifferDecompress.c unsigned char * pout_end = pout + outlen ; 8
static int
CVE_2014_6432_PATCHED_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pout = outbuf ; 6
unsigned char * pout_end = pout + outlen ; 8
if ( pout + 1 > pout_end )  49
if ( pout + length > pout_end )  81
if ( pout + length > pout_end )  108
if ( pout + length > pout_end )  143
if ( pout + length > pout_end )  178
------------------------------
922 /home/SySeVR/data/CVE_2014_6432_PATCHED_SnifferDecompress.c unsigned char * pin_end = pin + inlen ; 7
static int
CVE_2014_6432_PATCHED_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pin_end = pin + inlen ; 7
while ( pin < pin_end )  22
if ( pin + 2 >= pin_end )  33
if ( pin >= pin_end )  64
if ( pin >= pin_end )  102
if ( pin >= pin_end )  129
------------------------------
923 /home/SySeVR/data/CVE_2014_6432_VULN_SnifferDecompress.c unsigned char * pout_end = pout + outlen ; 8
static int
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pout = outbuf ; 6
unsigned char * pout_end = pout + outlen ; 8
if ( pout + length > pout_end )  70
if ( pout + length > pout_end )  97
if ( pout + length > pout_end )  132
if ( pout + length > pout_end )  161
------------------------------
924 /home/SySeVR/data/CVE_2014_6432_VULN_SnifferDecompress.c unsigned char * pin_end = pin + inlen ; 7
static int
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char *outbuf,
size_t outlen, int *err) 3
unsigned char * pin = inbuf ; 5
unsigned char * pin_end = pin + inlen ; 7
if ( pin >= pin_end )  32
if ( pin >= pin_end )  53
if ( pin >= pin_end )  91
if ( pin >= pin_end )  118
if ( pin >= pin_end )  176
------------------------------
925 /home/SySeVR/data/CVE_2014_7937_PATCHED_vorbis_residue_decode_internal.c unsigned voffs_mod = voffset - voffs_div * ch ; 118
static av_always_inline int CVE_2014_7937_PATCHED_vorbis_residue_decode_internal(vorbis_context *vc,
vorbis_residue *vr,
unsigned ch,
uint8_t *do_not_decode,
float *vec,
unsigned vlen,
unsigned ch_left,
int vr_type) 8
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; 11
uint8_t * classifs = vr -> classifs ; 12
unsigned pass , ch_used , i , j , k , l ; 13
unsigned max_output = ( ch - 1 ) * vlen ; 14
int ptns_to_read = vr -> ptns_to_read ; 15
if ( vr_type == 2 )  18
for (j = 1; j < ch; ++j) 19
do_not_decode [ 0 ] &= do_not_decode [ j ]; 20
if ( do_not_decode [ 0 ] )  21
ch_used = 1; 23
max_output += vr -> end / ch; 24
ch_used = ch; 26
max_output += vr -> end; 27
if ( max_output > ch_left * vlen )  30
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )  31
ptns_to_read --; 32
for (pass = 0; pass <= vr->maxpass; ++pass) 42
int voffset , partition_count , j_times_ptns_to_read ; 43
voffset = vr -> begin; 45
for (partition_count = 0; partition_count < ptns_to_read;) 46
if ( ! pass )  47
int ret ; 48
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count , ptns_to_read ) ) < 0 )  49
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) 52
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) 53
if ( ! do_not_decode [ j ] )  56
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
int vqbook = vr -> books [ vqclass ] [ pass ] ; 58
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )  60
unsigned dim = vc -> codebooks [ vqbook ] . dimensions ; 62
if ( vr_type == 0 )  66
vec [ voffs + k + l * step ] += codebook . codevectors [ coffs + l ]; 72
if ( vr_type == 1 )  74
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 79
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d  \n" , pass , voffs , vec [ voffs ] , codebook . codevectors [ coffs + l ] , coffs ); 81
if ( vr_type == 2 && ch == 2 && ( voffset & 1 ) == 0 && ( dim & 1 ) == 0 )  85
vec [ voffs + k ] += codebook . codevectors [ coffs ]; 91
vec [ voffs + k + vlen ] += codebook . codevectors [ coffs + 1 ]; 92
vec [ voffs ] += codebook . codevectors [ coffs ]; 97
vec [ voffs + 1 ] += codebook . codevectors [ coffs + 2 ]; 98
vec [ voffs + vlen ] += codebook . codevectors [ coffs + 1 ]; 99
vec [ voffs + vlen + 1 ] += codebook . codevectors [ coffs + 3 ]; 100
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 106
vec [ voffs + vlen ] += codebook . codevectors [ coffs + l + 1 ]; 107
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffset / ch + ( voffs % ch ) * vlen , vec [ voffset / ch + ( voffs % ch ) * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 109
if ( vr_type == 2 )  116
unsigned voffs_div = FASTDIV ( voffset << 1 , ch << 1 ) ; 117
unsigned voffs_mod = voffset - voffs_div * ch ; 118
vec [ voffs_div + voffs_mod * vlen ] += codebook . codevectors [ coffs + l ]; 123
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffs_div + voffs_mod * vlen , vec [ voffs_div + voffs_mod * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 126
if ( ++ voffs_mod == ch )  131
voffs_div ++; 132
j_times_ptns_to_read += ptns_to_read; 140
voffset += vr -> partition_size; 143
------------------------------
926 /home/SySeVR/data/CVE_2014_7937_PATCHED_vorbis_residue_decode_internal.c unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
static av_always_inline int CVE_2014_7937_PATCHED_vorbis_residue_decode_internal(vorbis_context *vc,
vorbis_residue *vr,
unsigned ch,
uint8_t *do_not_decode,
float *vec,
unsigned vlen,
unsigned ch_left,
int vr_type) 8
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ; 11
uint8_t * classifs = vr -> classifs ; 12
unsigned pass , ch_used , i , j , k , l ; 13
unsigned max_output = ( ch - 1 ) * vlen ; 14
int ptns_to_read = vr -> ptns_to_read ; 15
if ( vr_type == 2 )  18
for (j = 1; j < ch; ++j) 19
do_not_decode [ 0 ] &= do_not_decode [ j ]; 20
if ( do_not_decode [ 0 ] )  21
ch_used = 1; 23
max_output += vr -> end / ch; 24
ch_used = ch; 26
max_output += vr -> end; 27
if ( max_output > ch_left * vlen )  30
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )  31
ptns_to_read --; 32
for (pass = 0; pass <= vr->maxpass; ++pass) 42
int voffset , partition_count , j_times_ptns_to_read ; 43
for (partition_count = 0; partition_count < ptns_to_read;) 46
if ( ! pass )  47
int ret ; 48
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count , ptns_to_read ) ) < 0 )  49
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) 52
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) 53
if ( ! do_not_decode [ j ] )  56
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
int vqbook = vr -> books [ vqclass ] [ pass ] ; 58
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )  60
unsigned dim = vc -> codebooks [ vqbook ] . dimensions ; 62
unsigned step = FASTDIV ( vr -> partition_size << 1 , dim << 1 ) ; 63
vorbis_codebook codebook = vc -> codebooks [ vqbook ] ; 64
for (k = 0; k < step; ++k) 69
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 70
for (l = 0; l < dim; ++l) 71
vec [ voffs + k + l * step ] += codebook . codevectors [ coffs + l ]; 72
for (k = 0; k < step; ++k) 76
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 77
for (l = 0; l < dim; ++l, ++voffs) 78
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 79
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d  \n" , pass , voffs , vec [ voffs ] , codebook . codevectors [ coffs + l ] , coffs ); 81
if ( vr_type == 2 && ch == 2 && ( voffset & 1 ) == 0 && ( dim & 1 ) == 0 )  85
if ( dim == 2 )  88
for (k = 0; k < step; ++k) 89
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * 2; 90
vec [ voffs + k ] += codebook . codevectors [ coffs ]; 91
vec [ voffs + k + vlen ] += codebook . codevectors [ coffs + 1 ]; 92
if ( dim == 4 )  94
for (k = 0; k < step; ++k, voffs += 2) 95
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * 4; 96
vec [ voffs ] += codebook . codevectors [ coffs ]; 97
vec [ voffs + 1 ] += codebook . codevectors [ coffs + 2 ]; 98
vec [ voffs + vlen ] += codebook . codevectors [ coffs + 1 ]; 99
vec [ voffs + vlen + 1 ] += codebook . codevectors [ coffs + 3 ]; 100
for (k = 0; k < step; ++k) 103
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 104
for (l = 0; l < dim; l += 2, voffs++) 105
vec [ voffs ] += codebook . codevectors [ coffs + l ]; 106
vec [ voffs + vlen ] += codebook . codevectors [ coffs + l + 1 ]; 107
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffset / ch + ( voffs % ch ) * vlen , vec [ voffset / ch + ( voffs % ch ) * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 109
for (k = 0; k < step; ++k) 120
coffs = get_vlc2 ( gb , codebook . vlc . table , codebook . nb_bits , 3 ) * dim; 121
for (l = 0; l < dim; ++l) 122
vec [ voffs_div + voffs_mod * vlen ] += codebook . codevectors [ coffs + l ]; 123
av_dlog ( NULL , " pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n" , pass , voffs_div + voffs_mod * vlen , vec [ voffs_div + voffs_mod * vlen ] , codebook . codevectors [ coffs + l ] , coffs , l ); 126
if ( ++ voffs_mod == ch )  131
voffs_div ++; 132
j_times_ptns_to_read += ptns_to_read; 140
------------------------------
927 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
height *= 2; 114
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
s -> first_picture = 0; 121
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
s -> rgb = 1; 131
if ( ! s -> lossless )  132
s -> rgb = 0; 133
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
for (i = 0; i < 4; i++) 316
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
------------------------------
928 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
height *= 2; 114
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
s -> first_picture = 0; 121
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
s -> rgb = 1; 131
if ( ! s -> lossless )  132
s -> rgb = 0; 133
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
for (i = 0; i < 4; i++) 316
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
if ( s -> progressive )  333
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
------------------------------
929 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int len , nb_components , i , width , height , pix_fmt_id , ret ; 3
int h_count [ MAX_COMPONENTS ] ; 4
int v_count [ MAX_COMPONENTS ] ; 5
s -> cur_scan = 0; 7
s -> upscale_h = s -> upscale_v = 0; 8
s -> avctx -> bits_per_raw_sample = s -> bits = get_bits ( & s -> gb , 8 ); 12
if ( s -> pegasus_rct )  15
s -> bits = 9; 16
if ( s -> bits == 9 && ! s -> pegasus_rct )  17
s -> rct = 1; 18
if ( s -> lossless && s -> avctx -> lowres )  20
height = get_bits ( & s -> gb , 16 ); 25
width = get_bits ( & s -> gb , 16 ); 26
if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  32
height = s -> height; 33
if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  36
nb_components = get_bits ( & s -> gb , 8 ); 39
if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  40
if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  43
if ( nb_components != s -> nb_components )  44
if ( s -> ls && ! ( s -> bits <= 8 || nb_components == 1 ) )  50
s -> nb_components = nb_components; 56
s -> h_max = 1; 57
s -> v_max = 1; 58
memset ( h_count , 0 , sizeof ( h_count ) ); 59
memset ( v_count , 0 , sizeof ( v_count ) ); 60
for (i = 0; i < nb_components; i++) 61
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
if ( ! h_count [ i ] || ! v_count [ i ] )  76
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
height *= 2; 114
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
s -> first_picture = 0; 121
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
s -> rgb = 1; 131
if ( ! s -> lossless )  132
s -> rgb = 0; 133
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
for (i = 0; i < 4; i++) 316
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
------------------------------
930 /home/SySeVR/data/CVE_2014_8546_VULN_cinepak_decode_vectors.c const uint8_t * eod = ( data + size ) ; 4
static int CVE_2014_8546_VULN_cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,
int chunk_id, int size, const uint8_t *data) 2
const uint8_t * eod = ( data + size ) ; 4
if ( ( data + 4 ) > eod )  34
if ( ( data + 4 ) > eod )  44
if ( data >= eod )  54
if ( ( data + 4 ) > eod )  79
------------------------------
931 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c int rem = skb -> len - hdrlen - per_fragm ; 10
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
if ( rem )  41
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
------------------------------
932 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c int pos = hdrlen + per_fragm ; 9
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int pos = hdrlen + per_fragm ; 9
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
------------------------------
933 /home/SySeVR/data/CVE_2014_8709_PATCHED_ieee80211_fragment.c int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
static int CVE_2014_8709_PATCHED_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int pos = hdrlen + per_fragm ; 9
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
if ( rem )  41
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
skb_trim ( skb , hdrlen + per_fragm ); 56
------------------------------
934 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c int rem = skb -> len - hdrlen - per_fragm ; 10
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
if ( rem )  41
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
------------------------------
935 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c int pos = hdrlen + per_fragm ; 9
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int pos = hdrlen + per_fragm ; 9
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
------------------------------
936 /home/SySeVR/data/CVE_2014_8709_VULN_ieee80211_fragment.c int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
static int CVE_2014_8709_VULN_ieee80211_fragment(struct ieee80211_tx_data *tx,
struct sk_buff *skb, int hdrlen,
int frag_threshold) 3
int per_fragm = frag_threshold - hdrlen - FCS_LEN ; 8
int pos = hdrlen + per_fragm ; 9
int rem = skb -> len - hdrlen - per_fragm ; 10
if ( WARN_ON ( rem < 0 ) )  12
while ( rem )  17
int fraglen = per_fragm ; 18
if ( fraglen > rem )  20
fraglen = rem; 21
rem -= fraglen; 22
if ( rem )  41
memcpy ( skb_put ( tmp , fraglen ) , skb -> data + pos , fraglen ); 50
pos += fraglen; 52
skb -> len = hdrlen + per_fragm; 56
------------------------------
937 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c size_t len = NS_tstrlen ( gInstallDirPath + commonPrefixLength ) ; 636
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
if ( sReplaceRequest )  624
size_t commonPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , gInstallDirPath , nullptr ) ; 627
size_t len = NS_tstrlen ( gInstallDirPath + commonPrefixLength ) ; 636
p += len; 637
bufferLeft -= len; 638
* p = NS_T ( '\\' ); 639
bufferLeft --; 641
* p = NS_T ( '\0' ); 642
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
------------------------------
938 /home/SySeVR/data/CVE_2015_3395_VULN_msrle_decode_pal4.c int frame_size = row_dec * avctx -> height ; 10
static int CVE_2015_3395_VULN_msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,
GetByteContext *gb) 2
int row_dec = pic -> linesize [ 0 ] ; 8
int frame_size = row_dec * avctx -> height ; 10
if ( row_ptr + pixel_ptr + stream_byte > frame_size || bytestream2_get_bytes_left ( gb ) < rle_code )  42
if ( row_ptr + pixel_ptr + stream_byte > frame_size )  69
------------------------------
939 /home/SySeVR/data/CVE_2015_3808_VULN_dissect_lbmr_pser.c guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
curr_offset += hdr_len; 26
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
curr_offset += L_LBMR_PSER_OPTLEN_T; 45
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
guint8 option_len = tvb_get_guint8 ( tvb , O_LBMR_PSER_OPT_HDR_T_LEN ) ; 52
switch ( opt_type )  54
curr_offset += L_LBMR_PSER_OPT_CTXINST_T; 64
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
curr_offset += option_len; 69
opt_len -= option_len; 70
expert_add_info_format ( pinfo , NULL , & ei_lbmr_analysis_invalid_value , "Unknown LBMR PSER option 0x%02x" , opt_type ); 71
------------------------------
940 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c guint8 option_len = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN ) ; 52
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
curr_offset += hdr_len; 26
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
curr_offset += L_LBMR_PSER_OPTLEN_T; 45
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
guint8 option_len = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN ) ; 52
switch ( opt_type )  54
ctxinst_item = proto_tree_add_item ( opts_tree , hf_lbmr_pser_opt_ctxinst , tvb , curr_offset , L_LBMR_PSER_OPT_CTXINST_T , ENC_NA ); 58
ctxinst_tree = proto_item_add_subtree ( ctxinst_item , ett_lbmr_pser_opt_ctxinst ); 59
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_len , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_LEN , L_LBMR_PSER_OPT_CTXINST_T_LEN , ENC_BIG_ENDIAN ); 60
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_type , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_TYPE , L_LBMR_PSER_OPT_CTXINST_T_TYPE , ENC_BIG_ENDIAN ); 61
proto_tree_add_item ( ctxinst_tree , hf_lbmr_pser_opt_ctxinst_ctxinst , tvb , curr_offset + O_LBMR_PSER_OPT_CTXINST_T_CTXINST , L_LBMR_PSER_OPT_CTXINST_T_CTXINST , ENC_NA ); 62
len += L_LBMR_PSER_OPT_CTXINST_T; 63
curr_offset += L_LBMR_PSER_OPT_CTXINST_T; 64
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
len += option_len; 68
curr_offset += option_len; 69
opt_len -= option_len; 70
expert_add_info_format ( pinfo , NULL , & ei_lbmr_analysis_invalid_value , "Unknown LBMR PSER option 0x%02x" , opt_type ); 71
if ( option_len == 0 )  72
return ( len ) ; 73
return ( len ) ; 79
------------------------------
941 /home/SySeVR/data/CVE_2015_3809_PATCHED_dissect_lbmr_pser.c guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
static int CVE_2015_3809_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree) 1
int curr_offset = offset ; 8
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ); 11
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ); 12
curr_offset += hdr_len; 26
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )  28
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ); 36
curr_offset += L_LBMR_PSER_OPTLEN_T; 45
opt_len -= L_LBMR_PSER_OPTLEN_T; 46
while ( opt_len > 0 )  47
guint8 opt_type = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE ) ; 51
guint8 option_len = tvb_get_guint8 ( tvb , curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN ) ; 52
switch ( opt_type )  54
curr_offset += L_LBMR_PSER_OPT_CTXINST_T; 64
opt_len -= L_LBMR_PSER_OPT_CTXINST_T; 65
curr_offset += option_len; 69
opt_len -= option_len; 70
expert_add_info_format ( pinfo , NULL , & ei_lbmr_analysis_invalid_value , "Unknown LBMR PSER option 0x%02x" , opt_type ); 71
if ( option_len == 0 )  72
------------------------------
942 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  166
max = 0; 184
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 185
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  186
max = fd_i -> offset + fd_i -> len; 188
if ( max < ( fd_head -> datalen ) )  192
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 206
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 207
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 211
if ( fd_i -> len )  212
if ( fd_i -> offset + fd_i -> len > dfpos )  230
if ( fd_i -> offset >= fd_head -> datalen )  231
fd_i -> flags |= FD_TOOLONGFRAGMENT; 248
fd_head -> flags |= FD_TOOLONGFRAGMENT; 249
if ( dfpos < fd_i -> offset )  250
fd_head -> error = "dfpos < offset"; 261
if ( dfpos - fd_i -> offset > fd_i -> len )  262
fd_head -> error = "dfpos - offset > len"; 263
if ( ! fd_head -> tvb_data )  264
fd_head -> error = "no data"; 265
fraglen = fd_i -> len; 267
if ( fd_i -> offset + fraglen > fd_head -> datalen )  268
fd_i -> flags |= FD_TOOLONGFRAGMENT; 283
fd_head -> flags |= FD_TOOLONGFRAGMENT; 284
fraglen = fd_head -> datalen - fd_i -> offset; 285
if ( fd_i -> offset < dfpos )  287
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 288
fd_i -> flags |= FD_OVERLAP; 290
fd_head -> flags |= FD_OVERLAP; 291
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  292
fd_i -> flags |= FD_OVERLAPCONFLICT; 296
fd_head -> flags |= FD_OVERLAPCONFLICT; 297
if ( fraglen < dfpos - fd_i -> offset )  300
fd_head -> error = "fraglen < dfpos - offset"; 304
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 309
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  313
fd_head -> error = "offset + len < offset"; 315
if ( fd_i -> flags & FD_SUBSET_TVB )  319
fd_i -> flags &= ~FD_SUBSET_TVB; 320
fd_i -> tvb_data = NULL; 324
------------------------------
943 /home/SySeVR/data/CVE_2015_3813_PATCHED_fragment_add_work.c guint32 end_offset = fd -> offset + fd -> len ; 134
static gboolean
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd -> flags |= FD_MULTIPLETAILS; 114
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
guint32 end_offset = fd -> offset + fd -> len ; 134
if ( end_offset > fd_head -> datalen || end_offset < fd -> offset || end_offset < fd -> len )  138
------------------------------
944 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fragment_item * fd_i ; 7
guint32 max , dfpos , fraglen ; 8
guint8 * data ; 10
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next) 43
if ( ! fd_i -> tvb_data )  44
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset ); 45
fd_i -> flags |= FD_SUBSET_TVB; 46
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 48
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )  164
max = 0; 182
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) 183
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )  184
max = fd_i -> offset + fd_i -> len; 186
if ( max < ( fd_head -> datalen ) )  190
data = ( guint8 * ) g_malloc ( fd_head -> datalen ); 204
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen ); 205
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) 209
if ( fd_i -> len )  210
if ( fd_i -> offset + fd_i -> len > dfpos )  228
if ( fd_i -> offset >= fd_head -> datalen )  229
fd_i -> flags |= FD_TOOLONGFRAGMENT; 246
fd_head -> flags |= FD_TOOLONGFRAGMENT; 247
if ( dfpos < fd_i -> offset )  248
fd_head -> error = "dfpos < offset"; 259
if ( dfpos - fd_i -> offset > fd_i -> len )  260
fd_head -> error = "dfpos - offset > len"; 261
if ( ! fd_head -> tvb_data )  262
fd_head -> error = "no data"; 263
fraglen = fd_i -> len; 265
if ( fd_i -> offset + fraglen > fd_head -> datalen )  266
fd_i -> flags |= FD_TOOLONGFRAGMENT; 281
fd_head -> flags |= FD_TOOLONGFRAGMENT; 282
fraglen = fd_head -> datalen - fd_i -> offset; 283
if ( fd_i -> offset < dfpos )  285
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ; 286
fd_i -> flags |= FD_OVERLAP; 288
fd_head -> flags |= FD_OVERLAP; 289
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )  290
fd_i -> flags |= FD_OVERLAPCONFLICT; 294
fd_head -> flags |= FD_OVERLAPCONFLICT; 295
if ( fraglen < dfpos - fd_i -> offset )  298
fd_head -> error = "fraglen < dfpos - offset"; 302
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) ); 307
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )  311
fd_head -> error = "offset + len < offset"; 313
if ( fd_i -> flags & FD_SUBSET_TVB )  317
fd_i -> flags &= ~FD_SUBSET_TVB; 318
fd_i -> tvb_data = NULL; 322
------------------------------
945 /home/SySeVR/data/CVE_2015_3813_VULN_fragment_add_work.c guint32 end_offset = fd -> offset + fd -> len ; 134
static gboolean
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int offset,
const packet_info *pinfo, const guint32 frag_offset,
const guint32 frag_data_len, const gboolean more_frags) 4
fragment_item * fd ; 6
fd = g_slice_new ( fragment_item ); 13
fd -> next = NULL; 14
fd -> flags = 0; 15
fd -> frame = pinfo -> fd -> num; 16
fd -> offset = frag_offset; 17
fd -> fragment_nr_offset = 0; 18
fd -> len = frag_data_len; 19
fd -> tvb_data = NULL; 20
fd -> error = NULL; 21
if ( fd_head -> flags & FD_DEFRAGMENTED )  26
if ( frag_offset + frag_data_len >= fd_head -> datalen )  34
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )  38
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET ); 50
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS ); 51
fd_head -> datalen = 0; 52
fd_head -> reassembled_in = 0; 53
if ( fd -> frame > fd_head -> frame )  99
fd_head -> frame = fd -> frame; 100
if ( ! more_frags )  102
if ( fd_head -> flags & FD_DATALEN_SET )  106
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )  110
fd -> flags |= FD_MULTIPLETAILS; 114
fd_head -> flags |= FD_MULTIPLETAILS; 115
fd_head -> datalen = fd -> offset + fd -> len; 121
fd_head -> flags |= FD_DATALEN_SET; 122
if ( fd_head -> flags & FD_DEFRAGMENTED )  133
guint32 end_offset = fd -> offset + fd -> len ; 134
if ( end_offset > fd_head -> datalen || end_offset < fd -> offset || end_offset < fd -> len )  138
------------------------------
