1 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c [u'v_count'] 6
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int v_count [ MAX_COMPONENTS ] ; 6
memset ( v_count , 0 , sizeof ( v_count ) ); 66
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
2 /home/SySeVR/data/CVE-2015-1872_VULN_ff_mjpeg_decode_sof.c [u'h_count'] 5
int ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int h_count [ MAX_COMPONENTS ] ; 5
memset ( h_count , 0 , sizeof ( h_count ) ); 65
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 69
h_count [ i ] = get_bits ( & s -> gb , 4 ); 70
v_count [ i ] = get_bits ( & s -> gb , 4 ); 71
if ( h_count [ i ] > s -> h_max )  73
s -> h_max = h_count [ i ]; 74
if ( v_count [ i ] > s -> v_max )  75
s -> v_max = v_count [ i ]; 76
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 77
if ( s -> quant_index [ i ] >= 4 )  78
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 79
if ( ! h_count [ i ] || ! v_count [ i ] )  82
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 83
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 89
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  94
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 95
if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  101
s -> width = width; 106
s -> height = height; 107
s -> bits = bits; 108
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 109
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 110
s -> interlaced = 0; 111
s -> got_picture = 0; 112
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  115
s -> interlaced = 1; 118
s -> bottom_field = s -> interlace_polarity; 119
s -> picture_ptr -> interlaced_frame = 1; 120
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 121
ret = ff_set_dimensions ( s -> avctx , width , height ); 125
if ( ret < 0 )  126
return ret ; 127
s -> first_picture = 0; 129
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  132
if ( s -> progressive )  133
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 134
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  138
s -> rgb = 1; 139
if ( ! s -> lossless )  140
pix_fmt_id = ( ( unsigned ) s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 143
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 147
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  150
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 151
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  152
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 153
for (i = 0; i < 8; i++) 155
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 156
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 157
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 158
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  160
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 161
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  162
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 163
if ( is == 1 && js == 2 )  165
if ( i & 1 )  166
s -> upscale_h |= 1 << ( j / 2 ); 166
s -> upscale_v |= 1 << ( j / 2 ); 167
switch ( pix_fmt_id )  171
if ( s -> rgb )  173
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 174
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  176
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 177
if ( s -> bits <= 8 )  179
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 179
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 180
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 181
av_assert0 ( s -> nb_components == 3 ); 184
if ( s -> rgb )  187
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 188
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  190
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 191
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 193
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 194
av_assert0 ( s -> nb_components == 4 ); 197
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  201
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 202
s -> upscale_v |= 6; 203
s -> upscale_h |= 6; 204
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  205
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 206
s -> upscale_v |= 6; 207
s -> upscale_h |= 6; 208
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 209
if ( s -> bits <= 8 )  211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 211
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 212
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 213
av_assert0 ( s -> nb_components == 4 ); 215
if ( s -> bits <= 8 )  221
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 221
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 224
if ( s -> bits <= 8 )  229
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 229
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 232
if ( s -> bits <= 8 )  243
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 244
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 246
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  253
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 254
s -> upscale_v |= 3; 257
if ( pix_fmt_id == 0x14111100 )  259
s -> upscale_v |= 6; 260
if ( s -> bits <= 8 )  261
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 261
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 264
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  268
if ( s -> bits <= 8 )  269
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRP; 269
s -> upscale_h |= 3; 272
if ( s -> bits <= 8 )  274
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 274
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 275
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 276
if ( s -> bits <= 8 )  281
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 281
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 284
if ( s -> bits <= 8 )  289
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 289
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 290
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 291
if ( pix_fmt_id == 0x42111100 )  292
if ( s -> bits > 8 )  293
s -> upscale_h = 6; 295
if ( pix_fmt_id == 0x24111100 )  296
if ( s -> bits > 8 )  297
if ( s -> bits <= 8 )  303
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 303
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 306
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x bits:%d\n" , pix_fmt_id , s -> bits ); 310
s -> upscale_h = s -> upscale_v = 0; 311
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  314
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 315
if ( s -> ls )  318
s -> upscale_h = s -> upscale_v = 0; 319
if ( s -> nb_components > 1 )  320
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 321
if ( s -> palette_index && s -> bits <= 8 )  322
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 323
if ( s -> bits <= 8 )  324
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 325
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 327
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 330
if ( ! s -> pix_desc )  331
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 332
av_frame_unref ( s -> picture_ptr ); 336
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  337
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 339
s -> picture_ptr -> key_frame = 1; 340
s -> got_picture = 1; 341
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 344
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 346
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 351
if ( s -> rgb && ! s -> lossless && ! s -> ls )  354
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 355
if ( s -> progressive )  360
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 361
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 362
for (i = 0; i < s->nb_components; i++) 363
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 364
av_freep ( & s -> blocks [ i ] ); 365
av_freep ( & s -> last_nnz [ i ] ); 366
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 367
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 368
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  369
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 371
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 373
------------------------------
3 /home/SySeVR/data/CVE-2015-3906_VULN_logcat_log.c [u'time_buffer'] 5
static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,
gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,
const gchar *log) 3
gchar time_buffer [ 15 ] ; 5
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 24
return g_strdup_printf ( "%s.%03i %c/%s(%5i): %s\n" , time_buffer , microseconds , priority , tag , pid , log ) ; 26
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 29
return g_strdup_printf ( "%s.%03i %5i:%5i %c %s: %s\n" , time_buffer , microseconds , pid , tid , priority , tag , log ) ; 31
strftime ( time_buffer , sizeof ( time_buffer ) , "%m-%d %H:%M:%S" , gmtime ( & datetime ) ); 34
return g_strdup_printf ( "[ %s.%03i %5i:%5i %c/%s ]\n%s\n\n" , time_buffer , microseconds , pid , tid , priority , tag , log ) ; 36
------------------------------
4 /home/SySeVR/data/CVE-2016-7179_VULN_parse_outhdr_string.c [u'digit_array'] 8
static void parse_outhdr_string(const guchar *outhdr_string, gint outhdr_string_len) 1
int n = 0 ; 3
for (outhdr_values_found=0; outhdr_values_found < MAX_OUTHDR_VALUES; ) 6
guint digit_array [ MAX_OUTHDR_VALUES ] ; 8
guint number_digits = 0 ; 9
guint number = 0 ; 11
guint multiplier = 1 ; 12
guint d ; 13
for ( ; n < outhdr_string_len; n++) 16
if ( ! g_ascii_isdigit ( outhdr_string [ n ] ) )  17
digit_array [ number_digits ++ ] = outhdr_string [ n ] - '0'; 21
if ( number_digits == 0 )  25
for (d=number_digits; d > 0; d--) 31
number += ( ( digit_array [ d - 1 ] ) * multiplier ); 32
multiplier *= 10; 33
outhdr_values [ outhdr_values_found ++ ] = number; 35
n ++; 38
------------------------------
5 /home/SySeVR/data/CVE-2016-7180_VULN_dissect_ipmi_trace.c [u'str'] 38
dissect_ipmi_trace(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 1
guint block_type , chn_num , data_type , tmp ; 3
if ( tvb_captured_length ( tvb ) < 11 )  6
tmp = tvb_get_guint8 ( tvb , 0 ); 13
block_type = ( tmp >> 4 ) & 3; 16
if ( block_type == HPM2_TRACE_PACKET_DATA )  32
if ( block_type == HPM2_CHN_STATE_NOTIFY )  34
if ( block_type == HPM2_EMBED_ASCII_MSG )  37
char str [ 257 ] ; 38
tvb_memcpy ( tvb , str , 11 , str_len ); 45
str [ str_len ] = 0; 48
col_add_str ( pinfo -> cinfo , COL_INFO , str ); 51
------------------------------
6 /home/SySeVR/data/CVE_2004_1151_PATCHED_sys32_ni_syscall.c [u'lastcomm'] 4
int CVE_2004_1151_PATCHED_sys32_ni_syscall(int call) 1
struct task_struct * me = current ; 3
static char lastcomm [ sizeof ( me -> comm ) ] ; 4
if ( strncmp ( lastcomm , me -> comm , sizeof ( lastcomm ) ) )  6
strncpy ( lastcomm , me -> comm , sizeof ( lastcomm ) ); 9
------------------------------
7 /home/SySeVR/data/CVE_2004_1151_VULN_sys32_ni_syscall.c [u'lastcomm'] 4
int CVE_2004_1151_VULN_sys32_ni_syscall(int call) 1
static char lastcomm [ 8 ] ; 4
if ( strcmp ( lastcomm , me -> comm ) )  5
strcpy ( lastcomm , me -> comm ); 8
------------------------------
8 /home/SySeVR/data/CVE_2005_3356_VULN_do_open.c [u'O_ACCMODE', u'oflag2acc'] 3
static struct file *CVE_2005_3356_VULN_do_open(struct dentry *dentry, int oflag) 1
static int oflag2acc [ O_ACCMODE ] = { MAY_READ , MAY_WRITE , MAY_READ | MAY_WRITE } ; 3
if ( ( oflag & O_ACCMODE ) == ( O_RDWR | O_WRONLY ) )  7
if ( permission ( dentry -> d_inode , oflag2acc [ oflag & O_ACCMODE ] , NULL ) )  10
------------------------------
9 /home/SySeVR/data/CVE_2006_2935_VULN_dvd_read_bca.c [u'buf'] 4
static int CVE_2006_2935_VULN_dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s) 1
u_char buf [ 4 + 188 ] ; 4
init_cdrom_command ( & cgc , buf , sizeof ( buf ) , CGC_DATA_READ ); 8
s -> bca . len = buf [ 0 ] << 8 | buf [ 1 ]; 16
if ( s -> bca . len < 12 || s -> bca . len > 188 )  17
cdinfo ( CD_WARNING , "Received invalid BCA length (%d)\n" , s -> bca . len ); 18
memcpy ( s -> bca . value , & buf [ 4 ] , s -> bca . len ); 21
------------------------------
10 /home/SySeVR/data/CVE_2006_4813_PATCHED___block_prepare_write.c [u'wait_bh', u'head', u'bh', u'wait'] 8
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page *page,
unsigned from, unsigned to, get_block_t *get_block) 2
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ; 8
* wait_bh ++ = bh; 70
while ( wait_bh > wait )  76
wait_on_buffer ( * -- wait_bh ); 77
if ( ! buffer_uptodate ( * wait_bh ) )  78
------------------------------
11 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c [u'todir'] 10
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char todir [ PATH_MAX ] ; 10
snprintf ( todir , sizeof ( todir ) , "%s%s/%s/tmp" , VM_SPOOL_DIR , vmu -> context , vmu -> mailbox ); 30
make_gsm_file ( vms -> fn , vms -> imapuser , todir , vms -> curmsg ); 31
------------------------------
12 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c [u'category'] 9
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char category [ 32 ] ; 9
ast_copy_string ( category , temp , sizeof ( category ) ); 97
category [ 0 ] = '\0'; 99
if ( ( ! res ) && ! ast_strlen_zero ( category ) )  106
res = play_message_category ( chan , category ); 107
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_ENVELOPE ) ) && origtime [ 0 ] != '\0' )  110
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
------------------------------
13 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c [u'duration'] 8
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char duration [ 16 ] ; 8
ast_copy_string ( duration , temp , sizeof ( duration ) ); 90
duration [ 0 ] = '\0'; 92
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
res = play_message_duration ( chan , vms , duration , vmu -> saydurationm ); 116
if ( ! res )  125
return res ; 131
------------------------------
14 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c [u'origtime'] 7
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char origtime [ 32 ] ; 7
ast_copy_string ( origtime , temp , sizeof ( origtime ) ); 83
origtime [ 0 ] = '\0'; 85
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_ENVELOPE ) ) && origtime [ 0 ] != '\0' )  110
res = play_message_datetime ( chan , vmu , origtime , "IMAP_STORAGE" ); 111
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
------------------------------
15 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c [u'context'] 6
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char context [ 256 ] ; 6
ast_copy_string ( context , temp , sizeof ( context ) ); 76
context [ 0 ] = '\0'; 78
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
res = play_message_callerid ( chan , vms , cid , context , 0 ); 113
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
------------------------------
16 /home/SySeVR/data/CVE_2007_4521_PATCHED_play_message.c [u'cid'] 5
static int CVE_2007_4521_PATCHED_play_message(struct ast_channel *chan, struct ast_vm_user *vmu, struct vm_state *vms) 1
char cid [ 256 ] ; 5
ast_copy_string ( cid , temp , sizeof ( cid ) ); 69
cid [ 0 ] = '\0'; 71
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYCID ) ) && cid [ 0 ] != '\0' && context [ 0 ] != '\0' )  112
res = play_message_callerid ( chan , vms , cid , context , 0 ); 113
if ( ( ! res ) && ( ast_test_flag ( vmu , VM_SAYDURATION ) ) && duration [ 0 ] != '\0' )  115
if ( ! res )  125
return res ; 131
------------------------------
17 /home/SySeVR/data/CVE_2007_4571_PATCHED_snd_mem_proc_read.c [u'types'] 6
static int CVE_2007_4571_PATCHED_snd_mem_proc_read(struct seq_file *seq, void *offset) 1
static char * types [ ] = { "UNKNOWN" , "CONT" , "DEV" , "DEV-SG" , "SBUS" } ; 6
seq_printf ( seq , "buffer %d : ID %08x : type %s\n" , devno , mem -> id , types [ mem -> buffer . dev . type ] ); 14
------------------------------
18 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c [u'tmp'] 55
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
unsigned long ident = 0 ; 4
if ( ! ( s = find_session ( ident ) ) )  20
if ( ! ( s = ast_calloc ( 1 , sizeof ( * s ) ) ) )  22
memcpy ( & s -> sin , requestor , sizeof ( s -> sin ) ); 26
s -> fd = - 1; 27
s -> waiting_thread = AST_PTHREADT_NULL; 28
s -> send_events = 0; 29
s -> inuse = 1; 32
s -> managerid = rand ( ) | ( unsigned long ) s; 33
s -> eventq = master_eventq; 37
while ( s -> eventq -> next )  38
s -> eventq = s -> eventq -> next; 39
if ( ! s -> authenticated && ( httptimeout > 5 ) )  47
s -> sessiontimeout += httptimeout; 50
if ( s )  53
char tmp [ 80 ] ; 55
sprintf ( tmp , "%08lx" , s -> managerid ); 83
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
tmp = xml_translate ( s -> outputstr -> str , params ); 97
tmp = html_translate ( s -> outputstr -> str ); 99
tmp = s -> outputstr -> str; 101
if ( tmp )  102
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
if ( tmp != s -> outputstr -> str )  111
free ( tmp ); 112
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
19 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c [u'cookie'] 6
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
char cookie [ 128 ] ; 6
ast_build_string ( & c , & len , "%s\r\n" , ast_http_setcookie ( "mansession_id" , tmp , httptimeout , cookie , sizeof ( cookie ) ) ); 84
------------------------------
20 /home/SySeVR/data/CVE_2008_1390_VULN_generic_http_callback.c [u'workspace'] 5
static char *CVE_2008_1390_VULN_generic_http_callback(int format, struct sockaddr_in *requestor, const char *uri, struct ast_variable *params, int *status, char **title, int *contentlength) 1
char workspace [ 512 ] ; 5
char * c = workspace ; 9
retval = malloc ( strlen ( workspace ) + strlen ( tmp ) + 128 ); 103
if ( retval )  104
strcpy ( retval , workspace ); 105
strcpy ( retval + strlen ( retval ) , tmp ); 106
c = retval + strlen ( retval ); 107
ast_build_string ( & c , & len , "</ajax-response>\n" ); 120
ast_build_string ( & c , & len , "</table></body>\r\n" ); 122
return retval ; 147
------------------------------
21 /home/SySeVR/data/CVE_2009_2484_VULN_Win32AddConnection.c [u'psz_server', u'psz_remote', u'psz_share'] 6
static void CVE_2009_2484_VULN_Win32AddConnection( access_t *p_access, char *psz_path,
char *psz_user, char *psz_pwd,
char *psz_domain ) 3
char psz_remote [ MAX_PATH ] , psz_server [ MAX_PATH ] , psz_share [ MAX_PATH ] ; 6
strlcpy ( psz_server , psz_path , sizeof ( psz_server ) ); 31
psz_share [ 0 ] = 0; 32
strlcpy ( psz_share , psz_parser , sizeof ( psz_share ) ); 38
sprintf ( psz_remote , "\\\\%s\\%s" , psz_server , psz_share ); 41
net_resource . lpRemoteName = psz_remote; 42
i_result = OurWNetAddConnection2 ( & net_resource , psz_pwd , psz_user , 0 ); 44
if ( i_result != NO_ERROR )  46
msg_Dbg ( p_access , "connected to %s" , psz_remote ); 48
if ( i_result != ERROR_ALREADY_ASSIGNED && i_result != ERROR_DEVICE_ALREADY_REMEMBERED )  50
msg_Dbg ( p_access , "already connected to %s" , psz_remote ); 53
msg_Dbg ( p_access , "failed to connect to %s" , psz_remote ); 57
------------------------------
22 /home/SySeVR/data/CVE_2009_2909_PATCHED_ax25_setsockopt.c [u'devname'] 7
static int CVE_2009_2909_PATCHED_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
char devname [ IFNAMSIZ ] ; 7
if ( copy_from_user ( devname , optval , optlen ) )  110
dev = dev_get_by_name ( & init_net , devname ); 115
if ( dev == NULL )  116
dev_put ( dev ); 125
ax25 -> ax25_dev = ax25_dev_ax25dev ( dev ); 129
ax25_fillin_cb ( ax25 , ax25 -> ax25_dev ); 130
------------------------------
23 /home/SySeVR/data/CVE_2009_2909_VULN_ax25_setsockopt.c [u'devname'] 7
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int optname,
char __user *optval, int optlen) 2
char devname [ IFNAMSIZ ] ; 7
if ( copy_from_user ( devname , optval , optlen ) )  110
dev = dev_get_by_name ( & init_net , devname ); 115
if ( dev == NULL )  116
dev_put ( dev ); 125
ax25 -> ax25_dev = ax25_dev_ax25dev ( dev ); 129
ax25_fillin_cb ( ax25 , ax25 -> ax25_dev ); 130
------------------------------
24 /home/SySeVR/data/CVE_2010_2068_PATCHED_ap_proxy_http_process_response.c [u'hop_by_hop_hdrs'] 20
static
apr_status_t CVE_2010_2068_PATCHED_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
static const char * hop_by_hop_hdrs [ ] = { "Keep-Alive" , "Proxy-Authenticate" , "TE" , "Trailer" , "Upgrade" , NULL } ; 20
for (i=0; hop_by_hop_hdrs[i]; ++i) 231
apr_table_unset ( r -> headers_out , hop_by_hop_hdrs [ i ] ); 232
------------------------------
25 /home/SySeVR/data/CVE_2010_2068_PATCHED_ap_proxy_http_process_response.c [u'buffer'] 8
static
apr_status_t CVE_2010_2068_PATCHED_ap_proxy_http_process_response(apr_pool_t * p, request_rec *r,
proxy_conn_rec *backend,
conn_rec *origin,
proxy_server_conf *conf,
char *server_portstr) 6
char buffer [ HUGE_STRING_LEN ] ; 8
rc = ap_proxygetline ( tmp_bb , buffer , sizeof ( buffer ) , rp , 0 , & len ); 42
rc = ap_proxygetline ( tmp_bb , buffer , sizeof ( buffer ) , rp , 0 , & len ); 45
ap_log_rerror ( APLOG_MARK , APLOG_ERR , rc , r ,
"proxy: error reading status line from remote "
"server %s" , backend -> hostname ) 50
if ( APR_STATUS_IS_TIMEUP ( rc ) )  51
if ( r -> proxyreq == PROXYREQ_REVERSE && c -> keepalives && ! APR_STATUS_IS_TIMEUP ( rc ) )  66
backend -> worker -> s -> read += len; 114
if ( apr_date_checkmask ( buffer , "HTTP/#.# ###*" ) )  119
if ( 2 != sscanf ( buffer , "HTTP/%u.%u" , & major , & minor ) )  122
if ( ( buffer [ 5 ] != '1' ) || ( len >= sizeof ( buffer ) - 1 ) )  129
return ap_proxyerror ( r , HTTP_BAD_GATEWAY ,
apr_pstrcat ( p , "Corrupt status line returned by remote "
"server: " , buffer , NULL ) ) 132
keepchar = buffer [ 12 ]; 136
buffer [ 12 ] = '\0'; 137
r -> status = atoi ( & buffer [ 9 ] ); 138
if ( keepchar != '\0' )  140
buffer [ 12 ] = keepchar; 141
buffer [ 12 ] = ' '; 146
buffer [ 13 ] = '\0'; 147
r -> status_line = apr_pstrdup ( p , & buffer [ 9 ] ); 149
save_table = apr_table_make ( r -> pool , 2 ); 157
apr_table_do ( addit_dammit , save_table , r -> headers_out , "Set-Cookie" , NULL ); 158
ap_proxy_read_headers ( r , rp , buffer , sizeof ( buffer ) , origin , & pread_len ); 162
if ( r -> headers_out == NULL )  165
ap_log_error ( APLOG_MARK , APLOG_WARNING , 0 ,
r -> server , "proxy: bad HTTP/%d.%d header "
"returned by %s (%s)" , major , minor , r -> uri ,
r -> method ) 169
backend -> close += 1; 170
r -> headers_out = apr_table_make ( r -> pool , 1 ); 176
r -> status = HTTP_BAD_GATEWAY; 177
r -> status_line = "bad gateway"; 178
return r -> status ; 179
apr_table_do ( addit_dammit , save_table , r -> headers_out , "Set-Cookie" , NULL ); 183
if ( ! apr_is_empty_table ( save_table ) )  187
apr_table_unset ( r -> headers_out , "Set-Cookie" ); 188
r -> headers_out = apr_table_overlay ( r -> pool , r -> headers_out , save_table ); 189
if ( apr_table_get ( r -> headers_out , "Transfer-Encoding" ) && apr_table_get ( r -> headers_out , "Content-Length" ) )  195
apr_table_unset ( r -> headers_out , "Content-Length" ); 206
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , r -> server ,
"proxy: server %s returned Transfer-Encoding"
" and Content-Length" , backend -> hostname ) 209
backend -> close += 1; 210
te = apr_table_get ( r -> headers_out , "Transfer-Encoding" ); 217
backend -> close += ap_proxy_liststr ( apr_table_get ( r -> headers_out , "Connection" ) , "close" ); 219
ap_proxy_clear_connection ( p , r -> headers_out ); 222
if ( buf = apr_table_get ( r -> headers_out , "Content-Type" ) )  223
ap_set_content_type ( r , apr_pstrdup ( p , buf ) ); 224
if ( ! ap_is_HTTP_INFO ( r -> status ) )  226
apr_table_unset ( r -> headers_out , hop_by_hop_hdrs [ i ] ); 232
r -> headers_out = ap_proxy_clean_warnings ( p , r -> headers_out ); 235
const char * server_name = ap_get_server_name ( r ) ; 239
if ( server_name == r -> hostname )  245
server_name = r -> server -> server_hostname; 246
apr_table_addn ( r -> headers_out , "Via" , ( conf -> viaopt == via_full ) ? apr_psprintf ( p , "%d.%d %s%s (%s)" , HTTP_VERSION_MAJOR ( r -> proto_num ) , HTTP_VERSION_MINOR ( r -> proto_num ) , server_name , server_portstr , AP_SERVER_BASEVERSION ) : apr_psprintf ( p , "%d.%d %s%s" , HTTP_VERSION_MAJOR ( r -> proto_num ) , HTTP_VERSION_MINOR ( r -> proto_num ) , server_name , server_portstr ) ); 248
backend -> close += 1; 266
backend -> close += 1; 274
if ( ap_is_HTTP_INFO ( r -> status ) )  277
const char * policy = apr_table_get ( r -> subprocess_env , "proxy-interim-response" ) ; 296
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , NULL , "proxy: HTTP: received interim %d response" , r -> status ); 298
if ( ! policy || ! strcasecmp ( policy , "RFC" ) )  301
if ( strcasecmp ( policy , "Suppress" ) )  307
if ( ( r -> status == 401 ) && ( conf -> error_override ) )  316
if ( buf = apr_table_get ( r -> headers_out , wa ) )  319
apr_table_set ( r -> err_headers_out , wa , buf ); 320
ap_log_error ( APLOG_MARK , APLOG_DEBUG , 0 , r -> server , "proxy: origin server sent 401 without WWW-Authenticate header" ); 322
ap_xlate_proto_to_ascii ( buffer , len ); 346
e = apr_bucket_heap_create ( buffer , cntr , NULL , c -> bucket_alloc ); 349
APR_BRIGADE_INSERT_TAIL ( bb , e ); 350
if ( ( ! r -> header_only ) && ! interim_response && ( r -> status != HTTP_NO_CONTENT ) && ( r -> status != HTTP_NOT_MODIFIED ) )  354
rp -> headers_in = apr_table_copy ( r -> pool , r -> headers_out ); 364
if ( te && ! apr_table_get ( rp -> headers_in , "Transfer-Encoding" ) )  370
apr_table_add ( rp -> headers_in , "Transfer-Encoding" , te ); 371
apr_table_unset ( r -> headers_out , "Transfer-Encoding" ); 374
if ( ! conf -> error_override || ! ap_is_HTTP_ERROR ( r -> status ) )  383
rv = ap_get_brigade ( rp -> input_filters , bb , AP_MODE_READBYTES , mode , conf -> io_buffer_size ); 392
if ( APR_STATUS_IS_EAGAIN ( rv ) || ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( bb ) ) )  398
APR_BRIGADE_INSERT_TAIL ( bb , e ); 402
backend -> close = 1; 405
if ( rv == APR_EOF )  412
if ( rv != APR_SUCCESS )  415
ap_log_cerror ( APLOG_MARK , APLOG_ERR , rv , c , "proxy: error reading response" ); 420
backend -> worker -> s -> read += readbytes; 432
backend -> close = 1; 456
APR_BRIGADE_INSERT_TAIL ( bb , e ); 474
if ( ! ap_is_HTTP_ERROR ( r -> status ) )  500
int status = r -> status ; 507
if ( ! r -> header_only && ( status != HTTP_NO_CONTENT ) && ( status != HTTP_NOT_MODIFIED ) )  510
return status ; 515
------------------------------
26 /home/SySeVR/data/CVE_2010_2431_VULN_cupsFileOpen.c [u'portname', u'hostname'] 9
cups_file_t *				/* O - CUPS file or @code NULL@ if the file or socket cannot be opened */
CVE_2010_2431_VULN_cupsFileOpen(const char *filename,	/* I - Name of file */
const char *mode)		/* I - Open mode */ 6
char hostname [ 1024 ] , * portname ; 9
strlcpy ( hostname , filename , sizeof ( hostname ) ); 45
if ( ( portname = strrchr ( hostname , ':' ) ) != NULL )  46
* portname ++ = '\0'; 47
if ( ( addrlist = httpAddrGetList ( hostname , AF_UNSPEC , portname ) ) == NULL )  55
if ( ! httpAddrConnect ( addrlist , & fd ) )  62
httpAddrFreeList ( addrlist ); 64
httpAddrFreeList ( addrlist ); 68
------------------------------
27 /home/SySeVR/data/CVE_2010_2495_VULN_pppol2tp_sendmsg.c [u'ppph'] 4
static int CVE_2010_2495_VULN_pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
size_t total_len) 2
static const unsigned char ppph [ 2 ] = { 0xff , 0x03 } ; 4
skb -> data [ 0 ] = ppph [ 0 ]; 66
skb -> data [ 1 ] = ppph [ 1 ]; 67
skb_put ( skb , 2 ); 68
error = memcpy_fromiovec ( skb -> data , m -> msg_iov , total_len ); 71
if ( error < 0 )  72
kfree_skb ( skb ); 73
skb_put ( skb , total_len ); 76
skb -> ip_summed = CHECKSUM_NONE; 80
unsigned char * datap = skb -> data ; 109
printk ( " %02X" , * datap ++ ); 113
len = skb -> len; 123
if ( error >= 0 )  127
tunnel -> stats . tx_bytes += len; 129
session -> stats . tx_bytes += len; 131
return error ; 144
------------------------------
28 /home/SySeVR/data/CVE_2010_2803_VULN_drm_ioctl.c [u'stack_kdata'] 10
long CVE_2010_2803_VULN_drm_ioctl(struct file *filp,
unsigned int cmd, unsigned long arg) 2
char stack_kdata [ 128 ] ; 10
kdata = stack_kdata; 52
if ( copy_from_user ( kdata , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) != 0 )  63
retcode = func ( dev , kdata , file_priv ); 70
retcode = func ( dev , kdata , file_priv ); 73
if ( copy_to_user ( ( void __user * ) arg , kdata , _IOC_SIZE ( cmd ) ) != 0 )  78
if ( kdata != stack_kdata )  85
kfree ( kdata ); 86
if ( retcode )  88
DRM_DEBUG ( "ret = %x\n" , retcode ); 89
return retcode ; 90
------------------------------
29 /home/SySeVR/data/CVE_2010_3848_PATCHED_econet_sendmsg.c [u'iov'] 16
static int CVE_2010_3848_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct iovec iov [ 2 ] ; 16
iov [ 0 ] . iov_base = ( void * ) & ah; 191
iov [ 0 ] . iov_len = size; 192
iov [ 1 ] . iov_base = userbuf; 200
iov [ 1 ] . iov_len = len; 201
udpmsg . msg_iov = & iov [ 0 ]; 225
udpmsg . msg_iovlen = 2; 226
udpmsg . msg_control = NULL; 227
udpmsg . msg_controllen = 0; 228
udpmsg . msg_flags = 0; 229
err = sock_sendmsg ( udpsock , & udpmsg , size ); 232
return err ; 243
------------------------------
30 /home/SySeVR/data/CVE_2010_3848_VULN_econet_sendmsg.c [u'iov'] 16
static int CVE_2010_3848_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct iovec iov [ msg -> msg_iovlen + 1 ] ; 16
iov [ 0 ] . iov_base = ( void * ) & ah; 194
iov [ 0 ] . iov_len = size; 195
void __user * base = msg -> msg_iov [ i ] . iov_base ; 197
size_t iov_len = msg -> msg_iov [ i ] . iov_len ; 198
if ( ! access_ok ( VERIFY_READ , base , iov_len ) )  200
iov [ i + 1 ] . iov_base = base; 204
iov [ i + 1 ] . iov_len = iov_len; 205
size += iov_len; 206
udpmsg . msg_iov = & iov [ 0 ]; 230
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 231
udpmsg . msg_control = NULL; 232
udpmsg . msg_controllen = 0; 233
udpmsg . msg_flags = 0; 234
err = sock_sendmsg ( udpsock , & udpmsg , size ); 237
return err ; 244
------------------------------
31 /home/SySeVR/data/CVE_2010_3849_PATCHED_econet_sendmsg.c [u'iov'] 16
static int CVE_2010_3849_PATCHED_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct iovec iov [ msg -> msg_iovlen + 1 ] ; 16
iov [ 0 ] . iov_base = ( void * ) & ah; 184
iov [ 0 ] . iov_len = size; 185
void __user * base = msg -> msg_iov [ i ] . iov_base ; 187
size_t iov_len = msg -> msg_iov [ i ] . iov_len ; 188
if ( ! access_ok ( VERIFY_READ , base , iov_len ) )  190
iov [ i + 1 ] . iov_base = base; 194
iov [ i + 1 ] . iov_len = iov_len; 195
size += iov_len; 196
udpmsg . msg_iov = & iov [ 0 ]; 220
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 221
udpmsg . msg_control = NULL; 222
udpmsg . msg_controllen = 0; 223
udpmsg . msg_flags = 0; 224
err = sock_sendmsg ( udpsock , & udpmsg , size ); 227
return err ; 234
------------------------------
32 /home/SySeVR/data/CVE_2010_3849_VULN_econet_sendmsg.c [u'iov'] 16
static int CVE_2010_3849_VULN_econet_sendmsg(struct kiocb *iocb, struct socket *sock,
struct msghdr *msg, size_t len) 2
struct iovec iov [ msg -> msg_iovlen + 1 ] ; 16
iov [ 0 ] . iov_base = ( void * ) & ah; 194
iov [ 0 ] . iov_len = size; 195
void __user * base = msg -> msg_iov [ i ] . iov_base ; 197
size_t iov_len = msg -> msg_iov [ i ] . iov_len ; 198
if ( ! access_ok ( VERIFY_READ , base , iov_len ) )  200
iov [ i + 1 ] . iov_base = base; 204
iov [ i + 1 ] . iov_len = iov_len; 205
size += iov_len; 206
udpmsg . msg_iov = & iov [ 0 ]; 230
udpmsg . msg_iovlen = msg -> msg_iovlen + 1; 231
udpmsg . msg_control = NULL; 232
udpmsg . msg_controllen = 0; 233
udpmsg . msg_flags = 0; 234
err = sock_sendmsg ( udpsock , & udpmsg , size ); 237
return err ; 244
------------------------------
33 /home/SySeVR/data/CVE_2010_4165_VULN_do_tcp_setsockopt.c [u'name'] 12
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int level,
int optname, char __user *optval, unsigned int optlen) 2
switch ( optname )  10
char name [ TCP_CA_NAME_MAX ] ; 12
name [ val ] = 0; 21
err = tcp_set_congestion_control ( sk , name ); 24
return err ; 26
return err ; 60
return err ; 109
if ( get_user ( val , ( int __user * ) optval ) )  119
if ( val < 8 || val > MAX_TCP_WINDOW )  129
tp -> rx_opt . user_mss = val; 133
if ( val )  137
if ( val < 0 || val > 1 )  154
tp -> thin_lto = val; 157
if ( val < 0 || val > 1 )  161
tp -> thin_dupack = val; 164
if ( val )  179
tp -> nonagle |= TCP_NAGLE_CORK; 180
if ( val < 1 || val > MAX_TCP_KEEPIDLE )  190
tp -> keepalive_time = val * HZ; 193
u32 elapsed = keepalive_time_elapsed ( tp ) ; 197
if ( tp -> keepalive_time > elapsed )  198
elapsed = tp -> keepalive_time - elapsed; 199
inet_csk_reset_keepalive_timer ( sk , elapsed ); 202
if ( val < 1 || val > MAX_TCP_KEEPINTVL )  207
tp -> keepalive_intvl = val * HZ; 210
if ( val < 1 || val > MAX_TCP_KEEPCNT )  213
tp -> keepalive_probes = val; 216
if ( val < 1 || val > MAX_TCP_SYNCNT )  219
icsk -> icsk_syn_retries = val; 222
if ( val < 0 )  226
tp -> linger2 = - 1; 227
if ( val > sysctl_tcp_fin_timeout / HZ )  228
tp -> linger2 = val * HZ; 231
icsk -> icsk_accept_queue . rskq_defer_accept = secs_to_retrans ( val , TCP_TIMEOUT_INIT / HZ , TCP_RTO_MAX / HZ ); 236
if ( ! val )  242
tp -> window_clamp = 0; 247
tp -> window_clamp = val < SOCK_MIN_RCVBUF / 2 ? SOCK_MIN_RCVBUF / 2 : val; 249
if ( ! val )  254
icsk -> icsk_ack . pingpong = 1; 255
if ( ! ( val & 1 ) )  263
err = tp -> af_specific -> md5_parse ( sk , optval , optlen ); 272
return err ; 282
------------------------------
34 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeScroll.c [u'copy'] 3
static int CVE_2011_0021_PATCHED_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ; 3
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) ); 41
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
35 /home/SySeVR/data/CVE_2011_0021_PATCHED_DecodeTileBlock.c [u'p_color'] 3
static int CVE_2011_0021_PATCHED_DecodeTileBlock( decoder_sys_t *p_cdg, const uint8_t *p_data, int doXor ) 1
int p_color [ 2 ] ; 3
p_color [ 0 ] = p_data [ 0 ] & 0x0f; 7
p_color [ 1 ] = p_data [ 1 ] & 0x0f; 8
* p ^= p_color [ idx ]; 26
* p = p_color [ idx ]; 28
------------------------------
36 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeScroll.c [u'copy'] 3
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy ) 1
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ; 3
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) ); 41
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ]; 65
------------------------------
37 /home/SySeVR/data/CVE_2011_0021_VULN_DecodeTileBlock.c [u'p_color'] 3
static int CVE_2011_0021_VULN_DecodeTileBlock( decoder_sys_t *p_cdg, const uint8_t *p_data, int doXor ) 1
int p_color [ 2 ] ; 3
p_color [ 0 ] = p_data [ 0 ] & 0x0f; 7
p_color [ 1 ] = p_data [ 1 ] & 0x0f; 8
* p ^= p_color [ idx ]; 20
* p = p_color [ idx ]; 22
------------------------------
38 /home/SySeVR/data/CVE_2011_0055_VULN_JO.c [u'vec'] 9
static JSBool
CVE_2011_0055_VULN_JO(JSContext *cx, jsval *vp, StringifyContext *scx) 2
if ( ! scx -> cb . append ( '{' ) )  6
jsval vec [ 3 ] = { JSVAL_NULL , JSVAL_NULL , JSVAL_NULL } ; 9
jsval & key = vec [ 0 ] ; 11
jsval & outputValue = vec [ 1 ] ; 12
vec [ 2 ] = OBJECT_TO_JSVAL ( scx -> replacer ); 21
keySource = & vec [ 2 ]; 22
if ( ! js_ValueToIterator ( cx , JSITER_ENUMERATE , keySource ) )  25
iterObj = JSVAL_TO_OBJECT ( * keySource ); 27
if ( ! js_CallIteratorNext ( cx , iterObj , & key ) )  34
if ( key == JSVAL_HOLE )  36
if ( ! js_IdIsIndex ( key , & index ) )  42
if ( ! scx -> replacer -> getProperty ( cx , key , & newKey ) )  46
if ( JSVAL_IS_STRING ( key ) )  52
ks = JSVAL_TO_STRING ( key ); 53
ks = js_ValueToString ( cx , key ); 55
if ( ! ks )  56
if ( ! js_ValueToStringId ( cx , STRING_TO_JSVAL ( ks ) , & id ) || ! js_HasOwnProperty ( cx , obj -> map -> ops -> lookupProperty , obj , id , & v ) )  65
JSString * s = js_ValueToString ( cx , key ) ; 99
if ( ! s )  100
s -> getCharsAndLength ( chars , length ); 105
if ( iterObj )  115
JS_ASSERT ( OBJECT_TO_JSVAL ( iterObj ) == * keySource ); 117
ok &= js_CloseIterator ( cx , * keySource ); 118
if ( ! ok )  121
------------------------------
39 /home/SySeVR/data/CVE_2011_0726_PATCHED_do_task_stat.c [u'tcomm'] 19
static int CVE_2011_0726_PATCHED_do_task_stat(struct seq_file *m, struct pid_namespace *ns,
struct pid *pid, struct task_struct *task, int whole) 2
char tcomm [ sizeof ( task -> comm ) ] ; 19
get_task_comm ( tcomm , task ); 34
seq_printf ( m , "%d (%s) %c %d %d %d %d %d %u %lu \\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\n" , pid_nr_ns ( pid , ns ) , tcomm , state , ppid , pgid , sid , tty_nr , tty_pgrp , task -> flags , min_flt , cmin_flt , maj_flt , cmaj_flt , cputime_to_clock_t ( utime ) , cputime_to_clock_t ( stime ) , cputime_to_clock_t ( cutime ) , cputime_to_clock_t ( cstime ) , priority , nice , num_threads , start_time , vsize , mm ? get_mm_rss ( mm ) : 0 , rsslim , mm ? ( permitted ? mm -> start_code : 1 ) : 0 , mm ? ( permitted ? mm -> end_code : 1 ) : 0 , ( permitted && mm ) ? mm -> start_stack : 0 , esp , eip , task -> pending . signal . sig [ 0 ] & 0x7fffffffUL , task -> blocked . sig [ 0 ] & 0x7fffffffUL , sigign . sig [ 0 ] & 0x7fffffffUL , sigcatch . sig [ 0 ] & 0x7fffffffUL , wchan , 0UL , 0UL , task -> exit_signal , task_cpu ( task ) , task -> rt_priority , task -> policy , ( unsigned long long ) delayacct_blkio_ticks ( task ) , cputime_to_clock_t ( gtime ) , cputime_to_clock_t ( cgtime ) ); 106
------------------------------
40 /home/SySeVR/data/CVE_2011_0726_VULN_do_task_stat.c [u'tcomm'] 19
static int CVE_2011_0726_VULN_do_task_stat(struct seq_file *m, struct pid_namespace *ns,
struct pid *pid, struct task_struct *task, int whole) 2
char tcomm [ sizeof ( task -> comm ) ] ; 19
get_task_comm ( tcomm , task ); 34
seq_printf ( m , "%d (%s) %c %d %d %d %d %d %u %lu \\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\n" , pid_nr_ns ( pid , ns ) , tcomm , state , ppid , pgid , sid , tty_nr , tty_pgrp , task -> flags , min_flt , cmin_flt , maj_flt , cmaj_flt , cputime_to_clock_t ( utime ) , cputime_to_clock_t ( stime ) , cputime_to_clock_t ( cutime ) , cputime_to_clock_t ( cstime ) , priority , nice , num_threads , start_time , vsize , mm ? get_mm_rss ( mm ) : 0 , rsslim , mm ? mm -> start_code : 0 , mm ? mm -> end_code : 0 , ( permitted && mm ) ? mm -> start_stack : 0 , esp , eip , task -> pending . signal . sig [ 0 ] & 0x7fffffffUL , task -> blocked . sig [ 0 ] & 0x7fffffffUL , sigign . sig [ 0 ] & 0x7fffffffUL , sigcatch . sig [ 0 ] & 0x7fffffffUL , wchan , 0UL , 0UL , task -> exit_signal , task_cpu ( task ) , task -> rt_priority , task -> policy , ( unsigned long long ) delayacct_blkio_ticks ( task ) , cputime_to_clock_t ( gtime ) , cputime_to_clock_t ( cgtime ) ); 106
------------------------------
41 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c [u'lengths'] 22
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int lengths [ 16 ] ; 22
if ( ( stat = decode_open_type ( buf , len , & ptr , & bufs [ total_count + i ] , & lengths [ total_count + i ] ) ) != 0 )  53
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 65
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 66
s -> f [ ifp_no ] . mallocd = 0; 68
s -> f [ ifp_no ] . seqno = seq_no - i; 69
s -> f [ ifp_no ] . datalen = lengths [ i - 1 ]; 70
s -> f [ ifp_no ] . data = ( uint8_t * ) bufs [ i - 1 ]; 71
s -> f [ ifp_no ] . offset = 0; 72
s -> f [ ifp_no ] . src = "UDPTL"; 73
if ( ifp_no > 0 )  74
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 75
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 76
ifp_no ++; 77
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
------------------------------
42 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c [u'bufs'] 21
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
const uint8_t * bufs [ 16 ] ; 21
if ( ( stat = decode_open_type ( buf , len , & ptr , & bufs [ total_count + i ] , & lengths [ total_count + i ] ) ) != 0 )  53
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 65
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 66
s -> f [ ifp_no ] . mallocd = 0; 68
s -> f [ ifp_no ] . seqno = seq_no - i; 69
s -> f [ ifp_no ] . datalen = lengths [ i - 1 ]; 70
s -> f [ ifp_no ] . data = ( uint8_t * ) bufs [ i - 1 ]; 71
s -> f [ ifp_no ] . offset = 0; 72
s -> f [ ifp_no ] . src = "UDPTL"; 73
if ( ifp_no > 0 )  74
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 75
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 76
ifp_no ++; 77
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
------------------------------
43 /home/SySeVR/data/CVE_2011_1147_VULN_udptl_rx_packet.c [u'repaired'] 20
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len) 1
int repaired [ 16 ] ; 20
memset ( repaired , 0 , sizeof ( repaired ) ); 99
repaired [ x ] = TRUE; 104
s -> rx [ x ] . fec_span = span; 114
s -> rx [ x ] . fec_entries = entries; 121
if ( ( stat = decode_open_type ( buf , len , & ptr , & data , & s -> rx [ x ] . fec_len [ i ] ) ) != 0 )  125
if ( s -> rx [ x ] . fec_len [ i ] > LOCAL_FAX_MAX_DATAGRAM )  127
memcpy ( s -> rx [ x ] . fec [ i ] , data , s -> rx [ x ] . fec_len [ i ] ); 131
for (j = 0; j < s->rx[x].fec_len[i]; j++) 134
for (l = x; l != ((x - (16 - span*entries)) & UDPTL_BUF_MASK); l = (l - 1) & UDPTL_BUF_MASK) 142
if ( s -> rx [ l ] . fec_len [ 0 ] <= 0 )  143
for (m = 0; m < s->rx[l].fec_entries; m++) 145
limit = ( l + m ) & UDPTL_BUF_MASK; 146
for (which = -1, k = (limit - s->rx[l].fec_span * s->rx[l].fec_entries) & UDPTL_BUF_MASK; k != limit; k = (k + s->rx[l].fec_entries) & UDPTL_BUF_MASK) 147
if ( s -> rx [ k ] . buf_len <= 0 )  148
which = ( which == - 1 ) ? k : - 2; 149
if ( which >= 0 )  151
for (j = 0; j < s->rx[l].fec_len[m]; j++) 153
s -> rx [ which ] . buf [ j ] = s -> rx [ l ] . fec [ m ] [ j ]; 154
for (k = (limit - s->rx[l].fec_span * s->rx[l].fec_entries) & UDPTL_BUF_MASK; k != limit; k = (k + s->rx[l].fec_entries) & UDPTL_BUF_MASK) 155
s -> rx [ which ] . buf [ j ] ^= ( s -> rx [ k ] . buf_len > j ) ? s -> rx [ k ] . buf [ j ] : 0; 156
s -> rx [ which ] . buf_len = s -> rx [ l ] . fec_len [ m ]; 158
repaired [ which ] = TRUE; 159
for (l = (x + 1) & UDPTL_BUF_MASK, j = seq_no - UDPTL_BUF_MASK; l != x; l = (l + 1) & UDPTL_BUF_MASK, j++) 164
if ( repaired [ l ] )  165
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 167
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 168
s -> f [ ifp_no ] . mallocd = 0; 170
s -> f [ ifp_no ] . seqno = j; 171
s -> f [ ifp_no ] . datalen = s -> rx [ l ] . buf_len; 172
s -> f [ ifp_no ] . data = s -> rx [ l ] . buf; 173
s -> f [ ifp_no ] . offset = 0; 174
s -> f [ ifp_no ] . src = "UDPTL"; 175
if ( ifp_no > 0 )  176
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 177
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 178
ifp_no ++; 179
if ( seq_no >= s -> rx_seq_no )  186
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM; 188
s -> f [ ifp_no ] . subclass = AST_MODEM_T38; 189
s -> f [ ifp_no ] . mallocd = 0; 191
s -> f [ ifp_no ] . seqno = seq_no; 192
s -> f [ ifp_no ] . datalen = ifp_len; 193
s -> f [ ifp_no ] . data = ( uint8_t * ) ifp; 194
s -> f [ ifp_no ] . offset = 0; 195
s -> f [ ifp_no ] . src = "UDPTL"; 196
if ( ifp_no > 0 )  197
AST_LIST_NEXT ( & s -> f [ ifp_no - 1 ] , frame_list ) = & s -> f [ ifp_no ]; 198
AST_LIST_NEXT ( & s -> f [ ifp_no ] , frame_list ) = NULL; 199
ifp_no ++; 201
s -> rx_seq_no = seq_no + 1; 204
return ifp_no ; 205
------------------------------
44 /home/SySeVR/data/CVE_2011_1175_VULN_handle_tcptls_connection.c [u'err'] 7
static void *CVE_2011_1175_VULN_handle_tcptls_connection(void *data) 1
char err [ 256 ] ; 7
ast_verb ( 2 , "Problem setting up ssl connection: %s\n" , ERR_error_string ( ERR_get_error ( ) , err ) ); 21
------------------------------
45 /home/SySeVR/data/CVE_2011_1573_VULN_sctp_make_init_ack.c [u'extensions'] 16
struct sctp_chunk *CVE_2011_1573_VULN_sctp_make_init_ack(const struct sctp_association *asoc,
const struct sctp_chunk *chunk,
gfp_t gfp, int unkparam_len) 3
__u8 extensions [ 3 ] ; 16
extensions [ num_ext ] = SCTP_CID_ASCONF; 54
extensions [ num_ext + 1 ] = SCTP_CID_ASCONF_ACK; 55
num_ext += 2; 56
extensions [ num_ext ] = SCTP_CID_AUTH; 78
num_ext += 1; 79
if ( num_ext )  82
chunksize += sizeof ( sctp_supported_ext_param_t ) + num_ext; 83
retval = sctp_make_chunk ( asoc , SCTP_CID_INIT_ACK , 0 , chunksize ); 86
if ( ! retval )  87
retval -> transport = chunk -> transport; 93
retval -> subh . init_hdr = sctp_addto_chunk ( retval , sizeof ( initack ) , & initack ); 94
retval -> param_hdr . v = sctp_addto_chunk ( retval , addrs_len , addrs . v ); 96
sctp_addto_chunk ( retval , cookie_len , cookie ); 97
sctp_addto_chunk ( retval , sizeof ( ecap_param ) , & ecap_param ); 99
if ( num_ext )  100
ext_param . param_hdr . length = htons ( sizeof ( sctp_supported_ext_param_t ) + num_ext ); 102
sctp_addto_chunk ( retval , sizeof ( sctp_supported_ext_param_t ) , & ext_param ); 104
sctp_addto_param ( retval , num_ext , extensions ); 106
sctp_addto_chunk ( retval , sizeof ( prsctp_param ) , & prsctp_param ); 109
sctp_addto_chunk ( retval , sizeof ( aiparam ) , & aiparam ); 115
sctp_addto_chunk ( retval , ntohs ( auth_random -> length ) , auth_random ); 119
sctp_addto_chunk ( retval , ntohs ( auth_hmacs -> length ) , auth_hmacs ); 122
sctp_addto_chunk ( retval , ntohs ( auth_chunks -> length ) , auth_chunks ); 125
retval -> asoc = ( struct sctp_association * ) asoc; 130
retval -> transport = chunk -> transport; 142
return retval ; 148
------------------------------
46 /home/SySeVR/data/CVE_2011_1833_PATCHED_ecryptfs_parse_options.c [u'args'] 15
static int CVE_2011_1833_PATCHED_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
uid_t *check_ruid) 2
substring_t args [ MAX_OPT_ARGS ] ; 15
token = match_token ( p , tokens , args ); 37
switch ( token )  38
sig_src = args [ 0 ] . from; 41
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); 42
if ( rc )  44
printk ( KERN_ERR "Error attempting to register "
"global sig; rc = [%d]\n" , rc ) 46
cipher_name_src = args [ 0 ] . from; 53
cipher_name_dst = mount_crypt_stat -> global_default_cipher_name; 54
strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ); 57
cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 59
cipher_key_bytes_src = args [ 0 ] . from; 63
cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); 64
mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; 67
mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; 72
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 76
mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; 80
mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; 82
fnek_src = args [ 0 ] . from; 86
fnek_dst = mount_crypt_stat -> global_default_fnek_sig; 87
strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ); 89
mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; 90
rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); 92
if ( rc )  96
printk ( KERN_ERR "Error attempting to register "
"global fnek sig [%s]; rc = [%d]\n" ,
mount_crypt_stat -> global_default_fnek_sig ,
rc ) 100
mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); 103
fn_cipher_name_src = args [ 0 ] . from; 108
fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name; 109
strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ); 111
mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; 113
fn_cipher_key_bytes_src = args [ 0 ] . from; 118
fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); 119
mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; 122
mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; 127
mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; 130
printk ( KERN_WARNING
"%s: eCryptfs: unrecognized option [%s]\n" ,
__func__ , p ) 140
ecryptfs_printk ( KERN_ERR , "You must supply at least one valid "
"auth tok signature as a mount "
"parameter; see the eCryptfs README\n" ) 147
BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ); 153
strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ); 154
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set )  157
strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ); 159
mount_crypt_stat -> global_default_cipher_key_size = 0; 162
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set )  163
mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size; 165
if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) )  168
rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ); 170
if ( rc )  173
if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) )  185
rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ); 188
if ( rc )  191
if ( rc )  205
printk ( KERN_WARNING "One or more global auth toks could not "
"properly register; rc = [%d]\n" , rc ) 207
return rc ; 209
------------------------------
47 /home/SySeVR/data/CVE_2011_2534_VULN_clusterip_proc_write.c [u'buffer'] 6
static ssize_t CVE_2011_2534_VULN_clusterip_proc_write(struct file *file, const char __user *input,
size_t size, loff_t *ofs) 2
char buffer [ PROC_WRITELEN + 1 ] ; 6
if ( copy_from_user ( buffer , input , PROC_WRITELEN ) )  9
if ( * buffer == '+' )  12
nodenum = simple_strtoul ( buffer + 1 , NULL , 10 ); 13
if ( clusterip_add_node ( c , nodenum ) )  14
if ( * buffer == '-' )  16
nodenum = simple_strtoul ( buffer + 1 , NULL , 10 ); 17
if ( clusterip_del_node ( c , nodenum ) )  18
------------------------------
48 /home/SySeVR/data/CVE_2011_2536_PATCHED_register_verify.c [u'tmp'] 7
static enum check_auth_result CVE_2011_2536_PATCHED_register_verify(struct sip_pvt *p, struct ast_sockaddr *addr,
struct sip_request *req, const char *uri) 3
char tmp [ 256 ] ; 7
ast_copy_string ( tmp , get_header ( req , "To" ) , sizeof ( tmp ) ); 13
c = get_in_brackets ( tmp ); 15
c = remove_uri_parameters ( c ); 16
if ( parse_uri ( c , "sip:,sips:" , & name , & dummy , & domain , NULL ) )  18
ast_log ( LOG_NOTICE , "Invalid to address: '%s' from %s (missing sip:) trying to use anyway...\n" , c , ast_sockaddr_stringify_addr ( addr ) ); 19
------------------------------
49 /home/SySeVR/data/CVE_2011_2536_VULN_register_verify.c [u'tmp'] 7
static enum check_auth_result CVE_2011_2536_VULN_register_verify(struct sip_pvt *p, struct ast_sockaddr *addr,
struct sip_request *req, const char *uri) 3
char tmp [ 256 ] ; 7
ast_copy_string ( tmp , get_header ( req , "To" ) , sizeof ( tmp ) ); 13
c = get_in_brackets ( tmp ); 15
c = remove_uri_parameters ( c ); 16
if ( parse_uri ( c , "sip:,sips:" , & name , & dummy , & domain , NULL ) )  18
ast_log ( LOG_NOTICE , "Invalid to address: '%s' from %s (missing sip:) trying to use anyway...\n" , c , ast_sockaddr_stringify_addr ( addr ) ); 19
------------------------------
50 /home/SySeVR/data/CVE_2011_2980_PATCHED_ThinkPadSensor__Startup.c [u'path'] 4
PRBool
CVE_2011_2980_PATCHED_ThinkPadSensor::Startup() 2
WCHAR path [ MAX_PATH + sizeof ( "sensor.dll" ) ] ; 4
if ( GetSystemDirectoryW ( path , MAX_PATH ) )  5
wcscat ( path , L "sensor.dll" ) 6
mLibrary = LoadLibraryW ( path ); 7
if ( ! mLibrary )  9
gShockproofGetAccelerometerData = ( ShockproofGetAccelerometerData ) GetProcAddress ( mLibrary , "ShockproofGetAccelerometerData" ); 12
if ( ! gShockproofGetAccelerometerData )  14
FreeLibrary ( mLibrary ); 15
------------------------------
51 /home/SySeVR/data/CVE_2011_3362_PATCHED_decode_residual_block.c [u'run_buf'] 7
static int CVE_2011_3362_PATCHED_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
uint8_t run_buf [ 65 ] ; 7
run_buf [ i ] = run; 28
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  30
------------------------------
52 /home/SySeVR/data/CVE_2011_3362_PATCHED_decode_residual_block.c [u'level_buf'] 6
static int CVE_2011_3362_PATCHED_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
DCTELEM level_buf [ 65 ] ; 6
level_buf [ i ] = level; 27
run_buf [ i ] = run; 28
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  30
------------------------------
53 /home/SySeVR/data/CVE_2011_3362_VULN_decode_residual_block.c [u'run_buf'] 6
static int CVE_2011_3362_VULN_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
uint8_t run_buf [ 65 ] ; 6
run_buf [ i ] = run; 27
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  29
------------------------------
54 /home/SySeVR/data/CVE_2011_3362_VULN_decode_residual_block.c [u'level_buf'] 5
static int CVE_2011_3362_VULN_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
DCTELEM level_buf [ 65 ] ; 5
level_buf [ i ] = level; 26
run_buf [ i ] = run; 27
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  29
------------------------------
55 /home/SySeVR/data/CVE_2011_3945_PATCHED_decode_frame.c [u'offsets'] 6
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
int offsets [ 8 ] ; 6
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
if ( offsets [ oidx ] < 0 )  56
offsets [ oidx ] = AV_RL24 ( buf ); 59
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
56 /home/SySeVR/data/CVE_2011_3945_VULN_decode_frame.c [u'offsets'] 6
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) 1
int offsets [ 7 ] ; 6
offsets [ i ] = - 1; 37
while ( outcnt < maxcnt && buf_end - 2 > buf )  39
out [ outcnt ++ ] = code; 44
if ( offsets [ oidx ] < 0 )  56
offsets [ oidx ] = AV_RL24 ( buf ); 59
start = ( outcnt + offsets [ oidx ] ) % maxcnt; 63
if ( maxcnt - start < count )  65
inp = prev + start; 68
if ( outcnt < offset )  83
inp = out + outcnt - offset; 86
if ( maxcnt - outcnt < count )  89
for (i = 0; i < count; i++) 92
out [ outcnt ++ ] = inp [ i ]; 93
if ( outcnt - maxcnt )  97
av_log ( avctx , AV_LOG_DEBUG , "frame finished with %d diff\n" , outcnt - maxcnt ); 98
------------------------------
57 /home/SySeVR/data/CVE_2011_3950_PATCHED_dirac_decode_data_unit.c [u'ver'] 32
static int CVE_2011_3950_PATCHED_dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int size) 1
int i , parse_code = buf [ 4 ] ; 5
if ( size < DATA_UNIT_HEADER_SIZE )  8
if ( parse_code == pc_seq_header )  13
if ( parse_code == pc_eos )  27
if ( parse_code == pc_aux_data )  30
if ( buf [ 13 ] == 1 )  31
int ver [ 3 ] ; 32
if ( sscanf ( buf + 14 , "Schroedinger %d.%d.%d" , ver , ver + 1 , ver + 2 ) == 3 )  35
if ( ver [ 0 ] == 1 && ver [ 1 ] == 0 && ver [ 2 ] <= 7 )  36
------------------------------
58 /home/SySeVR/data/CVE_2011_3973_PATCHED_decode_residual_block.c [u'run_buf'] 7
static int CVE_2011_3973_PATCHED_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
uint8_t run_buf [ 65 ] ; 7
run_buf [ i ] = run; 30
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  32
------------------------------
59 /home/SySeVR/data/CVE_2011_3973_PATCHED_decode_residual_block.c [u'level_buf'] 6
static int CVE_2011_3973_PATCHED_decode_residual_block(AVSContext *h, GetBitContext *gb,
const struct dec_2dvlc *r, int esc_golomb_order,
int qp, uint8_t *dst, int stride) 3
DCTELEM level_buf [ 65 ] ; 6
level_buf [ i ] = level; 29
run_buf [ i ] = run; 30
if ( dequant ( h , level_buf , run_buf , block , ff_cavs_dequant_mul [ qp ] , ff_cavs_dequant_shift [ qp ] , i ) )  32
------------------------------
60 /home/SySeVR/data/CVE_2011_4594_PATCHED___sys_sendmsg.c [u'iovstack', u'iov'] 8
static int CVE_2011_4594_PATCHED___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
struct msghdr *msg_sys, unsigned flags,
struct used_address *used_address) 3
struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; 8
err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 38
err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ); 42
if ( err < 0 )  45
total_len = err; 47
if ( err )  58
err = sock_sendmsg_nosec ( sock , msg_sys , total_len ); 94
err = sock_sendmsg ( sock , msg_sys , total_len ); 97
if ( used_address && err >= 0 )  102
if ( iov != iovstack )  113
sock_kfree_s ( sock -> sk , iov , iov_size ); 114
return err ; 116
------------------------------
61 /home/SySeVR/data/CVE_2011_4598_PATCHED_handle_request_info.c [u'buf'] 3
static void CVE_2011_4598_PATCHED_handle_request_info(struct sip_pvt *p, struct sip_request *req) 1
char buf [ 1024 ] ; 3
ast_copy_string ( buf , c , sizeof ( buf ) ); 24
if ( ast_strlen_zero ( buf ) )  33
if ( buf [ 0 ] == '*' )  38
if ( buf [ 0 ] == '#' )  40
if ( ( buf [ 0 ] >= 'A' ) && ( buf [ 0 ] <= 'D' ) )  42
event = 12 + buf [ 0 ] - 'A'; 43
if ( buf [ 0 ] == '!' )  44
event = atoi ( buf ); 47
if ( event == 16 )  48
if ( event < 10 )  57
f . subclass . integer = '0' + event; 58
if ( event == 10 )  59
if ( event == 11 )  61
if ( event < 16 )  63
f . subclass . integer = 'A' + ( event - 12 ); 64
f . len = duration; 66
ast_queue_frame ( p -> owner , & f ); 67
ast_verbose ( "* DTMF-relay event received: %c\n" , ( int ) f . subclass . integer ); 69
get_msg_text ( buf , sizeof ( buf ) , req , TRUE ); 83
if ( ast_strlen_zero ( buf ) )  86
event = atoi ( buf ); 90
if ( event == 16 )  91
if ( event < 10 )  100
f . subclass . integer = '0' + event; 101
if ( event == 10 )  102
if ( event == 11 )  104
if ( event < 16 )  106
f . subclass . integer = 'A' + ( event - 12 ); 107
f . len = duration; 109
ast_queue_frame ( p -> owner , & f ); 110
ast_verbose ( "* DTMF-relay event received: %c\n" , ( int ) f . subclass . integer ); 112
f . len = 100; 164
f . subclass . integer = feat -> exten [ j ]; 166
ast_queue_frame ( p -> owner , & f ); 167
ast_verbose ( "* DTMF-relay event faked: %c\n" , f . subclass . integer ); 169
ast_log ( LOG_WARNING , "Unable to parse INFO message from %s. Content %s\n" , p -> callid , buf ); 185
------------------------------
62 /home/SySeVR/data/CVE_2011_4598_VULN_handle_request_info.c [u'buf'] 3
static void CVE_2011_4598_VULN_handle_request_info(struct sip_pvt *p, struct sip_request *req) 1
char buf [ 1024 ] ; 3
ast_copy_string ( buf , c , sizeof ( buf ) ); 24
if ( ast_strlen_zero ( buf ) )  33
if ( buf [ 0 ] == '*' )  38
if ( buf [ 0 ] == '#' )  40
if ( ( buf [ 0 ] >= 'A' ) && ( buf [ 0 ] <= 'D' ) )  42
event = 12 + buf [ 0 ] - 'A'; 43
if ( buf [ 0 ] == '!' )  44
event = atoi ( buf ); 47
if ( event == 16 )  48
if ( event < 10 )  57
f . subclass . integer = '0' + event; 58
if ( event == 10 )  59
if ( event == 11 )  61
if ( event < 16 )  63
f . subclass . integer = 'A' + ( event - 12 ); 64
f . len = duration; 66
ast_queue_frame ( p -> owner , & f ); 67
ast_verbose ( "* DTMF-relay event received: %c\n" , ( int ) f . subclass . integer ); 69
get_msg_text ( buf , sizeof ( buf ) , req , TRUE ); 83
if ( ast_strlen_zero ( buf ) )  86
event = atoi ( buf ); 90
if ( event == 16 )  91
ast_queue_frame ( p -> owner , & f ); 94
if ( event < 10 )  100
f . subclass . integer = '0' + event; 101
if ( event == 10 )  102
if ( event == 11 )  104
if ( event < 16 )  106
f . subclass . integer = 'A' + ( event - 12 ); 107
f . len = duration; 109
ast_queue_frame ( p -> owner , & f ); 110
ast_verbose ( "* DTMF-relay event received: %c\n" , ( int ) f . subclass . integer ); 112
f . len = 100; 157
f . subclass . integer = feat -> exten [ j ]; 159
ast_queue_frame ( p -> owner , & f ); 160
ast_verbose ( "* DTMF-relay event faked: %c\n" , f . subclass . integer ); 162
ast_log ( LOG_WARNING , "Unable to parse INFO message from %s. Content %s\n" , p -> callid , buf ); 178
------------------------------
63 /home/SySeVR/data/CVE_2012_0067_PATCHED_iptrace_read_1_0.c [u'fddi_padding'] 9
static gboolean CVE_2012_0067_PATCHED_iptrace_read_1_0(wtap *wth, int *err, gchar **err_info,
gint64 *data_offset) 2
guint8 fddi_padding [ 3 ] ; 9
if ( ! iptrace_read_rec_data ( wth -> fh , fddi_padding , 3 , err , err_info ) )  68
------------------------------
64 /home/SySeVR/data/CVE_2012_0067_PATCHED_iptrace_read_1_0.c [u'header'] 6
static gboolean CVE_2012_0067_PATCHED_iptrace_read_1_0(wtap *wth, int *err, gchar **err_info,
gint64 *data_offset) 2
guint8 header [ IPTRACE_1_0_PHDR_SIZE ] ; 6
ret = iptrace_read_rec_header ( wth -> fh , header , IPTRACE_1_0_PHDR_SIZE , err , err_info ); 13
if ( ret <= 0 )  15
pkt_hdr . if_type = header [ 28 ]; 26
wth -> phdr . pkt_encap = wtap_encap_ift ( pkt_hdr . if_type ); 27
packet_size = pntohl ( & header [ 0 ] ); 30
if ( packet_size < IPTRACE_1_0_PDATA_SIZE )  31
* err_info = g_strdup_printf ( "iptrace: file has a %u-byte record, too small to have even a packet meta-data header" , packet_size ); 37
packet_size -= IPTRACE_1_0_PDATA_SIZE; 41
if ( wth -> phdr . pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED )  47
if ( packet_size < 3 )  52
* err_info = g_strdup_printf ( "iptrace: file has a %u-byte record, too small to have even a packet meta-data header" , packet_size + IPTRACE_1_0_PDATA_SIZE ); 58
packet_size -= 3; 62
wth -> data_offset += 3; 63
if ( ! iptrace_read_rec_data ( wth -> fh , fddi_padding , 3 , err , err_info ) )  68
if ( packet_size > WTAP_MAX_PACKET_SIZE )  72
* err_info = g_strdup_printf ( "iptrace: File has %u-byte packet, bigger than maximum of %u" , packet_size , WTAP_MAX_PACKET_SIZE ); 78
buffer_assure_space ( wth -> frame_buffer , packet_size ); 83
data_ptr = buffer_start_ptr ( wth -> frame_buffer ); 84
if ( ! iptrace_read_rec_data ( wth -> fh , data_ptr , packet_size , err , err_info ) )  85
wth -> data_offset += packet_size; 88
wth -> phdr . len = packet_size; 90
wth -> phdr . caplen = packet_size; 91
wth -> phdr . ts . secs = pntohl ( & header [ 4 ] ); 92
wth -> phdr . ts . nsecs = 0; 93
if ( wth -> phdr . pkt_encap == WTAP_ENCAP_UNKNOWN )  95
* err_info = g_strdup_printf ( "iptrace: interface type IFT=0x%02x unknown or unsupported" , pkt_hdr . if_type ); 97
fill_in_pseudo_header ( wth -> phdr . pkt_encap , data_ptr , wth -> phdr . caplen , & wth -> pseudo_header , header ); 103
if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN )  112
wth -> file_encap = wth -> phdr . pkt_encap; 113
if ( wth -> file_encap != wth -> phdr . pkt_encap )  115
------------------------------
65 /home/SySeVR/data/CVE_2012_0067_VULN_iptrace_read_1_0.c [u'fddi_padding'] 9
static gboolean CVE_2012_0067_VULN_iptrace_read_1_0(wtap *wth, int *err, gchar **err_info,
gint64 *data_offset) 2
guint8 fddi_padding [ 3 ] ; 9
if ( ! iptrace_read_rec_data ( wth -> fh , fddi_padding , 3 , err , err_info ) )  47
------------------------------
66 /home/SySeVR/data/CVE_2012_0067_VULN_iptrace_read_1_0.c [u'header'] 6
static gboolean CVE_2012_0067_VULN_iptrace_read_1_0(wtap *wth, int *err, gchar **err_info,
gint64 *data_offset) 2
guint8 header [ IPTRACE_1_0_PHDR_SIZE ] ; 6
ret = iptrace_read_rec_header ( wth -> fh , header , IPTRACE_1_0_PHDR_SIZE , err , err_info ); 13
if ( ret <= 0 )  15
pkt_hdr . if_type = header [ 28 ]; 26
wth -> phdr . pkt_encap = wtap_encap_ift ( pkt_hdr . if_type ); 27
packet_size = pntohl ( & header [ 0 ] ) - IPTRACE_1_0_PDATA_SIZE; 30
if ( wth -> phdr . pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED )  36
packet_size -= 3; 41
wth -> data_offset += 3; 42
if ( ! iptrace_read_rec_data ( wth -> fh , fddi_padding , 3 , err , err_info ) )  47
buffer_assure_space ( wth -> frame_buffer , packet_size ); 52
data_ptr = buffer_start_ptr ( wth -> frame_buffer ); 53
if ( ! iptrace_read_rec_data ( wth -> fh , data_ptr , packet_size , err , err_info ) )  54
wth -> data_offset += packet_size; 57
wth -> phdr . len = packet_size; 59
wth -> phdr . caplen = packet_size; 60
wth -> phdr . ts . secs = pntohl ( & header [ 4 ] ); 61
wth -> phdr . ts . nsecs = 0; 62
if ( wth -> phdr . pkt_encap == WTAP_ENCAP_UNKNOWN )  64
* err_info = g_strdup_printf ( "iptrace: interface type IFT=0x%02x unknown or unsupported" , pkt_hdr . if_type ); 66
fill_in_pseudo_header ( wth -> phdr . pkt_encap , data_ptr , wth -> phdr . caplen , & wth -> pseudo_header , header ); 72
if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN )  81
wth -> file_encap = wth -> phdr . pkt_encap; 82
if ( wth -> file_encap != wth -> phdr . pkt_encap )  84
------------------------------
67 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c [u'cns'] 446
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
------------------------------
68 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c [u'cns'] 314
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
------------------------------
69 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c [u'cns'] 198
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
------------------------------
70 /home/SySeVR/data/CVE_2012_0477_PATCHED_nsISO2022CNToUnicode__Convert.c [u'gb'] 116
NS_IMETHODIMP CVE_2012_0477_PATCHED_nsISO2022CNToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
nsresult rv ; 7
PRInt32 aLen ; 8
while ( src < srcEnd )  10
switch ( mState )  12
if ( ESC == * src )  15
mState = eState_ESC; 16
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  18
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 20
mState = eState_ASCII; 22
if ( '$' == * src )  27
mState = eState_ESC_24; 28
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  30
* dest ++ = ( PRUnichar ) ESC; 32
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 33
mState = eState_ASCII; 35
if ( ')' == * src )  40
mState = eState_ESC_24_29; 41
if ( '*' == * src )  42
mState = eState_ESC_24_2A; 43
if ( '+' == * src )  44
mState = eState_ESC_24_2B; 45
if ( CHECK_OVERRUN ( dest , destEnd , 3 ) )  47
* dest ++ = ( PRUnichar ) ESC; 49
* dest ++ = ( PRUnichar ) '$'; 50
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 51
mState = eState_ASCII; 53
if ( 'A' == * src )  58
mState = eState_ESC_24_29_A; 59
if ( 'G' == * src )  60
mState = eState_ESC_24_29_G; 61
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  63
* dest ++ = ( PRUnichar ) ESC; 65
* dest ++ = ( PRUnichar ) '$'; 66
* dest ++ = ( PRUnichar ) ')'; 67
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 68
mState = eState_ASCII; 70
if ( SO == * src )  75
mState = eState_GB2312_1980; 76
mRunLength = 0; 77
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  79
* dest ++ = ( PRUnichar ) ESC; 81
* dest ++ = ( PRUnichar ) '$'; 82
* dest ++ = ( PRUnichar ) ')'; 83
* dest ++ = ( PRUnichar ) 'A'; 84
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 85
mState = eState_ASCII; 87
if ( SI == * src )  92
mState = eState_ESC_24_29_A_SO_SI; 93
if ( mRunLength == 0 )  94
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  95
* dest ++ = 0xFFFD; 97
mRunLength = 0; 99
if ( ESC == * src )  100
mState = eState_ESC; 101
if ( 0x20 < * src && * src < 0x7f )  103
mData = * src; 104
mState = eState_GB2312_1980_2ndbyte; 105
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  107
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 109
if ( 0x20 < * src && * src < 0x7f )  115
unsigned char gb [ 2 ] ; 116
PRInt32 gbLen = 2 ; 117
gb [ 0 ] = mData | 0x80; 119
gb [ 1 ] = * src | 0x80; 120
aLen = destEnd - dest; 122
rv = GB2312_To_Unicode ( gb , gbLen , dest , & aLen ); 123
if ( rv == NS_OK_UDEC_MOREOUTPUT )  125
if ( NS_FAILED ( rv ) )  127
dest += aLen; 131
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  133
* dest ++ = ( PRUnichar ) mData; 135
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 136
mState = eState_GB2312_1980; 138
if ( SO == * src )  142
mState = eState_GB2312_1980; 143
mRunLength = 0; 144
if ( ESC == * src )  145
mState = eState_ESC; 146
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  148
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 150
mState = eState_ESC_24_29_A_SO_SI; 152
if ( SO == * src )  157
mState = eState_CNS11643_1; 158
mRunLength = 0; 159
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  161
* dest ++ = ( PRUnichar ) ESC; 163
* dest ++ = ( PRUnichar ) '$'; 164
* dest ++ = ( PRUnichar ) ')'; 165
* dest ++ = ( PRUnichar ) 'G'; 166
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 167
mState = eState_ASCII; 169
if ( SI == * src )  174
mState = eState_ESC_24_29_G_SO_SI; 175
if ( mRunLength == 0 )  176
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  177
* dest ++ = 0xFFFD; 179
mRunLength = 0; 181
if ( ESC == * src )  182
mState = eState_ESC; 183
if ( 0x20 < * src && * src < 0x7f )  185
mData = * src; 186
mState = eState_CNS11643_1_2ndbyte; 187
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  189
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 191
if ( 0x20 < * src && * src < 0x7f )  197
unsigned char cns [ 4 ] ; 198
PRInt32 cnsLen = 2 ; 199
cns [ 0 ] = mData | 0x80; 201
cns [ 1 ] = * src | 0x80; 202
aLen = destEnd - dest; 204
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 205
if ( rv == NS_OK_UDEC_MOREOUTPUT )  207
if ( NS_FAILED ( rv ) )  209
dest += aLen; 213
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  215
* dest ++ = ( PRUnichar ) mData; 217
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 218
mState = eState_CNS11643_1; 220
if ( SO == * src )  224
mState = eState_CNS11643_1; 225
mRunLength = 0; 226
if ( ESC == * src )  227
mState = eState_ESC; 228
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  230
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 232
mState = eState_ESC_24_29_G_SO_SI; 234
if ( 'H' == * src )  239
mState = eState_ESC_24_2A_H; 240
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  242
* dest ++ = ( PRUnichar ) ESC; 244
* dest ++ = ( PRUnichar ) '$'; 245
* dest ++ = ( PRUnichar ) '*'; 246
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 247
mState = eState_ASCII; 249
if ( ESC == * src )  254
mState = eState_ESC_24_2A_H_ESC; 255
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  257
* dest ++ = ( PRUnichar ) ESC; 259
* dest ++ = ( PRUnichar ) '$'; 260
* dest ++ = ( PRUnichar ) '*'; 261
* dest ++ = ( PRUnichar ) 'H'; 262
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 263
mState = eState_ASCII; 265
if ( SS2 == * src )  270
mState = eState_CNS11643_2; 271
mRunLength = 0; 272
if ( '$' == * src )  273
mState = eState_ESC_24; 274
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  276
* dest ++ = ( PRUnichar ) ESC; 278
* dest ++ = ( PRUnichar ) '$'; 279
* dest ++ = ( PRUnichar ) '*'; 280
* dest ++ = ( PRUnichar ) 'H'; 281
* dest ++ = ( PRUnichar ) ESC; 282
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 283
mState = eState_ASCII; 285
if ( SI == * src )  290
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 291
if ( mRunLength == 0 )  292
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  293
* dest ++ = 0xFFFD; 295
mRunLength = 0; 297
if ( ESC == * src )  298
mState = eState_ESC_24_2A_H_ESC; 299
if ( 0x20 < * src && * src < 0x7f )  301
mData = * src; 302
mState = eState_CNS11643_2_2ndbyte; 303
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  305
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 307
if ( 0x20 < * src && * src < 0x7f )  313
unsigned char cns [ 4 ] ; 314
PRInt32 cnsLen = 4 ; 315
cns [ 0 ] = ( unsigned char ) MBYTE; 317
cns [ 1 ] = ( unsigned char ) ( PMASK + 2 ); 318
cns [ 2 ] = mData | 0x80; 319
cns [ 3 ] = * src | 0x80; 320
aLen = destEnd - dest; 322
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 323
if ( rv == NS_OK_UDEC_MOREOUTPUT )  325
if ( NS_FAILED ( rv ) )  327
dest += aLen; 331
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  333
* dest ++ = ( PRUnichar ) mData; 335
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 336
mState = eState_CNS11643_2; 338
if ( ESC == * src )  342
mState = eState_ESC_24_2A_H_ESC_SS2_SI_ESC; 343
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  345
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 347
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 349
if ( SS2 == * src )  354
mState = eState_CNS11643_2; 355
mRunLength = 0; 356
if ( '$' == * src )  357
mState = eState_ESC_24; 358
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  360
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 362
mState = eState_ESC_24_2A_H_ESC_SS2_SI; 364
if ( 'I' <= * src && * src <= 'M' )  369
mState = eState_ESC_24_2B_I; 370
mPlaneID = * src - 'I' + 3; 371
if ( CHECK_OVERRUN ( dest , destEnd , 4 ) )  373
* dest ++ = ( PRUnichar ) ESC; 375
* dest ++ = ( PRUnichar ) '$'; 376
* dest ++ = ( PRUnichar ) '+'; 377
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 378
mState = eState_ASCII; 380
if ( ESC == * src )  385
mState = eState_ESC_24_2B_I_ESC; 386
if ( CHECK_OVERRUN ( dest , destEnd , 5 ) )  388
* dest ++ = ( PRUnichar ) ESC; 390
* dest ++ = ( PRUnichar ) '$'; 391
* dest ++ = ( PRUnichar ) '+'; 392
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 393
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 394
mState = eState_ASCII; 396
if ( SS3 == * src )  401
mState = eState_CNS11643_3; 402
mRunLength = 0; 403
if ( '$' == * src )  404
mState = eState_ESC_24; 405
if ( CHECK_OVERRUN ( dest , destEnd , 6 ) )  407
* dest ++ = ( PRUnichar ) ESC; 409
* dest ++ = ( PRUnichar ) '$'; 410
* dest ++ = ( PRUnichar ) '+'; 411
* dest ++ = ( PRUnichar ) 'I' + mPlaneID - 3; 412
* dest ++ = ( PRUnichar ) ESC; 413
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 414
mState = eState_ASCII; 416
if ( SI == * src )  421
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 422
if ( mRunLength == 0 )  423
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  424
* dest ++ = 0xFFFD; 426
mRunLength = 0; 428
if ( ESC == * src )  429
mState = eState_ESC_24_2B_I_ESC; 430
if ( 0x20 < * src && * src < 0x7f )  432
mData = * src; 433
mState = eState_CNS11643_3_2ndbyte; 434
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  436
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 438
if ( 0x20 < * src && * src < 0x7f )  445
unsigned char cns [ 4 ] ; 446
PRInt32 cnsLen = 4 ; 447
cns [ 0 ] = ( unsigned char ) MBYTE; 449
cns [ 1 ] = ( unsigned char ) ( PMASK + mPlaneID ); 450
cns [ 2 ] = mData | 0x80; 451
cns [ 3 ] = * src | 0x80; 452
aLen = destEnd - dest; 454
rv = EUCTW_To_Unicode ( cns , cnsLen , dest , & aLen ); 455
if ( rv == NS_OK_UDEC_MOREOUTPUT )  457
if ( NS_FAILED ( rv ) )  459
dest += aLen; 463
if ( CHECK_OVERRUN ( dest , destEnd , 2 ) )  465
* dest ++ = ( PRUnichar ) mData; 467
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 468
mState = eState_CNS11643_3; 470
if ( ESC == * src )  474
mState = eState_ESC_24_2B_I_ESC_SS3_SI_ESC; 475
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  477
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 479
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 481
if ( SS3 == * src )  486
mState = eState_CNS11643_3; 487
mRunLength = 0; 488
if ( '$' == * src )  489
mState = eState_ESC_24; 490
if ( CHECK_OVERRUN ( dest , destEnd , 1 ) )  492
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 494
mState = eState_ESC_24_2B_I_ESC_SS3_SI; 496
src ++; 505
------------------------------
71 /home/SySeVR/data/CVE_2012_0477_VULN_nsISO2022KRToUnicode__Convert.c [u'ksx'] 130
NS_IMETHODIMP CVE_2012_0477_VULN_nsISO2022KRToUnicode::Convert(const char * aSrc, PRInt32 * aSrcLen, PRUnichar * aDest, PRInt32 * aDestLen) 1
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ; 3
const unsigned char * src = ( unsigned char * ) aSrc ; 4
PRUnichar * destEnd = aDest + * aDestLen ; 5
PRUnichar * dest = aDest ; 6
while ( src < srcEnd )  7
if ( * src == 0x0a || * src == 0x0d )  10
mState = mState_Init; 11
switch ( mState )  13
if ( 0x1b == * src )  16
mLastLegalState = mState_ASCII; 17
mState = mState_ESC; 18
mState = mState_ASCII; 21
if ( 0x0e == * src )  25
mState = mState_KSX1001_1992; 26
mRunLength = 0; 27
if ( * src & 0x80 )  29
* dest ++ = 0xFFFD; 30
if ( dest >= destEnd )  31
* dest ++ = ( PRUnichar ) * src; 35
if ( dest >= destEnd )  36
if ( '$' == * src )  42
mState = mState_ESC_24; 43
if ( ( dest + 2 ) >= destEnd )  46
* dest ++ = ( PRUnichar ) 0x1b; 48
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 49
mState = mLastLegalState; 50
if ( ')' == * src )  55
mState = mState_ESC_24_29; 56
if ( ( dest + 3 ) >= destEnd )  59
* dest ++ = ( PRUnichar ) 0x1b; 61
* dest ++ = ( PRUnichar ) '$'; 62
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 63
mState = mLastLegalState; 64
if ( 'C' == * src )  70
mState = mState_ASCII; 71
mRunLength = 0; 72
if ( ( dest + 4 ) >= destEnd )  75
* dest ++ = ( PRUnichar ) 0x1b; 77
* dest ++ = ( PRUnichar ) '$'; 78
* dest ++ = ( PRUnichar ) ')'; 79
* dest ++ = ( 0x80 & * src ) ? 0xFFFD : ( PRUnichar ) * src; 80
mState = mLastLegalState; 81
if ( 0x20 < ( PRUint8 ) * src && ( PRUint8 ) * src < 0x7f )  86
mState = mState_KSX1001_1992_2ndbyte; 88
if ( 0x0f == * src )  90
mState = mState_ASCII; 91
if ( mRunLength == 0 )  92
if ( dest + 1 >= destEnd )  93
* dest ++ = 0xFFFD; 95
mRunLength = 0; 97
if ( ( PRUint8 ) * src == 0x20 || ( PRUint8 ) * src == 0x09 )  99
mState = mState_KSX1001_1992; 101
* dest ++ = ( PRUnichar ) * src; 102
if ( dest >= destEnd )  104
* dest ++ = 0xFFFD; 108
if ( dest >= destEnd )  109
if ( 0x20 < ( PRUint8 ) * src && ( PRUint8 ) * src < 0x7f )  115
if ( ! mEUCKRDecoder )  126
* dest ++ = 0xFFFD; 127
unsigned char ksx [ 2 ] ; 130
PRUnichar uni ; 131
ksx [ 0 ] = mData | 0x80; 136
ksx [ 1 ] = * src | 0x80; 137
mEUCKRDecoder -> Convert ( ( const char * ) ksx , & ksxLen , & uni , & uniLen ); 139
* dest ++ = uni; 140
if ( dest >= destEnd )  143
mState = mState_KSX1001_1992; 145
if ( 0x0f == * src )  148
mState = mState_ASCII; 149
mState = mState_KSX1001_1992; 152
* dest ++ = 0xFFFD; 154
if ( dest >= destEnd )  155
mState = mLastLegalState; 161
* dest ++ = 0xFFFD; 162
if ( dest >= destEnd )  163
src ++; 168
------------------------------
72 /home/SySeVR/data/CVE_2012_1183_PATCHED_milliwatt_generate.c [u'buf'] 3
static int CVE_2012_1183_PATCHED_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) - ( AST_FRIENDLY_OFFSET / sizeof ( buf [ 0 ] ) ) ; 4
wf . data . ptr = buf + AST_FRIENDLY_OFFSET; 12
if ( samples > maxsamples )  19
ast_log ( LOG_WARNING , "Only doing %d samples (%d requested)\n" , maxsamples , samples ); 20
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
for (i = 0; i < len; i++) 29
buf [ AST_FRIENDLY_OFFSET + i ] = digital_milliwatt [ ( * indexp ) ++ ]; 30
* indexp &= 7; 31
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
73 /home/SySeVR/data/CVE_2012_1183_VULN_milliwatt_generate.c [u'buf'] 3
static int CVE_2012_1183_VULN_milliwatt_generate(struct ast_channel *chan, void *data, int len, int samples) 1
unsigned char buf [ AST_FRIENDLY_OFFSET + 640 ] ; 3
const int maxsamples = ARRAY_LEN ( buf ) ; 4
wf . data . ptr = buf + AST_FRIENDLY_OFFSET; 12
if ( samples > maxsamples )  19
ast_log ( LOG_WARNING , "Only doing %d samples (%d requested)\n" , maxsamples , samples ); 20
samples = maxsamples; 21
len = samples * sizeof ( buf [ 0 ] ); 24
wf . datalen = len; 25
wf . samples = samples; 26
for (i = 0; i < len; i++) 29
buf [ AST_FRIENDLY_OFFSET + i ] = digital_milliwatt [ ( * indexp ) ++ ]; 30
* indexp &= 7; 31
if ( ast_write ( chan , & wf ) < 0 )  34
------------------------------
74 /home/SySeVR/data/CVE_2012_1184_VULN_ast_parse_digest.c [u'c', u'val', u'key'] 4
int CVE_2012_1184_VULN_ast_parse_digest(const char *digest, struct ast_http_digest *d, int request, int pedantic) 2
char * c , key [ 512 ] , val [ 512 ] ; 4
c = ast_skip_blanks ( ast_str_buffer ( str ) ); 14
if ( strncasecmp ( c , "Digest " , strlen ( "Digest " ) ) )  16
c += strlen ( "Digest " ); 21
while ( * c && * ( c = ast_skip_blanks ( c ) ) )  24
while ( * c && * c != '=' && * c != ',' && ! isspace ( * c ) )  27
key [ i ++ ] = * c ++; 28
key [ i ] = '\0'; 30
c = ast_skip_blanks ( c ); 31
if ( * c == '=' )  32
c = ast_skip_blanks ( ++ c ); 33
if ( * c == '\"' )  35
c ++; 37
while ( * c && * c != '\"' )  38
if ( * c == '\\' && c [ 1 ] != '\0' )  39
c ++; 40
val [ i ++ ] = * c ++; 42
while ( * c && * c != ',' && ! isspace ( * c ) )  46
val [ i ++ ] = * c ++; 47
val [ i ] = '\0'; 50
while ( * c && * c != ',' )  53
c ++; 54
if ( * c )  56
c ++; 57
if ( ! strcasecmp ( key , "username" ) )  60
ast_string_field_set ( d , username , val ); 61
if ( ! strcasecmp ( key , "realm" ) )  62
ast_string_field_set ( d , realm , val ); 63
if ( ! strcasecmp ( key , "nonce" ) )  64
ast_string_field_set ( d , nonce , val ); 65
if ( ! strcasecmp ( key , "uri" ) )  66
ast_string_field_set ( d , uri , val ); 67
if ( ! strcasecmp ( key , "domain" ) )  68
ast_string_field_set ( d , domain , val ); 69
if ( ! strcasecmp ( key , "response" ) )  70
ast_string_field_set ( d , response , val ); 71
if ( ! strcasecmp ( key , "algorithm" ) )  72
if ( strcasecmp ( val , "MD5" ) )  73
ast_log ( LOG_WARNING , "Digest algorithm: \"%s\" not supported.\n" , val ); 74
if ( ! strcasecmp ( key , "cnonce" ) )  77
ast_string_field_set ( d , cnonce , val ); 78
if ( ! strcasecmp ( key , "opaque" ) )  79
ast_string_field_set ( d , opaque , val ); 80
if ( ! strcasecmp ( key , "qop" ) && ! strcasecmp ( val , "auth" ) )  81
if ( ! strcasecmp ( key , "nc" ) )  83
if ( sscanf ( val , "%30lx" , & u ) != 1 )  85
ast_log ( LOG_WARNING , "Incorrect Digest nc value: \"%s\".\n" , val ); 86
ast_string_field_set ( d , nc , val ); 89
------------------------------
75 /home/SySeVR/data/CVE_2012_1947_VULN_nsNativeCharsetConverter__UnicodeToNative.c [u'ubuf'] 30
nsresult
CVE_2012_1947_VULN_nsNativeCharsetConverter::UnicodeToNative(const PRUnichar **input,
PRUint32         *inputLeft,
char            **output,
PRUint32         *outputLeft) 5
if ( gUnicodeToNative != INVALID_ICONV_T )  11
if ( ( gUnicodeToUTF8 != INVALID_ICONV_T ) && ( gUTF8ToNative != INVALID_ICONV_T ) )  26
char ubuf [ 6 ] ; 30
char * p = ubuf ; 34
p = ubuf; 41
res = xp_iconv ( gUTF8ToNative , ( const char * * ) & p , & n , output , & outLeft ); 43
if ( res == ( size_t ) - 1 )  44
if ( res != ( size_t ) - 1 )  57
------------------------------
76 /home/SySeVR/data/CVE_2012_1952_PATCHED_nsTableFrame__InsertFrames.c [u'insertions'] 23
NS_IMETHODIMP
CVE_2012_1952_PATCHED_nsTableFrame::InsertFrames(ChildListID     aListID,
nsIFrame*       aPrevFrame,
nsFrameList&    aFrameList) 4
if ( ( aPrevFrame && ! aPrevFrame -> GetNextSibling ( ) ) || ( ! aPrevFrame && GetChildList ( aListID ) . IsEmpty ( ) ) )  15
ChildListInsertions insertions [ 2 ] ; 23
insertions [ 0 ] . mID = kColGroupList; 31
insertions [ 0 ] . mList . AppendFrames ( nsnull , head ); 32
insertions [ 1 ] . mID = kPrincipalList; 34
insertions [ 1 ] . mList . AppendFrames ( nsnull , head ); 35
for (PRUint32 i = 0; i < ArrayLength(insertions); ++i) 43
if ( ! insertions [ i ] . mList . IsEmpty ( ) )  47
HomogenousInsertFrames ( insertions [ i ] . mID , aPrevFrame , insertions [ i ] . mList ); 48
------------------------------
77 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
78 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
79 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
80 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
81 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
82 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
83 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
84 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 80
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
85 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
86 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
87 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
88 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
89 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
90 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
91 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
92 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'backing_filename'] 14
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
int ret ; 5
char tmp_filename [ PATH_MAX ] ; 6
if ( flags & BDRV_O_SNAPSHOT )  8
BlockDriverState * bs1 ; 9
int is_protocol = 0 ; 11
BlockDriver * bdrv_qcow2 ; 12
QEMUOptionParameter * options ; 13
char backing_filename [ PATH_MAX ] ; 14
bs1 = bdrv_new ( "" ); 20
ret = CVE_2012_2652_VULN_bdrv_open ( bs1 , filename , 0 , drv ); 21
if ( ret < 0 )  22
if ( bs1 -> drv && bs1 -> drv -> protocol_name )  28
is_protocol = 1; 29
if ( is_protocol )  36
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
bdrv_qcow2 = bdrv_find_format ( "qcow2" ); 42
options = parse_option_parameters ( "" , bdrv_qcow2 -> create_options , NULL ); 43
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
filename = tmp_filename; 58
drv = bdrv_qcow2; 59
bs -> is_temporary = 1; 60
if ( ! drv )  64
ret = find_image_format ( filename , & drv ); 65
if ( ! drv )  68
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
if ( ( flags & BDRV_O_NO_BACKING ) == 0 && bs -> backing_file [ 0 ] != '\0' )  79
char backing_filename [ PATH_MAX ] ; 80
int back_flags ; 81
BlockDriver * back_drv = NULL ; 82
bs -> backing_hd = bdrv_new ( "" ); 84
if ( bs -> backing_format [ 0 ] != '\0' )  94
back_drv = bdrv_find_format ( bs -> backing_format ); 95
back_flags = flags & ~ ( BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING ); 99
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
if ( flags & BDRV_O_SNAPSHOT )  8
char backing_filename [ PATH_MAX ] ; 14
snprintf ( backing_filename , sizeof ( backing_filename ) , "%s" , filename ); 37
if ( ! realpath ( filename , backing_filename ) )  39
set_option_parameter ( options , BLOCK_OPT_BACKING_FILE , backing_filename ); 46
pstrcpy ( backing_filename , sizeof ( backing_filename ) , bs -> backing_file ); 87
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
ret = CVE_2012_2652_VULN_bdrv_open ( bs -> backing_hd , backing_filename , back_flags , back_drv ); 102
if ( ret < 0 )  103
return ret ; 105
return ret ; 125
------------------------------
93 /home/SySeVR/data/CVE_2012_2652_VULN_bdrv_open.c [u'tmp_filename'] 6
int CVE_2012_2652_VULN_bdrv_open(BlockDriverState *bs, const char *filename, int flags,
BlockDriver *drv) 3
char tmp_filename [ PATH_MAX ] ; 6
get_tmp_filename ( tmp_filename , sizeof ( tmp_filename ) ); 33
ret = bdrv_create ( bdrv_qcow2 , tmp_filename , options ); 52
if ( ret < 0 )  54
return ret ; 55
filename = tmp_filename; 58
ret = find_image_format ( filename , & drv ); 65
ret = bdrv_open_common ( bs , filename , flags , drv ); 73
if ( ret < 0 )  74
path_combine ( backing_filename , sizeof ( backing_filename ) , filename , bs -> backing_file ); 90
if ( ret < 0 )  103
return ret ; 105
unlink ( filename ); 123
return ret ; 125
------------------------------
94 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c [u'k'] 164
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
ALSSpecificConfig * sconf = & ctx -> sconf ; 3
GetBitContext * gb = & ctx -> gb ; 5
unsigned int sub_blocks , log2_sub_blocks , sb_length ; 9
* bd -> const_block = 0; 18
* bd -> opt_order = 1; 20
bd -> js_blocks = get_bits1 ( gb ); 21
if ( ! sconf -> bgmc && ! sconf -> sb_part )  26
log2_sub_blocks = 0; 27
if ( sconf -> bgmc && sconf -> sb_part )  29
log2_sub_blocks = get_bits ( gb , 2 ); 30
log2_sub_blocks = 2 * get_bits1 ( gb ); 32
sub_blocks = 1 << log2_sub_blocks; 35
if ( bd -> block_length & ( sub_blocks - 1 ) )  39
if ( sconf -> bgmc )  162
unsigned int k [ 8 ] ; 164
k [ sb ] = s [ sb ] > b ? s [ sb ] - b : 0; 178
delta [ sb ] = 5 - s [ sb ] + k [ sb ]; 179
ff_bgmc_decode ( gb , sb_length , current_res , delta [ sb ] , sx [ sb ] , & high , & low , & value , ctx -> bgmc_lut , ctx -> bgmc_lut_status ); 181
for (sb = 0; sb < sub_blocks; sb++, i = 0) 194
unsigned int cur_tail_code = tail_code [ sx [ sb ] ] [ delta [ sb ] ] ; 195
unsigned int cur_k = k [ sb ] ; 196
unsigned int cur_s = s [ sb ] ; 197
for (; i < sb_length; i++) 199
int32_t res = * current_res ; 200
if ( res == cur_tail_code )  202
unsigned int max_msb = ( 2 + ( sx [ sb ] > 2 ) + ( sx [ sb ] > 10 ) ) << ( 5 - delta [ sb ] ) ; 203
res = decode_rice ( gb , cur_s ); 206
if ( res >= 0 )  208
res += ( max_msb ) << cur_k; 209
res -= ( max_msb - 1 ) << cur_k; 211
if ( res > cur_tail_code )  214
res --; 215
if ( res & 1 )  217
res = - res; 218
res >>= 1; 220
if ( cur_k )  222
res <<= cur_k; 223
res |= get_bits_long ( gb , cur_k ); 224
* current_res ++ = res; 228
------------------------------
95 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c [u'delta'] 163
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
ALSSpecificConfig * sconf = & ctx -> sconf ; 3
GetBitContext * gb = & ctx -> gb ; 5
unsigned int sub_blocks , log2_sub_blocks , sb_length ; 9
* bd -> const_block = 0; 18
* bd -> opt_order = 1; 20
bd -> js_blocks = get_bits1 ( gb ); 21
if ( ! sconf -> bgmc && ! sconf -> sb_part )  26
log2_sub_blocks = 0; 27
if ( sconf -> bgmc && sconf -> sb_part )  29
log2_sub_blocks = get_bits ( gb , 2 ); 30
log2_sub_blocks = 2 * get_bits1 ( gb ); 32
sub_blocks = 1 << log2_sub_blocks; 35
if ( bd -> block_length & ( sub_blocks - 1 ) )  39
if ( sconf -> bgmc )  162
int delta [ 8 ] ; 163
k [ sb ] = s [ sb ] > b ? s [ sb ] - b : 0; 178
delta [ sb ] = 5 - s [ sb ] + k [ sb ]; 179
ff_bgmc_decode ( gb , sb_length , current_res , delta [ sb ] , sx [ sb ] , & high , & low , & value , ctx -> bgmc_lut , ctx -> bgmc_lut_status ); 181
for (sb = 0; sb < sub_blocks; sb++, i = 0) 194
unsigned int cur_tail_code = tail_code [ sx [ sb ] ] [ delta [ sb ] ] ; 195
unsigned int cur_k = k [ sb ] ; 196
unsigned int cur_s = s [ sb ] ; 197
for (; i < sb_length; i++) 199
int32_t res = * current_res ; 200
if ( res == cur_tail_code )  202
unsigned int max_msb = ( 2 + ( sx [ sb ] > 2 ) + ( sx [ sb ] > 10 ) ) << ( 5 - delta [ sb ] ) ; 203
res = decode_rice ( gb , cur_s ); 206
if ( res >= 0 )  208
res += ( max_msb ) << cur_k; 209
res -= ( max_msb - 1 ) << cur_k; 211
if ( res > cur_tail_code )  214
res --; 215
if ( res & 1 )  217
res = - res; 218
res >>= 1; 220
if ( cur_k )  222
res <<= cur_k; 223
res |= get_bits_long ( gb , cur_k ); 224
* current_res ++ = res; 228
------------------------------
96 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c [u'sx'] 8
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
unsigned int sx [ 8 ] ; 8
sx [ k ] = s [ k ] & 0x0F; 53
s [ k ] >>= 4; 54
int rice_param = parcor_rice_table [ sconf -> coef_table ] [ k ] [ 1 ] ; 102
int offset = parcor_rice_table [ sconf -> coef_table ] [ k ] [ 0 ] ; 103
quant_cof [ k ] = decode_rice ( gb , rice_param ) + offset; 104
for (; k < k_max; k++) 109
quant_cof [ k ] = decode_rice ( gb , 2 ) + ( k & 1 ); 110
for (; k < opt_order; k++) 113
quant_cof [ k ] = decode_rice ( gb , 1 ); 114
quant_cof [ 0 ] = 32 * parcor_scaled_values [ quant_cof [ 0 ] + 64 ]; 116
quant_cof [ 1 ] = - 32 * parcor_scaled_values [ quant_cof [ 1 ] + 64 ]; 119
for (k = 2; k < opt_order; k++) 122
quant_cof [ k ] = ( quant_cof [ k ] << 14 ) + ( add_base << 13 ); 123
bd -> raw_samples [ 1 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 3 , ctx -> s_max ) ); 154
bd -> raw_samples [ 2 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 1 , ctx -> s_max ) ); 156
unsigned int b = av_clip ( ( av_ceil_log2 ( bd -> block_length ) - 3 ) >> 1 , 0 , 5 ) ; 165
current_res = bd -> raw_samples + start; 175
k [ sb ] = s [ sb ] > b ? s [ sb ] - b : 0; 178
delta [ sb ] = 5 - s [ sb ] + k [ sb ]; 179
ff_bgmc_decode ( gb , sb_length , current_res , delta [ sb ] , sx [ sb ] , & high , & low , & value , ctx -> bgmc_lut , ctx -> bgmc_lut_status ); 181
current_res += sb_length; 184
current_res = bd -> raw_samples + start; 192
for (sb = 0; sb < sub_blocks; sb++, i = 0) 194
unsigned int cur_tail_code = tail_code [ sx [ sb ] ] [ delta [ sb ] ] ; 195
unsigned int cur_k = k [ sb ] ; 196
unsigned int cur_s = s [ sb ] ; 197
for (; i < sb_length; i++) 199
int32_t res = * current_res ; 200
if ( res == cur_tail_code )  202
unsigned int max_msb = ( 2 + ( sx [ sb ] > 2 ) + ( sx [ sb ] > 10 ) ) << ( 5 - delta [ sb ] ) ; 203
res = decode_rice ( gb , cur_s ); 206
if ( res >= 0 )  208
res += ( max_msb ) << cur_k; 209
res -= ( max_msb - 1 ) << cur_k; 211
if ( res > cur_tail_code )  214
res --; 215
if ( res & 1 )  217
res = - res; 218
res >>= 1; 220
if ( cur_k )  222
res <<= cur_k; 223
res |= get_bits_long ( gb , cur_k ); 224
* current_res ++ = res; 228
current_res = bd -> raw_samples + start; 232
* current_res ++ = decode_rice ( gb , s [ sb ] ); 236
------------------------------
97 /home/SySeVR/data/CVE_2012_2790_VULN_read_var_block_data.c [u's'] 7
static int CVE_2012_2790_VULN_read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) 1
unsigned int s [ 8 ] ; 7
s [ 0 ] = get_bits ( gb , 8 + ( sconf -> resolution > 1 ) ); 48
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 2 ); 50
for (k = 0; k < sub_blocks; k++) 52
sx [ k ] = s [ k ] & 0x0F; 53
s [ k ] >>= 4; 54
s [ 0 ] = get_bits ( gb , 4 + ( sconf -> resolution > 1 ) ); 57
s [ k ] = s [ k - 1 ] + decode_rice ( gb , 0 ); 59
for (k = 2; k < opt_order; k++) 93
quant_cof [ k ] = get_bits ( gb , 7 ); 94
int rice_param = parcor_rice_table [ sconf -> coef_table ] [ k ] [ 1 ] ; 102
int offset = parcor_rice_table [ sconf -> coef_table ] [ k ] [ 0 ] ; 103
quant_cof [ k ] = decode_rice ( gb , rice_param ) + offset; 104
for (; k < k_max; k++) 109
quant_cof [ k ] = decode_rice ( gb , 2 ) + ( k & 1 ); 110
for (; k < opt_order; k++) 113
quant_cof [ k ] = decode_rice ( gb , 1 ); 114
quant_cof [ 0 ] = 32 * parcor_scaled_values [ quant_cof [ 0 ] + 64 ]; 116
quant_cof [ 1 ] = - 32 * parcor_scaled_values [ quant_cof [ 1 ] + 64 ]; 119
for (k = 2; k < opt_order; k++) 122
quant_cof [ k ] = ( quant_cof [ k ] << 14 ) + ( add_base << 13 ); 123
bd -> raw_samples [ 1 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 3 , ctx -> s_max ) ); 154
bd -> raw_samples [ 2 ] = decode_rice ( gb , FFMIN ( s [ 0 ] + 1 , ctx -> s_max ) ); 156
unsigned int b = av_clip ( ( av_ceil_log2 ( bd -> block_length ) - 3 ) >> 1 , 0 , 5 ) ; 165
current_res = bd -> raw_samples + start; 175
k [ sb ] = s [ sb ] > b ? s [ sb ] - b : 0; 178
delta [ sb ] = 5 - s [ sb ] + k [ sb ]; 179
ff_bgmc_decode ( gb , sb_length , current_res , delta [ sb ] , sx [ sb ] , & high , & low , & value , ctx -> bgmc_lut , ctx -> bgmc_lut_status ); 181
current_res += sb_length; 184
current_res = bd -> raw_samples + start; 192
for (sb = 0; sb < sub_blocks; sb++, i = 0) 194
unsigned int cur_tail_code = tail_code [ sx [ sb ] ] [ delta [ sb ] ] ; 195
unsigned int cur_k = k [ sb ] ; 196
unsigned int cur_s = s [ sb ] ; 197
for (; i < sb_length; i++) 199
int32_t res = * current_res ; 200
if ( res == cur_tail_code )  202
unsigned int max_msb = ( 2 + ( sx [ sb ] > 2 ) + ( sx [ sb ] > 10 ) ) << ( 5 - delta [ sb ] ) ; 203
res = decode_rice ( gb , cur_s ); 206
if ( res >= 0 )  208
res += ( max_msb ) << cur_k; 209
res -= ( max_msb - 1 ) << cur_k; 211
if ( res > cur_tail_code )  214
res --; 215
if ( res & 1 )  217
res = - res; 218
res >>= 1; 220
if ( cur_k )  222
res <<= cur_k; 223
res |= get_bits_long ( gb , cur_k ); 224
* current_res ++ = res; 228
current_res = bd -> raw_samples + start; 232
* current_res ++ = decode_rice ( gb , s [ sb ] ); 236
------------------------------
98 /home/SySeVR/data/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c [u'extrema'] 21
nsresult
CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 extrema [ 4 ] ; 21
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRInt32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
99 /home/SySeVR/data/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c [u'extrema'] 21
nsresult
CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 extrema [ 4 ] ; 21
extrema [ i ] = sourceData [ targIndex + i ]; 37
for (PRUint32 i = 0; i < 4; i++) 41
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 42
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  43
extrema [ i ] = pixel; 47
targetData [ targIndex ] = extrema [ 0 ]; 52
targetData [ targIndex + 1 ] = extrema [ 1 ]; 53
targetData [ targIndex + 2 ] = extrema [ 2 ]; 54
targetData [ targIndex + 3 ] = extrema [ 3 ]; 55
------------------------------
100 /home/SySeVR/data/CVE_2012_4186_PATCHED_nsWaveReader__LoadFormatChunk.c [u'chunkExtension'] 66
bool
CVE_2012_4186_PATCHED_nsWaveReader::LoadFormatChunk() 2
PRUint32 fmtSize , rate , channels , frameSize , sampleFormat ; 4
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ScanForwardUntil ( FRMT_CHUNK_MAGIC , & fmtSize ) )  14
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  18
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  28
p += 4; 37
if ( fmtSize > WAVE_FORMAT_CHUNK_SIZE )  48
char extLength [ 2 ] ; 49
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  52
PRUint16 extra = ReadUint16LE ( & p ) ; 57
if ( fmtSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  58
extra += extra % 2; 62
if ( extra > 0 )  64
nsAutoArrayPtr < char > chunkExtension ( new char [ extra ] ) ; 66
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  67
------------------------------
101 /home/SySeVR/data/CVE_2012_4186_PATCHED_nsWaveReader__LoadFormatChunk.c [u'extLength'] 49
bool
CVE_2012_4186_PATCHED_nsWaveReader::LoadFormatChunk() 2
PRUint32 fmtSize , rate , channels , frameSize , sampleFormat ; 4
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
if ( ! ScanForwardUntil ( FRMT_CHUNK_MAGIC , & fmtSize ) )  14
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  18
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  28
if ( fmtSize > WAVE_FORMAT_CHUNK_SIZE )  48
char extLength [ 2 ] ; 49
const char * p = extLength ; 50
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  52
------------------------------
102 /home/SySeVR/data/CVE_2012_4186_PATCHED_nsWaveReader__LoadFormatChunk.c [u'waveFormat'] 5
bool
CVE_2012_4186_PATCHED_nsWaveReader::LoadFormatChunk() 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  18
p += 4; 37
frameSize = ReadUint16LE ( & p ); 39
sampleFormat = ReadUint16LE ( & p ); 41
PRUint16 extra = ReadUint16LE ( & p ) ; 57
if ( fmtSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  58
extra += extra % 2; 62
if ( extra > 0 )  64
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  67
unsigned int actualFrameSize = sampleFormat == 8 ? 1 : 2 * channels ; 80
if ( rate < 100 || rate > 96000 || channels < 1 || channels > MAX_CHANNELS || ( frameSize != 1 && frameSize != 2 && frameSize != 4 ) || ( sampleFormat != 8 && sampleFormat != 16 ) || frameSize != actualFrameSize )  81
mFrameSize = frameSize; 93
if ( sampleFormat == 8 )  94
------------------------------
103 /home/SySeVR/data/CVE_2012_4288_VULN_dissect_xtp_ecntl.c [u'ecntl'] 8
static void
CVE_2012_4288_VULN_dissect_xtp_ecntl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
guint32 offset) 3
struct xtp_ecntl ecntl [ 1 ] ; 8
ecntl -> rseq = tvb_get_ntohl ( tvb , offset ); 26
ecntl -> rseq <<= 32; 27
ecntl -> rseq += tvb_get_ntohl ( tvb , offset + 4 ); 28
ecntl -> alloc = tvb_get_ntohl ( tvb , offset ); 31
ecntl -> alloc <<= 32; 32
ecntl -> alloc += tvb_get_ntohl ( tvb , offset + 4 ); 33
ecntl -> echo = tvb_get_ntohl ( tvb , offset ); 36
ecntl -> nspan = tvb_get_ntohl ( tvb , offset ); 39
spans_len = 16 * ecntl -> nspan; 42
if ( len != spans_len )  43
proto_item_append_text ( top_ti , ", bogus spans field length (%u, must be %u)" , len , spans_len ); 44
spans = ep_alloc0 ( spans_len ); 50
p = spans; 51
for (i = 0; i < ecntl->nspan*2; i++) 52
* p ++ = span; 56
col_append_fstr ( pinfo -> cinfo , COL_INFO ,
" Recv-Seq=%" G_GINT64_MODIFIER "u" , ecntl -> rseq )
col_append_fstr ( pinfo -> cinfo , COL_INFO ,
" Alloc=%" G_GINT64_MODIFIER "u" , ecntl -> alloc ) 65
proto_item_append_text ( top_ti ,
", Recv-Seq: %" G_GINT64_MODIFIER "u" , ecntl -> rseq ) 68
proto_tree_add_uint64 ( xtp_subtree , hf_xtp_ecntl_rseq , tvb , offset , 8 , ecntl -> rseq ); 73
proto_tree_add_uint64 ( xtp_subtree , hf_xtp_ecntl_alloc , tvb , offset , 8 , ecntl -> alloc ); 77
proto_tree_add_uint ( xtp_subtree , hf_xtp_ecntl_echo , tvb , offset , 4 , ecntl -> echo ); 81
proto_tree_add_uint ( xtp_subtree , hf_xtp_ecntl_nspan , tvb , offset , 4 , ecntl -> nspan ); 85
p = spans; 89
for (i = 0; i < ecntl->nspan; i++) 90
proto_tree_add_uint64 ( xtp_subtree , hf_xtp_ecntl_span_left , tvb , offset , 8 , * p ); 91
p ++; 93
proto_tree_add_uint64 ( xtp_subtree , hf_xtp_ecntl_span_right , tvb , offset , 8 , * p ); 95
p ++; 97
------------------------------
104 /home/SySeVR/data/CVE_2012_4289_PATCHED_proto_register_afp.c [u'ett'] 1504
void
CVE_2012_4289_PATCHED_proto_register_afp(void) 2
static gint * ett [ ] = { & ett_afp , & ett_afp_server_vol , & ett_afp_vol_list , & ett_afp_vol_flag , & ett_afp_vol_bitmap , & ett_afp_vol_attribute , & ett_afp_dir_bitmap , & ett_afp_file_bitmap , & ett_afp_unix_privs , & ett_afp_enumerate , & ett_afp_enumerate_line , & ett_afp_access_mode , & ett_afp_dir_attribute , & ett_afp_file_attribute , & ett_afp_path_name , & ett_afp_lock_flags , & ett_afp_dir_ar , & ett_afp_cat_search , & ett_afp_cat_r_bitmap , & ett_afp_cat_spec , & ett_afp_vol_did , & ett_afp_user_bitmap , & ett_afp_message_bitmap , & ett_afp_extattr_bitmap , & ett_afp_extattr_names , & ett_afp_acl_list_bitmap , & ett_afp_acl_access_bitmap , & ett_afp_ace_entries , & ett_afp_ace_entry , & ett_afp_ace_flags , & ett_afp_spotlight_queries , & ett_afp_spotlight_query_line , & ett_afp_spotlight_query , & ett_afp_spotlight_data , & ett_afp_spotlight_toc } ; 1504
proto_register_subtree_array ( ett , array_length ( ett ) ); 1544
------------------------------
105 /home/SySeVR/data/CVE_2012_4289_VULN_proto_register_afp.c [u'ett'] 1504
void
CVE_2012_4289_VULN_proto_register_afp(void) 2
static gint * ett [ ] = { & ett_afp , & ett_afp_server_vol , & ett_afp_vol_list , & ett_afp_vol_flag , & ett_afp_vol_bitmap , & ett_afp_vol_attribute , & ett_afp_dir_bitmap , & ett_afp_file_bitmap , & ett_afp_unix_privs , & ett_afp_enumerate , & ett_afp_enumerate_line , & ett_afp_access_mode , & ett_afp_dir_attribute , & ett_afp_file_attribute , & ett_afp_path_name , & ett_afp_lock_flags , & ett_afp_dir_ar , & ett_afp_cat_search , & ett_afp_cat_r_bitmap , & ett_afp_cat_spec , & ett_afp_vol_did , & ett_afp_user_bitmap , & ett_afp_message_bitmap , & ett_afp_extattr_bitmap , & ett_afp_extattr_names , & ett_afp_acl_list_bitmap , & ett_afp_acl_access_bitmap , & ett_afp_ace_entries , & ett_afp_ace_entry , & ett_afp_ace_flags , & ett_afp_spotlight_queries , & ett_afp_spotlight_query_line , & ett_afp_spotlight_query , & ett_afp_spotlight_data , & ett_afp_spotlight_toc } ; 1504
proto_register_subtree_array ( ett , array_length ( ett ) ); 1544
------------------------------
106 /home/SySeVR/data/CVE_2012_4293_PATCHED_dissect_ecat_eoe.c [u'szText'] 7
static void CVE_2012_4293_PATCHED_dissect_ecat_eoe(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree) 1
char szText [ 200 ] ; 7
g_snprintf ( szText , nMax , "EoE-Frag %d" , eoe . anEoeHeaderDataUnion . v . Fragment ); 27
g_snprintf ( szText , nMax , "EoE" ); 29
col_append_str ( pinfo -> cinfo , COL_INFO , szText ); 30
EoETypeFormatter ( & eoe , szText , nMax ); 40
proto_item_set_text ( anItem , "%s" , szText ); 41
EoEFragNoFormatter ( & eoe , szText , nMax ); 47
proto_item_set_text ( anItem , "%s" , szText ); 48
EoEOffsetFormatter ( & eoe , szText , nMax ); 51
proto_item_set_text ( anItem , "%s" , szText ); 52
EoEFrameFormatter ( & eoe , szText , nMax ); 55
proto_item_set_text ( anItem , "%s" , szText ); 56
EoELastFormatter ( & eoe , szText , nMax ); 59
proto_item_set_text ( anItem , "%s" , szText ); 60
------------------------------
107 /home/SySeVR/data/CVE_2012_4293_VULN_proto_register_ecat_mailbox.c [u'ett'] 642
void CVE_2012_4293_VULN_proto_register_ecat_mailbox(void) 1
static gint * ett [ ] = { & ett_ecat_mailbox , & ett_ecat_mailbox_eoe , & ett_ecat_mailbox_eoe_init , & ett_ecat_mailbox_eoe_macfilter , & ett_ecat_mailbox_eoe_macfilter_filter , & ett_ecat_mailbox_eoe_macfilter_filtermask , & ett_ecat_mailbox_coe , & ett_ecat_mailbox_sdo , & ett_ecat_mailbox_coe_sdoccs , & ett_ecat_mailbox_coe_sdoscs , & ett_ecat_mailbox_foe , & ett_ecat_mailbox_foe_efw , & ett_ecat_mailbox_soeflag , & ett_ecat_mailbox_soe , & ett_ecat_mailbox_fraghead , & ett_ecat_mailbox_header } ; 642
proto_register_subtree_array ( ett , array_length ( ett ) ); 665
------------------------------
108 /home/SySeVR/data/CVE_2012_4530_PATCHED_load_script.c [u'interp'] 5
static int CVE_2012_4530_PATCHED_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char interp [ BINPRM_BUF_SIZE ] ; 5
strcpy ( interp , i_name ); 43
retval = bprm_change_interp ( interp , bprm ); 68
if ( retval < 0 )  69
return retval ; 70
file = open_exec ( interp ); 75
if ( IS_ERR ( file ) )  76
return PTR_ERR ( file ) ; 77
bprm -> file = file; 79
retval = prepare_binprm ( bprm ); 80
if ( retval < 0 )  81
return retval ; 82
return search_binary_handler ( bprm , regs ) ; 83
------------------------------
109 /home/SySeVR/data/CVE_2012_4530_VULN_load_script.c [u'interp'] 5
static int CVE_2012_4530_VULN_load_script(struct linux_binprm *bprm,struct pt_regs *regs) 1
char interp [ BINPRM_BUF_SIZE ] ; 5
strcpy ( interp , i_name ); 43
bprm -> interp = interp; 68
file = open_exec ( interp ); 73
if ( IS_ERR ( file ) )  74
return PTR_ERR ( file ) ; 75
bprm -> file = file; 77
retval = prepare_binprm ( bprm ); 78
if ( retval < 0 )  79
return retval ; 80
return search_binary_handler ( bprm , regs ) ; 81
------------------------------
110 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c [u'auth_buf'] 225
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
guint offset = 0 , offset2 ; 112
guint8 type , len ; 115
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  124
type = tvb_get_guint8 ( tvb , offset ); 125
len = tvb_get_guint8 ( tvb , offset + 1 ); 126
offset2 = offset; 128
if ( type == 1 && len == 40 )  129
offset += 2; 139
if ( tree )  153
offset ++; 157
offset ++; 159
offset ++; 161
ipver = tvb_get_guint8 ( tvb , offset ); 162
if ( ipver == 4 )  184
if ( ipver == 6 )  187
if ( type == 2 && len == 4 )  198
if ( type == 3 && len == 8 )  221
if ( tree )  223
gchar auth_buf [ 8 + 1 ] ; 225
tvb_memcpy ( tvb , auth_buf , offset , 8 ); 234
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 235
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 236
if ( type == 4 && len == 28 )  242
offset = offset2 + len + 2; 274
------------------------------
111 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c [u'auth_buf'] 49
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( tree )  44
gchar auth_buf [ 8 + 1 ] ; 49
tvb_memcpy ( tvb , auth_buf , offset , 8 ); 80
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
112 /home/SySeVR/data/CVE_2012_5237_PATCHED_dissect_hsrp.c [u'dst'] 5
static int
CVE_2012_5237_PATCHED_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
address_to_str_buf ( & ( pinfo -> dst ) , dst , sizeof dst ); 17
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  109
------------------------------
113 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c [u'auth_buf'] 220
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
guint offset = 0 ; 110
guint8 type , len ; 113
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )  122
type = tvb_get_guint8 ( tvb , offset ); 123
len = tvb_get_guint8 ( tvb , offset + 1 ); 124
if ( type == 1 && len == 40 )  126
offset += 2; 136
if ( tree )  150
offset ++; 154
offset ++; 156
offset ++; 158
ipver = tvb_get_guint8 ( tvb , offset ); 159
offset ++; 161
offset += 2; 163
offset += 6; 165
offset += 4; 167
offset += 4; 174
offset += 4; 180
if ( ipver == 4 )  181
if ( ipver == 6 )  184
if ( type == 2 && len == 4 )  194
if ( tree )  204
offset += 2; 208
offset += 2; 213
if ( type == 3 && len == 8 )  216
if ( tree )  218
gchar auth_buf [ 8 + 1 ] ; 220
offset += 2; 224
tvb_memcpy ( tvb , auth_buf , offset , 8 ); 229
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 230
proto_tree_add_string_format ( text_auth_tlv , hf_hsrp2_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 231
if ( type == 4 && len == 28 )  236
if ( tree )  238
offset += 2; 243
offset ++; 248
offset ++; 250
offset += 2; 252
offset += 4; 254
offset += 4; 256
------------------------------
114 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c [u'auth_buf'] 49
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
if ( pinfo -> destport != UDP_PORT_HSRP && pinfo -> destport != UDP_PORT_HSRP2_V6 )  11
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( tree )  44
gchar auth_buf [ 8 + 1 ] ; 49
tvb_memcpy ( tvb , auth_buf , offset , 8 ); 80
auth_buf [ sizeof auth_buf - 1 ] = '\0'; 81
proto_tree_add_string_format ( hsrp_tree , hf_hsrp_auth_data , tvb , offset , 8 , auth_buf , "Authentication Data: %sDefault (%s)" , ( tvb_strneql ( tvb , offset , "cisco" , strlen ( "cisco" ) ) ) == 0 ? "" : "Non-" , auth_buf ); 82
------------------------------
115 /home/SySeVR/data/CVE_2012_5237_VULN_dissect_hsrp.c [u'dst'] 5
static int
CVE_2012_5237_VULN_dissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
gchar dst [ 16 ] ; 5
address_to_str_buf ( & ( pinfo -> dst ) , dst , sizeof dst ); 17
if ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP_DST_IP_ADDR ) == 0 )  19
if ( ( pinfo -> dst . type == AT_IPv4 && strcmp ( dst , HSRP2_DST_IP_ADDR ) == 0 ) || ( pinfo -> dst . type == AT_IPv6 && pinfo -> destport == UDP_PORT_HSRP2_V6 ) )  107
------------------------------
116 /home/SySeVR/data/CVE_2012_5238_PATCHED_proto_register_lcp.c [u'ett'] 247
void
CVE_2012_5238_PATCHED_proto_register_lcp(void) 2
static gint * ett [ ] = { & ett_lcp , & ett_lcp_options , & ett_lcp_vendor_opt , & ett_lcp_mru_opt , & ett_lcp_asyncmap_opt , & ett_lcp_authprot_opt , & ett_lcp_qualprot_opt , & ett_lcp_magicnumber_opt , & ett_lcp_linkqualmon_opt , & ett_lcp_pcomp_opt , & ett_lcp_acccomp_opt , & ett_lcp_fcs_alternatives_opt , & ett_lcp_self_desc_pad_opt , & ett_lcp_numbered_mode_opt , & ett_lcp_callback_opt , & ett_lcp_compound_frames_opt , & ett_lcp_nomdataencap_opt , & ett_lcp_multilink_mrru_opt , & ett_lcp_multilink_ssnh_opt , & ett_lcp_multilink_ep_disc_opt , & ett_lcp_magic_block , & ett_lcp_dce_identifier_opt , & ett_lcp_multilink_pp_opt , & ett_lcp_bacp_link_discrim_opt , & ett_lcp_auth_opt , & ett_lcp_cobs_opt , & ett_lcp_prefix_elision_opt , & ett_multilink_hdr_fmt_opt , & ett_lcp_internationalization_opt , & ett_lcp_simple_opt } ; 247
proto_register_subtree_array ( ett , array_length ( ett ) ); 283
------------------------------
117 /home/SySeVR/data/CVE_2012_6058_PATCHED_dissect_icmpv6.c [u'tmp'] 159
static int
CVE_2012_6058_PATCHED_dissect_icmpv6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offset ; 11
guint8 icmp6_type , icmp6_code ; 13
offset = 0; 19
icmp6_type = tvb_get_guint8 ( tvb , offset ); 28
if ( icmp6_type == ICMP6_ECHO_REQUEST || icmp6_type == ICMP6_ECHO_REPLY )  116
if ( pinfo -> destport == 3544 && icmp6_type == ICMP6_ECHO_REQUEST )  133
if ( ! pinfo -> flags . in_error_pkt )  148
if ( icmp6_type == ICMP6_ECHO_REQUEST )  153
guint16 tmp [ 2 ] ; 159
tmp [ 0 ] = ~cksum; 161
tmp [ 1 ] = ~0x0100; 162
cksum_vec [ 0 ] . ptr = ( guint8 * ) tmp; 164
conv_key [ 0 ] = in_cksum ( cksum_vec , 1 ); 165
if ( conv_key [ 0 ] == 0 )  166
conv_key [ 0 ] = 0xffff; 167
conv_key [ 0 ] |= 0x00010000; 169
trans = transaction_end ( pinfo , icmp6_tree , conv_key ); 170
if ( trans )  632
tap_queue_packet ( icmpv6_tap , pinfo , trans ); 633
------------------------------
118 /home/SySeVR/data/CVE_2012_6058_PATCHED_dissect_icmpv6.c [u'conv_key'] 149
static int
CVE_2012_6058_PATCHED_dissect_icmpv6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
int offset ; 11
guint8 icmp6_type , icmp6_code ; 13
offset = 0; 19
icmp6_type = tvb_get_guint8 ( tvb , offset ); 28
if ( icmp6_type == ICMP6_ECHO_REQUEST || icmp6_type == ICMP6_ECHO_REPLY )  116
if ( pinfo -> destport == 3544 && icmp6_type == ICMP6_ECHO_REQUEST )  133
if ( ! pinfo -> flags . in_error_pkt )  148
guint32 conv_key [ 2 ] ; 149
conv_key [ 1 ] = ( guint32 ) ( ( identifier << 16 ) | sequence ); 151
conv_key [ 0 ] = ( guint32 ) cksum; 154
conv_key [ 0 ] |= 0x00010000; 156
trans = transaction_start ( pinfo , icmp6_tree , conv_key ); 157
conv_key [ 0 ] = in_cksum ( cksum_vec , 1 ); 165
if ( conv_key [ 0 ] == 0 )  166
conv_key [ 0 ] = 0xffff; 167
conv_key [ 0 ] |= 0x00010000; 169
trans = transaction_end ( pinfo , icmp6_tree , conv_key ); 170
if ( trans )  632
tap_queue_packet ( icmpv6_tap , pinfo , trans ); 633
------------------------------
119 /home/SySeVR/data/CVE_2012_6058_PATCHED_dissect_icmpv6.c [u'phdr'] 9
static int
CVE_2012_6058_PATCHED_dissect_icmpv6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
guint32 phdr [ 2 ] ; 9
phdr [ 0 ] = g_htonl ( reported_length ); 95
phdr [ 1 ] = g_htonl ( IP_PROTO_ICMPV6 ); 96
------------------------------
120 /home/SySeVR/data/CVE_2012_6058_PATCHED_dissect_icmpv6.c [u'cksum_vec'] 8
static int
CVE_2012_6058_PATCHED_dissect_icmpv6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) 2
vec_t cksum_vec [ 4 ] ; 8
cksum_vec [ 0 ] . ptr = pinfo -> src . data; 90
cksum_vec [ 0 ] . len = pinfo -> src . len; 91
cksum_vec [ 1 ] . ptr = pinfo -> dst . data; 92
cksum_vec [ 1 ] . len = pinfo -> dst . len; 93
cksum_vec [ 2 ] . ptr = ( const guint8 * ) & phdr; 94
cksum_vec [ 2 ] . len = 8; 97
cksum_vec [ 3 ] . len = reported_length; 98
cksum_vec [ 3 ] . ptr = tvb_get_ptr ( tvb , 0 , cksum_vec [ 3 ] . len ); 99
computed_cksum = in_cksum ( cksum_vec , 4 ); 100
if ( computed_cksum == 0 )  102
proto_item_append_text ( checksum_item , " [incorrect, should be 0x%04x]" , in_cksum_shouldbe ( cksum , computed_cksum ) ); 108
expert_add_info_format ( pinfo , checksum_item , PI_CHECKSUM , PI_WARN , "ICMPv6 Checksum Incorrect, should be 0x%04x" , in_cksum_shouldbe ( cksum , computed_cksum ) ); 109
cksum_vec [ 0 ] . len = sizeof ( tmp ); 163
cksum_vec [ 0 ] . ptr = ( guint8 * ) tmp; 164
conv_key [ 0 ] = in_cksum ( cksum_vec , 1 ); 165
if ( conv_key [ 0 ] == 0 )  166
conv_key [ 0 ] = 0xffff; 167
conv_key [ 0 ] |= 0x00010000; 169
trans = transaction_end ( pinfo , icmp6_tree , conv_key ); 170
if ( trans )  632
tap_queue_packet ( icmpv6_tap , pinfo , trans ); 633
------------------------------
121 /home/SySeVR/data/CVE_2013_0756_PATCHED_obj_toSource.c [u'valstr'] 108
static JSBool
CVE_2013_0756_PATCHED_obj_toSource(JSContext *cx, unsigned argc, Value *vp) 2
CallArgs args = CallArgsFromVp ( argc , vp ) ; 4
RootedObject obj ( cx , ToObject ( cx , args . thisv ( ) ) ) ; 7
if ( ! obj )  8
bool outermost = ( cx -> cycleDetectorSet . count ( ) == 0 ) ; 12
AutoCycleDetector detector ( cx , obj ) ; 14
if ( ! detector . init ( ) )  15
if ( detector . foundCycle ( ) )  17
StringBuffer buf ( cx ) ; 25
if ( outermost && ! buf . append ( '(' ) )  26
if ( ! buf . append ( '{' ) )  28
Value val [ 2 ] ; 31
JSString * gsop [ 2 ] ; 35
AutoIdVector idv ( cx ) ; 38
if ( ! GetPropertyNames ( cx , obj , JSITER_OWNONLY , & idv ) )  39
bool comma = false ; 42
for (size_t i = 0; i < idv.length(); ++i) 43
RootedId id ( cx , idv [ i ] ) ; 44
RootedObject obj2 ( cx ) ; 45
RootedShape shape ( cx ) ; 46
if ( ! JSObject :: lookupGeneric ( cx , obj , id , & obj2 , & shape ) )  47
int valcnt = 0 ; 51
if ( shape )  52
bool doGet = true ; 53
if ( obj2 -> isNative ( ) )  54
unsigned attrs = shape -> attributes ( ) ; 55
if ( attrs & JSPROP_GETTER )  56
doGet = false; 57
val [ valcnt ] = shape -> getterValue ( ); 58
gsop [ valcnt ] = cx -> runtime -> atomState . getAtom; 59
valcnt ++; 60
if ( attrs & JSPROP_SETTER )  62
doGet = false; 63
val [ valcnt ] = shape -> setterValue ( ); 64
gsop [ valcnt ] = cx -> runtime -> atomState . setAtom; 65
valcnt ++; 66
if ( doGet )  69
valcnt = 1; 70
gsop [ 0 ] = NULL; 71
MutableHandleValue vp = MutableHandleValue :: fromMarkedLocation ( & val [ 0 ] ) ; 72
if ( ! JSObject :: getGeneric ( cx , obj , obj , id , vp ) )  73
RawString s = ToString ( cx , IdToValue ( id ) ) ; 79
if ( ! s )  80
Rooted < JSLinearString * > idstr ( cx , s -> ensureLinear ( cx ) ) ; 82
if ( ! idstr )  83
if ( JSID_IS_ATOM ( id ) ? ! IsIdentifier ( idstr ) : ( ! JSID_IS_INT ( id ) || JSID_TO_INT ( id ) < 0 ) )  90
s = js_QuoteString ( cx , idstr , jschar ( '\'' ) ); 94
if ( ! s || ! ( idstr = s -> ensureLinear ( cx ) ) )  95
for (int j = 0; j < valcnt; j++) 99
if ( gsop [ j ] && val [ j ] . isUndefined ( ) )  104
RootedString valstr ( cx , js_ValueToSource ( cx , val [ j ] ) ) ; 108
if ( ! valstr )  109
const jschar * vchars = valstr -> getChars ( cx ) ; 111
if ( ! vchars )  112
size_t vlength = valstr -> length ( ) ; 114
if ( gsop [ j ] && IsFunctionObject ( val [ j ] ) )  120
const jschar * start = vchars ; 121
const jschar * end = vchars + vlength ; 122
uint8_t parenChomp = 0 ; 124
if ( vchars [ 0 ] == '(' )  125
vchars ++; 126
parenChomp = 1; 127
if ( vchars )  131
vchars = js_strchr_limit ( vchars , ' ' , end ); 132
if ( vchars )  138
vchars = js_strchr_limit ( vchars , '(' , end ); 139
if ( vchars )  141
if ( * vchars == ' ' )  142
vchars ++; 143
vlength = end - vchars - parenChomp; 144
gsop [ j ] = NULL; 146
vchars = start; 147
if ( comma && ! buf . append ( ", " ) )  151
comma = true; 153
if ( gsop [ j ] )  155
if ( ! buf . append ( gsop [ j ] ) || ! buf . append ( ' ' ) )  156
if ( ! buf . append ( idstr ) )  159
if ( ! buf . append ( gsop [ j ] ? ' ' : ':' ) )  161
if ( ! buf . append ( vchars , vlength ) )  164
------------------------------
122 /home/SySeVR/data/CVE_2013_0756_PATCHED_obj_toSource.c [u'id'] 44
static JSBool
CVE_2013_0756_PATCHED_obj_toSource(JSContext *cx, unsigned argc, Value *vp) 2
CallArgs args = CallArgsFromVp ( argc , vp ) ; 4
RootedObject obj ( cx , ToObject ( cx , args . thisv ( ) ) ) ; 7
if ( ! obj )  8
bool outermost = ( cx -> cycleDetectorSet . count ( ) == 0 ) ; 12
AutoCycleDetector detector ( cx , obj ) ; 14
if ( ! detector . init ( ) )  15
if ( detector . foundCycle ( ) )  17
StringBuffer buf ( cx ) ; 25
if ( outermost && ! buf . append ( '(' ) )  26
if ( ! buf . append ( '{' ) )  28
Value val [ 2 ] ; 31
JSString * gsop [ 2 ] ; 35
AutoIdVector idv ( cx ) ; 38
if ( ! GetPropertyNames ( cx , obj , JSITER_OWNONLY , & idv ) )  39
bool comma = false ; 42
for (size_t i = 0; i < idv.length(); ++i) 43
RootedId id ( cx , idv [ i ] ) ; 44
RootedObject obj2 ( cx ) ; 45
RootedShape shape ( cx ) ; 46
if ( ! JSObject :: lookupGeneric ( cx , obj , id , & obj2 , & shape ) )  47
int valcnt = 0 ; 51
if ( shape )  52
bool doGet = true ; 53
if ( obj2 -> isNative ( ) )  54
unsigned attrs = shape -> attributes ( ) ; 55
if ( attrs & JSPROP_GETTER )  56
doGet = false; 57
val [ valcnt ] = shape -> getterValue ( ); 58
gsop [ valcnt ] = cx -> runtime -> atomState . getAtom; 59
valcnt ++; 60
if ( attrs & JSPROP_SETTER )  62
doGet = false; 63
val [ valcnt ] = shape -> setterValue ( ); 64
gsop [ valcnt ] = cx -> runtime -> atomState . setAtom; 65
valcnt ++; 66
if ( doGet )  69
valcnt = 1; 70
gsop [ 0 ] = NULL; 71
MutableHandleValue vp = MutableHandleValue :: fromMarkedLocation ( & val [ 0 ] ) ; 72
if ( ! JSObject :: getGeneric ( cx , obj , obj , id , vp ) )  73
RawString s = ToString ( cx , IdToValue ( id ) ) ; 79
if ( ! s )  80
Rooted < JSLinearString * > idstr ( cx , s -> ensureLinear ( cx ) ) ; 82
if ( ! idstr )  83
if ( JSID_IS_ATOM ( id ) ? ! IsIdentifier ( idstr ) : ( ! JSID_IS_INT ( id ) || JSID_TO_INT ( id ) < 0 ) )  90
s = js_QuoteString ( cx , idstr , jschar ( '\'' ) ); 94
if ( ! s || ! ( idstr = s -> ensureLinear ( cx ) ) )  95
for (int j = 0; j < valcnt; j++) 99
if ( gsop [ j ] && val [ j ] . isUndefined ( ) )  104
RootedString valstr ( cx , js_ValueToSource ( cx , val [ j ] ) ) ; 108
if ( ! valstr )  109
const jschar * vchars = valstr -> getChars ( cx ) ; 111
if ( ! vchars )  112
size_t vlength = valstr -> length ( ) ; 114
if ( gsop [ j ] && IsFunctionObject ( val [ j ] ) )  120
const jschar * start = vchars ; 121
const jschar * end = vchars + vlength ; 122
uint8_t parenChomp = 0 ; 124
if ( vchars [ 0 ] == '(' )  125
vchars ++; 126
parenChomp = 1; 127
if ( vchars )  131
vchars = js_strchr_limit ( vchars , ' ' , end ); 132
if ( vchars )  138
vchars = js_strchr_limit ( vchars , '(' , end ); 139
if ( vchars )  141
if ( * vchars == ' ' )  142
vchars ++; 143
vlength = end - vchars - parenChomp; 144
gsop [ j ] = NULL; 146
vchars = start; 147
if ( comma && ! buf . append ( ", " ) )  151
comma = true; 153
if ( gsop [ j ] )  155
if ( ! buf . append ( gsop [ j ] ) || ! buf . append ( ' ' ) )  156
if ( ! buf . append ( idstr ) )  159
if ( ! buf . append ( gsop [ j ] ? ' ' : ':' ) )  161
if ( ! buf . append ( vchars , vlength ) )  164
------------------------------
123 /home/SySeVR/data/CVE_2013_0756_PATCHED_obj_toSource.c [u'gsop'] 35
static JSBool
CVE_2013_0756_PATCHED_obj_toSource(JSContext *cx, unsigned argc, Value *vp) 2
CallArgs args = CallArgsFromVp ( argc , vp ) ; 4
RootedObject obj ( cx , ToObject ( cx , args . thisv ( ) ) ) ; 7
if ( ! obj )  8
bool outermost = ( cx -> cycleDetectorSet . count ( ) == 0 ) ; 12
AutoCycleDetector detector ( cx , obj ) ; 14
if ( ! detector . init ( ) )  15
if ( detector . foundCycle ( ) )  17
StringBuffer buf ( cx ) ; 25
if ( outermost && ! buf . append ( '(' ) )  26
if ( ! buf . append ( '{' ) )  28
JSString * gsop [ 2 ] ; 35
gsop [ valcnt ] = cx -> runtime -> atomState . getAtom; 59
valcnt ++; 60
val [ valcnt ] = shape -> setterValue ( ); 64
gsop [ valcnt ] = cx -> runtime -> atomState . setAtom; 65
valcnt ++; 66
gsop [ 0 ] = NULL; 71
MutableHandleValue vp = MutableHandleValue :: fromMarkedLocation ( & val [ 0 ] ) ; 72
if ( ! JSObject :: getGeneric ( cx , obj , obj , id , vp ) )  73
for (int j = 0; j < valcnt; j++) 99
if ( gsop [ j ] && val [ j ] . isUndefined ( ) )  104
RootedString valstr ( cx , js_ValueToSource ( cx , val [ j ] ) ) ; 108
if ( ! valstr )  109
const jschar * vchars = valstr -> getChars ( cx ) ; 111
if ( ! vchars )  112
size_t vlength = valstr -> length ( ) ; 114
if ( gsop [ j ] && IsFunctionObject ( val [ j ] ) )  120
const jschar * start = vchars ; 121
const jschar * end = vchars + vlength ; 122
if ( vchars [ 0 ] == '(' )  125
vchars ++; 126
if ( vchars )  131
vchars = js_strchr_limit ( vchars , ' ' , end ); 132
if ( vchars )  138
vchars = js_strchr_limit ( vchars , '(' , end ); 139
if ( vchars )  141
if ( * vchars == ' ' )  142
vchars ++; 143
vlength = end - vchars - parenChomp; 144
gsop [ j ] = NULL; 146
vchars = start; 147
if ( gsop [ j ] )  155
if ( ! buf . append ( gsop [ j ] ) || ! buf . append ( ' ' ) )  156
if ( ! buf . append ( gsop [ j ] ? ' ' : ':' ) )  161
if ( ! buf . append ( vchars , vlength ) )  164
------------------------------
124 /home/SySeVR/data/CVE_2013_0756_PATCHED_obj_toSource.c [u'val'] 31
static JSBool
CVE_2013_0756_PATCHED_obj_toSource(JSContext *cx, unsigned argc, Value *vp) 2
CallArgs args = CallArgsFromVp ( argc , vp ) ; 4
RootedObject obj ( cx , ToObject ( cx , args . thisv ( ) ) ) ; 7
if ( ! obj )  8
bool outermost = ( cx -> cycleDetectorSet . count ( ) == 0 ) ; 12
AutoCycleDetector detector ( cx , obj ) ; 14
if ( ! detector . init ( ) )  15
if ( detector . foundCycle ( ) )  17
StringBuffer buf ( cx ) ; 25
if ( outermost && ! buf . append ( '(' ) )  26
if ( ! buf . append ( '{' ) )  28
Value val [ 2 ] ; 31
PodArrayZero ( val ); 32
AutoArrayRooter tvr2 ( cx , ArrayLength ( val ) , val ) ; 33
val [ valcnt ] = shape -> getterValue ( ); 58
gsop [ valcnt ] = cx -> runtime -> atomState . getAtom; 59
valcnt ++; 60
val [ valcnt ] = shape -> setterValue ( ); 64
gsop [ valcnt ] = cx -> runtime -> atomState . setAtom; 65
valcnt ++; 66
gsop [ 0 ] = NULL; 71
MutableHandleValue vp = MutableHandleValue :: fromMarkedLocation ( & val [ 0 ] ) ; 72
if ( ! JSObject :: getGeneric ( cx , obj , obj , id , vp ) )  73
for (int j = 0; j < valcnt; j++) 99
if ( gsop [ j ] && val [ j ] . isUndefined ( ) )  104
RootedString valstr ( cx , js_ValueToSource ( cx , val [ j ] ) ) ; 108
if ( ! valstr )  109
const jschar * vchars = valstr -> getChars ( cx ) ; 111
if ( ! vchars )  112
size_t vlength = valstr -> length ( ) ; 114
if ( gsop [ j ] && IsFunctionObject ( val [ j ] ) )  120
const jschar * start = vchars ; 121
const jschar * end = vchars + vlength ; 122
if ( vchars [ 0 ] == '(' )  125
vchars ++; 126
if ( vchars )  131
vchars = js_strchr_limit ( vchars , ' ' , end ); 132
if ( vchars )  138
vchars = js_strchr_limit ( vchars , '(' , end ); 139
if ( vchars )  141
if ( * vchars == ' ' )  142
vchars ++; 143
vlength = end - vchars - parenChomp; 144
gsop [ j ] = NULL; 146
vchars = start; 147
if ( gsop [ j ] )  155
if ( ! buf . append ( gsop [ j ] ) || ! buf . append ( ' ' ) )  156
if ( ! buf . append ( gsop [ j ] ? ' ' : ':' ) )  161
if ( ! buf . append ( vchars , vlength ) )  164
------------------------------
125 /home/SySeVR/data/CVE_2013_0772_VULN_nsGIFDecoder2__OutputRow.c [u'kjump'] 88
uint32_t CVE_2013_0772_VULN_nsGIFDecoder2::OutputRow() 1
int drow_start , drow_end ; 3
drow_start = drow_end = mGIFStruct . irow; 4
if ( ( unsigned ) drow_start >= mGIFStruct . height )  7
if ( ! mGIFStruct . interlaced )  85
static const uint8_t kjump [ 5 ] = { 1 , 8 , 8 , 4 , 2 } ; 88
mGIFStruct . irow += kjump [ mGIFStruct . ipass ]; 91
if ( mGIFStruct . irow >= mGIFStruct . height )  92
mGIFStruct . irow = 8 >> mGIFStruct . ipass; 94
mGIFStruct . ipass ++; 95
while ( mGIFStruct . irow >= mGIFStruct . height )  97
return -- mGIFStruct . rows_remaining ; 100
------------------------------
126 /home/SySeVR/data/CVE_2013_0777_PATCHED_nsCSSRendering__PaintBoxShadowOuter.c [u'borderSizes'] 159
void
CVE_2013_0777_PATCHED_nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
nsRenderingContext& aRenderingContext,
nsIFrame* aForFrame,
const nsRect& aFrameArea,
const nsRect& aDirtyRect) 6
const nsStyleBorder * styleBorder = aForFrame -> GetStyleBorder ( ) ; 8
nsCSSShadowArray * shadows = styleBorder -> mBoxShadow ; 9
if ( ! shadows )  10
nscoord twipsPerPixel = aPresContext -> DevPixelsToAppUnits ( 1 ) ; 12
bool hasBorderRadius ; 14
bool nativeTheme ; 15
const nsStyleDisplay * styleDisplay = aForFrame -> GetStyleDisplay ( ) ; 19
nsITheme :: Transparency transparency ; 20
if ( aForFrame -> IsThemed ( styleDisplay , & transparency ) )  21
hasBorderRadius = false; 23
nativeTheme = transparency != nsITheme :: eOpaque; 26
nativeTheme = false; 28
nscoord twipsRadii [ 8 ] ; 29
hasBorderRadius = aForFrame -> GetBorderRadii ( twipsRadii ); 31
nsRect frameRect = nativeTheme ? aForFrame -> GetVisualOverflowRectRelativeToSelf ( ) + aFrameArea . TopLeft ( ) : aFrameArea ; 37
bool useSkipGfxRect = true ; 45
if ( nativeTheme )  46
useSkipGfxRect = ! aForFrame -> IsLeaf ( ); 52
nsRect paddingRect = aForFrame -> GetPaddingRect ( ) - aForFrame -> GetPosition ( ) + aFrameArea . TopLeft ( ) ; 53
skipGfxRect = nsLayoutUtils :: RectToGfxRect ( paddingRect , twipsPerPixel ); 55
for (uint32_t i = shadows->Length(); i > 0; --i) 62
nsCSSShadowItem * shadowItem = shadows -> ShadowAt ( i - 1 ) ; 63
if ( shadowItem -> mInset )  64
nsRect shadowRect = frameRect ; 67
nscoord pixelSpreadRadius ; 69
if ( nativeTheme )  70
pixelSpreadRadius = shadowItem -> mSpread; 71
pixelSpreadRadius = 0; 74
nscoord blurRadius = shadowItem -> mRadius ; 80
gfxContext * renderContext = aRenderingContext . ThebesContext ( ) ; 91
nsContextBoxBlur blurringArea ; 92
gfxContext * shadowContext = blurringArea . Init ( shadowRect , pixelSpreadRadius , blurRadius , twipsPerPixel , renderContext , aDirtyRect , useSkipGfxRect ? & skipGfxRect : nullptr , nativeTheme ? nsContextBoxBlur :: FORCE_MASK : 0 ) ; 98
if ( ! shadowContext )  103
if ( nativeTheme )  125
if ( hasBorderRadius )  155
gfxFloat borderSizes [ 4 ] ; 159
borderSizes [ NS_SIDE_LEFT ] = spreadDistance; 161
borderSizes [ NS_SIDE_TOP ] = spreadDistance; 162
borderSizes [ NS_SIDE_RIGHT ] = spreadDistance; 163
borderSizes [ NS_SIDE_BOTTOM ] = spreadDistance; 164
nsCSSBorderRenderer :: ComputeOuterRadii ( borderRadii , borderSizes , & clipRectRadii ); 166
------------------------------
127 /home/SySeVR/data/CVE_2013_0777_PATCHED_nsCSSRendering__PaintBoxShadowOuter.c [u'twipsRadii'] 29
void
CVE_2013_0777_PATCHED_nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
nsRenderingContext& aRenderingContext,
nsIFrame* aForFrame,
const nsRect& aFrameArea,
const nsRect& aDirtyRect) 6
const nsStyleBorder * styleBorder = aForFrame -> GetStyleBorder ( ) ; 8
nsCSSShadowArray * shadows = styleBorder -> mBoxShadow ; 9
if ( ! shadows )  10
const nsStyleDisplay * styleDisplay = aForFrame -> GetStyleDisplay ( ) ; 19
nsITheme :: Transparency transparency ; 20
if ( aForFrame -> IsThemed ( styleDisplay , & transparency ) )  21
nscoord twipsRadii [ 8 ] ; 29
hasBorderRadius = aForFrame -> GetBorderRadii ( twipsRadii ); 31
if ( hasBorderRadius )  32
ComputePixelRadii ( twipsRadii , twipsPerPixel , & borderRadii ); 33
if ( hasBorderRadius )  56
if ( hasBorderRadius )  145
if ( hasBorderRadius )  155
------------------------------
128 /home/SySeVR/data/CVE_2013_0777_VULN_nsCSSRendering__PaintBoxShadowOuter.c [u'borderSizes'] 156
void
CVE_2013_0777_VULN_nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
nsRenderingContext& aRenderingContext,
nsIFrame* aForFrame,
const nsRect& aFrameArea,
const nsRect& aDirtyRect) 6
const nsStyleBorder * styleBorder = aForFrame -> GetStyleBorder ( ) ; 8
nsCSSShadowArray * shadows = styleBorder -> mBoxShadow ; 9
if ( ! shadows )  10
nscoord twipsPerPixel = aPresContext -> DevPixelsToAppUnits ( 1 ) ; 12
bool hasBorderRadius ; 14
bool nativeTheme ; 15
const nsStyleDisplay * styleDisplay = aForFrame -> GetStyleDisplay ( ) ; 19
nsITheme :: Transparency transparency ; 20
if ( aForFrame -> IsThemed ( styleDisplay , & transparency ) )  21
hasBorderRadius = false; 23
nativeTheme = transparency != nsITheme :: eOpaque; 26
nativeTheme = false; 28
nscoord twipsRadii [ 8 ] ; 29
hasBorderRadius = aForFrame -> GetBorderRadii ( twipsRadii ); 31
nsRect frameRect = nativeTheme ? aForFrame -> GetVisualOverflowRectRelativeToSelf ( ) + aFrameArea . TopLeft ( ) : aFrameArea ; 37
bool useSkipGfxRect = true ; 45
if ( nativeTheme )  46
useSkipGfxRect = ! aForFrame -> IsLeaf ( ); 52
nsRect paddingRect = aForFrame -> GetPaddingRect ( ) - aForFrame -> GetPosition ( ) + aFrameArea . TopLeft ( ) ; 53
skipGfxRect = nsLayoutUtils :: RectToGfxRect ( paddingRect , twipsPerPixel ); 55
for (uint32_t i = shadows->Length(); i > 0; --i) 62
nsCSSShadowItem * shadowItem = shadows -> ShadowAt ( i - 1 ) ; 63
if ( shadowItem -> mInset )  64
nsRect shadowRect = frameRect ; 67
nscoord pixelSpreadRadius ; 69
if ( nativeTheme )  70
pixelSpreadRadius = shadowItem -> mSpread; 71
pixelSpreadRadius = 0; 74
nscoord blurRadius = shadowItem -> mRadius ; 80
gfxContext * renderContext = aRenderingContext . ThebesContext ( ) ; 91
nsRefPtr < gfxContext > shadowContext ; 92
nsContextBoxBlur blurringArea ; 93
shadowContext = blurringArea . Init ( shadowRect , pixelSpreadRadius , blurRadius , twipsPerPixel , renderContext , aDirtyRect , useSkipGfxRect ? & skipGfxRect : nullptr , nativeTheme ? nsContextBoxBlur :: FORCE_MASK : 0 ); 99
if ( ! shadowContext )  104
if ( nativeTheme )  122
if ( hasBorderRadius )  152
gfxFloat borderSizes [ 4 ] ; 156
borderSizes [ NS_SIDE_LEFT ] = spreadDistance; 158
borderSizes [ NS_SIDE_TOP ] = spreadDistance; 159
borderSizes [ NS_SIDE_RIGHT ] = spreadDistance; 160
borderSizes [ NS_SIDE_BOTTOM ] = spreadDistance; 161
nsCSSBorderRenderer :: ComputeOuterRadii ( borderRadii , borderSizes , & clipRectRadii ); 163
------------------------------
129 /home/SySeVR/data/CVE_2013_0777_VULN_nsCSSRendering__PaintBoxShadowOuter.c [u'twipsRadii'] 29
void
CVE_2013_0777_VULN_nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
nsRenderingContext& aRenderingContext,
nsIFrame* aForFrame,
const nsRect& aFrameArea,
const nsRect& aDirtyRect) 6
const nsStyleBorder * styleBorder = aForFrame -> GetStyleBorder ( ) ; 8
nsCSSShadowArray * shadows = styleBorder -> mBoxShadow ; 9
if ( ! shadows )  10
const nsStyleDisplay * styleDisplay = aForFrame -> GetStyleDisplay ( ) ; 19
nsITheme :: Transparency transparency ; 20
if ( aForFrame -> IsThemed ( styleDisplay , & transparency ) )  21
nscoord twipsRadii [ 8 ] ; 29
hasBorderRadius = aForFrame -> GetBorderRadii ( twipsRadii ); 31
if ( hasBorderRadius )  32
ComputePixelRadii ( twipsRadii , twipsPerPixel , & borderRadii ); 33
if ( hasBorderRadius )  56
if ( hasBorderRadius )  142
if ( hasBorderRadius )  152
------------------------------
130 /home/SySeVR/data/CVE_2013_0782_PATCHED_nsSaveAsCharset__HandleFallBack.c [u'fallbackStr'] 9
NS_IMETHODIMP
CVE_2013_0782_PATCHED_nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength,
int32_t *currentPos, int32_t estimatedLength) 3
char fallbackStr [ 256 ] ; 9
nsresult rv = DoConversionFallBack ( character , fallbackStr , 256 ) ; 10
if ( NS_SUCCEEDED ( rv ) )  11
int32_t tempLen = ( int32_t ) PL_strlen ( fallbackStr ) ; 12
if ( ( tempLen + estimatedLength ) >= ( * bufferLength - * currentPos ) )  15
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES ; 16
char * temp = ( char * ) PR_Realloc ( * outString , * bufferLength + addLength + 1 ) ; 18
if ( temp )  19
* bufferLength += addLength; 21
* outString = temp; 22
* outString = nullptr; 24
* bufferLength = 0; 25
memcpy ( ( * outString + * currentPos ) , fallbackStr , tempLen ); 29
* currentPos += tempLen; 30
return rv ; 32
------------------------------
131 /home/SySeVR/data/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c [u'updaterIdentity'] 101
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
132 /home/SySeVR/data/CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand.c [u'noWriteLock'] 45
BOOL
CVE_2013_0799_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
------------------------------
133 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c [u'offsets'] 450
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
switch ( avctx -> codec -> id )  40
int offsets [ 6 ] ; 450
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
bytestream2_seek ( & gb , offsets [ channel ] , SEEK_SET ); 458
samplesC = samples + channel; 459
current_sample = c -> status [ channel ] . predictor; 465
previous_sample = c -> status [ channel ] . prev_sample; 466
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
next_sample += ( current_sample * coeff1 ) + ( previous_sample * coeff2 ); 492
next_sample = av_clip_int16 ( next_sample >> 8 ); 494
previous_sample = current_sample; 496
current_sample = next_sample; 497
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
c -> status [ channel ] . predictor = current_sample; 511
c -> status [ channel ] . prev_sample = previous_sample; 512
c -> frame . nb_samples = count * 28; 516
for (channel=0; channel<avctx->channels; channel++) 521
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 552
c -> status [ 0 ] . step_index = bytestream2_get_le16u ( & gb ); 553
if ( c -> status [ 0 ] . step_index > 88u )  560
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
for (n = nb_samples >> (1 - st); n > 0; n--) 582
if ( ! c -> status [ 0 ] . step_index )  591
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
for (i = 0; i < 2; i++) 648
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
samples = ( short * ) c -> frame . data [ 0 ] + ch; 658
for (i = 0; i < nb_samples / 14; i++) 661
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
* ( AVFrame * ) data = c -> frame; 699
------------------------------
134 /home/SySeVR/data/CVE_2013_0844_VULN_adpcm_decode_frame.c [u'byte'] 417
static int CVE_2013_0844_VULN_adpcm_decode_frame(AVCodecContext *avctx, void *data,
int *got_frame_ptr, AVPacket *avpkt) 2
int buf_size = avpkt -> size ; 5
ADPCMDecodeContext * c = avctx -> priv_data ; 6
int count1 , count2 ; 11
int nb_samples , coded_samples , ret ; 12
nb_samples = get_nb_samples ( avctx , & gb , buf_size , & coded_samples ); 16
if ( nb_samples <= 0 )  17
c -> frame . nb_samples = nb_samples; 23
if ( ( ret = avctx -> get_buffer ( avctx , & c -> frame ) ) < 0 )  24
if ( coded_samples )  32
c -> frame . nb_samples = nb_samples = coded_samples; 35
switch ( avctx -> codec -> id )  40
if ( avctx -> channels != 2 )  362
for (count1 = 0; count1 < nb_samples / 28; count1++) 370
for (count1 = 0; count1 < nb_samples / 2; count1++) 416
int byte [ 2 ] ; 417
byte [ 0 ] = bytestream2_get_byteu ( & gb ); 419
byte [ 1 ] = bytestream2_get_byteu ( & gb ); 420
int sample = sign_extend ( byte [ channel ] >> i , 4 ) << shift [ channel ] ; 423
sample = ( sample + c -> status [ channel ] . sample1 * coeff [ channel ] [ 0 ] + c -> status [ channel ] . sample2 * coeff [ channel ] [ 1 ] + 0x80 ) >> 8; 424
c -> status [ channel ] . sample2 = c -> status [ channel ] . sample1; 427
c -> status [ channel ] . sample1 = av_clip_int16 ( sample ); 428
* samples ++ = c -> status [ channel ] . sample1; 429
for (channel=0; channel<avctx->channels; channel++) 452
offsets [ channel ] = ( big_endian ? bytestream2_get_be32 ( & gb ) : bytestream2_get_le32 ( & gb ) ) + ( avctx -> channels + 1 ) * 4; 453
for (channel=0; channel<avctx->channels; channel++) 457
bytestream2_seek ( & gb , offsets [ channel ] , SEEK_SET ); 458
samplesC = samples + channel; 459
current_sample = c -> status [ channel ] . predictor; 465
previous_sample = c -> status [ channel ] . prev_sample; 466
if ( byte == 0xEE )  471
* samplesC = sign_extend ( bytestream2_get_be16 ( & gb ) , 16 ); 476
samplesC += avctx -> channels; 477
coeff1 = ea_adpcm_table [ byte >> 4 ]; 480
coeff2 = ea_adpcm_table [ ( byte >> 4 ) + 4 ]; 481
shift = 20 - ( byte & 0x0F ); 482
next_sample = sign_extend ( byte , 4 ) << shift; 486
byte = bytestream2_get_byte ( & gb ); 488
next_sample = sign_extend ( byte >> 4 , 4 ) << shift; 489
next_sample += ( current_sample * coeff1 ) + ( previous_sample * coeff2 ); 492
next_sample = av_clip_int16 ( next_sample >> 8 ); 494
previous_sample = current_sample; 496
current_sample = next_sample; 497
* samplesC = current_sample; 498
samplesC += avctx -> channels; 499
c -> status [ channel ] . predictor = current_sample; 511
c -> status [ channel ] . prev_sample = previous_sample; 512
c -> frame . nb_samples = count * 28; 516
for (channel=0; channel<avctx->channels; channel++) 521
int coeff [ 2 ] [ 4 ] , shift [ 4 ] 522
short * s2 , * s = & samples [ channel ] ; 523
for (n=0; n<4; n++, s+=32*avctx->channels) 524
coeff [ i ] [ n ] = ea_adpcm_table [ ( val & 0x0F ) + 4 * i ]; 527
s [ 0 ] = val & ~0x0F; 528
shift [ n ] = 20 - ( val & 0x0F ); 531
s [ avctx -> channels ] = val & ~0x0F; 532
s = & samples [ m * avctx -> channels + channel ]; 536
for (n=0; n<4; n++, s+=32*avctx->channels) 537
for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) 539
int level = sign_extend ( byte >> ( 4 - i ) , 4 ) << shift [ n ] ; 540
int pred = s2 [ - 1 * avctx -> channels ] * coeff [ 0 ] [ n ] + s2 [ - 2 * avctx -> channels ] * coeff [ 1 ] [ n ] ; 541
s2 [ 0 ] = av_clip_int16 ( ( level + pred + 0x80 ) >> 8 ); 543
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  551
c -> status [ 0 ] . predictor = sign_extend ( bytestream2_get_le16u ( & gb ) , 16 ); 552
c -> status [ 0 ] . step_index = bytestream2_get_le16u ( & gb ); 553
if ( c -> status [ 0 ] . step_index > 88u )  560
av_log ( avctx , AV_LOG_ERROR , "ERROR: step_index = %i\n" , c -> status [ 0 ] . step_index ); 561
for (n = nb_samples >> (1 - st); n > 0; n--) 566
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_IMA_AMV )  569
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , lo , 3 ); 577
* samples ++ = adpcm_ima_expand_nibble ( & c -> status [ 0 ] , hi , 3 ); 578
for (n = nb_samples >> (1 - st); n > 0; n--) 582
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ 0 ] , v >> 4 ); 584
* samples ++ = adpcm_ct_expand_nibble ( & c -> status [ st ] , v & 0x0F ); 585
if ( ! c -> status [ 0 ] . step_index )  591
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 593
* samples ++ = 128 * ( bytestream2_get_byteu ( & gb ) - 0x80 ); 595
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_4 )  599
for (n = nb_samples >> (1 - st); n > 0; n--) 600
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 4 , 4 , 0 ); 602
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x0F , 4 , 0 ); 604
if ( avctx -> codec -> id == AV_CODEC_ID_ADPCM_SBPRO_3 )  607
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 5 , 3 , 0 ); 610
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x07 , 3 , 0 ); 612
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte & 0x03 , 2 , 0 ); 614
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , byte >> 6 , 2 , 2 ); 620
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , ( byte >> 4 ) & 0x03 , 2 , 2 ); 622
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ 0 ] , ( byte >> 2 ) & 0x03 , 2 , 2 ); 624
* samples ++ = adpcm_sbpro_expand_nibble ( & c -> status [ st ] , byte & 0x03 , 2 , 2 ); 626
adpcm_swf_decode ( avctx , buf , buf_size , samples ); 632
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ 0 ] , v & 0x0F ); 638
* samples ++ = adpcm_yamaha_expand_nibble ( & c -> status [ st ] , v >> 4 ); 639
for (i = 0; i < 2; i++) 648
table [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 650
for (i = 0; i < 2; i++) 653
for (n = 0; n < 2; n++) 654
prev [ i ] [ n ] = sign_extend ( bytestream2_get_be16u ( & gb ) , 16 ); 655
samples = ( short * ) c -> frame . data [ 0 ] + ch; 658
for (i = 0; i < nb_samples / 14; i++) 661
int index = ( byte >> 4 ) & 7 ; 663
unsigned int exp = byte & 0x0F ; 664
int factor1 = table [ ch ] [ index * 2 ] ; 665
int factor2 = table [ ch ] [ index * 2 + 1 ] ; 666
for (n = 0; n < 14; n++) 669
if ( n & 1 )  672
sampledat = sign_extend ( byte , 4 ); 673
byte = bytestream2_get_byteu ( & gb ); 675
sampledat = sign_extend ( byte >> 4 , 4 ); 676
sampledat = ( ( prev [ ch ] [ 0 ] * factor1 + prev [ ch ] [ 1 ] * factor2 ) >> 11 ) + ( sampledat << exp ); 679
* samples = av_clip_int16 ( sampledat ); 681
prev [ ch ] [ 1 ] = prev [ ch ] [ 0 ]; 682
prev [ ch ] [ 0 ] = * samples ++; 683
samples += st; 687
* ( AVFrame * ) data = c -> frame; 699
------------------------------
135 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c [u'id_list'] 736
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
h -> ref_count [ 1 ] = 1; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> list_count = 1; 582
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
h -> use_weight = 0; 612
for (i = 0; i < 2; i++) 613
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h0 -> max_contexts = 1; 703
if ( ! h0 -> single_decode_warning )  704
h0 -> single_decode_warning = 1; 707
if ( h != h0 )  709
for (j = 0; j < 2; j++) 735
int id_list [ 16 ] ; 736
id_list [ i ] = 60; 739
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
id_list [ i ] = k; 745
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
------------------------------
136 /home/SySeVR/data/CVE_2013_0850_PATCHED_decode_slice_header.c [u'max'] 557
static int CVE_2013_0850_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
------------------------------
137 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c [u'id_list'] 736
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  560
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 561
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 562
if ( num_ref_idx_active_override_flag )  564
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 565
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  566
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 567
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 575
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  579
h -> list_count = 2; 580
h -> list_count = 1; 582
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 584
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  589
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 591
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  595
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 596
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  599
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 600
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  604
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  608
h -> use_weight = 0; 612
for (i = 0; i < 2; i++) 613
h -> luma_weight_flag [ i ] = 0; 614
h -> chroma_weight_flag [ i ] = 0; 615
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  619
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  636
tmp = get_ue_golomb_31 ( & s -> gb ); 637
if ( tmp > 2 )  638
h -> cabac_init_idc = tmp; 642
h -> last_qscale_diff = 0; 645
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 646
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  647
s -> qscale = tmp; 651
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 652
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 653
h -> deblocking_filter = 1; 661
h -> slice_alpha_c0_offset = 52; 662
h -> slice_beta_offset = 52; 663
if ( h -> pps . deblocking_filter_parameters_present )  664
tmp = get_ue_golomb_31 ( & s -> gb ); 665
if ( tmp > 2 )  666
h -> deblocking_filter = tmp; 671
if ( h -> deblocking_filter < 2 )  672
h -> deblocking_filter ^= 1; 673
if ( h -> deblocking_filter )  675
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 676
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 677
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  678
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  688
h -> deblocking_filter = 0; 695
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  697
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  698
h0 -> max_contexts = 1; 703
if ( ! h0 -> single_decode_warning )  704
h0 -> single_decode_warning = 1; 707
if ( h != h0 )  709
for (j = 0; j < 2; j++) 735
int id_list [ 16 ] ; 736
id_list [ i ] = 60; 739
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  740
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 742
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  744
id_list [ i ] = k; 745
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  749
id_list [ i ] = h -> short_ref_count + k; 750
for (i = 0; i < 16; i++) 758
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 759
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 761
for (i = 16; i < 48; i++) 763
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 764
------------------------------
138 /home/SySeVR/data/CVE_2013_0850_VULN_decode_slice_header.c [u'max'] 557
static int CVE_2013_0850_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_dropable ; 10
int must_reinit ; 11
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  14
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 19
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 20
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 23
if ( first_mb_in_slice == 0 )  25
h0 -> current_slice = 0; 30
if ( ! s0 -> first_field )  31
s -> current_picture_ptr = NULL; 37
slice_type = get_ue_golomb_31 ( & s -> gb ); 41
if ( slice_type > 9 )  42
if ( slice_type > 4 )  48
slice_type -= 5; 49
h -> slice_type_fixed = 0; 52
slice_type = golomb_to_pict_type [ slice_type ]; 54
h -> slice_type = slice_type; 59
h -> slice_type_nos = slice_type & 3; 60
s -> pict_type = h -> slice_type; 63
pps_id = get_ue_golomb ( & s -> gb ); 65
if ( pps_id >= MAX_PPS_COUNT )  66
if ( ! h0 -> pps_buffers [ pps_id ] )  70
h -> pps = * h0 -> pps_buffers [ pps_id ]; 76
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  78
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 84
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 86
s -> avctx -> level = h -> sps . level_idc; 87
s -> avctx -> refs = h -> sps . ref_frame_count; 88
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 90
if ( must_reinit && ( h != h0 || ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) )  97
s -> mb_width = h -> sps . mb_width; 103
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 104
h -> b_stride = s -> mb_width * 4; 106
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 108
s -> width = 16 * s -> mb_width; 110
s -> height = 16 * s -> mb_height; 111
if ( must_reinit )  113
h -> list_count = 0; 117
h -> current_slice = 0; 118
if ( ! s -> context_initialized )  120
if ( h != h0 )  121
if ( FFALIGN ( s -> avctx -> width , 16 ) == s -> width && FFALIGN ( s -> avctx -> height , 16 * ( 2 - h -> sps . frame_mbs_only_flag ) ) == s -> height && ! h -> sps . crop_right && ! h -> sps . crop_bottom && ( s -> avctx -> width != s -> width || s -> avctx -> height && s -> height ) )  126
s -> avctx -> width -= ( 2 >> CHROMA444 ) * FFMIN ( h -> sps . crop_right , ( 8 << CHROMA444 ) - 1 ); 136
s -> avctx -> height -= ( 1 << s -> chroma_y_shift ) * FFMIN ( h -> sps . crop_bottom , ( 16 >> s -> chroma_y_shift ) - 1 ) * ( 2 - h -> sps . frame_mbs_only_flag ); 137
s -> avctx -> sample_aspect_ratio = h -> sps . sar; 139
if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU && ( h -> sps . bit_depth_luma != 8 || h -> sps . chroma_format_idc > 1 ) )  142
if ( s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  151
if ( h -> sps . bit_depth_luma >= 8 && h -> sps . bit_depth_luma <= 14 && h -> sps . bit_depth_luma != 11 && h -> sps . bit_depth_luma != 13 && ( h -> sps . bit_depth_luma != 9 || ! CHROMA422 ) )  153
s -> avctx -> bits_per_raw_sample = h -> sps . bit_depth_luma; 155
h -> cur_chroma_format_idc = h -> sps . chroma_format_idc; 156
h -> pixel_shift = h -> sps . bit_depth_luma > 8; 157
s -> dsp . dct_bits = h -> sps . bit_depth_luma > 8 ? 32 : 16; 161
if ( h -> sps . video_signal_type_present_flag )  170
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 171
if ( h -> sps . colour_description_present_flag )  173
s -> avctx -> color_primaries = h -> sps . color_primaries; 174
s -> avctx -> color_trc = h -> sps . color_trc; 175
s -> avctx -> colorspace = h -> sps . colorspace; 176
switch ( h -> sps . bit_depth_luma )  188
if ( CHROMA444 )  190
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  191
s -> avctx -> pix_fmt = PIX_FMT_GBRP9; 192
s -> avctx -> pix_fmt = PIX_FMT_YUV444P9; 194
if ( CHROMA422 )  195
s -> avctx -> pix_fmt = PIX_FMT_YUV422P9; 196
s -> avctx -> pix_fmt = PIX_FMT_YUV420P9; 198
if ( CHROMA444 )  201
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  202
s -> avctx -> pix_fmt = PIX_FMT_GBRP10; 203
s -> avctx -> pix_fmt = PIX_FMT_YUV444P10; 205
if ( CHROMA422 )  206
s -> avctx -> pix_fmt = PIX_FMT_YUV422P10; 207
s -> avctx -> pix_fmt = PIX_FMT_YUV420P10; 209
if ( CHROMA444 )  212
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  213
s -> avctx -> pix_fmt = PIX_FMT_GBRP12; 214
s -> avctx -> pix_fmt = PIX_FMT_YUV444P12; 216
if ( CHROMA422 )  217
s -> avctx -> pix_fmt = PIX_FMT_YUV422P12; 218
s -> avctx -> pix_fmt = PIX_FMT_YUV420P12; 220
if ( CHROMA444 )  223
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  224
s -> avctx -> pix_fmt = PIX_FMT_GBRP14; 225
s -> avctx -> pix_fmt = PIX_FMT_YUV444P14; 227
if ( CHROMA422 )  228
s -> avctx -> pix_fmt = PIX_FMT_YUV422P14; 229
s -> avctx -> pix_fmt = PIX_FMT_YUV420P14; 231
if ( CHROMA444 )  234
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; 235
if ( s -> avctx -> colorspace == AVCOL_SPC_RGB )  237
s -> avctx -> pix_fmt = PIX_FMT_GBR24P; 238
if ( CHROMA422 )  243
s -> avctx -> pix_fmt = s -> avctx -> color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; 244
s -> avctx -> pix_fmt = s -> avctx -> get_format ( s -> avctx , s -> avctx -> codec -> pix_fmts ? s -> avctx -> codec -> pix_fmts : s -> avctx -> color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420 ); 247
s -> avctx -> hwaccel = ff_find_hwaccel ( s -> avctx -> codec -> id , s -> avctx -> pix_fmt ); 261
if ( ff_MPV_common_init ( s ) < 0 )  264
s -> first_field = 0; 268
h -> prev_interlaced_frame = 1; 269
if ( ff_h264_alloc_tables ( h ) < 0 )  272
if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_SLICE ) )  278
if ( context_init ( h ) < 0 )  279
for (i = 1; i < s->slice_context_count; i++) 284
H264Context * c ; 285
c = h -> thread_context [ i ] = av_malloc ( sizeof ( H264Context ) ); 286
for (i = 0; i < s->slice_context_count; i++) 298
if ( context_init ( h -> thread_context [ i ] ) < 0 )  299
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  307
h -> dequant_coeff_pps = pps_id; 308
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 312
h -> mb_mbaff = 0; 314
h -> mb_aff_frame = 0; 315
last_pic_structure = s0 -> picture_structure; 316
last_pic_dropable = s -> dropable; 317
s -> dropable = h -> nal_ref_idc == 0; 318
if ( h -> sps . frame_mbs_only_flag )  319
s -> picture_structure = PICT_FRAME; 320
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  322
if ( get_bits1 ( & s -> gb ) )  326
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 327
s -> picture_structure = PICT_FRAME; 329
h -> mb_aff_frame = h -> sps . mb_aff; 330
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 333
if ( h0 -> current_slice != 0 )  335
if ( last_pic_structure != s -> picture_structure || last_pic_dropable != s -> dropable )  336
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  348
int unwrap_prev_frame_num = h -> prev_frame_num ; 349
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 350
if ( unwrap_prev_frame_num > h -> frame_num )  352
unwrap_prev_frame_num -= max_frame_num; 353
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  355
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 356
if ( unwrap_prev_frame_num < 0 )  357
unwrap_prev_frame_num += max_frame_num; 358
h -> prev_frame_num = unwrap_prev_frame_num; 360
if ( s0 -> first_field )  369
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  381
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  389
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  400
if ( last_pic_dropable != s -> dropable )  410
s -> picture_structure = last_pic_structure; 414
s -> dropable = last_pic_dropable; 415
s0 -> current_picture_ptr -> owner2 = s0; 425
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  430
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 432
if ( ff_h264_frame_start ( h ) < 0 )  435
h -> prev_frame_num ++; 437
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 438
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 439
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  443
if ( h -> short_ref_count )  452
if ( prev )  453
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 457
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 459
if ( s0 -> first_field )  466
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  472
s0 -> current_picture_ptr = NULL; 475
s0 -> first_field = FIELD_PICTURE; 476
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  478
s0 -> first_field = 1; 484
s0 -> current_picture_ptr = NULL; 485
s0 -> first_field = 0; 488
s0 -> first_field = FIELD_PICTURE; 493
if ( ! FIELD_PICTURE || s0 -> first_field )  496
if ( ff_h264_frame_start ( h ) < 0 )  497
s -> current_picture_ptr -> frame_num = h -> frame_num; 508
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  511
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 516
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 517
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  518
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 519
if ( s -> picture_structure == PICT_FRAME )  522
h -> curr_pic_num = h -> frame_num; 523
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 524
h -> curr_pic_num = 2 * h -> frame_num + 1; 526
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 527
if ( h -> sps . poc_type == 0 )  533
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 534
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  536
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 537
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  540
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 541
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  543
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 544
if ( h -> pps . redundant_pic_cnt_present )  549
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 550
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 553
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 554
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  556
unsigned max [ 2 ] ; 557
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 558
max [ 1 ] = 31; 570
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  573
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 574
------------------------------
139 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c [u'id_list'] 637
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  220
if ( ! s0 -> current_picture_ptr )  228
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( s0 -> first_field )  357
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
s0 -> current_picture_ptr = NULL; 366
s0 -> first_field = FIELD_PICTURE; 367
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
s0 -> first_field = 1; 375
s0 -> current_picture_ptr = NULL; 376
s0 -> first_field = 0; 379
s0 -> first_field = FIELD_PICTURE; 384
if ( ! FIELD_PICTURE || s0 -> first_field )  387
if ( ff_h264_frame_start ( h ) < 0 )  388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  396
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
if ( s -> picture_structure == PICT_FRAME )  413
h -> curr_pic_num = h -> frame_num; 414
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 415
h -> curr_pic_num = 2 * h -> frame_num + 1; 417
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 418
if ( h -> sps . poc_type == 0 )  424
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
unsigned max [ 2 ] ; 448
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  451
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 452
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 453
if ( num_ref_idx_active_override_flag )  455
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 456
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  457
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 458
h -> ref_count [ 1 ] = 1; 461
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  470
h -> list_count = 2; 471
h -> list_count = 1; 473
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 475
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  480
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  486
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 487
s -> last_picture_ptr -> owner2 = s; 488
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  491
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 492
s -> next_picture_ptr -> owner2 = s; 493
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  497
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  501
h -> use_weight = 0; 505
for (i = 0; i < 2; i++) 506
h -> luma_weight_flag [ i ] = 0; 507
h -> chroma_weight_flag [ i ] = 0; 508
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  517
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  537
tmp = get_ue_golomb_31 ( & s -> gb ); 538
if ( tmp > 2 )  539
h -> cabac_init_idc = tmp; 543
h -> last_qscale_diff = 0; 546
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 547
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  548
s -> qscale = tmp; 552
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 553
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 554
h -> deblocking_filter = 1; 562
h -> slice_alpha_c0_offset = 52; 563
h -> slice_beta_offset = 52; 564
if ( h -> pps . deblocking_filter_parameters_present )  565
tmp = get_ue_golomb_31 ( & s -> gb ); 566
if ( tmp > 2 )  567
h -> deblocking_filter = tmp; 572
if ( h -> deblocking_filter < 2 )  573
h -> deblocking_filter ^= 1; 574
if ( h -> deblocking_filter )  576
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 577
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 578
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  579
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  589
h -> deblocking_filter = 0; 596
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  598
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  599
h0 -> max_contexts = 1; 604
if ( ! h0 -> single_decode_warning )  605
h0 -> single_decode_warning = 1; 608
if ( h != h0 )  610
for (j = 0; j < 2; j++) 636
int id_list [ 16 ] ; 637
id_list [ i ] = 60; 640
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  641
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 643
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  645
id_list [ i ] = k; 646
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  650
id_list [ i ] = h -> short_ref_count + k; 651
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 660
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 662
for (i = 16; i < 48; i++) 664
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 665
------------------------------
140 /home/SySeVR/data/CVE_2013_0867_PATCHED_decode_slice_header.c [u'max'] 448
static int CVE_2013_0867_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
if ( h0 -> s . avctx -> pix_fmt != get_pixel_format ( h0 ) )  121
must_reinit = 1; 122
s -> mb_width = h -> sps . mb_width; 124
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 125
h -> b_stride = s -> mb_width * 4; 127
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 129
s -> width = 16 * s -> mb_width; 131
s -> height = 16 * s -> mb_height; 132
if ( h -> sps . video_signal_type_present_flag )  134
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 135
if ( h -> sps . colour_description_present_flag )  137
if ( s -> avctx -> colorspace != h -> sps . colorspace )  138
needs_reinit = 1; 139
s -> avctx -> color_primaries = h -> sps . color_primaries; 140
s -> avctx -> color_trc = h -> sps . color_trc; 141
s -> avctx -> colorspace = h -> sps . colorspace; 142
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  146
if ( h != h0 )  151
if ( ( ret = get_pixel_format ( h ) ) < 0 )  159
s -> avctx -> pix_fmt = ret; 161
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  166
h -> context_reinitialized = 1; 171
if ( ! s -> context_initialized )  173
if ( h != h0 )  174
if ( ( ret = get_pixel_format ( h ) ) < 0 )  180
s -> avctx -> pix_fmt = ret; 182
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  184
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  191
h -> dequant_coeff_pps = pps_id; 192
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 196
h -> mb_mbaff = 0; 198
h -> mb_aff_frame = 0; 199
last_pic_structure = s0 -> picture_structure; 200
last_pic_droppable = s0 -> droppable; 201
s -> droppable = h -> nal_ref_idc == 0; 202
if ( h -> sps . frame_mbs_only_flag )  203
s -> picture_structure = PICT_FRAME; 204
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  206
if ( get_bits1 ( & s -> gb ) )  210
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 211
s -> picture_structure = PICT_FRAME; 213
h -> mb_aff_frame = h -> sps . mb_aff; 214
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 217
if ( h0 -> current_slice != 0 )  219
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  220
if ( ! s0 -> current_picture_ptr )  228
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  237
int unwrap_prev_frame_num = h -> prev_frame_num ; 238
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 239
if ( unwrap_prev_frame_num > h -> frame_num )  241
unwrap_prev_frame_num -= max_frame_num; 242
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  244
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 245
if ( unwrap_prev_frame_num < 0 )  246
unwrap_prev_frame_num += max_frame_num; 247
h -> prev_frame_num = unwrap_prev_frame_num; 249
if ( s0 -> first_field )  258
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  270
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  278
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  289
if ( last_pic_droppable != s -> droppable )  299
s -> picture_structure = last_pic_structure; 303
s -> droppable = last_pic_droppable; 304
s0 -> current_picture_ptr -> owner2 = s0; 314
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  319
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 321
if ( ff_h264_frame_start ( h ) < 0 )  324
h -> prev_frame_num ++; 326
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 327
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 328
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  331
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  334
if ( h -> short_ref_count )  343
if ( prev )  344
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 348
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 350
if ( s0 -> first_field )  357
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  363
s0 -> current_picture_ptr = NULL; 366
s0 -> first_field = FIELD_PICTURE; 367
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  369
s0 -> first_field = 1; 375
s0 -> current_picture_ptr = NULL; 376
s0 -> first_field = 0; 379
s0 -> first_field = FIELD_PICTURE; 384
if ( ! FIELD_PICTURE || s0 -> first_field )  387
if ( ff_h264_frame_start ( h ) < 0 )  388
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  396
s -> current_picture_ptr -> frame_num = h -> frame_num; 399
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  402
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 407
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 408
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  409
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 410
if ( s -> picture_structure == PICT_FRAME )  413
h -> curr_pic_num = h -> frame_num; 414
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 415
h -> curr_pic_num = 2 * h -> frame_num + 1; 417
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 418
if ( h -> sps . poc_type == 0 )  424
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 425
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  427
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 428
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  431
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 432
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  434
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 435
if ( h -> pps . redundant_pic_cnt_present )  440
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 441
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 444
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 445
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  447
unsigned max [ 2 ] ; 448
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 449
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  464
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 465
------------------------------
141 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c [u'id_list'] 636
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  219
if ( ! s0 -> current_picture_ptr )  227
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( s0 -> first_field )  356
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
s0 -> current_picture_ptr = NULL; 365
s0 -> first_field = FIELD_PICTURE; 366
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
s0 -> first_field = 1; 374
s0 -> current_picture_ptr = NULL; 375
s0 -> first_field = 0; 378
s0 -> first_field = FIELD_PICTURE; 383
if ( ! FIELD_PICTURE || s0 -> first_field )  386
if ( ff_h264_frame_start ( h ) < 0 )  387
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
if ( s -> picture_structure == PICT_FRAME )  412
h -> curr_pic_num = h -> frame_num; 413
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 414
h -> curr_pic_num = 2 * h -> frame_num + 1; 416
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 417
if ( h -> sps . poc_type == 0 )  423
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
unsigned max [ 2 ] ; 447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  450
h -> direct_spatial_mv_pred = get_bits1 ( & s -> gb ); 451
num_ref_idx_active_override_flag = get_bits1 ( & s -> gb ); 452
if ( num_ref_idx_active_override_flag )  454
h -> ref_count [ 0 ] = get_ue_golomb ( & s -> gb ) + 1; 455
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  456
h -> ref_count [ 1 ] = get_ue_golomb ( & s -> gb ) + 1; 457
h -> ref_count [ 1 ] = 1; 460
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
h -> ref_count [ 0 ] = h -> ref_count [ 1 ] = 1; 465
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  469
h -> list_count = 2; 470
h -> list_count = 1; 472
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = h -> list_count = 0; 474
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering ( h ) < 0 )  479
h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0; 481
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  485
s -> last_picture_ptr = & h -> ref_list [ 0 ] [ 0 ]; 486
s -> last_picture_ptr -> owner2 = s; 487
if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  490
s -> next_picture_ptr = & h -> ref_list [ 1 ] [ 0 ]; 491
s -> next_picture_ptr -> owner2 = s; 492
if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) )  496
if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B )  500
h -> use_weight = 0; 504
for (i = 0; i < 2; i++) 505
h -> luma_weight_flag [ i ] = 0; 506
h -> chroma_weight_flag [ i ] = 0; 507
if ( h -> nal_ref_idc && ff_h264_decode_ref_pic_marking ( h0 , & s -> gb , ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  516
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac )  536
tmp = get_ue_golomb_31 ( & s -> gb ); 537
if ( tmp > 2 )  538
h -> cabac_init_idc = tmp; 542
h -> last_qscale_diff = 0; 545
tmp = h -> pps . init_qp + get_se_golomb ( & s -> gb ); 546
if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) )  547
s -> qscale = tmp; 551
h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , s -> qscale ); 552
h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , s -> qscale ); 553
h -> deblocking_filter = 1; 561
h -> slice_alpha_c0_offset = 52; 562
h -> slice_beta_offset = 52; 563
if ( h -> pps . deblocking_filter_parameters_present )  564
tmp = get_ue_golomb_31 ( & s -> gb ); 565
if ( tmp > 2 )  566
h -> deblocking_filter = tmp; 571
if ( h -> deblocking_filter < 2 )  572
h -> deblocking_filter ^= 1; 573
if ( h -> deblocking_filter )  575
h -> slice_alpha_c0_offset += get_se_golomb ( & s -> gb ) << 1; 576
h -> slice_beta_offset += get_se_golomb ( & s -> gb ) << 1; 577
if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U )  578
if ( s -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( s -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) )  588
h -> deblocking_filter = 0; 595
if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 )  597
if ( s -> avctx -> flags2 & CODEC_FLAG2_FAST )  598
h0 -> max_contexts = 1; 603
if ( ! h0 -> single_decode_warning )  604
h0 -> single_decode_warning = 1; 607
if ( h != h0 )  609
for (j = 0; j < 2; j++) 635
int id_list [ 16 ] ; 636
id_list [ i ] = 60; 639
if ( h -> ref_list [ j ] [ i ] . f . data [ 0 ] )  640
uint8_t * base = h -> ref_list [ j ] [ i ] . f . base [ 0 ] ; 642
if ( h -> short_ref [ k ] -> f . base [ 0 ] == base )  644
id_list [ i ] = k; 645
if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . base [ 0 ] == base )  649
id_list [ i ] = h -> short_ref_count + k; 650
for (i = 0; i < 16; i++) 658
ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 659
ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1; 661
for (i = 16; i < 48; i++) 663
ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . f . reference & 3 ); 664
------------------------------
142 /home/SySeVR/data/CVE_2013_0867_VULN_decode_slice_header.c [u'max'] 447
static int CVE_2013_0867_VULN_decode_slice_header(H264Context *h, H264Context *h0) 1
MpegEncContext * const s = & h -> s
MpegEncContext * const s0 = & h0 -> s 4
unsigned int first_mb_in_slice ; 5
unsigned int pps_id ; 6
int num_ref_idx_active_override_flag , ret ; 7
unsigned int slice_type , tmp , i , j ; 8
int last_pic_structure , last_pic_droppable ; 10
int must_reinit ; 11
int needs_reinit = 0 ; 12
if ( ( s -> avctx -> flags2 & CODEC_FLAG2_FAST ) && ! h -> nal_ref_idc && ! h -> pixel_shift )  15
s -> me . qpel_put = s -> dsp . put_h264_qpel_pixels_tab; 20
s -> me . qpel_avg = s -> dsp . avg_h264_qpel_pixels_tab; 21
first_mb_in_slice = get_ue_golomb_long ( & s -> gb ); 24
if ( first_mb_in_slice == 0 )  26
h0 -> current_slice = 0; 31
if ( ! s0 -> first_field )  32
s -> current_picture_ptr = NULL; 38
slice_type = get_ue_golomb_31 ( & s -> gb ); 42
if ( slice_type > 9 )  43
if ( slice_type > 4 )  49
slice_type -= 5; 50
h -> slice_type_fixed = 0; 53
slice_type = golomb_to_pict_type [ slice_type ]; 55
h -> slice_type = slice_type; 60
h -> slice_type_nos = slice_type & 3; 61
s -> pict_type = h -> slice_type; 64
pps_id = get_ue_golomb ( & s -> gb ); 66
if ( pps_id >= MAX_PPS_COUNT )  67
if ( ! h0 -> pps_buffers [ pps_id ] )  71
h -> pps = * h0 -> pps_buffers [ pps_id ]; 77
if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  79
SPS * new_sps = h0 -> sps_buffers [ h -> pps . sps_id ] ; 89
h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 91
if ( h -> sps . chroma_format_idc != new_sps -> chroma_format_idc || h -> sps . bit_depth_luma != new_sps -> bit_depth_luma )  93
needs_reinit = 1; 95
h -> current_sps_id = h -> pps . sps_id; 97
h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; 98
if ( s -> mb_width != h -> sps . mb_width || s -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  100
needs_reinit = 1; 105
if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  107
s -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); 111
s -> avctx -> level = h -> sps . level_idc; 112
s -> avctx -> refs = h -> sps . ref_frame_count; 113
must_reinit = ( s -> context_initialized && ( 16 * h -> sps . mb_width != s -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != s -> avctx -> coded_height || s -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , s -> avctx -> sample_aspect_ratio ) ) ); 115
s -> mb_width = h -> sps . mb_width; 123
s -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); 124
h -> b_stride = s -> mb_width * 4; 126
s -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; 128
s -> width = 16 * s -> mb_width; 130
s -> height = 16 * s -> mb_height; 131
if ( h -> sps . video_signal_type_present_flag )  133
s -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; 134
if ( h -> sps . colour_description_present_flag )  136
if ( s -> avctx -> colorspace != h -> sps . colorspace )  137
needs_reinit = 1; 138
s -> avctx -> color_primaries = h -> sps . color_primaries; 139
s -> avctx -> color_trc = h -> sps . color_trc; 140
s -> avctx -> colorspace = h -> sps . colorspace; 141
if ( s -> context_initialized && ( needs_reinit || must_reinit ) )  145
if ( h != h0 )  150
if ( ( ret = get_pixel_format ( h ) ) < 0 )  158
s -> avctx -> pix_fmt = ret; 160
if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  165
h -> context_reinitialized = 1; 170
if ( ! s -> context_initialized )  172
if ( h != h0 )  173
if ( ( ret = get_pixel_format ( h ) ) < 0 )  179
s -> avctx -> pix_fmt = ret; 181
if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  183
if ( h == h0 && h -> dequant_coeff_pps != pps_id )  190
h -> dequant_coeff_pps = pps_id; 191
h -> frame_num = get_bits ( & s -> gb , h -> sps . log2_max_frame_num ); 195
h -> mb_mbaff = 0; 197
h -> mb_aff_frame = 0; 198
last_pic_structure = s0 -> picture_structure; 199
last_pic_droppable = s0 -> droppable; 200
s -> droppable = h -> nal_ref_idc == 0; 201
if ( h -> sps . frame_mbs_only_flag )  202
s -> picture_structure = PICT_FRAME; 203
if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  205
if ( get_bits1 ( & s -> gb ) )  209
s -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & s -> gb ); 210
s -> picture_structure = PICT_FRAME; 212
h -> mb_aff_frame = h -> sps . mb_aff; 213
h -> mb_field_decoding_flag = s -> picture_structure != PICT_FRAME; 216
if ( h0 -> current_slice != 0 )  218
if ( last_pic_structure != s -> picture_structure || last_pic_droppable != s -> droppable )  219
if ( ! s0 -> current_picture_ptr )  227
if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  236
int unwrap_prev_frame_num = h -> prev_frame_num ; 237
int max_frame_num = 1 << h -> sps . log2_max_frame_num ; 238
if ( unwrap_prev_frame_num > h -> frame_num )  240
unwrap_prev_frame_num -= max_frame_num; 241
if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  243
unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; 244
if ( unwrap_prev_frame_num < 0 )  245
unwrap_prev_frame_num += max_frame_num; 246
h -> prev_frame_num = unwrap_prev_frame_num; 248
if ( s0 -> first_field )  257
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  269
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  277
if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && s -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && s -> picture_structure == PICT_TOP_FIELD ) ) )  288
if ( last_pic_droppable != s -> droppable )  298
s -> picture_structure = last_pic_structure; 302
s -> droppable = last_pic_droppable; 303
s0 -> current_picture_ptr -> owner2 = s0; 313
while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! s0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  318
Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; 320
if ( ff_h264_frame_start ( h ) < 0 )  323
h -> prev_frame_num ++; 325
h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; 326
s -> current_picture_ptr -> frame_num = h -> prev_frame_num; 327
if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && s -> avctx -> err_recognition & AV_EF_EXPLODE )  330
if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) )  333
if ( h -> short_ref_count )  342
if ( prev )  343
h -> short_ref [ 0 ] -> poc = prev -> poc + 2; 347
h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; 349
if ( s0 -> first_field )  356
if ( ! FIELD_PICTURE || s -> picture_structure == last_pic_structure )  362
s0 -> current_picture_ptr = NULL; 365
s0 -> first_field = FIELD_PICTURE; 366
if ( s0 -> current_picture_ptr -> frame_num != h -> frame_num )  368
s0 -> first_field = 1; 374
s0 -> current_picture_ptr = NULL; 375
s0 -> first_field = 0; 378
s0 -> first_field = FIELD_PICTURE; 383
if ( ! FIELD_PICTURE || s0 -> first_field )  386
if ( ff_h264_frame_start ( h ) < 0 )  387
if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  395
s -> current_picture_ptr -> frame_num = h -> frame_num; 398
if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s -> mb_num || first_mb_in_slice >= s -> mb_num )  401
s -> resync_mb_x = s -> mb_x = first_mb_in_slice % s -> mb_width; 406
s -> resync_mb_y = s -> mb_y = ( first_mb_in_slice / s -> mb_width ) << FIELD_OR_MBAFF_PICTURE; 407
if ( s -> picture_structure == PICT_BOTTOM_FIELD )  408
s -> resync_mb_y = s -> mb_y = s -> mb_y + 1; 409
if ( s -> picture_structure == PICT_FRAME )  412
h -> curr_pic_num = h -> frame_num; 413
h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; 414
h -> curr_pic_num = 2 * h -> frame_num + 1; 416
h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); 417
if ( h -> sps . poc_type == 0 )  423
h -> poc_lsb = get_bits ( & s -> gb , h -> sps . log2_max_poc_lsb ); 424
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  426
h -> delta_poc_bottom = get_se_golomb ( & s -> gb ); 427
if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  430
h -> delta_poc [ 0 ] = get_se_golomb ( & s -> gb ); 431
if ( h -> pps . pic_order_present == 1 && s -> picture_structure == PICT_FRAME )  433
h -> delta_poc [ 1 ] = get_se_golomb ( & s -> gb ); 434
if ( h -> pps . redundant_pic_cnt_present )  439
h -> redundant_pic_count = get_ue_golomb ( & s -> gb ); 440
h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; 443
h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; 444
if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  446
unsigned max [ 2 ] ; 447
max [ 0 ] = max [ 1 ] = s -> picture_structure == PICT_FRAME ? 15 : 31; 448
if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  463
av_log ( h -> s . avctx , AV_LOG_ERROR , "reference overflow %u > %u or %u > %u\n" , h -> ref_count [ 0 ] - 1 , max [ 0 ] , h -> ref_count [ 1 ] - 1 , max [ 1 ] ); 464
------------------------------
143 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c [u'len'] 5
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint8_t len [ 1 << VLC_BITS ] ; 5
av_assert0 ( i < ( 1 << VLC_BITS ) ); 18
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 27
av_assert0 ( i < ( 1 << VLC_BITS ) ); 53
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 70
------------------------------
144 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c [u'bits'] 4
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint16_t bits [ 1 << VLC_BITS ] ; 4
av_assert0 ( i < ( 1 << VLC_BITS ) ); 18
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 27
av_assert0 ( i < ( 1 << VLC_BITS ) ); 53
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 70
------------------------------
145 /home/SySeVR/data/CVE_2013_0868_PATCHED_generate_joint_tables.c [u'symbols'] 3
static void CVE_2013_0868_PATCHED_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
av_assert0 ( i < ( 1 << VLC_BITS ) ); 18
len [ i ] = len0 + len1; 19
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 20
symbols [ i ] = ( y << 8 ) + u; 21
if ( symbols [ i ] != 0xffff )  22
i ++; 23
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 27
av_assert0 ( i < ( 1 << VLC_BITS ) ); 53
len [ i ] = len0 + len1 + len2; 54
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 55
map [ i ] [ G ] = g; 57
map [ i ] [ B ] = g + b; 58
map [ i ] [ R ] = g + r; 59
map [ i ] [ B ] = g; 61
map [ i ] [ G ] = b; 62
map [ i ] [ R ] = r; 63
i ++; 65
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 70
------------------------------
146 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c [u'len'] 5
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint8_t len [ 1 << VLC_BITS ] ; 5
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 26
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 68
------------------------------
147 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c [u'bits'] 4
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint16_t bits [ 1 << VLC_BITS ] ; 4
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 26
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 68
------------------------------
148 /home/SySeVR/data/CVE_2013_0868_VULN_generate_joint_tables.c [u'symbols'] 3
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s) 1
uint16_t symbols [ 1 << VLC_BITS ] ; 3
len [ i ] = len0 + len1; 18
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ]; 19
symbols [ i ] = ( y << 8 ) + u; 20
if ( symbols [ i ] != 0xffff )  21
i ++; 22
ff_init_vlc_sparse ( & s -> vlc [ 3 + p ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , symbols , 2 , 2 , 0 ); 26
len [ i ] = len0 + len1 + len2; 52
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ]; 53
map [ i ] [ G ] = g; 55
map [ i ] [ B ] = g + b; 56
map [ i ] [ R ] = g + r; 57
map [ i ] [ B ] = g; 59
map [ i ] [ G ] = b; 60
map [ i ] [ R ] = r; 61
i ++; 63
init_vlc ( & s -> vlc [ 3 ] , VLC_BITS , i , len , 1 , 1 , bits , 2 , 2 , 0 ); 68
------------------------------
149 /home/SySeVR/data/CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand.c [u'updaterIdentity'] 101
BOOL
CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
150 /home/SySeVR/data/CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand.c [u'noWriteLock'] 45
BOOL
CVE_2013_1672_PATCHED_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
------------------------------
151 /home/SySeVR/data/CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand.c [u'updaterIdentity'] 101
BOOL
CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
WCHAR installDirUpdater [ MAX_PATH + 1 ] = L '\0' 61
wcsncpy ( installDirUpdater , installDir , MAX_PATH ); 62
result = FALSE; 65
BOOL updaterIsCorrect ; 68
if ( result && ! VerifySameFiles ( argv [ 0 ] , installDirUpdater , updaterIsCorrect ) )  69
result = FALSE; 73
if ( result && ! updaterIsCorrect )  76
result = FALSE; 78
if ( result )  81
HMODULE updaterModule = LoadLibraryEx ( argv [ 0 ] , NULL , LOAD_LIBRARY_AS_DATAFILE ) ; 95
if ( ! updaterModule )  97
char updaterIdentity [ 64 ] ; 101
if ( ! LoadStringA ( updaterModule , IDS_UPDATER_IDENTITY , updaterIdentity , sizeof ( updaterIdentity ) ) )  102
if ( strcmp ( updaterIdentity , UPDATER_IDENTITY_STRING ) )  109
------------------------------
152 /home/SySeVR/data/CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand.c [u'noWriteLock'] 45
BOOL
CVE_2013_1672_VULN_ProcessSoftwareUpdateCommand(DWORD argc, LPWSTR *argv) 2
if ( argc < 3 )  5
WCHAR installDir [ MAX_PATH + 1 ] = L '\0' 20
if ( ! GetInstallationDir ( argc , argv , installDir ) )  21
BOOL isLocal = FALSE ; 33
if ( ! IsLocalFile ( argv [ 0 ] , isLocal ) || ! isLocal )  34
nsAutoHandle noWriteLock ( CreateFileW ( argv [ 0 ] , GENERIC_READ , FILE_SHARE_READ , NULL , OPEN_EXISTING , 0 , NULL ) ) ; 45
if ( INVALID_HANDLE_VALUE == noWriteLock )  47
------------------------------
153 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c [u'extrema'] 22
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint8 extrema [ 4 ] ; 22
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
154 /home/SySeVR/data/CVE_2013_1693_VULN_nsSVGFEMorphologyElement__Filter.c [u'yExt', u'xExt'] 21
nsresult
CVE_2013_1693_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance *instance,
const nsTArray<const Image*>& aSources,
const Image* aTarget,
const nsIntRect& rect) 5
PRInt32 rx , ry ; 7
if ( rx < 0 || ry < 0 )  10
if ( rx == 0 && ry == 0 )  14
PRUint32 xExt [ 4 ] , yExt [ 4 ] ; 21
if ( x == rect . x || xExt [ 0 ] <= startX || xExt [ 1 ] <= startX || xExt [ 2 ] <= startX || xExt [ 3 ] <= startX )  44
extrema [ i ] = sourceData [ targIndex + i ]; 48
for (i = 0; i < 4; i++) 52
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ; 53
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  54
extrema [ i ] = pixel; 58
xExt [ i ] = x1; 59
yExt [ i ] = y1; 60
PRUint8 pixel = sourceData [ y1 * stride + 4 * endX + i ] ; 68
if ( ( extrema [ i ] >= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] <= pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )  69
extrema [ i ] = pixel; 73
xExt [ i ] = endX; 74
yExt [ i ] = y1; 75
targetData [ targIndex ] = extrema [ 0 ]; 80
targetData [ targIndex + 1 ] = extrema [ 1 ]; 81
targetData [ targIndex + 2 ] = extrema [ 2 ]; 82
targetData [ targIndex + 3 ] = extrema [ 3 ]; 83
------------------------------
155 /home/SySeVR/data/CVE_2013_1696_PATCHED_nsDSURIContentListener__CheckOneFrameOptionsPolicy.c [u'allowFrom'] 3
bool CVE_2013_1696_PATCHED_nsDSURIContentListener::CheckOneFrameOptionsPolicy(nsIHttpChannel *httpChannel,
const nsAString& policy) 2
static const char allowFrom [ ] = "allow-from " ; 3
const uint32_t allowFromLen = ArrayLength ( allowFrom ) - 1 ; 4
bool isAllowFrom = StringHead ( policy , allowFromLen ) . LowerCaseEqualsLiteral ( allowFrom ) ; 5
if ( ! policy . LowerCaseEqualsLiteral ( "deny" ) && ! policy . LowerCaseEqualsLiteral ( "sameorigin" ) && ! isAllowFrom )  9
if ( isAllowFrom )  111
rv = NS_NewURI ( getter_AddRefs ( uri ) , Substring ( policy , allowFromLen ) ); 112
if ( NS_FAILED ( rv ) )  114
if ( NS_FAILED ( rv ) )  118
------------------------------
156 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'installDir'] 768
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 575
NS_tchar * targetPath = argv [ callbackIndex ] ; 577
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 578
if ( sReplaceRequest )  580
NS_tchar installDir [ MAXPATHLEN ] ; 597
if ( ! GetInstallationDir ( installDir ) )  598
targetPath = buffer; 602
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  604
if ( ! sReplaceRequest )  620
const int max_retries = 10 ; 653
int retries = 1 ; 654
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , 0 , NULL ); 660
if ( callbackFile != INVALID_HANDLE_VALUE )  665
while ( ++ retries <= max_retries )  674
if ( callbackFile == INVALID_HANDLE_VALUE )  678
if ( argc > callbackIndex )  757
if ( gSucceeded )  759
if ( ! sUsingService )  767
NS_tchar installDir [ MAXPATHLEN ] ; 768
if ( GetInstallationDir ( installDir ) )  769
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  770
StartServiceUpdate ( installDir ); 774
------------------------------
157 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'installDir'] 597
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
if ( sReplaceRequest )  580
NS_tchar installDir [ MAXPATHLEN ] ; 597
if ( ! GetInstallationDir ( installDir ) )  598
size_t callbackPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , installDir , NULL ) ; 600
NS_tstrncpy ( p , argv [ callbackIndex ] + max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 601
if ( GetInstallationDir ( installDir ) )  769
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  770
StartServiceUpdate ( installDir ); 774
------------------------------
158 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'buffer'] 578
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 578
NS_tchar * p = buffer ; 584
NS_tstrncpy ( p , argv [ callbackIndex ] , commonPrefixLength ); 585
p += commonPrefixLength; 586
NS_tstrncpy ( p , gDestinationPath + commonPrefixLength , bufferLeft ); 588
p += len; 591
* p = NS_T ( '\\' ); 593
* p = NS_T ( '\0' ); 596
NS_tstrncpy ( p , argv [ callbackIndex ] + max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 601
targetPath = buffer; 602
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  604
LOG ( ( "CVE_2013_1707_PATCHED_NS_main: unable to find callback file: " LOG_S , targetPath ) ) 606
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , 0 , NULL ); 660
if ( callbackFile != INVALID_HANDLE_VALUE )  665
LOG ( ( "CVE_2013_1707_PATCHED_NS_main: callback app open attempt %d failed. "
"File: " LOG_S ". Last error: %d" , retries ,
targetPath , lastWriteError ) ) 671
if ( callbackFile == INVALID_HANDLE_VALUE )  678
CloseHandle ( callbackFile ); 724
------------------------------
159 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'callbackLongPath'] 575
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 575
ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ); 576
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  604
NS_tchar * s = callbackLongPath ; 622
s += len; 626
if ( * s == NS_T ( '\\' ) )  627
if ( * s == NS_T ( '\\' ) )  633
* d = * s; 636
while ( * s )  639
* d = NS_T ( '\0' ); 640
------------------------------
160 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'applyDirLongPath'] 554
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
int len = NS_tstrlen ( applyDirLongPath ) ; 621
s += len; 626
if ( * s == NS_T ( '\\' ) )  627
if ( * s == NS_T ( '\\' ) )  633
* d = * s; 636
while ( * s )  639
* d = NS_T ( '\0' ); 640
------------------------------
161 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'maintenanceServiceKey'] 321
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( useService )  300
BOOL isLocal = FALSE ; 301
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 302
if ( useService )  311
BOOL unpromptedElevation ; 312
if ( IsUnpromptedElevation ( unpromptedElevation ) )  313
useService = ! unpromptedElevation; 314
if ( useService )  320
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 321
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  324
------------------------------
162 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'installDir'] 292
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  413
if ( ! GetInstallationDir ( installDir ) )  598
if ( GetInstallationDir ( installDir ) )  769
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  770
StartServiceUpdate ( installDir ); 774
------------------------------
163 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'installDir'] 202
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
NS_tchar * slash = ( NS_tchar * ) NS_tstrrchr ( installDir , NS_SLASH ) ; 206
* slash = NS_T ( '\0' ); 207
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
if ( ! GetInstallationDir ( installDir ) )  293
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  413
if ( ! GetInstallationDir ( installDir ) )  598
if ( GetInstallationDir ( installDir ) )  769
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  770
StartServiceUpdate ( installDir ); 774
------------------------------
164 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'updateLockFilePath'] 192
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , gDestinationPath ); 196
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 214
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  394
CloseHandle ( updateLockFileHandle ); 395
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  458
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  467
CloseHandle ( updateLockFileHandle ); 468
CloseHandle ( updateLockFileHandle ); 477
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 560
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 609
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 690
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 778
------------------------------
165 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'MAXPATHLEN', u'elevatedLockFilePath'] 189
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ); 243
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; 249
if ( startedFromUnelevatedUpdater )  258
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
CloseHandle ( elevatedFileHandle ); 288
CloseHandle ( elevatedFileHandle ); 456
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 560
size_t bufferLeft = MAXPATHLEN * 2 ; 579
bufferLeft -= commonPrefixLength; 587
NS_tstrncpy ( p , gDestinationPath + commonPrefixLength , bufferLeft ); 588
bufferLeft -= len; 592
bufferLeft --; 595
NS_tstrncpy ( p , argv [ callbackIndex ] + max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 601
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 609
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 690
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 778
------------------------------
166 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'tmpDir'] 164
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
if ( sReplaceRequest )  160
NS_tchar tmpDir [ MAXPATHLEN ] ; 164
if ( GetTempPathW ( MAXPATHLEN , tmpDir ) )  165
NS_tchdir ( tmpDir ); 166
------------------------------
167 /home/SySeVR/data/CVE_2013_1707_PATCHED_NS_main.c [u'installDir'] 101
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! GetInstallationDir ( installDir ) )  203
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
if ( ! GetInstallationDir ( installDir ) )  293
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  413
if ( ! GetInstallationDir ( installDir ) )  598
if ( GetInstallationDir ( installDir ) )  769
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  770
StartServiceUpdate ( installDir ); 774
------------------------------
168 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'installDir'] 762
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 575
NS_tchar * targetPath = argv [ callbackIndex ] ; 577
NS_tchar buffer [ MAXPATHLEN * 2 ] ; 578
if ( sReplaceRequest )  579
NS_tchar installDir [ MAXPATHLEN ] ; 591
if ( ! GetInstallationDir ( installDir ) )  592
targetPath = buffer; 596
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  598
if ( ! sReplaceRequest )  614
const int max_retries = 10 ; 647
int retries = 1 ; 648
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , 0 , NULL ); 654
if ( callbackFile != INVALID_HANDLE_VALUE )  659
while ( ++ retries <= max_retries )  668
if ( callbackFile == INVALID_HANDLE_VALUE )  672
if ( argc > callbackIndex )  751
if ( gSucceeded )  753
if ( ! sUsingService )  761
NS_tchar installDir [ MAXPATHLEN ] ; 762
if ( GetInstallationDir ( installDir ) )  763
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  764
StartServiceUpdate ( installDir ); 768
------------------------------
169 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'installDir'] 591
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
if ( sReplaceRequest )  579
NS_tchar installDir [ MAXPATHLEN ] ; 591
if ( ! GetInstallationDir ( installDir ) )  592
size_t callbackPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , installDir , NULL ) ; 594
NS_tstrcpy ( p , argv [ callbackIndex ] + max ( callbackPrefixLength , commonPrefixLength ) ); 595
if ( GetInstallationDir ( installDir ) )  763
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  764
StartServiceUpdate ( installDir ); 768
------------------------------
170 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'buffer'] 578
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar buffer [ MAXPATHLEN * 2 ] ; 578
NS_tchar * p = buffer ; 583
NS_tstrncpy ( p , argv [ callbackIndex ] , commonPrefixLength ); 584
p += commonPrefixLength; 585
NS_tstrcpy ( p , gDestinationPath + commonPrefixLength ); 586
p += NS_tstrlen ( gDestinationPath + commonPrefixLength ); 587
* p = NS_T ( '\\' ); 588
* p = NS_T ( '\0' ); 590
NS_tstrcpy ( p , argv [ callbackIndex ] + max ( callbackPrefixLength , commonPrefixLength ) ); 595
targetPath = buffer; 596
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  598
LOG ( ( "CVE_2013_1707_VULN_NS_main: unable to find callback file: " LOG_S , targetPath ) ) 600
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , NULL , OPEN_EXISTING , 0 , NULL ); 654
if ( callbackFile != INVALID_HANDLE_VALUE )  659
LOG ( ( "CVE_2013_1707_VULN_NS_main: callback app open attempt %d failed. "
"File: " LOG_S ". Last error: %d" , retries ,
targetPath , lastWriteError ) ) 665
if ( callbackFile == INVALID_HANDLE_VALUE )  672
CloseHandle ( callbackFile ); 718
------------------------------
171 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'callbackLongPath'] 575
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
if ( argc > callbackIndex )  569
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 575
ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ); 576
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  598
NS_tchar * s = callbackLongPath ; 616
s += len; 620
if ( * s == NS_T ( '\\' ) )  621
if ( * s == NS_T ( '\\' ) )  627
* d = * s; 630
while ( * s )  633
* d = NS_T ( '\0' ); 634
------------------------------
172 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'applyDirLongPath'] 554
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
gDestinationPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 29
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
GonkAutoMounter mounter ; 497
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  498
if ( ! sReplaceRequest )  509
if ( NS_tchdir ( gDestinationPath ) != 0 )  511
int rv = NS_tmkdir ( gDestinationPath , 0755 ) ; 513
if ( rv == OK && errno != EEXIST )  514
if ( NS_tchdir ( gDestinationPath ) != 0 )  516
if ( ! sReplaceRequest )  533
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gDestinationPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 536
if ( ! destpath )  537
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 554
if ( ! GetLongPathNameW ( gDestinationPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  555
int len = NS_tstrlen ( applyDirLongPath ) ; 615
s += len; 620
if ( * s == NS_T ( '\\' ) )  621
if ( * s == NS_T ( '\\' ) )  627
* d = * s; 630
while ( * s )  633
* d = NS_T ( '\0' ); 634
------------------------------
173 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'maintenanceServiceKey'] 321
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( useService )  300
BOOL isLocal = FALSE ; 301
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 302
if ( useService )  311
BOOL unpromptedElevation ; 312
if ( IsUnpromptedElevation ( unpromptedElevation ) )  313
useService = ! unpromptedElevation; 314
if ( useService )  320
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 321
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  324
------------------------------
174 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'installDir'] 292
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != NULL ; 38
useService = IsUpdateStatusPendingService ( ); 44
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 48
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
HANDLE elevatedFileHandle ; 272
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
PRUnichar * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 286
if ( ! cmdLine )  287
NS_tchar installDir [ MAXPATHLEN ] ; 292
if ( ! GetInstallationDir ( installDir ) )  293
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  413
if ( ! GetInstallationDir ( installDir ) )  592
if ( GetInstallationDir ( installDir ) )  763
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  764
StartServiceUpdate ( installDir ); 768
------------------------------
175 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'installDir'] 202
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
if ( sBackgroundUpdate )  193
if ( sReplaceRequest )  199
NS_tchar installDir [ MAXPATHLEN ] ; 202
if ( ! GetInstallationDir ( installDir ) )  203
NS_tchar * slash = ( NS_tchar * ) NS_tstrrchr ( installDir , NS_SLASH ) ; 206
* slash = NS_T ( '\0' ); 207
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
if ( ! GetInstallationDir ( installDir ) )  293
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  413
if ( ! GetInstallationDir ( installDir ) )  592
if ( GetInstallationDir ( installDir ) )  763
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  764
StartServiceUpdate ( installDir ); 768
------------------------------
176 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'updateLockFilePath'] 192
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
sBackgroundUpdate = true; 85
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
const int callbackIndex = 5 ; 174
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL; 177
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )  190
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 192
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , gDestinationPath ); 196
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 214
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  222
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 235
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  264
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  394
CloseHandle ( updateLockFileHandle ); 395
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  426
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  458
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  467
CloseHandle ( updateLockFileHandle ); 468
CloseHandle ( updateLockFileHandle ); 477
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 560
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 603
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 684
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 772
------------------------------
177 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'MAXPATHLEN', u'elevatedLockFilePath'] 189
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 189
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ); 243
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; 249
if ( startedFromUnelevatedUpdater )  258
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  266
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , NULL , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , NULL ); 273
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  281
CloseHandle ( elevatedFileHandle ); 288
CloseHandle ( elevatedFileHandle ); 456
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 560
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 603
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 684
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 772
------------------------------
178 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'tmpDir'] 164
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
__int64 pid = 0 ; 72
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! WriteStatusFile ( "applying" ) )  125
if ( pid > 0 )  138
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 139
if ( parent )  143
DWORD result = WaitForSingleObject ( parent , 5000 ) ; 144
if ( result != WAIT_OBJECT_0 )  146
if ( sReplaceRequest )  160
NS_tchar tmpDir [ MAXPATHLEN ] ; 164
if ( GetTempPathW ( MAXPATHLEN , tmpDir ) )  165
NS_tchdir ( tmpDir ); 166
------------------------------
179 /home/SySeVR/data/CVE_2013_1707_VULN_NS_main.c [u'installDir'] 101
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 3 )  17
if ( argc > 3 )  76
pid = _wtoi64 ( argv [ 3 ] ); 78
if ( pid == - 1 )  82
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )  86
sReplaceRequest = true; 89
if ( sReplaceRequest )  98
NS_tchar installDir [ MAXPATHLEN ] ; 101
if ( ! GetInstallationDir ( installDir ) )  102
if ( ! GetInstallationDir ( installDir ) )  203
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 208
if ( ! GetInstallationDir ( installDir ) )  293
if ( CalculateRegistryPathFromFilePath ( installDir , maintenanceServiceKey ) )  322
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  413
if ( ! GetInstallationDir ( installDir ) )  592
if ( GetInstallationDir ( installDir ) )  763
if ( ! LaunchWinPostProcess ( installDir , gSourcePath , false , NULL ) )  764
StartServiceUpdate ( installDir ); 768
------------------------------
180 /home/SySeVR/data/CVE_2013_1708_VULN_WaveReader__LoadListChunk.c [u'chunk'] 16
bool
CVE_2013_1708_VULN_WaveReader::LoadListChunk(uint32_t aChunkSize,
nsAutoPtr<nsHTMLMediaElement::MetadataTags> &aTags) 3
static const unsigned int MAX_CHUNK_SIZE = 1 << 16 ; 9
if ( aChunkSize > MAX_CHUNK_SIZE )  12
nsAutoArrayPtr < char > chunk ( new char [ aChunkSize ] ) ; 16
if ( ! ReadAll ( chunk . get ( ) , aChunkSize ) )  17
const char * p = chunk . get ( ) ; 22
while ( p + 8 < end )  39
if ( p + length > end )  47
p += length; 59
------------------------------
181 /home/SySeVR/data/CVE_2013_1726_PATCHED_mar_read_product_info_block.c [u'buf'] 10
int
CVE_2013_1726_PATCHED_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
char buf [ 97 ] = { '\0' } ; 10
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
infoBlock -> MARChannelID = location; 56
location += len + 1; 57
if ( len >= 64 )  58
infoBlock -> MARChannelID = NULL; 59
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
location += len + 1; 66
if ( len >= 32 )  67
infoBlock -> MARChannelID = NULL; 68
infoBlock -> productVersion = NULL; 69
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
------------------------------
182 /home/SySeVR/data/CVE_2013_1726_VULN_mar_read_product_info_block.c [u'buf'] 10
int
CVE_2013_1726_VULN_mar_read_product_info_block(MarFile *mar,
struct ProductInformationBlock *infoBlock) 3
char buf [ 97 ] = { '\0' } ; 10
if ( fread ( buf , additionalBlockSize , 1 , mar -> fp ) != 1 )  47
location = buf; 54
len = strlen ( location ); 55
infoBlock -> MARChannelID = location; 56
location += len + 1; 57
if ( len >= 64 )  58
infoBlock -> MARChannelID = NULL; 59
len = strlen ( location ); 64
infoBlock -> productVersion = location; 65
location += len + 1; 66
if ( len >= 32 )  67
infoBlock -> MARChannelID = NULL; 68
infoBlock -> productVersion = NULL; 69
infoBlock -> MARChannelID = strdup ( infoBlock -> MARChannelID ); 72
infoBlock -> productVersion = strdup ( infoBlock -> productVersion ); 74
------------------------------
183 /home/SySeVR/data/CVE_2013_1732_VULN_nsBlockFrame__Reflow.c [u'buf'] 324
NS_IMETHODIMP
CVE_2013_1732_VULN_nsBlockFrame::Reflow(nsPresContext*           aPresContext,
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
nsReflowStatus&          aStatus) 5
const nsHTMLReflowState * reflowState = & aReflowState ; 26
nsAutoPtr < nsHTMLReflowState > mutableReflowState ; 27
if ( aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE && aReflowState . ComputedHeight ( ) != NS_AUTOHEIGHT && ApplyOverflowClipping ( this , aReflowState . mStyleDisplay ) )  30
nsMargin heightExtras = aReflowState . mComputedBorderPadding ; 33
if ( GetSkipSides ( ) & NS_SIDE_TOP )  34
heightExtras . top = 0; 35
heightExtras . top += aReflowState . mComputedMargin . top; 39
if ( GetEffectiveComputedHeight ( aReflowState ) + heightExtras . TopBottom ( ) <= aReflowState . availableHeight )  42
mutableReflowState = new nsHTMLReflowState ( aReflowState ); 44
mutableReflowState -> availableHeight = NS_UNCONSTRAINEDSIZE; 45
reflowState = mutableReflowState; 46
if ( IsFrameTreeTooDeep ( * reflowState , aMetrics , aStatus ) )  71
nsBlockReflowState state ( * reflowState , aPresContext , this , aMetrics , topMarginRoot , bottomMarginRoot , needFloatManager ) ; 77
state . mOverflowTracker = & tracker; 107
nsOverflowAreas fcBounds ; 111
nsReflowStatus fcStatus = NS_FRAME_COMPLETE ; 112
rv = ReflowPushedFloats ( state , fcBounds , fcStatus ); 113
rv = ReflowDirtyLines ( state ); 125
if ( NS_FAILED ( rv ) )  127
if ( gLameReflowMetrics )  312
char buf [ 400 ] ; 324
PR_snprintf ( buf , sizeof ( buf ) , ": %lld elapsed (%lld per line) (%d lines; %d new lines)" , delta , perLineDelta , numLines , ectc - ctc ); 325
printf ( "%s\n" , buf ); 328
------------------------------
184 /home/SySeVR/data/CVE_2013_1772_PATCHED_call_console_drivers.c [u'buf_prefix'] 16
static void CVE_2013_1772_PATCHED_call_console_drivers(unsigned start, unsigned end) 1
unsigned cur_index , start_print ; 3
static int msg_level = - 1 ; 4
cur_index = start; 8
while ( cur_index != end )  10
if ( msg_level < 0 && ( ( end - cur_index ) > 2 ) )  11
char buf_prefix [ SYSLOG_PRI_MAX_LENGTH + 1 ] ; 16
unsigned i ; 17
for (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) 18
buf_prefix [ i ] = LOG_BUF ( cur_index + i ); 19
buf_prefix [ i ] = '\0'; 21
cur_index += log_prefix ( ( const char * ) & buf_prefix , & msg_level , NULL ); 24
start_print = cur_index; 25
while ( cur_index != end )  27
char c = LOG_BUF ( cur_index ) ; 28
cur_index ++; 30
if ( c == '\n' )  31
_call_console_drivers ( start_print , cur_index , msg_level ); 41
msg_level = - 1; 42
start_print = cur_index; 43
_call_console_drivers ( start_print , end , msg_level ); 48
------------------------------
185 /home/SySeVR/data/CVE_2013_1792_PATCHED_install_user_keyrings.c [u'buf'] 6
int CVE_2013_1792_PATCHED_install_user_keyrings(void) 1
char buf [ 20 ] ; 6
sprintf ( buf , "_uid.%u" , uid ); 29
uid_keyring = find_keyring_by_name ( buf , true ); 31
if ( IS_ERR ( uid_keyring ) )  32
uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , KEY_ALLOC_IN_QUOTA , NULL ); 33
if ( IS_ERR ( uid_keyring ) )  36
ret = PTR_ERR ( uid_keyring ); 37
sprintf ( buf , "_uid_ses.%u" , uid ); 44
session_keyring = find_keyring_by_name ( buf , true ); 46
if ( IS_ERR ( session_keyring ) )  47
session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , KEY_ALLOC_IN_QUOTA , NULL ); 48
if ( IS_ERR ( session_keyring ) )  51
ret = PTR_ERR ( session_keyring ); 52
ret = key_link ( session_keyring , uid_keyring ); 58
if ( ret < 0 )  59
user -> uid_keyring = uid_keyring; 64
user -> session_keyring = session_keyring; 65
key_put ( session_keyring ); 73
key_put ( uid_keyring ); 75
kleave ( " = %d" , ret ); 78
return ret ; 79
------------------------------
186 /home/SySeVR/data/CVE_2013_1848_PATCHED_ext3_blkdev_get.c [u'b'] 4
static struct block_device *CVE_2013_1848_PATCHED_ext3_blkdev_get(dev_t dev, struct super_block *sb) 1
char b [ BDEVNAME_SIZE ] ; 4
ext3_msg ( sb , KERN_ERR , "error: failed to open journal device %s: %ld" , __bdevname ( dev , b ) , PTR_ERR ( bdev ) ); 12
------------------------------
187 /home/SySeVR/data/CVE_2013_3674_VULN_cdg_decode_frame.c [u'cdg_data'] 8
static int CVE_2013_3674_VULN_cdg_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame, AVPacket *avpkt) 2
uint8_t cdg_data [ CDG_DATA_SIZE ] ; 8
bytestream_get_buffer ( & buf , cdg_data , buf_size - CDG_HEADER_SIZE ); 35
if ( ! ( cdg_data [ 1 ] & 0x0F ) )  40
memset ( cc -> frame . data [ 0 ] , cdg_data [ 0 ] & 0x0F , cc -> frame . linesize [ 0 ] * CDG_FULL_HEIGHT ); 41
cdg_load_palette ( cc , cdg_data , inst == CDG_INST_LOAD_PAL_LO ); 51
cdg_border_preset ( cc , cdg_data ); 54
ret = cdg_tile_block ( cc , cdg_data , inst == CDG_INST_TILE_BLOCK_XOR ); 63
if ( ret )  64
return ret ; 66
if ( ret )  78
return ret ; 80
cdg_scroll ( cc , cdg_data , & new_frame , inst == CDG_INST_SCROLL_COPY ); 83
------------------------------
188 /home/SySeVR/data/CVE_2013_4079_VULN_dissect_schedule_message.c [u'other_slots'] 8
static void
CVE_2013_4079_VULN_dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 2
guint16 other_slots [ 48 ] ; 8
memset ( & other_slots , 0xFF , sizeof ( other_slots ) ); 53
octet1 = tvb_get_guint8 ( tvb , offset ); 75
if ( ( octet1 & 0x80 ) == 0x80 )  76
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 82
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 83
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 84
offset += 2; 87
other_slots [ new_slots [ i ] - 1 ] = msg_id; 88
if ( ( octet1 & 0xC0 ) == 0 )  90
if ( octet1 < new_slots [ i ] )  93
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 95
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 98
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 102
if ( octet1 == 0x40 )  107
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , new_slots [ k ] ); 110
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 111
if ( octet1 == 0x41 )  113
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , new_slots [ k ] ); 116
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 117
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 123
proto_item_set_end ( item , tvb , offset ); 126
item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ); 129
sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ); 130
for (k=0; offset<len; j++) 131
while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) )  133
octet1 = tvb_get_guint8 ( tvb , offset ); 140
if ( ( octet1 & 0x80 ) == 0x80 )  141
if ( ( offset + 1 ) < len )  143
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 149
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 150
other_slots [ k ] = msg_id; 151
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message: %d, First transmission of an SMSCB within the Schedule Period" , ++ k , msg_id ); 152
offset += 2; 155
if ( ( octet1 & 0xC0 ) == 0 )  158
if ( octet1 < k )  161
other_slots [ k ] = other_slots [ octet1 - 1 ]; 163
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , ++ k , other_slots [ octet1 - 1 ] , octet1 ); 164
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , ++ k , octet1 ); 170
if ( octet1 == 0x40 )  175
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , ++ k ); 178
if ( octet1 == 0x41 )  180
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , ++ k ); 183
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , ++ k , octet1 ); 188
proto_item_set_end ( item , tvb , offset ); 191
proto_tree_add_text ( sched_tree , tvb , offset , - 1 , "Padding" ); 192
------------------------------
189 /home/SySeVR/data/CVE_2013_4079_VULN_dissect_schedule_message.c [u'sched_end', u'new_slots', u'len', u'sched_begin'] 5
static void
CVE_2013_4079_VULN_dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree) 2
guint8 len , sched_begin , sched_end , new_slots [ 48 ] ; 5
len = tvb_length ( tvb ); 12
schedule_item = proto_tree_add_protocol_format ( top_tree , proto_cbch , tvb , 0 , len , "GSM CBCH Schedule Message" ); 16
sched_tree = proto_item_add_subtree ( schedule_item , ett_schedule_msg ); 19
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_type , tvb , offset , 1 , ENC_BIG_ENDIAN ); 21
sched_begin = octet1 & 0x3F; 25
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_begin_slot , tvb , offset ++ , 1 , ENC_BIG_ENDIAN ); 26
if ( 1 == sched_begin )  27
proto_tree_add_text ( sched_tree , tvb , offset - 1 , 1 , "(apparently) Scheduled Scheduling Message" ); 29
if ( ( 2 <= sched_begin ) && ( 48 >= sched_begin ) )  31
proto_tree_add_text ( sched_tree , tvb , offset - 1 , 1 , "(apparently) Unscheduled Scheduling Message" ); 33
proto_tree_add_text ( sched_tree , tvb , offset - 1 , 1 , "Begin Slot Number out of range: ignoring message" ); 37
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_spare , tvb , offset , 1 , ENC_BIG_ENDIAN ); 40
sched_end = tvb_get_guint8 ( tvb , offset ); 41
proto_tree_add_item ( sched_tree , hf_gsm_cbch_sched_end_slot , tvb , offset ++ , 1 , ENC_BIG_ENDIAN ); 42
if ( sched_end < sched_begin )  43
proto_tree_add_text ( sched_tree , tvb , offset - 1 , 1 , "End Slot Number less than Begin Slot Number: ignoring message" ); 45
memset ( & new_slots , 0xFF , sizeof ( new_slots ) ); 52
octet1 = tvb_get_guint8 ( tvb , offset ++ ); 58
if ( octet1 & ( 0x80 >> j ) )  63
new_slots [ k ++ ] = ( i << 3 ) + j + 1; 65
item = proto_tree_add_text ( sched_tree , tvb , offset - 6 , 6 , "This schedule contains %d slots with new messages" , k ); 70
sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ); 71
for (i=0; i<k; i++) 72
DISSECTOR_ASSERT ( new_slots [ i ] < 48 ); 74
octet1 = tvb_get_guint8 ( tvb , offset ); 75
if ( ( octet1 & 0x80 ) == 0x80 )  76
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 82
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 83
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message ID: %d, First transmission of an SMSCB within the Schedule Period" , new_slots [ i ] , msg_id ); 84
offset += 2; 87
other_slots [ new_slots [ i ] - 1 ] = msg_id; 88
if ( ( octet1 & 0xC0 ) == 0 )  90
if ( octet1 < new_slots [ i ] )  93
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , new_slots [ i ] , other_slots [ octet1 - 1 ] , octet1 ); 95
other_slots [ new_slots [ i ] - 1 ] = other_slots [ octet1 - 1 ]; 98
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , new_slots [ i ] , octet1 ); 102
if ( octet1 == 0x40 )  107
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , new_slots [ k ] ); 110
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 111
if ( octet1 == 0x41 )  113
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , new_slots [ k ] ); 116
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 117
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , new_slots [ k ] , octet1 ); 122
other_slots [ new_slots [ i ] - 1 ] = 0xFFFE; 123
proto_item_set_end ( item , tvb , offset ); 126
item = proto_tree_add_text ( sched_tree , tvb , offset , 0 , "Other message slots in this schedule" ); 129
sched_subtree = proto_item_add_subtree ( item , ett_schedule_new_msg ); 130
for (k=0; offset<len; j++) 131
while ( ( other_slots [ k ] != 0xFFFF ) && ( k < sched_end ) )  133
k ++; 135
if ( k >= sched_end )  137
octet1 = tvb_get_guint8 ( tvb , offset ); 140
if ( ( octet1 & 0x80 ) == 0x80 )  141
if ( ( offset + 1 ) < len )  143
octet2 = tvb_get_guint8 ( tvb , offset + 1 ); 149
msg_id = ( ( octet1 & 0x7F ) << 8 ) + octet2; 150
other_slots [ k ] = msg_id; 151
proto_tree_add_text ( sched_subtree , tvb , offset , 2 , "Slot: %d, Message: %d, First transmission of an SMSCB within the Schedule Period" , ++ k , msg_id ); 152
offset += 2; 155
if ( ( octet1 & 0xC0 ) == 0 )  158
if ( octet1 < k )  161
other_slots [ k ] = other_slots [ octet1 - 1 ]; 163
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Message ID: %d, Repeat of Slot %d" , ++ k , other_slots [ octet1 - 1 ] , octet1 ); 164
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d, Apparent forward reference to slot %d" , ++ k , octet1 ); 170
if ( octet1 == 0x40 )  175
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, optional reading" , ++ k ); 178
if ( octet1 == 0x41 )  180
proto_tree_add_text ( sched_subtree , tvb , offset ++ , 1 , "Slot: %d Free Message Slot, reading advised" , ++ k ); 183
proto_tree_add_text ( sched_subtree , tvb , offset , 1 , "Slot: %d reserved MDT: %x" , ++ k , octet1 ); 188
proto_item_set_end ( item , tvb , offset ); 191
proto_tree_add_text ( sched_tree , tvb , offset , - 1 , "Padding" ); 192
------------------------------
190 /home/SySeVR/data/CVE_2013_4082_VULN_vwr_read.c [u'rec'] 4
static gboolean CVE_2013_4082_VULN_vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) 1
guint8 rec [ B_SIZE ] ; 4
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )  17
vwr_read_rec_data ( wth , data_ptr , rec , rec_size ); 40
vwr_read_rec_data_vVW510021 ( wth , data_ptr , rec , rec_size , IS_TX ); 43
vwr_read_rec_data_ethernet ( wth , data_ptr , rec , rec_size , IS_TX ); 46
vwr_read_rec_data_ethernet ( wth , data_ptr , rec , rec_size , IS_TX ); 49
------------------------------
191 /home/SySeVR/data/CVE_2013_4512_VULN_exitcode_proc_write.c [u'end', u'buf'] 4
static ssize_t CVE_2013_4512_VULN_exitcode_proc_write(struct file *file,
const char __user *buffer, size_t count, loff_t *pos) 2
char * end , buf [ sizeof ( "nnnnn\0" ) ] ; 4
if ( copy_from_user ( buf , buffer , count ) )  7
tmp = simple_strtol ( buf , & end , 0 ); 10
if ( ( * end != '\0' ) && ! isspace ( * end ) )  11
uml_exitcode = tmp; 14
------------------------------
192 /home/SySeVR/data/CVE_2013_4534_VULN_openpic_realize.c [u'list_fsl'] 29
static void CVE_2013_4534_VULN_openpic_realize(DeviceState *dev, Error **errp) 1
static const MemReg list_fsl [ ] = { { "msi" , & openpic_msi_ops_be , OPENPIC_MSI_REG_START , OPENPIC_MSI_REG_SIZE } , { "summary" , & openpic_summary_ops_be , OPENPIC_SUMMARY_REG_START , OPENPIC_SUMMARY_REG_SIZE } , { NULL } } ; 29
map_list ( opp , list_fsl , & list_count ); 48
map_list ( opp , list_fsl , & list_count ); 61
------------------------------
193 /home/SySeVR/data/CVE_2013_4534_VULN_openpic_realize.c [u'list_be'] 18
static void CVE_2013_4534_VULN_openpic_realize(DeviceState *dev, Error **errp) 1
static const MemReg list_be [ ] = { { "glb" , & openpic_glb_ops_be , OPENPIC_GLB_REG_START , OPENPIC_GLB_REG_SIZE } , { "tmr" , & openpic_tmr_ops_be , OPENPIC_TMR_REG_START , OPENPIC_TMR_REG_SIZE } , { "src" , & openpic_src_ops_be , OPENPIC_SRC_REG_START , OPENPIC_SRC_REG_SIZE } , { "cpu" , & openpic_cpu_ops_be , OPENPIC_CPU_REG_START , OPENPIC_CPU_REG_SIZE } , { NULL } } ; 18
map_list ( opp , list_be , & list_count ); 47
map_list ( opp , list_be , & list_count ); 60
------------------------------
194 /home/SySeVR/data/CVE_2013_4534_VULN_openpic_realize.c [u'list_le'] 7
static void CVE_2013_4534_VULN_openpic_realize(DeviceState *dev, Error **errp) 1
static const MemReg list_le [ ] = { { "glb" , & openpic_glb_ops_le , OPENPIC_GLB_REG_START , OPENPIC_GLB_REG_SIZE } , { "tmr" , & openpic_tmr_ops_le , OPENPIC_TMR_REG_START , OPENPIC_TMR_REG_SIZE } , { "src" , & openpic_src_ops_le , OPENPIC_SRC_REG_START , OPENPIC_SRC_REG_SIZE } , { "cpu" , & openpic_cpu_ops_le , OPENPIC_CPU_REG_START , OPENPIC_CPU_REG_SIZE } , { NULL } } ; 7
map_list ( opp , list_le , & list_count ); 84
------------------------------
195 /home/SySeVR/data/CVE_2013_4928_PATCHED_dissect_headers.c [u'key'] 115
static int
CVE_2013_4928_PATCHED_dissect_headers(proto_tree *tree, tvbuff_t *tvb, int offset, packet_info *pinfo,
gint profile, gboolean is_obex_over_l2cap) 3
gint item_length = - 1 ; 9
gint parameters_length ; 10
guint8 hdr_id , i ; 11
if ( tvb_length_remaining ( tvb , offset ) > 0 )  13
proto_item * hdrs ; 14
hdrs = proto_tree_add_text ( tree , tvb , offset , item_length , "Headers" ); 15
hdrs_tree = proto_item_add_subtree ( hdrs , ett_btobex_hdrs ); 16
while ( tvb_length_remaining ( tvb , offset ) > 0 )  22
hdr_id = tvb_get_guint8 ( tvb , offset ); 23
switch ( 0xC0 & hdr_id )  25
item_length = tvb_get_ntohs ( tvb , offset + 1 ); 28
item_length = tvb_get_ntohs ( tvb , offset + 1 ); 31
item_length = 2; 34
item_length = 5; 37
hdr = proto_tree_add_text ( hdrs_tree , tvb , offset , item_length , "%s" , val_to_str_ext_const ( hdr_id , & header_id_vals_ext , "Unknown" ) ); 41
hdr_tree = proto_item_add_subtree ( hdr , ett_btobex_hdr ); 43
offset ++; 47
switch ( 0xC0 & hdr_id )  49
offset += 2; 54
if ( item_length > 3 )  56
offset += item_length - 3; 63
if ( hdr_id == 0x4C )  71
parameters_length = tvb_get_ntohs ( tvb , offset ) - 3; 74
offset += 2; 75
switch ( profile )  77
offset = dissect_bpp_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 79
offset = dissect_bip_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 82
offset = dissect_pbap_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 85
offset = dissect_map_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 88
offset = dissect_raw_application_parameters ( tvb , hdr_tree , offset , parameters_length ); 91
offset += 2; 98
if ( ( ( hdr_id == 0x46 ) || ( hdr_id == 0x4a ) ) && ( item_length == 19 ) )  102
for(i=0; target_vals[i].strptr != NULL; i++) 103
if ( tvb_memeql ( tvb , offset , target_vals [ i ] . value , target_vals [ i ] . length ) == 0 )  104
if ( ! pinfo -> fd -> flags . visited )  109
emem_tree_key_t key [ 6 ] ; 115
key [ 0 ] . length = 1; 146
key [ 0 ] . key = & k_interface_id; 147
key [ 1 ] . length = 1; 148
key [ 1 ] . key = & k_adapter_id; 149
key [ 2 ] . length = 1; 150
key [ 2 ] . key = & k_chandle; 151
key [ 3 ] . length = 1; 152
key [ 3 ] . key = & k_channel; 153
key [ 4 ] . length = 1; 154
key [ 4 ] . key = & k_frame_number; 155
key [ 5 ] . length = 0; 156
key [ 5 ] . key = NULL; 157
se_tree_insert32_array ( obex_profile , key , obex_profile_data ); 166
if ( item_length >= 3 )  184
offset += item_length - 3; 185
offset ++; 190
offset += 4; 195
------------------------------
196 /home/SySeVR/data/CVE_2013_4928_VULN_dissect_headers.c [u'key'] 116
static int
CVE_2013_4928_VULN_dissect_headers(proto_tree *tree, tvbuff_t *tvb, int offset, packet_info *pinfo,
gint profile, gboolean is_obex_over_l2cap) 3
gint item_length = - 1 ; 9
gint parameters_length ; 10
guint8 hdr_id , i ; 11
if ( tvb_length_remaining ( tvb , offset ) > 0 )  13
proto_item * hdrs ; 14
hdrs = proto_tree_add_text ( tree , tvb , offset , item_length , "Headers" ); 15
hdrs_tree = proto_item_add_subtree ( hdrs , ett_btobex_hdrs ); 16
while ( tvb_length_remaining ( tvb , offset ) > 0 )  22
hdr_id = tvb_get_guint8 ( tvb , offset ); 23
switch ( 0xC0 & hdr_id )  25
item_length = tvb_get_ntohs ( tvb , offset + 1 ); 28
item_length = tvb_get_ntohs ( tvb , offset + 1 ); 31
item_length = 2; 34
item_length = 5; 37
hdr = proto_tree_add_text ( hdrs_tree , tvb , offset , item_length , "%s" , val_to_str_ext_const ( hdr_id , & header_id_vals_ext , "Unknown" ) ); 41
hdr_tree = proto_item_add_subtree ( hdr , ett_btobex_hdr ); 43
offset ++; 47
switch ( 0xC0 & hdr_id )  49
offset += 2; 54
offset += item_length - 3; 68
if ( hdr_id == 0x4C )  72
parameters_length = tvb_get_ntohs ( tvb , offset ) - 3; 75
offset += 2; 76
switch ( profile )  78
offset = dissect_bpp_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 80
offset = dissect_bip_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 83
offset = dissect_pbap_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 86
offset = dissect_map_application_parameters ( tvb , pinfo , hdr_tree , offset , parameters_length ); 89
offset = dissect_raw_application_parameters ( tvb , hdr_tree , offset , parameters_length ); 92
offset += 2; 99
if ( ( ( hdr_id == 0x46 ) || ( hdr_id == 0x4a ) ) && ( item_length == 19 ) )  103
for(i=0; target_vals[i].strptr != NULL; i++) 104
if ( tvb_memeql ( tvb , offset , target_vals [ i ] . value , target_vals [ i ] . length ) == 0 )  105
if ( ! pinfo -> fd -> flags . visited )  110
emem_tree_key_t key [ 6 ] ; 116
key [ 0 ] . length = 1; 147
key [ 0 ] . key = & k_interface_id; 148
key [ 1 ] . length = 1; 149
key [ 1 ] . key = & k_adapter_id; 150
key [ 2 ] . length = 1; 151
key [ 2 ] . key = & k_chandle; 152
key [ 3 ] . length = 1; 153
key [ 3 ] . key = & k_channel; 154
key [ 4 ] . length = 1; 155
key [ 4 ] . key = & k_frame_number; 156
key [ 5 ] . length = 0; 157
key [ 5 ] . key = NULL; 158
se_tree_insert32_array ( obex_profile , key , obex_profile_data ); 167
offset += item_length - 3; 185
offset ++; 190
offset += 4; 195
------------------------------
197 /home/SySeVR/data/CVE_2013_4932_PATCHED_elem_tv_short.c [u'buf'] 12
guint16 CVE_2013_4932_PATCHED_elem_tv_short(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint8 iei, gint pdu_type, int idx, guint32 offset, const gchar *name_add) 1
char buf [ 10 + 1 ] ; 12
other_decode_bitfield_value ( buf , oct , 0xf0 , 8 ); 37
proto_tree_add_text ( subtree , tvb , curr_offset , 1 , "%s = Element ID: 0x%1x-" , buf , oct >> 4 ); 38
------------------------------
198 /home/SySeVR/data/CVE_2013_4933_PATCHED_netmon_open.c [u'magic'] 4
int CVE_2013_4933_PATCHED_netmon_open(wtap *wth, int *err, gchar **err_info) 1
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
if ( bytes_read != sizeof hdr )  36
if ( ( guint32 ) bytes_read != frame_table_length )  174
------------------------------
199 /home/SySeVR/data/CVE_2013_4933_VULN_netmon_open.c [u'magic'] 4
int CVE_2013_4933_VULN_netmon_open(wtap *wth, int *err, gchar **err_info) 1
char magic [ MAGIC_SIZE ] ; 4
bytes_read = file_read ( magic , MAGIC_SIZE , wth -> fh ); 20
if ( bytes_read != MAGIC_SIZE )  21
if ( memcmp ( magic , netmon_1_x_magic , MAGIC_SIZE ) != 0 && memcmp ( magic , netmon_2_x_magic , MAGIC_SIZE ) != 0 )  28
if ( bytes_read != sizeof hdr )  36
if ( ( guint32 ) bytes_read != frame_table_length )  170
------------------------------
200 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c [u'totag'] 184
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
cmd = REQ_OFFSET_TO_STR ( req , rlpart1 ); 49
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
snprintf ( p -> lastmsg , sizeof ( p -> lastmsg ) , "Rx: %s" , cmd ); 168
if ( sip_cfg . pedanticsipchecking )  170
if ( ! p -> initreq . headers && req -> has_to_tag )  175
if ( ! req -> ignore && req -> method == SIP_INVITE )  177
char totag [ 128 ] ; 184
gettag ( req , "To" , totag , sizeof ( totag ) ); 185
ast_string_field_set ( p , tag , totag ); 186
------------------------------
201 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c [u'tag'] 163
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( p -> icseq && p -> icseq == seqno && req -> method != SIP_ACK && ( p -> method != SIP_CANCEL || p -> alreadygone ) )  137
req -> ignore = 1; 144
if ( ! p -> pendinginvite && ( req -> method == SIP_CANCEL ) )  150
if ( seqno >= p -> icseq )  155
p -> icseq = seqno; 159
if ( ast_strlen_zero ( p -> theirtag ) )  162
char tag [ 128 ] ; 163
gettag ( req , "From" , tag , sizeof ( tag ) ); 165
ast_string_field_set ( p , theirtag , tag ); 166
ast_string_field_set ( p , tag , totag ); 186
------------------------------
202 /home/SySeVR/data/CVE_2013_5641_PATCHED_handle_incoming.c [u'seconds'] 129
static int CVE_2013_5641_PATCHED_handle_incoming(struct sip_pvt *p, struct sip_request *req, struct ast_sockaddr *addr, int *recount, int *nounlock) 3
const char * cmd ; 7
const char * cseq ; 8
const char * via ; 10
uint32_t seqno ; 13
int len ; 14
int error = 0 ; 18
cseq = sip_get_header ( req , "Cseq" ); 25
cmd = REQ_OFFSET_TO_STR ( req , header [ 0 ] ); 26
via = __get_header ( req , "Via" , & via_pos ); 28
if ( ast_strlen_zero ( cmd ) || ast_strlen_zero ( cseq ) || ast_strlen_zero ( via ) )  33
error = 1; 35
if ( ! error && sscanf ( cseq , "%30u%n" , & seqno , & len ) != 1 )  37
error = 1; 39
if ( error )  41
if ( req -> method == SIP_RESPONSE )  58
p -> method = req -> method; 119
if ( p -> icseq && ( p -> icseq > seqno ) )  122
if ( p -> pendinginvite && seqno == p -> pendinginvite && ( req -> method == SIP_ACK || req -> method == SIP_CANCEL ) )  123
if ( req -> method == SIP_INVITE )  127
char seconds [ 4 ] ; 129
snprintf ( seconds , sizeof ( seconds ) , "%u" , ran ); 130
transmit_response_with_retry_after ( p , "500 Server error" , req , seconds ); 131
------------------------------
203 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c [u's2', u's1'] 699
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; 37
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
int newnoncodeccapability ; 42
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
int debug = sip_debug_test_pvt ( p ) ; 59
struct ast_format tmp_fmt ; 63
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; 501
if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  525
p -> jointnoncodeccapability = newnoncodeccapability; 530
if ( p -> trtp )  604
if ( tportno > 0 )  605
if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  612
p -> red = 1; 613
p -> red = 0; 616
if ( ( portno == - 1 ) && ( p -> t38 . state != T38_DISABLED ) && ( p -> t38 . state != T38_REJECTED ) )  682
if ( ! p -> owner )  691
if ( ast_format_cap_has_type ( p -> jointcaps , AST_FORMAT_TYPE_AUDIO ) )  697
if ( debug )  698
char s1 [ SIPBUFSIZE ] , s2 [ SIPBUFSIZE ] ; 699
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
------------------------------
204 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c [u's5', u's4', u's3', u's2', u's1'] 505
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int start = req -> sdp_start ; 6
int next = start ; 7
const char * value = NULL ; 12
struct ast_sockaddr sessionsa ; 18
struct ast_sockaddr audiosa ; 19
struct ast_sockaddr videosa ; 20
struct ast_sockaddr textsa ; 21
struct ast_sockaddr imagesa ; 22
struct ast_sockaddr * sa = NULL ; 23
struct ast_sockaddr * vsa = NULL ; 24
struct ast_sockaddr * tsa = NULL ; 25
struct ast_sockaddr * isa = NULL ; 26
int portno = - 1 ; 27
int vportno = - 1 ; 28
int tportno = - 1 ; 29
int udptlportno = - 1 ; 30
struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; 33
struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; 34
struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; 35
struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; 39
struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; 40
struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; 41
const char * codecs ; 44
int codec ; 45
int secure_audio = FALSE ; 48
int secure_video = FALSE ; 49
int numberofports ; 53
int numberofmediastreams = 0 ; 54
int red_data_pt [ 10 ] ; 56
char red_fmtp [ 100 ] = "empty" ; 58
int debug = sip_debug_test_pvt ( p ) ; 59
if ( ! p -> rtp )  67
if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  72
p -> lastrtprx = p -> lastrtptx = time ( NULL ); 83
memset ( p -> offered_media , 0 , sizeof ( p -> offered_media ) ); 85
nextm = get_sdp_iterate ( & next , req , "m" ); 88
if ( ast_strlen_zero ( nextm ) )  89
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  96
switch ( type )  98
if ( ! process_sdp_o ( value , p ) )  103
if ( process_sdp_c ( value , & sessionsa ) )  110
sa = & sessionsa; 112
vsa = sa; 113
tsa = sa; 114
isa = sa; 115
p -> novideo = TRUE; 137
p -> notext = TRUE; 138
while ( ! ast_strlen_zero ( nextm ) )  141
int audio = FALSE ; 142
int video = FALSE ; 143
int image = FALSE ; 144
int text = FALSE ; 145
int processed_crypto = FALSE ; 146
char protocol [ 5 ] = 0 , 147
int x ; 148
numberofports = 0; 150
len = - 1; 151
m = nextm; 153
iterator = next; 154
nextm = get_sdp_iterate ( & next , req , "m" ); 155
if ( strncmp ( m , "audio " , 6 ) == 0 )  158
if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  159
if ( x == 0 )  161
if ( ! strcmp ( protocol , "SAVP" ) )  171
secure_audio = 1; 172
if ( strcmp ( protocol , "AVP" ) )  173
if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  178
audio = TRUE; 184
p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; 185
portno = x; 186
codecs = m + len; 189
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 191
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  192
if ( strncmp ( m , "video " , 6 ) == 0 )  210
if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  211
if ( x == 0 )  213
if ( ! strcmp ( protocol , "SAVP" ) )  223
secure_video = 1; 224
if ( strcmp ( protocol , "AVP" ) )  225
if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  230
video = TRUE; 236
p -> novideo = FALSE; 237
p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; 238
vportno = x; 239
codecs = m + len; 242
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 244
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  245
if ( strncmp ( m , "text " , 5 ) == 0 )  262
if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  263
if ( x == 0 )  265
if ( p -> offered_media [ SDP_TEXT ] . order_offered )  275
text = TRUE; 281
p -> notext = FALSE; 282
p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; 283
tportno = x; 284
codecs = m + len; 287
for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) 289
if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  290
if ( strncmp ( m , "image " , 6 ) == 0 )  307
if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  308
if ( x == 0 )  310
if ( initialize_udptl ( p ) )  315
if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  321
image = TRUE; 327
p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; 332
udptlportno = x; 333
while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  353
switch ( type )  356
if ( audio )  358
if ( process_sdp_c ( value , & audiosa ) )  359
sa = & audiosa; 361
if ( video )  363
if ( process_sdp_c ( value , & videosa ) )  364
vsa = & videosa; 366
if ( text )  368
if ( process_sdp_c ( value , & textsa ) )  369
tsa = & textsa; 371
if ( image )  373
if ( process_sdp_c ( value , & imagesa ) )  374
isa = & imagesa; 376
if ( audio )  382
if ( process_sdp_a_sendonly ( value , & sendonly ) )  383
if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  385
processed_crypto = TRUE; 386
if ( video )  393
if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  394
processed_crypto = TRUE; 395
if ( text )  402
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  405
processed_crypto = TRUE; 406
if ( audio && secure_audio && ! processed_crypto )  425
if ( video && secure_video && ! processed_crypto )  428
if ( ! sa && ! vsa && ! tsa && ! isa )  435
if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  441
if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  450
if ( ! secure_audio && p -> srtp )  456
if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  462
if ( ! p -> novideo && ! secure_video && p -> vsrtp )  468
if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  474
if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  494
if ( debug )  503
char s1 [ SIPBUFSIZE ] , s2 [ SIPBUFSIZE ] , s3 [ SIPBUFSIZE ] , s4 [ SIPBUFSIZE ] , s5 [ SIPBUFSIZE ] ; 505
ast_verbose ( "Capabilities: us - %s, peer - audio=%s/video=%s/text=%s, combined - %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> caps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , peercapability ) , ast_getformatname_multiple ( s3 , SIPBUFSIZE , vpeercapability ) , ast_getformatname_multiple ( s4 , SIPBUFSIZE , tpeercapability ) , ast_getformatname_multiple ( s5 , SIPBUFSIZE , newjointcapability ) ); 507
ast_verbose ( "Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n" , ast_rtp_lookup_mime_multiple2 ( s1 , NULL , p -> noncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s2 , NULL , peernoncodeccapability , 0 , 0 ) , ast_rtp_lookup_mime_multiple2 ( s3 , NULL , newnoncodeccapability , 0 , 0 ) ); 519
ast_debug ( 1 , "Setting native formats after processing SDP. peer joint formats %s, old nativeformats %s\n" , ast_getformatname_multiple ( s1 , SIPBUFSIZE , p -> jointcaps ) , ast_getformatname_multiple ( s2 , SIPBUFSIZE , p -> owner -> nativeformats ) ); 700
------------------------------
205 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c [u'buf'] 62
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
char buf [ SIPBUFSIZE ] ; 62
ast_debug ( 2 , "We're settling with these formats: %s\n" , ast_getformatname_multiple ( buf , SIPBUFSIZE , p -> jointcaps ) ); 689
------------------------------
206 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c [u'red_fmtp'] 58
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
char red_fmtp [ 100 ] = "empty" ; 58
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
------------------------------
207 /home/SySeVR/data/CVE_2013_5642_VULN_process_sdp.c [u'red_data_pt'] 56
static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) 1
int red_data_pt [ 10 ] ; 56
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  126
if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  403
ast_rtp_red_init ( p -> trtp , 300 , red_data_pt , 2 ); 614
------------------------------
208 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c [u'sg_list'] 15
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void * sg_list [ 32 ] ; 15
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  95
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  238
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 247
if ( ! p )  248
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 254
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 255
sg_user [ i ] = ( void __user * ) addr; 256
sg_list [ i ] = p; 257
sg_indx = i; 258
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  261
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 267
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 269
byte_count += usg -> sg [ i ] . count; 270
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 271
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  277
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 285
if ( ! p )  286
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 292
sg_list [ i ] = p; 293
sg_indx = i; 294
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  297
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 304
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 307
byte_count += upsg -> sg [ i ] . count; 308
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 309
srbcmd -> count = cpu_to_le32 ( byte_count ); 312
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 313
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
------------------------------
209 /home/SySeVR/data/CVE_2013_6380_PATCHED_aac_send_raw_srb.c [u'sg_user'] 14
static int CVE_2013_6380_PATCHED_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void __user * sg_user [ 32 ] ; 14
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  135
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 144
if ( ! p )  145
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 151
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 152
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 153
sg_list [ i ] = p; 154
sg_indx = i; 155
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  158
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 164
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 166
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 167
byte_count += upsg -> sg [ i ] . count; 168
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 169
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  187
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 197
if ( ! p )  198
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 205
sg_list [ i ] = p; 206
sg_indx = i; 207
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  210
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 217
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 219
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 220
byte_count += usg -> sg [ i ] . count; 221
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 222
srbcmd -> count = cpu_to_le32 ( byte_count ); 226
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 227
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  238
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 247
if ( ! p )  248
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 254
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 255
sg_user [ i ] = ( void __user * ) addr; 256
sg_list [ i ] = p; 257
sg_indx = i; 258
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  261
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 267
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 269
byte_count += usg -> sg [ i ] . count; 270
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 271
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  277
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 285
if ( ! p )  286
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 292
sg_list [ i ] = p; 293
sg_indx = i; 294
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  297
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 304
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 307
byte_count += upsg -> sg [ i ] . count; 308
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 309
srbcmd -> count = cpu_to_le32 ( byte_count ); 312
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 313
for(i = 0 ; i <= sg_indx; i++) 328
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 329
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  333
for(i=0; i <= sg_indx; i++) 351
kfree ( sg_list [ i ] ); 352
------------------------------
210 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c [u'sg_list'] 15
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void * sg_list [ 32 ] ; 15
memset ( sg_list , 0 , sizeof ( sg_list ) ); 42
if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  94
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  134
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 143
if ( ! p )  144
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 150
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 151
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 152
sg_list [ i ] = p; 153
sg_indx = i; 154
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  157
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 163
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 165
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 166
byte_count += upsg -> sg [ i ] . count; 167
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 168
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  237
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 246
if ( ! p )  247
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 253
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 254
sg_user [ i ] = ( void __user * ) addr; 255
sg_list [ i ] = p; 256
sg_indx = i; 257
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  260
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 266
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 268
byte_count += usg -> sg [ i ] . count; 269
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 270
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  276
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 284
if ( ! p )  285
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 291
sg_list [ i ] = p; 292
sg_indx = i; 293
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  296
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 303
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 306
byte_count += upsg -> sg [ i ] . count; 307
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 308
srbcmd -> count = cpu_to_le32 ( byte_count ); 311
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 312
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
------------------------------
211 /home/SySeVR/data/CVE_2013_6380_VULN_aac_send_raw_srb.c [u'sg_user'] 14
static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) 1
void __user * sg_user [ 32 ] ; 14
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  134
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 143
if ( ! p )  144
addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ]; 150
addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32; 151
sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr; 152
sg_list [ i ] = p; 153
sg_indx = i; 154
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  157
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 163
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 165
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 166
byte_count += upsg -> sg [ i ] . count; 167
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 168
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  186
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 196
if ( ! p )  197
sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; 204
sg_list [ i ] = p; 205
sg_indx = i; 206
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  209
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 216
psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); 218
psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); 219
byte_count += usg -> sg [ i ] . count; 220
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 221
srbcmd -> count = cpu_to_le32 ( byte_count ); 225
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 226
if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  237
p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); 246
if ( ! p )  247
addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ]; 253
addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32; 254
sg_user [ i ] = ( void __user * ) addr; 255
sg_list [ i ] = p; 256
sg_indx = i; 257
if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) )  260
addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); 266
psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ); 268
byte_count += usg -> sg [ i ] . count; 269
psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); 270
if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  276
p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ); 284
if ( ! p )  285
sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr; 291
sg_list [ i ] = p; 292
sg_indx = i; 293
if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  296
addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ); 303
psg -> sg [ i ] . addr = cpu_to_le32 ( addr ); 306
byte_count += upsg -> sg [ i ] . count; 307
psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ); 308
srbcmd -> count = cpu_to_le32 ( byte_count ); 311
psg -> count = cpu_to_le32 ( sg_indx + 1 ); 312
for(i = 0 ; i <= sg_indx; i++) 327
byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); 328
if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  332
for(i=0; i <= sg_indx; i++) 350
kfree ( sg_list [ i ] ); 351
------------------------------
212 /home/SySeVR/data/CVE_2013_6671_PATCHED_nsHtml5TreeOperation__Perform.c [u'params'] 562
nsresult
CVE_2013_6671_PATCHED_nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
nsIContent** aScriptElement) 3
switch ( mOpCode )  6
nsCOMPtr < nsIAtom > atom = Reget ( mThree . atom ) ; 539
nsCOMPtr < nsIAtom > otherAtom = Reget ( mFour . atom ) ; 540
if ( otherAtom )  555
if ( atom )  561
const PRUnichar * params [ ] = { atom -> GetUTF16String ( ) } ; 562
rv = nsContentUtils :: FormatLocalizedString ( nsContentUtils :: eHTMLPARSER_PROPERTIES , msgId , params , message ); 563
NS_ENSURE_SUCCESS ( rv , rv ); 565
return rv ; 581
return rv ; 587
------------------------------
213 /home/SySeVR/data/CVE_2013_6671_PATCHED_nsHtml5TreeOperation__Perform.c [u'params'] 556
nsresult
CVE_2013_6671_PATCHED_nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
nsIContent** aScriptElement) 3
switch ( mOpCode )  6
nsCOMPtr < nsIAtom > atom = Reget ( mThree . atom ) ; 539
nsCOMPtr < nsIAtom > otherAtom = Reget ( mFour . atom ) ; 540
if ( otherAtom )  555
const PRUnichar * params [ ] = { atom -> GetUTF16String ( ) , otherAtom -> GetUTF16String ( ) } ; 556
rv = nsContentUtils :: FormatLocalizedString ( nsContentUtils :: eHTMLPARSER_PROPERTIES , msgId , params , message ); 558
NS_ENSURE_SUCCESS ( rv , rv ); 560
return rv ; 581
return rv ; 587
------------------------------
214 /home/SySeVR/data/CVE_2013_7009_VULN_rpza_decode_stream.c [u'color4'] 11
static void CVE_2013_7009_VULN_rpza_decode_stream(RpzaContext *s) 1
unsigned short color4 [ 4 ] ; 11
color4 [ 0 ] = colorB; 94
color4 [ 1 ] = 0; 95
color4 [ 2 ] = 0; 96
color4 [ 3 ] = colorA; 97
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10; 102
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10; 103
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5; 108
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5; 109
color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ); 114
color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ); 115
pixels [ block_ptr ] = color4 [ idx ]; 125
block_ptr ++; 126
block_ptr += row_inc; 128
pixels [ block_ptr ] = colorA; 146
block_ptr ++; 147
block_ptr += row_inc; 149
------------------------------
215 /home/SySeVR/data/CVE_2013_7011_VULN_read_header.c [u'state'] 3
static int CVE_2013_7011_VULN_read_header(FFV1Context *f) 1
uint8_t state [ CONTEXT_SIZE ] ; 3
memset ( state , 128 , sizeof ( state ) ); 7
unsigned v = get_symbol ( c , state , 0 ) ; 10
if ( v >= 2 )  11
av_log ( f -> avctx , AV_LOG_ERROR , "invalid version %d in ver01 header\n" , v ); 12
f -> version = v; 15
f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ); 16
if ( f -> ac > 1 )  17
f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ]; 19
f -> colorspace = get_symbol ( c , state , 0 ); 22
if ( f -> version > 0 )  24
f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ); 25
f -> chroma_planes = get_rac ( c , state ); 27
f -> chroma_h_shift = get_symbol ( c , state , 0 ); 28
f -> chroma_v_shift = get_symbol ( c , state , 0 ); 29
f -> transparency = get_rac ( c , state ); 30
f -> plane_count = 2 + f -> transparency; 31
if ( f -> colorspace == 0 )  34
if ( ! f -> transparency && ! f -> chroma_planes )  35
if ( f -> avctx -> bits_per_raw_sample <= 8 )  36
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 37
f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 39
if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency )  40
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  41
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P; 42
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P; 43
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P; 44
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P; 45
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P; 46
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P; 47
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 49
if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency )  52
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  53
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 54
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P; 55
f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 56
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 58
if ( f -> avctx -> bits_per_raw_sample == 9 )  61
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  63
if ( f -> avctx -> bits_per_raw_sample == 10 )  71
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  73
switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift )  82
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 83
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 84
f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 85
av_log ( f -> avctx , AV_LOG_ERROR , "format not supported\n" ); 87
if ( f -> colorspace == 1 )  91
if ( f -> chroma_h_shift || f -> chroma_v_shift )  92
av_log ( f -> avctx , AV_LOG_ERROR , "chroma subsampling not supported in this colorspace\n" ); 93
if ( f -> avctx -> bits_per_raw_sample == 9 )  97
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9; 98
if ( f -> avctx -> bits_per_raw_sample == 10 )  99
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10; 100
if ( f -> avctx -> bits_per_raw_sample == 12 )  101
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12; 102
if ( f -> avctx -> bits_per_raw_sample == 14 )  103
f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14; 104
if ( f -> transparency )  106
f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32; 106
f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32; 107
av_log ( f -> avctx , AV_LOG_ERROR , "colorspace not supported\n" ); 109
av_dlog ( f -> avctx , "%d %d %d\n" , f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ); 113
if ( f -> version < 2 )  115
context_count = read_quant_tables ( c , f -> quant_table ); 116
if ( context_count < 0 )  117
av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table error\n" ); 118
if ( f -> version < 3 )  121
f -> slice_count = get_symbol ( c , state , 0 ); 122
if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 )  135
av_log ( f -> avctx , AV_LOG_ERROR , "slice count %d is invalid\n" , f -> slice_count ); 136
for (j = 0; j < f->slice_count; j++) 140
FFV1Context * fs = f -> slice_context [ j ] ; 141
fs -> ac = f -> ac; 142
fs -> packed_at_lsb = f -> packed_at_lsb; 143
fs -> slice_damaged = 0; 145
if ( f -> version == 2 )  147
fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width; 148
fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height; 149
fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x; 150
fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y; 151
fs -> slice_x /= f -> num_h_slices; 153
fs -> slice_y /= f -> num_v_slices; 154
fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x; 155
fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y; 156
if ( ( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height )  157
if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height )  160
for (i = 0; i < f->plane_count; i++) 165
PlaneContext * const p = & fs -> plane [ i ] 166
if ( f -> version == 2 )  168
int idx = get_symbol ( c , state , 0 ) ; 169
if ( idx > ( unsigned ) f -> quant_table_count )  170
av_log ( f -> avctx , AV_LOG_ERROR , "quant_table_index out of range\n" ); 171
p -> quant_table_index = idx; 175
memcpy ( p -> quant_table , f -> quant_tables [ idx ] , sizeof ( p -> quant_table ) ); 176
context_count = f -> context_count [ idx ]; 178
memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ); 180
if ( f -> version <= 2 )  183
av_assert0 ( context_count >= 0 ); 184
if ( p -> context_count < context_count )  185
av_freep ( & p -> state ); 186
av_freep ( & p -> vlc_state ); 187
p -> context_count = context_count; 189
------------------------------
216 /home/SySeVR/data/CVE_2014_0221_PATCHED_dtls1_get_message_fragment.c [u'wire'] 4
static long
CVE_2014_0221_PATCHED_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 18
if ( i <= 0 )  20
return i ; 24
if ( i != DTLS1_HM_HEADER_LENGTH )  27
dtls1_get_message_header ( wire , & msg_hdr ); 35
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  53
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  60
s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , s , s -> msg_callback_arg ); 63
------------------------------
217 /home/SySeVR/data/CVE_2014_0221_VULN_dtls1_get_message_fragment.c [u'wire'] 4
static long
CVE_2014_0221_VULN_dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok) 2
unsigned char wire [ DTLS1_HM_HEADER_LENGTH ] ; 4
i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , 0 ); 17
if ( i <= 0 )  19
return i ; 23
if ( i != DTLS1_HM_HEADER_LENGTH )  26
dtls1_get_message_header ( wire , & msg_hdr ); 34
if ( ! s -> server && s -> d1 -> r_msg_hdr . frag_off == 0 && wire [ 0 ] == SSL3_MT_HELLO_REQUEST )  52
if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 )  59
s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , wire , DTLS1_HM_HEADER_LENGTH , s , s -> msg_callback_arg ); 62
if ( i <= 0 )  91
return i ; 95
if ( i != ( int ) frag_len )  103
------------------------------
218 /home/SySeVR/data/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c [u'chunkExtension'] 63
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
p += 4; 32
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
nsAutoArrayPtr < char > chunkExtension ( new char [ extra ] ) ; 63
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  64
------------------------------
219 /home/SySeVR/data/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c [u'extLength'] 44
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )  23
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )  43
char extLength [ 2 ] ; 44
const char * p = extLength ; 45
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )  47
------------------------------
220 /home/SySeVR/data/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c [u'waveFormat'] 5
bool
CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize) 2
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ; 5
const char * p = waveFormat ; 6
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )  12
p += 4; 32
frameSize = ReadUint16LE ( & p ); 34
sampleFormat = ReadUint16LE ( & p ); 36
uint16_t extra = ReadUint16LE ( & p ) ; 53
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )  54
extra += extra % 2; 58
if ( extra > 0 )  60
if ( ! ReadAll ( chunkExtension . get ( ) , extra ) )  64
unsigned int actualFrameSize = sampleFormat == 8 ? 1 : 2 * channels ; 78
if ( rate < 100 || rate > 96000 || ( ( ( channels < 1 || channels > MAX_CHANNELS ) || ( frameSize != 1 && frameSize != 2 && frameSize != 4 ) ) && ! mIgnoreAudioOutputFormat ) || ( sampleFormat != 8 && sampleFormat != 16 ) || frameSize != actualFrameSize )  79
mFrameSize = frameSize; 92
if ( sampleFormat == 8 )  93
------------------------------
221 /home/SySeVR/data/CVE_2014_1508_VULN_nsDisplayNotation__Paint.c [u'p'] 60
void CVE_2014_1508_VULN_nsDisplayNotation::Paint(nsDisplayListBuilder* aBuilder,
nsRenderingContext* aCtx) 2
nsPresContext * presContext = mFrame -> PresContext ( ) ; 5
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ; 6
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ; 13
switch ( mType )  19
gfxFloat W = rect . Width ( ) ; 48
gfxFloat H = rect . Height ( ) ; 48
gfxFloat l = sqrt ( W * W + H * H ) ; 49
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ; 50
gfxFloat w = W * f ; 51
gfxFloat h = H * f ; 51
gfxPoint p [ ] = { rect . TopRight ( ) , rect . TopRight ( ) + gfxPoint ( - w - .4 * h , std :: max ( - e / 2.0 , h - .4 * w ) ) , rect . TopRight ( ) + gfxPoint ( - .7 * w , .7 * h ) , rect . TopRight ( ) + gfxPoint ( std :: min ( e / 2.0 , - w + .4 * h ) , h + .4 * w ) , rect . TopRight ( ) } ; 60
gfxCtx -> Polygon ( p , sizeof ( p ) ); 67
------------------------------
222 /home/SySeVR/data/CVE_2014_2889_PATCHED_bpf_jit_compile.c [u'temp'] 3
void CVE_2014_2889_PATCHED_bpf_jit_compile(struct sk_filter *fp) 1
u8 temp [ 64 ] ; 3
------------------------------
223 /home/SySeVR/data/CVE_2014_2889_VULN_bpf_jit_compile.c [u'temp'] 3
void CVE_2014_2889_VULN_bpf_jit_compile(struct sk_filter *fp) 1
u8 temp [ 64 ] ; 3
------------------------------
224 /home/SySeVR/data/CVE_2014_3523_PATCHED_winnt_accept.c [u'events'] 28
static unsigned int __stdcall CVE_2014_3523_PATCHED_winnt_accept(void *lr_) 12
HANDLE events [ 3 ] ; 28
events [ 1 ] = exit_event; 94
events [ 2 ] = max_requests_per_child_event; 95
events [ 0 ] = exit_event; 102
events [ 1 ] = max_requests_per_child_event; 103
events [ 2 ] = CreateEvent ( NULL , FALSE , FALSE , NULL ); 104
rv = WSAEventSelect ( nlsd , events [ 2 ] , FD_ACCEPT ); 109
if ( rv )  110
CloseHandle ( events [ 2 ] ); 114
if ( ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) ) || ( rv == APR_FROM_OS_ERROR ( WSAEACCES ) ) )  193
if ( ( rv == APR_FROM_OS_ERROR ( WSAEINVAL ) ) || ( rv == APR_FROM_OS_ERROR ( WSAENOTSOCK ) ) )  205
if ( ( rv != APR_FROM_OS_ERROR ( ERROR_IO_PENDING ) ) && ( rv != APR_FROM_OS_ERROR ( WSA_IO_PENDING ) ) )  234
ap_log_error ( APLOG_MARK , APLOG_ERR , rv , ap_server_conf , APLOGNO ( 0033 9 )
"Child: Encountered too many AcceptEx "
"faults accepting client connections." )
ap_log_error ( APLOG_MARK , APLOG_NOTICE , rv , ap_server_conf , APLOGNO ( 00340 )
"winnt_mpm: falling back to "
"'AcceptFilter none'." ) 247
events [ 0 ] = context -> overlapped . hEvent; 256
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 259
while ( rv == WAIT_IO_COMPLETION )  260
if ( rv == WAIT_OBJECT_0 )  262
rv = WaitForMultipleObjectsEx ( 3 , events , FALSE , INFINITE , TRUE ); 345
while ( rv == WAIT_IO_COMPLETION )  346
if ( rv != WAIT_OBJECT_0 + 2 )  349
if ( rv == APR_FROM_OS_ERROR ( WSAECONNRESET ) || rv == APR_FROM_OS_ERROR ( WSAEINPROGRESS ) || rv == APR_FROM_OS_ERROR ( WSAEWOULDBLOCK ) )  368
ap_log_error ( APLOG_MARK , APLOG_DEBUG ,
rv , ap_server_conf , APLOGNO ( 00343 )
"accept() failed, retrying." ) 373
ap_log_error ( APLOG_MARK , APLOG_WARNING ,
rv , ap_server_conf , APLOGNO ( 00344 )
"accept() failed." ) 380
if ( rv == APR_FROM_OS_ERROR ( WSAEMFILE ) || rv == APR_FROM_OS_ERROR ( WSAENOBUFS ) )  382
ap_log_error ( APLOG_MARK , APLOG_ERR , rv , ap_server_conf , APLOGNO ( 00345 )
"Child: Encountered too many accept() "
"resource faults, aborting." ) 390
CloseHandle ( events [ 2 ] ); 448
------------------------------
225 /home/SySeVR/data/CVE_2014_5163_PATCHED_decode_apn.c [u'str'] 4
static void
CVE_2014_5163_PATCHED_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH + 1 ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
------------------------------
226 /home/SySeVR/data/CVE_2014_5163_VULN_decode_apn.c [u'str'] 4
static void
CVE_2014_5163_VULN_decode_apn(tvbuff_t * tvb, int offset, guint16 length, proto_tree * tree, proto_item *item) 2
guint8 str [ MAX_APN_LENGTH + 1 ] ; 4
memset ( str , 0 , MAX_APN_LENGTH ); 8
tvb_memcpy ( tvb , str , offset , length < MAX_APN_LENGTH ? length : MAX_APN_LENGTH ); 9
while ( ( curr_len < length ) && ( curr_len < MAX_APN_LENGTH ) )  12
guint step = str [ curr_len ] ; 14
str [ curr_len ] = '.'; 15
curr_len += step + 1; 16
proto_tree_add_string ( tree , hf_gtp_apn , tvb , offset , length , str + 1 ); 20
proto_item_append_text ( item , ": %s" , str + 1 ); 22
------------------------------
227 /home/SySeVR/data/CVE_2014_6427_PATCHED_is_rtsp_request_or_reply.c [u'response_chars'] 7
static gboolean
CVE_2014_6427_PATCHED_is_rtsp_request_or_reply(const guchar *line, size_t linelen, rtsp_type_t *type) 2
gchar response_chars [ 4 ] ; 7
memcpy ( response_chars , token , 3 ); 21
response_chars [ 3 ] = '\0'; 22
rtsp_stat_info -> response_code = ( guint ) strtoul ( response_chars , NULL , 10 ); 23
------------------------------
228 /home/SySeVR/data/CVE_2014_7145_PATCHED_SMB2_tcon.c [u'iov'] 7
int
CVE_2014_7145_PATCHED_SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,
struct cifs_tcon *tcon, const struct nls_table *cp) 3
struct kvec iov [ 2 ] ; 7
iov [ 0 ] . iov_base = ( char * ) req; 48
iov [ 0 ] . iov_len = get_rfc1002_length ( req ) + 4 - 1; 50
iov [ 1 ] . iov_base = unc_path; 56
iov [ 1 ] . iov_len = unc_path_len; 57
rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ); 61
rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base; 62
if ( rc != 0 )  64
ses -> ipc_tid = rsp -> hdr . TreeId; 73
if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK )  77
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE )  79
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT )  82
cifs_dbg ( VFS , "unknown share type %d\n" , rsp -> ShareType ); 86
tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ); 91
tcon -> capabilities = rsp -> Capabilities; 92
tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ); 93
tcon -> tidStatus = CifsGood; 94
tcon -> need_reconnect = false; 95
tcon -> tid = rsp -> hdr . TreeId; 96
strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ); 97
if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) )  99
init_copy_chunk_defaults ( tcon ); 102
if ( tcon -> ses -> server -> ops -> validate_negotiate )  103
rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ); 104
free_rsp_buf ( resp_buftype , rsp ); 106
return rc ; 108
if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME )  111
------------------------------
229 /home/SySeVR/data/CVE_2014_7145_VULN_SMB2_tcon.c [u'iov'] 7
int
CVE_2014_7145_VULN_SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,
struct cifs_tcon *tcon, const struct nls_table *cp) 3
struct kvec iov [ 2 ] ; 7
iov [ 0 ] . iov_base = ( char * ) req; 48
iov [ 0 ] . iov_len = get_rfc1002_length ( req ) + 4 - 1; 50
iov [ 1 ] . iov_base = unc_path; 56
iov [ 1 ] . iov_len = unc_path_len; 57
rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ); 61
rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base; 62
if ( rc != 0 )  64
ses -> ipc_tid = rsp -> hdr . TreeId; 73
if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK )  77
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE )  79
if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT )  82
cifs_dbg ( VFS , "unknown share type %d\n" , rsp -> ShareType ); 86
tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ); 91
tcon -> capabilities = rsp -> Capabilities; 92
tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ); 93
tcon -> tidStatus = CifsGood; 94
tcon -> need_reconnect = false; 95
tcon -> tid = rsp -> hdr . TreeId; 96
strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ); 97
if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) )  99
init_copy_chunk_defaults ( tcon ); 102
if ( tcon -> ses -> server -> ops -> validate_negotiate )  103
rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ); 104
free_rsp_buf ( resp_buftype , rsp ); 106
return rc ; 108
if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME )  111
------------------------------
230 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c [u'v_count'] 5
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int v_count [ MAX_COMPONENTS ] ; 5
memset ( v_count , 0 , sizeof ( v_count ) ); 60
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 73
if ( ! h_count [ i ] || ! v_count [ i ] )  76
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 77
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 83
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 89
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
return ret ; 119
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 126
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
if ( ! s -> lossless )  132
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 139
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
av_assert0 ( s -> nb_components == 3 ); 176
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
av_assert0 ( s -> nb_components == 4 ); 189
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
av_assert0 ( s -> nb_components == 4 ); 208
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); 283
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 288
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 305
av_frame_unref ( s -> picture_ptr ); 309
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 319
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 324
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 328
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
av_freep ( & s -> blocks [ i ] ); 338
av_freep ( & s -> last_nnz [ i ] ); 339
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
------------------------------
231 /home/SySeVR/data/CVE_2014_8541_VULN_ff_mjpeg_decode_sof.c [u'h_count'] 4
int CVE_2014_8541_VULN_ff_mjpeg_decode_sof(MJpegDecodeContext *s) 1
int h_count [ MAX_COMPONENTS ] ; 4
memset ( h_count , 0 , sizeof ( h_count ) ); 59
s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; 63
h_count [ i ] = get_bits ( & s -> gb , 4 ); 64
v_count [ i ] = get_bits ( & s -> gb , 4 ); 65
if ( h_count [ i ] > s -> h_max )  67
s -> h_max = h_count [ i ]; 68
if ( v_count [ i ] > s -> v_max )  69
s -> v_max = v_count [ i ]; 70
s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); 71
if ( s -> quant_index [ i ] >= 4 )  72
av_log ( s -> avctx , AV_LOG_ERROR , "quant_index is invalid\n" ); 73
if ( ! h_count [ i ] || ! v_count [ i ] )  76
av_log ( s -> avctx , AV_LOG_ERROR , "Invalid sampling factor in component %d %d:%d\n" , i , h_count [ i ] , v_count [ i ] ); 77
av_log ( s -> avctx , AV_LOG_DEBUG , "component %d %d:%d id: %d quant:%d\n" , i , h_count [ i ] , v_count [ i ] , s -> component_id [ i ] , s -> quant_index [ i ] ); 83
if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  88
avpriv_report_missing_feature ( s -> avctx , "Subsampling in JPEG-LS" ); 89
if ( width != s -> width || height != s -> height || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  95
s -> width = width; 99
s -> height = height; 100
memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); 101
memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); 102
s -> interlaced = 0; 103
s -> got_picture = 0; 104
if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  107
s -> interlaced = 1; 110
s -> bottom_field = s -> interlace_polarity; 111
s -> picture_ptr -> interlaced_frame = 1; 112
s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; 113
ret = ff_set_dimensions ( s -> avctx , width , height ); 117
if ( ret < 0 )  118
return ret ; 119
if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  124
if ( s -> progressive )  125
avpriv_request_sample ( s -> avctx , "progressively coded interlaced picture" ); 126
if ( s -> v_max == 1 && s -> h_max == 1 && s -> lossless == 1 && ( nb_components == 3 || nb_components == 4 ) )  130
if ( ! s -> lossless )  132
pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; 135
av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); 139
if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  142
pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; 143
if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  144
pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; 145
for (i = 0; i < 8; i++) 147
int j = 6 + ( i & 1 ) - ( i & 6 ) ; 148
int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; 149
int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; 150
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  152
js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; 153
if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  154
js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; 155
if ( is == 1 && js == 2 )  157
if ( i & 1 )  158
s -> upscale_h |= 1 << ( j / 2 ); 158
s -> upscale_v |= 1 << ( j / 2 ); 159
switch ( pix_fmt_id )  163
if ( s -> rgb )  165
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_BGR48; 166
if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  168
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_GBRP : AV_PIX_FMT_GBRP16; 169
if ( s -> bits <= 8 )  171
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 171
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16; 172
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 173
av_assert0 ( s -> nb_components == 3 ); 176
if ( s -> rgb )  179
s -> avctx -> pix_fmt = s -> bits <= 9 ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA64; 180
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  182
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 183
s -> avctx -> pix_fmt = s -> bits <= 8 ? AV_PIX_FMT_YUVA444P : AV_PIX_FMT_YUVA444P16; 185
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 186
av_assert0 ( s -> nb_components == 4 ); 189
if ( s -> adobe_transform == 0 && s -> bits <= 8 )  192
s -> avctx -> pix_fmt = AV_PIX_FMT_GBRAP; 193
s -> upscale_v = 6; 194
s -> upscale_h = 6; 195
s -> chroma_height = s -> height; 196
if ( s -> adobe_transform == 2 && s -> bits <= 8 )  197
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P; 198
s -> upscale_v = 6; 199
s -> upscale_h = 6; 200
s -> chroma_height = s -> height; 201
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 202
if ( s -> bits <= 8 )  204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P; 204
s -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P16; 205
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 206
av_assert0 ( s -> nb_components == 4 ); 208
if ( s -> bits <= 8 )  214
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 214
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 217
s -> chroma_height = s -> height; 218
if ( s -> bits <= 8 )  223
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV444P : AV_PIX_FMT_YUVJ444P; 223
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 226
s -> chroma_height = ( s -> height + 1 ) / 2; 227
if ( s -> bits <= 8 )  238
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 239
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 241
if ( s -> bits <= 8 )  247
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV440P : AV_PIX_FMT_YUVJ440P; 247
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 250
s -> chroma_height = ( s -> height + 1 ) / 2; 251
if ( s -> bits <= 8 )  254
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 254
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16; 255
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 256
if ( s -> bits <= 8 )  260
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV422P : AV_PIX_FMT_YUVJ422P; 260
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 263
if ( s -> bits <= 8 )  267
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_YUVJ420P; 267
s -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16; 268
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 269
if ( pix_fmt_id == 0x42111100 )  270
s -> upscale_h = 6; 271
s -> chroma_height = ( s -> height + 1 ) / 2; 272
if ( s -> bits <= 8 )  276
s -> avctx -> pix_fmt = s -> cs_itu601 ? AV_PIX_FMT_YUV411P : AV_PIX_FMT_YUVJ411P; 276
s -> avctx -> color_range = s -> cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG; 279
av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); 283
s -> upscale_h = s -> upscale_v = 0; 284
if ( ( s -> upscale_h || s -> upscale_v ) && s -> avctx -> lowres )  287
av_log ( s -> avctx , AV_LOG_ERROR , "lowres not supported for weird subsampling\n" ); 288
if ( s -> ls )  291
s -> upscale_h = s -> upscale_v = 0; 292
if ( s -> nb_components > 1 )  293
s -> avctx -> pix_fmt = AV_PIX_FMT_RGB24; 294
if ( s -> palette_index && s -> bits <= 8 )  295
s -> avctx -> pix_fmt = AV_PIX_FMT_PAL8; 296
if ( s -> bits <= 8 )  297
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8; 298
s -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16; 300
s -> pix_desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ); 303
if ( ! s -> pix_desc )  304
av_log ( s -> avctx , AV_LOG_ERROR , "Could not get a pixel format descriptor.\n" ); 305
av_frame_unref ( s -> picture_ptr ); 309
if ( ff_get_buffer ( s -> avctx , s -> picture_ptr , AV_GET_BUFFER_FLAG_REF ) < 0 )  310
s -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I; 312
s -> picture_ptr -> key_frame = 1; 313
s -> got_picture = 1; 314
s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; 317
av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); 319
av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); 324
if ( s -> rgb && ! s -> lossless && ! s -> ls )  327
av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); 328
if ( s -> progressive )  333
int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; 334
int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; 335
for (i = 0; i < s->nb_components; i++) 336
int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; 337
av_freep ( & s -> blocks [ i ] ); 338
av_freep ( & s -> last_nnz [ i ] ); 339
s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); 340
s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); 341
if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  342
s -> block_stride [ i ] = bw * s -> h_count [ i ]; 344
memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 346
------------------------------
232 /home/SySeVR/data/CVE_2014_8544_PATCHED_tiff_decode_tag.c [u'pal_gb'] 206
static int CVE_2014_8544_PATCHED_tiff_decode_tag(TiffContext *s, AVFrame *frame) 1
unsigned tag , type , count , off , value = 0 , value2 = 0 ; 3
int ret ; 6
ret = ff_tread_tag ( & s -> gb , s -> le , & tag , & type , & count , & start ); 9
if ( ret < 0 )  10
switch ( tag )  35
GetByteContext pal_gb [ 3 ] ; 206
pal_gb [ 0 ] = pal_gb [ 1 ] = pal_gb [ 2 ] = s -> gb; 212
bytestream2_skip ( & pal_gb [ 1 ] , count / 3 * off ); 213
bytestream2_skip ( & pal_gb [ 2 ] , count / 3 * off * 2 ); 214
p |= ( ff_tget ( & pal_gb [ 0 ] , type , s -> le ) >> off ) << 16; 219
p |= ( ff_tget ( & pal_gb [ 1 ] , type , s -> le ) >> off ) << 8; 220
p |= ff_tget ( & pal_gb [ 2 ] , type , s -> le ) >> off; 221
s -> palette [ i ] = p; 222
s -> palette_is_set = 1; 224
s -> planar = value == 2; 228
av_log ( s -> avctx , AV_LOG_ERROR , "subsample count invalid\n" ); 232
for (i = 0; i < count; i++) 235
s -> subsampling [ i ] = ff_tget ( & s -> gb , type , s -> le ); 236
------------------------------
233 /home/SySeVR/data/CVE_2014_8713_VULN_build_expert_data.c [u'temp_buffer'] 9
static void
CVE_2014_8713_VULN_build_expert_data(proto_tree *ncp_tree, const char *hf_name, char *buffer,
size_t buffer_size, int repeat_lookup,
gboolean search_structs) 4
char temp_buffer [ 256 ] = "\0" ; 9
if ( strlen ( temp_buffer ) + strlen ( buffer ) < 250 )  40
g_strlcat ( temp_buffer , buffer , 256 ); 41
g_strlcpy ( buffer , temp_buffer , buffer_size ); 44
g_strlcat ( temp_buffer , "/" , 256 ); 49
------------------------------
234 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_top_row_fields'] 311
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dfdpck_toprowflag1 [ ] = { & hf_tn5250_dfdpck_toprowflag1_0 , & hf_tn5250_dfdpck_toprowflag1_1 , & hf_tn5250_dfdpck_toprowflag1_2 , & hf_tn5250_dfdpck_toprowflag1_3 , & hf_tn5250_dfdpck_toprowflag1_4 , & hf_tn5250_dfdpck_toprowflag1_5 , & hf_tn5250_dfdpck_toprowflag1_6 , & hf_tn5250_dfdpck_toprowflag1_7 , NULL } ; 260
static const int * dfdpck_toprowflag2 [ ] = { & hf_tn5250_dfdpck_toprowflag2_0 , & hf_tn5250_dfdpck_toprowflag2_1 , & hf_tn5250_dfdpck_toprowflag2_2 , & hf_tn5250_dfdpck_toprowflag2_3 , & hf_tn5250_dfdpck_toprowflag2_4 , & hf_tn5250_dfdpck_toprowflag2_5 , & hf_tn5250_dfdpck_toprowflag2_6 , & hf_tn5250_dfdpck_toprowflag2_7 , NULL } ; 272
static const int * dfdpck_toprowflag3 [ ] = { & hf_tn5250_dfdpck_toprowflag3_0 , & hf_tn5250_dfdpck_toprowflag3_1 , & hf_tn5250_dfdpck_toprowflag3_2 , & hf_tn5250_dfdpck_toprowflag3_3 , & hf_tn5250_dfdpck_toprowflag3_4 , & hf_tn5250_dfdpck_toprowflag3_5 , & hf_tn5250_dfdpck_toprowflag3_6 , & hf_tn5250_dfdpck_toprowflag3_7 , NULL } ; 284
hf_items dfdpck_top_row_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_data_field , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_toprowflag1 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag1 , 0 } , { & hf_tn5250_dfdpck_toprowflag2 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag2 , 0 } , { & hf_tn5250_dfdpck_toprowflag3 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag3 , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 311
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
235 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_core_area_fields'] 303
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dfdpck_coreflag [ ] = { & hf_tn5250_dfdpck_coreflag_0 , & hf_tn5250_dfdpck_coreflag_1 , & hf_tn5250_dfdpck_coreflag_2 , & hf_tn5250_dfdpck_coreflag_3 , & hf_tn5250_dfdpck_coreflag_4 , & hf_tn5250_dfdpck_coreflag_5 , & hf_tn5250_dfdpck_coreflag_6 , & hf_tn5250_dfdpck_coreflag_7 , NULL } ; 248
hf_items dfdpck_core_area_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_data_field , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_coreflag , ett_tn5250_dfdpck_mask , 1 , dfdpck_coreflag , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 303
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
236 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_fields'] 296
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items dfdpck_fields [ ] = { { & hf_tn5250_dfdpck_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 296
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
237 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_toprowflag3'] 284
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dfdpck_toprowflag3 [ ] = { & hf_tn5250_dfdpck_toprowflag3_0 , & hf_tn5250_dfdpck_toprowflag3_1 , & hf_tn5250_dfdpck_toprowflag3_2 , & hf_tn5250_dfdpck_toprowflag3_3 , & hf_tn5250_dfdpck_toprowflag3_4 , & hf_tn5250_dfdpck_toprowflag3_5 , & hf_tn5250_dfdpck_toprowflag3_6 , & hf_tn5250_dfdpck_toprowflag3_7 , NULL } ; 284
hf_items dfdpck_top_row_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_data_field , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_toprowflag1 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag1 , 0 } , { & hf_tn5250_dfdpck_toprowflag2 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag2 , 0 } , { & hf_tn5250_dfdpck_toprowflag3 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag3 , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 311
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
238 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_toprowflag2'] 272
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dfdpck_toprowflag2 [ ] = { & hf_tn5250_dfdpck_toprowflag2_0 , & hf_tn5250_dfdpck_toprowflag2_1 , & hf_tn5250_dfdpck_toprowflag2_2 , & hf_tn5250_dfdpck_toprowflag2_3 , & hf_tn5250_dfdpck_toprowflag2_4 , & hf_tn5250_dfdpck_toprowflag2_5 , & hf_tn5250_dfdpck_toprowflag2_6 , & hf_tn5250_dfdpck_toprowflag2_7 , NULL } ; 272
hf_items dfdpck_top_row_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_data_field , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_toprowflag1 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag1 , 0 } , { & hf_tn5250_dfdpck_toprowflag2 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag2 , 0 } , { & hf_tn5250_dfdpck_toprowflag3 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag3 , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 311
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
239 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_toprowflag1'] 260
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dfdpck_toprowflag1 [ ] = { & hf_tn5250_dfdpck_toprowflag1_0 , & hf_tn5250_dfdpck_toprowflag1_1 , & hf_tn5250_dfdpck_toprowflag1_2 , & hf_tn5250_dfdpck_toprowflag1_3 , & hf_tn5250_dfdpck_toprowflag1_4 , & hf_tn5250_dfdpck_toprowflag1_5 , & hf_tn5250_dfdpck_toprowflag1_6 , & hf_tn5250_dfdpck_toprowflag1_7 , NULL } ; 260
hf_items dfdpck_top_row_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_data_field , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_toprowflag1 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag1 , 0 } , { & hf_tn5250_dfdpck_toprowflag2 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag2 , 0 } , { & hf_tn5250_dfdpck_toprowflag3 , ett_tn5250_dfdpck_mask , 1 , dfdpck_toprowflag3 , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 311
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
240 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dfdpck_coreflag'] 248
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dfdpck_coreflag [ ] = { & hf_tn5250_dfdpck_coreflag_0 , & hf_tn5250_dfdpck_coreflag_1 , & hf_tn5250_dfdpck_coreflag_2 , & hf_tn5250_dfdpck_coreflag_3 , & hf_tn5250_dfdpck_coreflag_4 , & hf_tn5250_dfdpck_coreflag_5 , & hf_tn5250_dfdpck_coreflag_6 , & hf_tn5250_dfdpck_coreflag_7 , NULL } ; 248
hf_items dfdpck_core_area_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_data_field , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dfdpck_coreflag , ett_tn5250_dfdpck_mask , 1 , dfdpck_coreflag , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 303
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
241 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dorm_fields'] 241
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items dorm_fields [ ] = { { & hf_tn5250_dorm_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dorm_ec , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 241
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
242 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dsc_fields'] 232
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items dsc_fields [ ] = { { & hf_tn5250_dsc_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsc_sk , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsc_ev , 0 , 1 , 0 , ENC_EBCDIC | ENC_NA } , { NULL , 0 , 0 , 0 , 0 } } ; 232
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
243 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_line_data_fields'] 218
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_cld_byte1 [ ] = { & hf_tn5250_wts_cld_flag1_0 , & hf_tn5250_wts_cld_flag1_1 , & hf_tn5250_wts_cld_flag1_2 , & hf_tn5250_wts_cld_flag1_3 , & hf_tn5250_wts_cld_flag1_4 , & hf_tn5250_wts_cld_flag1_5 , & hf_tn5250_wts_cld_flag1_6 , & hf_tn5250_wts_cld_flag1_7 , NULL } ; 184
static const int * wts_cld_byte2 [ ] = { & hf_tn5250_wts_cld_flag2_0 , & hf_tn5250_wts_cld_flag2_1 , & hf_tn5250_wts_cld_flag2_2 , & hf_tn5250_wts_cld_flag2_3 , & hf_tn5250_wts_cld_flag2_4 , & hf_tn5250_wts_cld_flag2_line_spacing , NULL } ; 196
static const int * wts_cld_byte3 [ ] = { & hf_tn5250_wts_cld_flag3_0 , & hf_tn5250_wts_cld_flag3_1 , & hf_tn5250_wts_cld_flag3_2 , & hf_tn5250_wts_cld_flag3_3 , & hf_tn5250_wts_cld_flag3_4 , & hf_tn5250_wts_cld_flag3_5 , & hf_tn5250_wts_cld_flag3_6 , & hf_tn5250_wts_cld_flag3_7 , NULL } ; 206
hf_items wts_line_data_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag1 , ett_tn5250_wts_mask , 1 , wts_cld_byte1 , 0 } , { & hf_tn5250_wts_cld_flag2 , ett_tn5250_wts_mask , 1 , wts_cld_byte2 , 0 } , { & hf_tn5250_wts_cld_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag3 , ett_tn5250_wts_mask , 1 , wts_cld_byte3 , 0 } , { & hf_tn5250_wts_cld_page_num , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_lmo , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_io , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_sli , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 218
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
244 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_cld_byte3'] 206
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_cld_byte3 [ ] = { & hf_tn5250_wts_cld_flag3_0 , & hf_tn5250_wts_cld_flag3_1 , & hf_tn5250_wts_cld_flag3_2 , & hf_tn5250_wts_cld_flag3_3 , & hf_tn5250_wts_cld_flag3_4 , & hf_tn5250_wts_cld_flag3_5 , & hf_tn5250_wts_cld_flag3_6 , & hf_tn5250_wts_cld_flag3_7 , NULL } ; 206
hf_items wts_line_data_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag1 , ett_tn5250_wts_mask , 1 , wts_cld_byte1 , 0 } , { & hf_tn5250_wts_cld_flag2 , ett_tn5250_wts_mask , 1 , wts_cld_byte2 , 0 } , { & hf_tn5250_wts_cld_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag3 , ett_tn5250_wts_mask , 1 , wts_cld_byte3 , 0 } , { & hf_tn5250_wts_cld_page_num , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_lmo , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_io , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_sli , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 218
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
245 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_cld_byte2'] 196
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_cld_byte2 [ ] = { & hf_tn5250_wts_cld_flag2_0 , & hf_tn5250_wts_cld_flag2_1 , & hf_tn5250_wts_cld_flag2_2 , & hf_tn5250_wts_cld_flag2_3 , & hf_tn5250_wts_cld_flag2_4 , & hf_tn5250_wts_cld_flag2_line_spacing , NULL } ; 196
hf_items wts_line_data_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag1 , ett_tn5250_wts_mask , 1 , wts_cld_byte1 , 0 } , { & hf_tn5250_wts_cld_flag2 , ett_tn5250_wts_mask , 1 , wts_cld_byte2 , 0 } , { & hf_tn5250_wts_cld_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag3 , ett_tn5250_wts_mask , 1 , wts_cld_byte3 , 0 } , { & hf_tn5250_wts_cld_page_num , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_lmo , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_io , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_sli , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 218
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
246 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_cld_byte1'] 184
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_cld_byte1 [ ] = { & hf_tn5250_wts_cld_flag1_0 , & hf_tn5250_wts_cld_flag1_1 , & hf_tn5250_wts_cld_flag1_2 , & hf_tn5250_wts_cld_flag1_3 , & hf_tn5250_wts_cld_flag1_4 , & hf_tn5250_wts_cld_flag1_5 , & hf_tn5250_wts_cld_flag1_6 , & hf_tn5250_wts_cld_flag1_7 , NULL } ; 184
hf_items wts_line_data_fields [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag1 , ett_tn5250_wts_mask , 1 , wts_cld_byte1 , 0 } , { & hf_tn5250_wts_cld_flag2 , ett_tn5250_wts_mask , 1 , wts_cld_byte2 , 0 } , { & hf_tn5250_wts_cld_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_flag3 , ett_tn5250_wts_mask , 1 , wts_cld_byte3 , 0 } , { & hf_tn5250_wts_cld_page_num , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_lmo , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_io , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_cld_sli , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 218
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
247 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_fields'] 174
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_byte1 [ ] = { & hf_tn5250_wts_flag1_0 , & hf_tn5250_wts_flag1_1 , & hf_tn5250_wts_flag1_2 , & hf_tn5250_wts_flag1_3 , & hf_tn5250_wts_flag1_reserved , NULL } ; 146
static const int * wts_byte2 [ ] = { & hf_tn5250_wts_flag2_reserved , & hf_tn5250_wts_flag2_6 , & hf_tn5250_wts_flag2_reserved2 , NULL } ; 155
static const int * wts_byte3 [ ] = { & hf_tn5250_wts_flag3_0 , & hf_tn5250_wts_flag3_1 , & hf_tn5250_wts_flag3_2 , & hf_tn5250_wts_flag3_3 , & hf_tn5250_wts_flag3_4 , & hf_tn5250_wts_flag3_5 , & hf_tn5250_wts_flag3_6 , & hf_tn5250_wts_flag3_7 , NULL } ; 162
hf_items wts_fields [ ] = { { & hf_tn5250_wts_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_flag1 , ett_tn5250_wts_mask , 1 , wts_byte1 , 0 } , { & hf_tn5250_wts_flag2 , ett_tn5250_wts_mask , 1 , wts_byte2 , 0 } , { & hf_tn5250_wts_flag3 , ett_tn5250_wts_mask , 1 , wts_byte3 , 0 } , { & hf_tn5250_wts_home_position_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_home_position_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 174
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
248 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_byte3'] 162
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_byte3 [ ] = { & hf_tn5250_wts_flag3_0 , & hf_tn5250_wts_flag3_1 , & hf_tn5250_wts_flag3_2 , & hf_tn5250_wts_flag3_3 , & hf_tn5250_wts_flag3_4 , & hf_tn5250_wts_flag3_5 , & hf_tn5250_wts_flag3_6 , & hf_tn5250_wts_flag3_7 , NULL } ; 162
hf_items wts_fields [ ] = { { & hf_tn5250_wts_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_flag1 , ett_tn5250_wts_mask , 1 , wts_byte1 , 0 } , { & hf_tn5250_wts_flag2 , ett_tn5250_wts_mask , 1 , wts_byte2 , 0 } , { & hf_tn5250_wts_flag3 , ett_tn5250_wts_mask , 1 , wts_byte3 , 0 } , { & hf_tn5250_wts_home_position_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_home_position_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 174
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
249 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_byte2'] 155
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_byte2 [ ] = { & hf_tn5250_wts_flag2_reserved , & hf_tn5250_wts_flag2_6 , & hf_tn5250_wts_flag2_reserved2 , NULL } ; 155
hf_items wts_fields [ ] = { { & hf_tn5250_wts_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_flag1 , ett_tn5250_wts_mask , 1 , wts_byte1 , 0 } , { & hf_tn5250_wts_flag2 , ett_tn5250_wts_mask , 1 , wts_byte2 , 0 } , { & hf_tn5250_wts_flag3 , ett_tn5250_wts_mask , 1 , wts_byte3 , 0 } , { & hf_tn5250_wts_home_position_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_home_position_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 174
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
250 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'wts_byte1'] 146
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * wts_byte1 [ ] = { & hf_tn5250_wts_flag1_0 , & hf_tn5250_wts_flag1_1 , & hf_tn5250_wts_flag1_2 , & hf_tn5250_wts_flag1_3 , & hf_tn5250_wts_flag1_reserved , NULL } ; 146
hf_items wts_fields [ ] = { { & hf_tn5250_wts_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_flag1 , ett_tn5250_wts_mask , 1 , wts_byte1 , 0 } , { & hf_tn5250_wts_flag2 , ett_tn5250_wts_mask , 1 , wts_byte2 , 0 } , { & hf_tn5250_wts_flag3 , ett_tn5250_wts_mask , 1 , wts_byte3 , 0 } , { & hf_tn5250_wts_home_position_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_wts_home_position_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 174
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
251 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dsl_fields2'] 137
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dsl_byte1 [ ] = { & hf_tn5250_dsl_flag1_0 , & hf_tn5250_dsl_flag1_1 , & hf_tn5250_dsl_flag1_2 , & hf_tn5250_dsl_flag1_reserved , NULL } ; 121
hf_items dsl_fields2 [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_flag1 , ett_tn5250_wsf_dsl_mask , 1 , dsl_byte1 , 0 } , { & hf_tn5250_dsl_id , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_location , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_function , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 137
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
252 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dsl_fields'] 129
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items dsl_fields [ ] = { { & hf_tn5250_dsl_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_rtl_offset , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_offset , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 129
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
253 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dsl_byte1'] 121
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dsl_byte1 [ ] = { & hf_tn5250_dsl_flag1_0 , & hf_tn5250_dsl_flag1_1 , & hf_tn5250_dsl_flag1_2 , & hf_tn5250_dsl_flag1_reserved , NULL } ; 121
hf_items dsl_fields2 [ ] = { { & hf_tn5250_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_flag1 , ett_tn5250_wsf_dsl_mask , 1 , dsl_byte1 , 0 } , { & hf_tn5250_dsl_id , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_location , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dsl_function , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 137
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
254 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dtsf_fields'] 109
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dtsf_byte1 [ ] = { & hf_tn5250_dtsf_flag1_0 , & hf_tn5250_dtsf_flag1_1 , & hf_tn5250_dtsf_flag1_2 , & hf_tn5250_dtsf_flag1_3 , & hf_tn5250_dtsf_flag1_4 , & hf_tn5250_dtsf_flag1_5 , & hf_tn5250_dtsf_flag1_6 , & hf_tn5250_dtsf_flag1_7 , NULL } ; 88
static const int * dtsf_byte2 [ ] = { & hf_tn5250_dtsf_flag2_0 , & hf_tn5250_dtsf_flag2_1 , & hf_tn5250_dtsf_flag2_2 , & hf_tn5250_dtsf_flag2_3 , & hf_tn5250_dtsf_flag2_4to7 , NULL } ; 100
hf_items dtsf_fields [ ] = { { & hf_tn5250_dtsf_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_flag1 , ett_tn5250_wsf_dtsf_mask , 1 , dtsf_byte1 , 0 } , { & hf_tn5250_dtsf_flag2 , ett_tn5250_wsf_dtsf_mask , 1 , dtsf_byte2 , 0 } , { & hf_tn5250_dtsf_text_body_height , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_text_body_width , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_line_cmd_field_size , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_location_of_pitch , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_first_line , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 109
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
255 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dtsf_byte2'] 100
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dtsf_byte2 [ ] = { & hf_tn5250_dtsf_flag2_0 , & hf_tn5250_dtsf_flag2_1 , & hf_tn5250_dtsf_flag2_2 , & hf_tn5250_dtsf_flag2_3 , & hf_tn5250_dtsf_flag2_4to7 , NULL } ; 100
hf_items dtsf_fields [ ] = { { & hf_tn5250_dtsf_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_flag1 , ett_tn5250_wsf_dtsf_mask , 1 , dtsf_byte1 , 0 } , { & hf_tn5250_dtsf_flag2 , ett_tn5250_wsf_dtsf_mask , 1 , dtsf_byte2 , 0 } , { & hf_tn5250_dtsf_text_body_height , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_text_body_width , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_line_cmd_field_size , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_location_of_pitch , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_first_line , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 109
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
256 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dtsf_byte1'] 88
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dtsf_byte1 [ ] = { & hf_tn5250_dtsf_flag1_0 , & hf_tn5250_dtsf_flag1_1 , & hf_tn5250_dtsf_flag1_2 , & hf_tn5250_dtsf_flag1_3 , & hf_tn5250_dtsf_flag1_4 , & hf_tn5250_dtsf_flag1_5 , & hf_tn5250_dtsf_flag1_6 , & hf_tn5250_dtsf_flag1_7 , NULL } ; 88
hf_items dtsf_fields [ ] = { { & hf_tn5250_dtsf_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_flag1 , ett_tn5250_wsf_dtsf_mask , 1 , dtsf_byte1 , 0 } , { & hf_tn5250_dtsf_flag2 , ett_tn5250_wsf_dtsf_mask , 1 , dtsf_byte2 , 0 } , { & hf_tn5250_dtsf_text_body_height , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_text_body_width , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_line_cmd_field_size , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_location_of_pitch , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dtsf_first_line , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 109
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
257 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dpo_fields'] 78
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dpo_byte1 [ ] = { & hf_tn5250_dpo_flag1_0 , & hf_tn5250_dpo_flag1_1 , & hf_tn5250_dpo_flag1_2 , & hf_tn5250_dpo_flag1_3 , & hf_tn5250_dpo_flag1_4 , & hf_tn5250_dpo_flag1_5 , & hf_tn5250_dpo_flag1_6 , & hf_tn5250_dpo_flag1_7 , NULL } ; 60
static const int * dpo_byte2 [ ] = { & hf_tn5250_dpo_flag2_0 , & hf_tn5250_dpo_flag2_reserved , NULL } ; 72
hf_items dpo_fields [ ] = { { & hf_tn5250_dpo_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dpo_flag1 , ett_tn5250_wsf_dpo_mask , 1 , dpo_byte1 , 0 } , { & hf_tn5250_dpo_flag2 , ett_tn5250_wsf_dpo_mask , 1 , dpo_byte2 , 0 } , { & hf_tn5250_dpo_displace_characters , 0 , 3 , 0 , ENC_EBCDIC | ENC_NA } , { & hf_tn5250_dpo_start_location_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dpo_start_location_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 78
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
258 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dpo_byte2'] 72
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dpo_byte2 [ ] = { & hf_tn5250_dpo_flag2_0 , & hf_tn5250_dpo_flag2_reserved , NULL } ; 72
hf_items dpo_fields [ ] = { { & hf_tn5250_dpo_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dpo_flag1 , ett_tn5250_wsf_dpo_mask , 1 , dpo_byte1 , 0 } , { & hf_tn5250_dpo_flag2 , ett_tn5250_wsf_dpo_mask , 1 , dpo_byte2 , 0 } , { & hf_tn5250_dpo_displace_characters , 0 , 3 , 0 , ENC_EBCDIC | ENC_NA } , { & hf_tn5250_dpo_start_location_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dpo_start_location_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 78
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
259 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dpo_byte1'] 60
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * dpo_byte1 [ ] = { & hf_tn5250_dpo_flag1_0 , & hf_tn5250_dpo_flag1_1 , & hf_tn5250_dpo_flag1_2 , & hf_tn5250_dpo_flag1_3 , & hf_tn5250_dpo_flag1_4 , & hf_tn5250_dpo_flag1_5 , & hf_tn5250_dpo_flag1_6 , & hf_tn5250_dpo_flag1_7 , NULL } ; 60
hf_items dpo_fields [ ] = { { & hf_tn5250_dpo_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dpo_flag1 , ett_tn5250_wsf_dpo_mask , 1 , dpo_byte1 , 0 } , { & hf_tn5250_dpo_flag2 , ett_tn5250_wsf_dpo_mask , 1 , dpo_byte2 , 0 } , { & hf_tn5250_dpo_displace_characters , 0 , 3 , 0 , ENC_EBCDIC | ENC_NA } , { & hf_tn5250_dpo_start_location_row , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dpo_start_location_col , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 78
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
260 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'rts_fields'] 52
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * rts_byte1 [ ] = { & hf_tn5250_rts_flag1_0 , & hf_tn5250_rts_flag1_reserved , NULL } ; 46
hf_items rts_fields [ ] = { { & hf_tn5250_rts_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_rts_flag1 , ett_tn5250_wsf_rts_mask , 1 , rts_byte1 , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 52
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
261 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'rts_byte1'] 46
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * rts_byte1 [ ] = { & hf_tn5250_rts_flag1_0 , & hf_tn5250_rts_flag1_reserved , NULL } ; 46
hf_items rts_fields [ ] = { { & hf_tn5250_rts_partition , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_rts_flag1 , ett_tn5250_wsf_rts_mask , 1 , rts_byte1 , 0 } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_reserved , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 52
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
262 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dckf_fields'] 39
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items dckf_fields [ ] = { { & hf_tn5250_dckf_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dckf_key_code , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dckf_function_code , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 39
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
263 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'dawt_fields'] 33
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items dawt_fields [ ] = { { & hf_tn5250_dawt_length , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_dawt_char , 0 , 1 , 0 , ENC_EBCDIC | ENC_NA } , { NULL , 0 , 0 , 0 , 0 } } ; 33
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
264 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'qss_fields'] 27
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * qss_byte1 [ ] = { & hf_tn5250_wsf_qss_flag1_0 , & hf_tn5250_wsf_qss_flag1_reserved , NULL } ; 15
static const int * qss_byte2 [ ] = { & hf_tn5250_wsf_qss_flag2_reserved , & hf_tn5250_wsf_qss_flag2_7 , NULL } ; 21
hf_items qss_fields [ ] = { { & hf_tn5250_wsf_qss_flag1 , ett_tn5250_wsf_qss_mask , 1 , qss_byte1 , 0 } , { & hf_tn5250_wsf_qss_flag2 , ett_tn5250_wsf_qss_mask , 1 , qss_byte2 , 0 } , { NULL , 0 , 0 , 0 , 0 } } ; 27
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
265 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'qss_byte2'] 21
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * qss_byte2 [ ] = { & hf_tn5250_wsf_qss_flag2_reserved , & hf_tn5250_wsf_qss_flag2_7 , NULL } ; 21
hf_items qss_fields [ ] = { { & hf_tn5250_wsf_qss_flag1 , ett_tn5250_wsf_qss_mask , 1 , qss_byte1 , 0 } , { & hf_tn5250_wsf_qss_flag2 , ett_tn5250_wsf_qss_mask , 1 , qss_byte2 , 0 } , { NULL , 0 , 0 , 0 , 0 } } ; 27
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
266 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'qss_byte1'] 15
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
static const int * qss_byte1 [ ] = { & hf_tn5250_wsf_qss_flag1_0 , & hf_tn5250_wsf_qss_flag1_reserved , NULL } ; 15
hf_items qss_fields [ ] = { { & hf_tn5250_wsf_qss_flag1 , ett_tn5250_wsf_qss_mask , 1 , qss_byte1 , 0 } , { & hf_tn5250_wsf_qss_flag2 , ett_tn5250_wsf_qss_mask , 1 , qss_byte2 , 0 } , { NULL , 0 , 0 , 0 , 0 } } ; 27
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
267 /home/SySeVR/data/CVE_2014_8714_PATCHED_dissect_write_structured_field.c [u'standard_fields'] 8
static guint32
CVE_2014_8714_PATCHED_dissect_write_structured_field(proto_tree *tn5250_tree, tvbuff_t *tvb, gint offset) 2
hf_items standard_fields [ ] = { { & hf_tn5250_sf_length , 0 , 2 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_sf_class , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { & hf_tn5250_sf_type , 0 , 1 , 0 , ENC_BIG_ENDIAN } , { NULL , 0 , 0 , 0 , 0 } } ; 8
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 && ! done )  321
sf_length = tvb_get_ntohs ( tvb , offset ); 322
type = tvb_get_guint8 ( tvb , offset + 3 ); 323
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , standard_fields ); 325
switch ( type )  327
proto_tree_add_item ( tn5250_tree , hf_tn5250_field_data , tvb , offset , ( sf_length - ( start + offset ) ) , ENC_EBCDIC | ENC_NA ); 329
offset += ( guint32 ) ( sf_length - ( start + offset ) ); 331
proto_tree_add_item ( tn5250_tree , hf_tn5250_reserved , tvb , offset , 1 , ENC_BIG_ENDIAN ); 334
offset ++; 336
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , qss_fields ); 339
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 342
while ( ( offset - start ) < sf_length )  344
length = tvb_get_guint8 ( tvb , offset ); 345
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dawt_fields ); 346
proto_tree_add_item ( tn5250_tree , hf_tn5250_dawt_message , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 347
offset += length; 349
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 353
while ( ( offset - start ) < sf_length )  355
length = tvb_get_guint8 ( tvb , offset ); 356
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dckf_fields ); 357
proto_tree_add_item ( tn5250_tree , hf_tn5250_dckf_prompt_text , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 359
offset += length; 361
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , rts_fields ); 365
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dpo_fields ); 368
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dtsf_fields ); 371
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields ); 374
while ( ( offset - start ) < sf_length )  375
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsl_fields2 ); 378
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_fields ); 382
length = tvb_get_guint8 ( tvb , offset ); 384
used = tn5250_add_hf_items ( tn5250_tree , tvb , offset , wts_line_data_fields ); 385
offset += used; 387
proto_tree_add_item ( tn5250_tree , hf_tn5250_wts_cld_li , tvb , offset , ( length - used ) , ENC_EBCDIC | ENC_NA ); 388
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dsc_fields ); 392
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 396
while ( ( offset - start ) < sf_length )  398
length = tvb_get_guint8 ( tvb , offset ); 399
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dorm_fields ); 400
proto_tree_add_item ( tn5250_tree , hf_tn5250_dorm_mt , tvb , offset , ( length - 2 ) , ENC_EBCDIC | ENC_NA ); 402
offset += length; 404
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_id , tvb , offset , 1 , ENC_BIG_ENDIAN ); 408
while ( ( offset - start ) < sf_length )  410
length = tvb_get_guint8 ( tvb , offset ); 411
proto_tree_add_item ( tn5250_tree , hf_tn5250_length , tvb , offset , 1 , ENC_BIG_ENDIAN ); 412
if ( length == 0 )  414
proto_tree_add_item ( tn5250_tree , hf_tn5250_dpt_ec , tvb , offset , length , ENC_EBCDIC | ENC_NA ); 416
offset += length; 418
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_fields ); 422
while ( ( offset - start ) < sf_length )  424
length = tvb_get_guint8 ( tvb , offset ); 425
type = tvb_get_guint8 ( tvb , offset + 1 ); 426
if ( type == CORE_AREA_COMMAND_KEYS )  427
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_core_area_fields ); 428
if ( type == TOP_ROW_COMMAND_KEYS )  430
offset += tn5250_add_hf_items ( tn5250_tree , tvb , offset , dfdpck_top_row_fields ); 431
step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ); 436
if ( step == 0 )  437
offset += step; 439
offset += dissect_unknown_data ( tn5250_tree , tvb , offset , start , sf_length ); 449
return ( offset - start ) ; 451
------------------------------
268 /home/SySeVR/data/CVE_2014_9316_PATCHED_mjpeg_decode_app.c [u'id_str'] 15
static int CVE_2014_9316_PATCHED_mjpeg_decode_app(MJpegDecodeContext *s) 1
int len , id , i ; 3
len = get_bits ( & s -> gb , 16 ); 5
if ( len < 6 )  6
if ( 8 * len > get_bits_left ( & s -> gb ) )  8
if ( s -> avctx -> debug & FF_DEBUG_STARTCODE )  14
char id_str [ 32 ] ; 15
av_get_codec_tag_string ( id_str , sizeof ( id_str ) , av_bswap32 ( id ) ); 16
av_log ( s -> avctx , AV_LOG_DEBUG , "APPx (%s / %8X) len=%d\n" , id_str , id , len ); 17
------------------------------
269 /home/SySeVR/data/CVE_2014_9316_VULN_mjpeg_decode_app.c [u'id_str'] 15
static int CVE_2014_9316_VULN_mjpeg_decode_app(MJpegDecodeContext *s) 1
int len , id , i ; 3
len = get_bits ( & s -> gb , 16 ); 5
if ( len < 6 )  6
if ( 8 * len > get_bits_left ( & s -> gb ) )  8
if ( s -> avctx -> debug & FF_DEBUG_STARTCODE )  14
char id_str [ 32 ] ; 15
av_get_codec_tag_string ( id_str , sizeof ( id_str ) , av_bswap32 ( id ) ); 16
av_log ( s -> avctx , AV_LOG_DEBUG , "APPx (%s / %8X) len=%d\n" , id_str , id , len ); 17
------------------------------
270 /home/SySeVR/data/CVE_2014_9374_PATCHED_AST_OPTIONAL_API_NAME.c [u'buf', u'MAXIMUM_FRAME_SIZE'] 3
int CVE_2014_9374_PATCHED_AST_OPTIONAL_API_NAME(ast_websocket_read)(struct ast_websocket *session, char **payload, uint64_t *payload_len, enum ast_websocket_opcode *opcode, int *fragmented) 1
char buf [ MAXIMUM_FRAME_SIZE ] = "" ; 3
if ( ws_safe_read ( session , & buf [ 0 ] , MIN_WS_HDR_SZ , opcode ) )  13
* opcode = buf [ 0 ] & 0xf; 19
* payload_len = buf [ 1 ] & 0x7f; 20
if ( * opcode == AST_WEBSOCKET_OPCODE_TEXT || * opcode == AST_WEBSOCKET_OPCODE_BINARY || * opcode == AST_WEBSOCKET_OPCODE_CONTINUATION || * opcode == AST_WEBSOCKET_OPCODE_PING || * opcode == AST_WEBSOCKET_OPCODE_PONG )  21
fin = ( buf [ 0 ] >> 7 ) & 1; 23
mask_present = ( buf [ 1 ] >> 7 ) & 1; 24
options_len += mask_present ? 4 : 0; 27
options_len += ( * payload_len == 126 ) ? 2 : ( * payload_len == 127 ) ? 8 : 0; 28
if ( options_len )  29
if ( ws_safe_read ( session , & buf [ frame_size ] , options_len , opcode ) )  31
frame_size += options_len; 34
if ( * payload_len == 126 )  37
* payload_len = ntohs ( get_unaligned_uint16 ( & buf [ 2 ] ) ); 39
mask = & buf [ 4 ]; 40
if ( * payload_len == 127 )  41
* payload_len = ntohl ( get_unaligned_uint64 ( & buf [ 2 ] ) ); 43
mask = & buf [ 10 ]; 44
mask = & buf [ 2 ]; 47
* payload = & buf [ frame_size ]; 51
frame_size = frame_size + ( * payload_len ); 52
if ( frame_size > MAXIMUM_FRAME_SIZE )  53
ast_log ( LOG_WARNING , "Cannot fit huge websocket frame of %zu bytes\n" , frame_size ); 54
if ( ws_safe_read ( session , ( * payload ) , ( * payload_len ) , opcode ) )  60
if ( mask_present )  64
for (pos = 0; pos < *payload_len; pos++) 66
( * payload ) [ pos ] ^= mask [ pos % 4 ]; 67
if ( ( * opcode == AST_WEBSOCKET_OPCODE_PING ) && ( ast_websocket_write ( session , AST_WEBSOCKET_OPCODE_PONG , * payload , * payload_len ) ) )  72
if ( * payload_len )  78
if ( ! ( new_payload = ast_realloc ( session -> payload , ( session -> payload_len + * payload_len ) ) ) )  79
ast_log ( LOG_WARNING , "Failed allocation: %p, %zu, %" PRIu64 "\n" ,
session -> payload , session -> payload_len , * payload_len ) 81
session -> payload = new_payload; 87
memcpy ( ( session -> payload + session -> payload_len ) , ( * payload ) , ( * payload_len ) ); 88
session -> payload_len += * payload_len; 89
if ( ! fin && session -> reconstruct && ( session -> payload_len < session -> reconstruct ) )  95
if ( * opcode != AST_WEBSOCKET_OPCODE_CONTINUATION )  97
session -> opcode = * opcode; 98
* opcode = AST_WEBSOCKET_OPCODE_CONTINUATION; 100
* payload = NULL; 102
if ( * opcode == AST_WEBSOCKET_OPCODE_CONTINUATION )  104
if ( ! fin )  105
* opcode = session -> opcode; 110
* payload_len = session -> payload_len; 113
* payload = session -> payload; 114
if ( * opcode == AST_WEBSOCKET_OPCODE_CLOSE )  117
if ( ( * payload_len ) && ( new_payload = ast_realloc ( session -> payload , * payload_len ) ) )  119
if ( ws_safe_read ( session , & buf [ frame_size ] , ( * payload_len ) , opcode ) )  120
session -> payload = new_payload; 123
memcpy ( session -> payload , & buf [ frame_size ] , * payload_len ); 124
* payload = session -> payload; 125
frame_size += ( * payload_len ); 126
session -> closing = 1; 129
ast_log ( LOG_WARNING , "WebSocket unknown opcode %u\n" , * opcode ); 131
------------------------------
271 /home/SySeVR/data/CVE_2015_0228_VULN_lua_websocket_read.c [u'frame'] 143
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
CVE_2015_0228_VULN_lua_websocket_read ( L ); 148
static int CVE_2015_0228_VULN_lua_websocket_read(lua_State *L) 1
apr_socket_t * sock ; 3
apr_status_t rv ; 4
unsigned short payload_short = 0 ; 8
unsigned char * mask_bytes ; 10
char byte ; 11
int plaintext ; 12
request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; 15
plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1; 16
mask_bytes = apr_pcalloc ( r -> pool , 4 ); 19
sock = ap_get_conn_socket ( r -> connection ); 20
if ( plaintext )  23
rv = apr_socket_recv ( sock , & byte , & len ); 24
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 27
if ( rv == APR_SUCCESS )  29
unsigned char fin , opcode , mask , payload ; 30
opcode = ( byte << 4 ) >> 4; 32
if ( plaintext )  35
rv = apr_socket_recv ( sock , & byte , & len ); 36
rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ); 39
if ( rv == APR_SUCCESS )  41
mask = byte >> 7; 42
payload = byte - 128; 43
plen = payload; 44
if ( payload == 126 )  47
len = 2; 48
if ( plaintext )  49
rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ); 50
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ); 53
payload_short = ntohs ( payload_short ); 56
if ( rv == APR_SUCCESS )  58
plen = payload_short; 59
if ( payload == 127 )  66
len = 8; 67
if ( plaintext )  68
rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ); 69
rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ); 72
if ( rv == APR_SUCCESS )  75
plen = ap_ntoh64 ( & payload_long ); 76
if ( mask )  88
len = 4; 89
if ( plaintext )  90
rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ); 91
rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ); 94
if ( rv != APR_SUCCESS )  97
if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 )  101
if ( opcode == 0x09 )  142
char frame [ 2 ] ; 143
frame [ 0 ] = 0x8A; 145
frame [ 1 ] = 0; 146
apr_socket_send ( sock , frame , & plen ); 147
------------------------------
272 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'newDistDir'] 825
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
NS_tchar newDistDir [ MAXPATHLEN ] ; 825
NS_tsnprintf ( newDistDir , sizeof ( newDistDir ) / sizeof ( newDistDir [ 0 ] ) , NS_T ( "%s/Contents/Resources/distribution" ) , gInstallDirPath ); 826
rv = NS_taccess ( newDistDir , F_OK ); 828
if ( ! rv )  829
if ( rv )  833
LOG ( ( "Removing old distribution directory failed - err: %d" , rv ) ); 834
LOG ( ( "Moving old distribution directory to new location. src: " LOG_S
", dst:" LOG_S , oldDistDir , newDistDir ) ) 838
rv = rename_file ( oldDistDir , newDistDir , true ); 839
if ( rv )  840
LOG ( ( "Moving old distribution directory to new location failed - "
"err: %d" , rv ) ) 842
------------------------------
273 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'oldDistDir'] 820
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldDistDir [ MAXPATHLEN ] ; 820
NS_tsnprintf ( oldDistDir , sizeof ( oldDistDir ) / sizeof ( oldDistDir [ 0 ] ) , NS_T ( "%s/Contents/MacOS/distribution" ) , gInstallDirPath ); 821
int rv = NS_taccess ( oldDistDir , F_OK ) ; 823
if ( ! rv )  824
LOG ( ( "New distribution directory already exists... removing old "
"distribution directory: " LOG_S , oldDistDir ) ) 831
rv = ensure_remove_recursive ( oldDistDir ); 832
if ( rv )  833
LOG ( ( "Removing old distribution directory failed - err: %d" , rv ) ); 834
LOG ( ( "Moving old distribution directory to new location. src: " LOG_S
", dst:" LOG_S , oldDistDir , newDistDir ) ) 838
rv = rename_file ( oldDistDir , newDistDir , true ); 839
if ( rv )  840
LOG ( ( "Moving old distribution directory to new location failed - "
"err: %d" , rv ) ) 842
------------------------------
274 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'oldPrecomplete'] 815
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
NS_tchar * targetPath = argv [ callbackIndex ] ; 621
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
if ( sReplaceRequest )  624
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
if ( ! sReplaceRequest )  667
const int max_retries = 10 ; 701
int retries = 1 ; 702
DWORD lastWriteError = 0 ; 703
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
lastWriteError = GetLastError ( ); 716
while ( ++ retries <= max_retries )  722
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( lastWriteError != ERROR_SHARING_VIOLATION )  727
if ( gSucceeded && ! sStagedUpdate )  814
NS_tchar oldPrecomplete [ MAXPATHLEN ] ; 815
NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath ); 816
NS_tremove ( oldPrecomplete ); 818
------------------------------
275 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'installDir'] 643
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
if ( sReplaceRequest )  624
NS_tchar installDir [ MAXPATHLEN ] ; 643
NS_tstrcpy ( installDir , gInstallDirPath ); 644
size_t callbackPrefixLength = PathCommonPrefixW ( argv [ callbackIndex ] , installDir , nullptr ) ; 645
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
------------------------------
276 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'buffer'] 622
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ; 622
NS_tchar * p = buffer ; 630
NS_tstrncpy ( p , argv [ callbackIndex ] , commonPrefixLength ); 631
p += commonPrefixLength; 632
NS_tstrncpy ( p , gInstallDirPath + commonPrefixLength , bufferLeft ); 634
p += len; 637
* p = NS_T ( '\\' ); 639
* p = NS_T ( '\0' ); 642
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
targetPath = buffer; 649
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
LOG ( ( "CVE_2015_0833_PATCHED_NS_main: unable to find callback file: " LOG_S , targetPath ) ) 653
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr ); 708
if ( callbackFile != INVALID_HANDLE_VALUE )  713
if ( callbackFile == INVALID_HANDLE_VALUE )  725
if ( callbackFile != INVALID_HANDLE_VALUE )  776
CloseHandle ( callbackFile ); 777
------------------------------
277 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'callbackLongPath'] 619
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
if ( argc > callbackIndex )  613
NS_tchar callbackLongPath [ MAXPATHLEN ] ; 619
ZeroMemory ( callbackLongPath , sizeof ( callbackLongPath ) ); 620
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )  651
NS_tchar * s = callbackLongPath ; 669
s += len; 673
if ( * s == NS_T ( '\\' ) )  674
if ( * s == NS_T ( '\\' ) )  680
* d = * s; 683
while ( * s )  686
* d = NS_T ( '\0' ); 687
------------------------------
278 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'applyDirLongPath'] 598
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 48
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' ); 117
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
GonkAutoMounter mounter ; 544
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )  545
if ( ! sReplaceRequest )  556
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  558
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ; 560
if ( rv == OK && errno != EEXIST )  561
if ( NS_tchdir ( gWorkingDirPath ) != 0 )  563
if ( ! sReplaceRequest )  577
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ; 580
if ( ! destpath )  581
NS_tchar applyDirLongPath [ MAXPATHLEN ] ; 598
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )  599
int len = NS_tstrlen ( applyDirLongPath ) ; 668
s += len; 673
if ( * s == NS_T ( '\\' ) )  674
if ( * s == NS_T ( '\\' ) )  680
* d = * s; 683
while ( * s )  686
* d = NS_T ( '\0' ); 687
------------------------------
279 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'maintenanceServiceKey'] 370
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ; 57
useService = IsUpdateStatusPendingService ( ); 63
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( ); 67
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
HANDLE elevatedFileHandle ; 326
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
wchar_t * cmdLine = MakeCommandLine ( argc - 1 , argv + 1 ) ; 340
if ( ! cmdLine )  341
if ( useService )  349
BOOL isLocal = FALSE ; 350
useService = IsLocalFile ( argv [ 0 ] , isLocal ) && isLocal; 351
if ( useService )  360
BOOL unpromptedElevation ; 361
if ( IsUnpromptedElevation ( unpromptedElevation ) )  362
useService = ! unpromptedElevation; 363
if ( useService )  369
WCHAR maintenanceServiceKey [ MAX_PATH + 1 ] ; 370
if ( CalculateRegistryPathFromFilePath ( gInstallDirPath , maintenanceServiceKey ) )  371
if ( RegOpenKeyExW ( HKEY_LOCAL_MACHINE , maintenanceServiceKey , 0 , KEY_READ | KEY_WOW64_64KEY , & baseKey ) == ERROR_SUCCESS )  373
------------------------------
280 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'installDir'] 259
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
if ( sStagedUpdate )  250
if ( sReplaceRequest )  256
NS_tchar installDir [ MAXPATHLEN ] ; 259
NS_tstrcpy ( installDir , gInstallDirPath ); 260
NS_tchar * slash = ( NS_tchar * ) NS_tstrrchr ( installDir , NS_SLASH ) ; 261
* slash = NS_T ( '\0' ); 262
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
NS_tstrcpy ( installDir , gInstallDirPath ); 644
------------------------------
281 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'updateLockFilePath'] 249
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
sStagedUpdate = true; 104
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
const int callbackIndex = 6 ; 231
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr; 234
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )  247
NS_tchar updateLockFilePath [ MAXPATHLEN ] ; 249
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s/updated.update_in_progress.lock" ) , gInstallDirPath ); 253
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ); 263
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ); 269
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )  277
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 290
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )  318
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  442
CloseHandle ( updateLockFileHandle ); 443
if ( ! useService && ! noServiceFallback && updateLockFileHandle == INVALID_HANDLE_VALUE )  473
if ( ! useService && ! noServiceFallback && INVALID_HANDLE_VALUE == updateLockFileHandle )  505
if ( updateLockFileHandle != INVALID_HANDLE_VALUE )  514
CloseHandle ( updateLockFileHandle ); 515
CloseHandle ( updateLockFileHandle ); 524
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 604
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 656
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 738
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 869
------------------------------
282 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'MAXPATHLEN', u'elevatedLockFilePath'] 246
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ; 246
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath ); 298
bool startedFromUnelevatedUpdater = GetFileAttributesW ( elevatedLockFilePath ) != INVALID_FILE_ATTRIBUTES ; 303
if ( startedFromUnelevatedUpdater )  312
if ( ! _waccess ( elevatedLockFilePath , F_OK ) && NS_tremove ( elevatedLockFilePath ) != 0 )  320
elevatedFileHandle = CreateFileW ( elevatedLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr ); 327
if ( elevatedFileHandle == INVALID_HANDLE_VALUE )  335
CloseHandle ( elevatedFileHandle ); 342
CloseHandle ( elevatedFileHandle ); 503
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 604
size_t bufferLeft = MAXPATHLEN * 2 ; 623
bufferLeft -= commonPrefixLength; 633
NS_tstrncpy ( p , gInstallDirPath + commonPrefixLength , bufferLeft ); 634
bufferLeft -= len; 638
bufferLeft --; 641
NS_tstrncpy ( p , argv [ callbackIndex ] + std :: max ( callbackPrefixLength , commonPrefixLength ) , bufferLeft ); 648
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 656
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 1 ); 738
EXIT_WHEN_ELEVATED ( elevatedLockFilePath , updateLockFileHandle , 0 ); 869
------------------------------
283 /home/SySeVR/data/CVE_2015_0833_PATCHED_NS_main.c [u'tmpDir'] 221
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv) 1
if ( argc < 4 )  36
__int64 pid = 0 ; 91
if ( argc > 4 )  95
pid = _wtoi64 ( argv [ 4 ] ); 97
if ( pid == - 1 )  101
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )  105
sReplaceRequest = true; 108
if ( ! WriteStatusFile ( "applying" ) )  149
if ( pid > 0 )  194
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ; 195
if ( parent )  199
updateFromMetro = IsUpdateFromMetro ( argc , argv ); 202
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ; 204
DWORD result = WaitForSingleObject ( parent , waitTime ) ; 206
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )  208
if ( sReplaceRequest )  217
NS_tchar tmpDir [ MAXPATHLEN ] ; 221
if ( GetTempPathW ( MAXPATHLEN , tmpDir ) )  222
NS_tchdir ( tmpDir ); 223
------------------------------
284 /home/SySeVR/data/CVE_2015_0833_VULN_UpdateThreadFunc.c [u'updatingDir'] 46
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
MARChannelStringTable MARStrings ; 26
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
MARStrings . MARChannelID [ 0 ] = '\0'; 30
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION ); 33
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
rv = CopyInstallDirToDestDir ( ); 40
if ( rv == OK )  43
NS_tchar updatingDir [ MAXPATHLEN ] ; 46
NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath ); 47
ensure_remove_recursive ( updatingDir ); 49
------------------------------
285 /home/SySeVR/data/CVE_2015_0833_VULN_UpdateThreadFunc.c [u'updateSettingsPath'] 22
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
int rv ; 5
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
rv = gArchiveReader . VerifySignature ( ); 17
if ( rv == OK )  20
if ( rv == OK )  21
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ; 22
NS_tsnprintf ( updateSettingsPath , sizeof ( updateSettingsPath ) / sizeof ( updateSettingsPath [ 0 ] ) , NS_T ( "%s/update-settings.ini" ) , gWorkingDirPath ); 23
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )  27
------------------------------
286 /home/SySeVR/data/CVE_2015_0833_VULN_UpdateThreadFunc.c [u'dataFile'] 9
static void
CVE_2015_0833_VULN_UpdateThreadFunc(void *param) 2
if ( sReplaceRequest )  6
NS_tchar dataFile [ MAXPATHLEN ] ; 9
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) ); 10
if ( rv == OK )  11
rv = gArchiveReader . Open ( dataFile ); 12
if ( rv == OK )  16
if ( rv == OK )  20
if ( rv == OK )  21
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )  39
if ( rv == OK )  43
if ( sReplaceRequest && rv && ! getenv ( "MOZ_NO_REPLACE_FALLBACK" ) )  54
if ( rv )  73
LOG ( ( "failed: %d" , rv ) ); 74
WriteStatusFile ( rv ); 88
------------------------------
287 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c [u'super', u'mimetype', u'type'] 13
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
char super [ MIME_MAX_SUPER ] , type [ MIME_MAX_TYPE ] , mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 13
if ( sscanf ( format -> values [ 0 ] . string . text , "%15[^/]/%255[^;]" , super , type ) != 2 )  92
if ( sscanf ( default_format , "%15[^/]/%255[^;]" , super , type ) != 2 )  109
strlcpy ( super , "application" , sizeof ( super ) ); 123
strlcpy ( type , "octet-stream" , sizeof ( type ) ); 124
if ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) )  127
filetype = mimeType ( MimeDatabase , super , type ); 144
cupsdLogMessage ( CUPSD_LOG_INFO , "[Job ???] Request file type is %s/%s." , filetype -> super , filetype -> type ); 146
filetype = mimeType ( MimeDatabase , super , type ); 150
if ( filetype && ( ! format || ( ! strcmp ( super , "application" ) && ! strcmp ( type , "octet-stream" ) ) ) )  152
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 161
ippSetString ( con -> request , & format , 0 , mimetype ); 165
ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 167
if ( ! filetype )  170
if ( ! _cups_strcasecmp ( filetype -> super , "application" ) && ( ! _cups_strcasecmp ( filetype -> type , "postscript" ) || ! _cups_strcasecmp ( filetype -> type , "pdf" ) ) )  190
if ( ( job = add_job ( con , printer , filetype ) ) == NULL )  199
cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ); 211
job -> koctets += kbytes; 213
if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL )  215
attr -> values [ 0 ] . integer += kbytes; 216
if ( add_file ( con , job , filetype , compression ) )  222
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
if ( cupsdTimeoutJob ( job ) )  234
cupsdLogJob ( job , CUPSD_LOG_INFO , "File of type %s/%s queued by \"%s\"." , filetype -> super , filetype -> type , job -> username ); 241
cupsdLogJob ( job , CUPSD_LOG_DEBUG , "hold_until=%d" , ( int ) job -> hold_until ); 244
cupsdLogJob ( job , CUPSD_LOG_INFO , "Queued on \"%s\" by \"%s\"." , job -> dest , job -> username ); 245
------------------------------
288 /home/SySeVR/data/CVE_2015_1158_PATCHED_print_job.c [u'filename'] 11
static void
CVE_2015_1158_PATCHED_print_job(cupsd_client_t  *con,		/* I - Client connection */
ipp_attribute_t *uri)		/* I - Printer URI */ 6
char filename [ 1024 ] ; 11
snprintf ( filename , sizeof ( filename ) , "%s/d%05d-%03d" , RequestRoot , job -> id , job -> num_files ); 225
rename ( con -> filename , filename ); 227
------------------------------
289 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c [u'mimetype'] 149
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
http_status_t status ; 8
ipp_attribute_t * attr , * auth_info ; 9
const char * mandatory ; 11
int i ; 17
static const char * const readonly [ ] = 23
if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) )  47
auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ); 60
if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK )  62
if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] )  67
if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) )  75
if ( ! printer -> accepting )  91
for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) 105
if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL )  107
if ( StrictConformance )  112
if ( printer -> pc )  126
for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
mandatory;
mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) 130
if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) )  132
if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) )  146
char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; 149
snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ); 153
send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported format \"%s\"." ) , mimetype ); 156
ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ); 159
------------------------------
290 /home/SySeVR/data/CVE_2015_1158_VULN_add_job.c [u'job_uri'] 15
static cupsd_job_t *			/* O - Job object */
CVE_2015_1158_VULN_add_job(cupsd_client_t  *con,		/* I - Client connection */
cupsd_printer_t *printer,	/* I - Destination printer */
mime_type_t     *filetype)	/* I - First print file type, if any */ 7
char job_uri [ HTTP_MAX_URI ] ; 15
httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , "ipp" , NULL , con -> clientname , con -> clientport , "/jobs/%d" , job -> id ); 710
ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , "job-uri" , NULL , job_uri ); 712
------------------------------
291 /home/SySeVR/data/CVE_2015_1158_VULN_authenticate_job.c [u'username', u'scheme', u'resource', u'host'] 11
static void
CVE_2015_1158_VULN_authenticate_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job URI */ 6
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 11
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 57
if ( strncmp ( resource , "/jobs/" , 6 ) )  61
jobid = atoi ( resource + 6 ); 72
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  79
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 85
if ( job -> state_value != IPP_JOB_HELD )  93
send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Job #%d is not held for authentication." ) , jobid ); 99
printer = cupsdFindDest ( job -> dest ); 120
if ( printer && printer -> num_auth_info_required > 0 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) )  122
send_http_error ( con , HTTP_UNAUTHORIZED , printer ); 124
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  135
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 137
save_auth_info ( con , job , auth_info ); 146
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  152
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 154
if ( attr )  156
attr -> value_tag = IPP_TAG_KEYWORD; 158
cupsdSetString ( & ( attr -> values [ 0 ] . string . text ) , "no-hold" ); 159
cupsdReleaseJob ( job ); 166
cupsdAddEvent ( CUPSD_EVENT_JOB_STATE , NULL , job , "Job authenticated by user" ); 168
cupsdLogJob ( job , CUPSD_LOG_INFO , "Authenticated by \"%s\"." , con -> username ); 170
------------------------------
292 /home/SySeVR/data/CVE_2015_1158_VULN_release_job.c [u'username', u'scheme', u'resource', u'host'] 9
static void
CVE_2015_1158_VULN_release_job(cupsd_client_t  *con,	/* I - Client connection */
ipp_attribute_t *uri)	/* I - Job or Printer URI */ 6
char scheme [ HTTP_MAX_URI ] , username [ HTTP_MAX_URI ] , host [ HTTP_MAX_URI ] , resource [ HTTP_MAX_URI ] ; 9
httpSeparateURI ( HTTP_URI_CODING_ALL , uri -> values [ 0 ] . string . text , scheme , sizeof ( scheme ) , username , sizeof ( username ) , host , sizeof ( host ) , & port , resource , sizeof ( resource ) ); 46
if ( strncmp ( resource , "/jobs/" , 6 ) )  50
jobid = atoi ( resource + 6 ); 61
if ( ( job = cupsdFindJob ( jobid ) ) == NULL )  68
send_ipp_status ( con , IPP_NOT_FOUND , _ ( "Job #%d does not exist." ) , jobid ); 74
if ( job -> state_value != IPP_JOB_HELD )  82
send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Job #%d is not held." ) , jobid ); 88
if ( ! validate_user ( job , con , job -> username , username , sizeof ( username ) ) )  96
send_http_error ( con , con -> username [ 0 ] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED , cupsdFindDest ( job -> dest ) ); 98
if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL )  107
attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ); 109
if ( attr )  111
_cupsStrFree ( attr -> values [ 0 ] . string . text ); 113
attr -> value_tag = IPP_TAG_KEYWORD; 115
attr -> values [ 0 ] . string . text = _cupsStrAlloc ( "no-hold" ); 116
cupsdAddEvent ( CUPSD_EVENT_JOB_CONFIG_CHANGED , cupsdFindDest ( job -> dest ) , job , "Job job-hold-until value changed by user." ); 118
ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ); 120
cupsdReleaseJob ( job ); 127
cupsdAddEvent ( CUPSD_EVENT_JOB_STATE , cupsdFindDest ( job -> dest ) , job , "Job released by user." ); 129
cupsdLogJob ( job , CUPSD_LOG_INFO , "Released by \"%s\"." , username ); 132
------------------------------
293 /home/SySeVR/data/CVE_2015_2666_PATCHED_get_matching_model_microcode.c [u'mc_saved_tmp'] 13
static enum ucode_state __init
CVE_2015_2666_PATCHED_get_matching_model_microcode(int cpu, unsigned long start,
void *data, size_t size,
struct mc_saved_data *mc_saved_data,
unsigned long *mc_saved_in_initrd,
struct ucode_cpu_info *uci) 6
struct microcode_intel * mc_saved_tmp [ MAX_UCODE_COUNT ] ; 13
while ( leftover && mc_saved_count < ARRAY_SIZE ( mc_saved_tmp ) )  17
_save_mc ( mc_saved_tmp , ucode_ptr , & mc_saved_count ); 38
mc_saved_in_initrd [ i ] = ( unsigned long ) mc_saved_tmp [ i ] - start; 54
------------------------------
294 /home/SySeVR/data/CVE_2015_2666_VULN_get_matching_model_microcode.c [u'mc_saved_tmp'] 13
static enum ucode_state __init
CVE_2015_2666_VULN_get_matching_model_microcode(int cpu, unsigned long start,
void *data, size_t size,
struct mc_saved_data *mc_saved_data,
unsigned long *mc_saved_in_initrd,
struct ucode_cpu_info *uci) 6
struct microcode_intel * mc_saved_tmp [ MAX_UCODE_COUNT ] ; 13
_save_mc ( mc_saved_tmp , ucode_ptr , & mc_saved_count ); 38
mc_saved_in_initrd [ i ] = ( unsigned long ) mc_saved_tmp [ i ] - start; 54
------------------------------
295 /home/SySeVR/data/CVE_2015_3008_VULN_handle_tcptls_connection.c [u'err'] 7
static void *CVE_2015_3008_VULN_handle_tcptls_connection(void *data) 1
char err [ 256 ] ; 7
ast_verb ( 2 , "Problem setting up ssl connection: %s\n" , ERR_error_string ( ERR_get_error ( ) , err ) ); 45
------------------------------
296 /home/SySeVR/data/CVE_2015_3331_PATCHED___driver_rfc4106_decrypt.c [u'iv_and_authTag'] 12
static int CVE_2015_3331_PATCHED___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
* ( iv + i ) = ctx -> nonce [ i ]; 30
for (i = 0; i < 8; i++) 31
* ( iv + 4 + i ) = req -> iv [ i ]; 32
* ( ( __be32 * ) ( iv + 12 ) ) = counter; 33
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
297 /home/SySeVR/data/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c [u'iv_and_authTag'] 12
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req) 1
u8 iv_and_authTag [ 32 + AESNI_ALIGN ] ; 12
u8 * iv = ( u8 * ) PTR_ALIGN ( ( u8 * ) iv_and_authTag , AESNI_ALIGN ) ; 13
u8 * authTag = iv + 16 ; 14
* ( iv + i ) = ctx -> nonce [ i ]; 30
for (i = 0; i < 8; i++) 31
* ( iv + 4 + i ) = req -> iv [ i ]; 32
* ( ( __be32 * ) ( iv + 12 ) ) = counter; 33
aesni_gcm_dec ( aes_ctx , dst , src , tempCipherLen , iv , ctx -> hash_subkey , assoc , ( unsigned long ) req -> assoclen , authTag , auth_tag_len ); 59
retval = memcmp ( src + tempCipherLen , authTag , auth_tag_len ) ? - EBADMSG : 0; 64
return retval ; 80
------------------------------
298 /home/SySeVR/data/CVE_2015_3811_PATCHED_wcp_uncompress.c [u'src_buf'] 13
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
src += 3; 87
data_cnt = ( * src >> 4 ) + 1; 96
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
src += 2; 106
if ( data_offset + 1 > buf_ptr -> initialized )  109
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data offset exceeds valid window size (%d > %d)" , data_offset + 1 , buf_ptr -> initialized ); 110
if ( data_offset + 1 < data_cnt )  116
expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data count exceeds offset (%d > %d)" , data_cnt , data_offset + 1 ); 117
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_ptr ); 123
if ( dst == NULL )  126
* dst = * src; 153
if ( dst ++ == buf_end )  154
comp_flag_bits <<= 1; 164
comp_flag_bits = * src ++; 172
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 174
buf_ptr -> buf_cur = dst; 200
------------------------------
299 /home/SySeVR/data/CVE_2015_3811_VULN_wcp_uncompress.c [u'src_buf'] 13
static tvbuff_t *CVE_2015_3811_VULN_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree) 1
guint8 src_buf [ MAX_WCP_BUF_LEN ] ; 13
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ); 40
if ( comp_flag_bits & 0x80 )  53
data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK; 62
if ( ( * src & 0xf0 ) == 0x10 )  63
data_cnt = * ( src + 2 ) + 1; 76
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 81
src += 3; 87
data_cnt = ( * src >> 4 ) + 1; 96
proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ); 101
proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ); 103
src += 2; 106
dst = decompressed_entry ( dst , data_offset , data_cnt , & len , buf_start , buf_end ); 110
if ( dst == NULL )  113
* dst = * src; 140
if ( dst ++ == buf_end )  141
comp_flag_bits <<= 1; 149
comp_flag_bits = * src ++; 157
proto_tree_add_uint ( cd_tree , hf_wcp_comp_bits , src_tvb , offset , 1 , comp_flag_bits ); 159
buf_ptr -> buf_cur = dst; 185
------------------------------
300 /home/SySeVR/data/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'dstStride'] 2
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
dstY += 2 * dstStride [ 0 ]; 35
dstU += dstStride [ 1 ]; 36
dstV += dstStride [ 1 ]; 37
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
dstY += 2 * dstStride [ 0 ]; 42
dstU += dstStride [ 1 ]; 43
dstV += dstStride [ 1 ]; 44
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
------------------------------
301 /home/SySeVR/data/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'dst'] 2
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
uint8_t * dstY = dst [ 0 ] ; 5
uint8_t * dstU = dst [ 1 ] ; 6
uint8_t * dstV = dst [ 2 ] ; 7
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
dstY += 2 * dstStride [ 0 ]; 35
dstU += dstStride [ 1 ]; 36
dstV += dstStride [ 1 ]; 37
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
dstY += 2 * dstStride [ 0 ]; 42
dstU += dstStride [ 1 ]; 43
dstV += dstStride [ 1 ]; 44
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
------------------------------
302 /home/SySeVR/data/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'srcStride'] 1
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
srcPtr += 2 * srcStride [ 0 ]; 34
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
srcPtr += 2 * srcStride [ 0 ]; 41
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
------------------------------
303 /home/SySeVR/data/CVE-2016-2328_VULN_bayer_to_yv12_wrapper.c [u'src'] 1
static int bayer_to_yv12_wrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,
int srcSliceH, uint8_t* dst[], int dstStride[]) 2
const uint8_t * srcPtr = src [ 0 ] ; 4
void ( * copy ) ( const uint8_t * src , int src_stride , uint8_t * dstY , uint8_t * dstU , uint8_t * dstV , int luma_stride , int width , int32_t * rgb2yuv )
void ( * interpolate ) ( const uint8_t * src , int src_stride , uint8_t * dstY , uint8_t * dstU , uint8_t * dstV , int luma_stride , int width , int32_t * rgb2yuv ) 10
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 33
srcPtr += 2 * srcStride [ 0 ]; 34
interpolate ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 40
srcPtr += 2 * srcStride [ 0 ]; 41
copy ( srcPtr , srcStride [ 0 ] , dstY , dstU , dstV , dstStride [ 0 ] , c -> srcW , c -> input_rgb2yuv_table ); 47
------------------------------
304 /home/SySeVR/data/CVE_2011_3936_PATCHED_dv_extract_audio.c [u'ppcm'] 1
static int CVE_2011_3936_PATCHED_dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],
const DVprofile *sys) 2
pcm = ppcm [ ipcm ++ ]; 30
if ( ! pcm )  31
pcm = ppcm [ ipcm ++ ]; 39
if ( ! pcm )  40
pcm [ of * 2 ] = frame [ d + 1 ]; 52
pcm [ of * 2 + 1 ] = frame [ d ]; 53
if ( pcm [ of * 2 + 1 ] == 0x80 && pcm [ of * 2 ] == 0x00 )  54
pcm [ of * 2 + 1 ] = 0; 55
pcm [ of * 2 ] = lc & 0xff; 68
pcm [ of * 2 + 1 ] = lc >> 8; 69
pcm [ of * 2 ] = rc & 0xff; 72
pcm [ of * 2 + 1 ] = rc >> 8; 73
------------------------------
305 /home/SySeVR/data/CVE_2011_3936_VULN_dv_extract_audio.c [u'ppcm'] 1
static int CVE_2011_3936_VULN_dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],
const DVprofile *sys) 2
pcm = ppcm [ ipcm ++ ]; 26
pcm = ppcm [ ipcm ++ ]; 35
if ( ! pcm )  36
pcm [ of * 2 ] = frame [ d + 1 ]; 48
pcm [ of * 2 + 1 ] = frame [ d ]; 49
if ( pcm [ of * 2 + 1 ] == 0x80 && pcm [ of * 2 ] == 0x00 )  50
pcm [ of * 2 + 1 ] = 0; 51
pcm [ of * 2 ] = lc & 0xff; 64
pcm [ of * 2 + 1 ] = lc >> 8; 65
pcm [ of * 2 ] = rc & 0xff; 68
pcm [ of * 2 + 1 ] = rc >> 8; 69
pcm = ppcm [ ipcm ++ ]; 79
if ( ! pcm )  80
------------------------------
306 /home/SySeVR/data/CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric.c [u'parameter'] 1
void CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
float y = parameter [ 0 ] ; 6
a = parameter [ 1 ]; 15
b = parameter [ 2 ]; 16
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 20
a = parameter [ 1 ]; 22
b = parameter [ 2 ]; 23
e = parameter [ 3 ]; 25
f = parameter [ 3 ]; 26
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 27
a = parameter [ 1 ]; 29
b = parameter [ 2 ]; 30
c = parameter [ 3 ]; 31
e = - c; 32
interval = parameter [ 4 ]; 34
a = parameter [ 1 ]; 36
b = parameter [ 2 ]; 37
c = parameter [ 3 ]; 38
e = parameter [ 5 ] - c; 39
f = parameter [ 6 ]; 40
interval = parameter [ 4 ]; 41
if ( X >= interval )  52
gamma_table [ X ] = clamp_float ( pow ( a * X / 255. + b , y ) + c + e ); 56
gamma_table [ X ] = clamp_float ( c * X / 255. + f ); 58
------------------------------
307 /home/SySeVR/data/CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric.c [u'gamma_table'] 1
void CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
gamma_table [ X ] = clamp_float ( pow ( a * X / 255. + b , y ) + c + e ); 56
gamma_table [ X ] = clamp_float ( c * X / 255. + f ); 58
------------------------------
308 /home/SySeVR/data/CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric.c [u'parameter'] 1
void CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
float y = parameter [ 0 ] ; 6
a = parameter [ 1 ]; 15
b = parameter [ 2 ]; 16
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 20
a = parameter [ 1 ]; 22
b = parameter [ 2 ]; 23
e = parameter [ 3 ]; 25
f = parameter [ 3 ]; 26
interval = - 1 * parameter [ 2 ] / parameter [ 1 ]; 27
a = parameter [ 1 ]; 29
b = parameter [ 2 ]; 30
c = parameter [ 3 ]; 31
e = - c; 32
interval = parameter [ 4 ]; 34
a = parameter [ 1 ]; 36
b = parameter [ 2 ]; 37
c = parameter [ 3 ]; 38
e = parameter [ 5 ] - c; 39
f = parameter [ 6 ]; 40
interval = parameter [ 4 ]; 41
if ( X >= interval )  52
gamma_table [ X ] = pow ( a * X / 255. + b , y ) + c + e; 56
gamma_table [ X ] = c * X / 255. + f; 58
------------------------------
309 /home/SySeVR/data/CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric.c [u'gamma_table'] 1
void CVE_2012_1960_VULN_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count) 1
gamma_table [ X ] = pow ( a * X / 255. + b , y ) + c + e; 56
gamma_table [ X ] = c * X / 255. + f; 58
------------------------------
310 /home/SySeVR/data/CVE_2012_2776_PATCHED_decode_cell_data.c [u'swap_quads'] 3
static int CVE_2012_2776_PATCHED_decode_cell_data(Cell *cell, uint8_t *block, uint8_t *ref_block,
int pitch, int h_zoom, int v_zoom, int mode,
const vqEntry *delta[2], int swap_quads[2],
const uint8_t **data_ptr, const uint8_t *last_ptr) 4
if ( swap_quads [ line & 1 ] )  55
------------------------------
311 /home/SySeVR/data/CVE_2012_2776_PATCHED_decode_cell_data.c [u'delta'] 3
static int CVE_2012_2776_PATCHED_decode_cell_data(Cell *cell, uint8_t *block, uint8_t *ref_block,
int pitch, int h_zoom, int v_zoom, int mode,
const vqEntry *delta[2], int swap_quads[2],
const uint8_t **data_ptr, const uint8_t *last_ptr) 4
delta_tab = delta [ line & 1 ]; 38
delta_tab = delta [ 1 ]; 40
if ( code < delta_tab -> num_dyads )  44
if ( dyad1 >= delta_tab -> num_dyads || dyad1 >= 248 )  48
code -= delta_tab -> num_dyads; 52
dyad1 = code / delta_tab -> quad_exp; 53
dyad2 = code % delta_tab -> quad_exp; 54
FFSWAP ( unsigned int , dyad1 , dyad2 ) 56
------------------------------
312 /home/SySeVR/data/CVE_2013_0311_VULN_translate_desc.c [u'iov'] 2
static int CVE_2013_0311_VULN_translate_desc(struct vhost_dev *dev, u64 addr, u32 len,
struct iovec iov[], int iov_size) 2
_iov = iov + ret; 24
_iov -> iov_len = min ( ( u64 ) len , size ); 26
_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ); 27
------------------------------
313 /home/SySeVR/data/CVE_2013_0799_VULN_GetInstallationDir.c [u'aResultDir'] 2
static BOOL
CVE_2013_0799_VULN_GetInstallationDir(int argcTmp, LPWSTR *argvTmp, WCHAR aResultDir[MAX_PATH]) 2
wcscpy ( aResultDir , argvTmp [ 2 ] ); 7
WCHAR * backSlash = wcsrchr ( aResultDir , L '\\' ) 8
bool replaceRequest = ( argcTmp >= 4 && wcsstr ( argvTmp [ 3 ] , L "/replace" ) ) 14
if ( backgroundUpdate || replaceRequest )  15
return PathRemoveFileSpecW ( aResultDir ) ; 16
------------------------------
314 /home/SySeVR/data/CVE_2014_8643_VULN_XRE_InitChildProcess.c [u'aArgv'] 3
nsresult
CVE_2014_8643_VULN_XRE_InitChildProcess(int aArgc,
char* aArgv[]) 3
NS_ENSURE_ARG_POINTER ( aArgv ); 6
NS_ENSURE_ARG_POINTER ( aArgv [ 0 ] ); 7
const char * const mach_port_name = aArgv [ -- aArgc ] 44
SetupErrorHandling ( aArgv [ 0 ] ); 87
const char * const crashReporterArg = aArgv [ -- aArgc ] 92
if ( 0 != strcmp ( "-" , crashReporterArg ) && ! XRE_SetRemoteExceptionHandler ( crashReporterArg ) )  98
if ( 0 != strcmp ( "false" , crashReporterArg ) && ! XRE_SetRemoteExceptionHandler ( nullptr ) )  106
gArgv = aArgv; 116
const char * const parentPIDString = aArgv [ aArgc - 1 ] 142
NS_ABORT_IF_FALSE ( parentPIDString , "NULL parent PID" ); 143
base :: ProcessId parentPID = strtol ( parentPIDString , & end , 10 ) ; 147
mozilla :: DebugOnly < bool > ok = base :: OpenProcessHandle ( parentPID , & parentHandle ) ; 151
NS_ABORT_IF_FALSE ( ok , "can't open handle to parent" ); 152
const char * const appModelUserId = aArgv [ -- aArgc ] 158
if ( appModelUserId )  159
if ( * appModelUserId != '-' )  161
appId . AssignWithConversion ( nsDependentCString ( appModelUserId ) ); 163
nsresult rv = XRE_InitCommandLine ( aArgc , aArgv ) ; 177
if ( NS_FAILED ( rv ) )  178
if ( aArgv [ idx ] && ! strcmp ( aArgv [ idx ] , "-appdir" ) )  224
appDir . Assign ( nsDependentCString ( aArgv [ idx + 1 ] ) ); 225
------------------------------
